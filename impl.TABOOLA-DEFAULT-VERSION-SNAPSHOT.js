/****** GENERATED BY LOCAL PROXY ************/






/*********  Taken from local file shared-objects.js, last modified 2023-10-23 13:57:13.131997486 +0300 IDT ******** */ 


(function(win) {
    win.TRC = win.TRC || {};

    // Object used by both tfa-trk and rbox
    win.TRC.sharedObjects = win.TRC.sharedObjects || {};

    // Used by both tfa-trk and rbox to keep which script files that were loaded in order to load them only once
    // The script files are loaded by adding a new SCRIPT HTML element to the DOM.
    // The script URLs are returned in the response from a recommendation request in an array called jst
    win.TRC.sharedObjects.loadedScripts = win.TRC.sharedObjects.loadedScripts || {};

    // Used by both tfa-trk and rbox to keep which pixel were fired in order to fire them only once
    // The pixels URLs are returned in the response from a recommendation request in an array called stp
    win.TRC.sharedObjects.loadedPixels = win.TRC.sharedObjects.loadedPixels || {};
}(window));


/*********  Taken from local file bundle.js, last modified 2024-01-08 13:27:29.42329733 +0200 IST ******** */ 


(function () {

    /**
     * about-us.js
     * This module is responsible for opening the 'by taboola'
     * dialog when a user clicks the attribution link
     */
    ((win, doc, trc) => {

        const TRC_MODAL_HIDDEN = 'trc_modal_hidden',
            TRC_MODAL_MASK = 'trc_modal_mask',
            TRC_MODAL_DIALOG = 'trc_modal_dialog',
            TRC_CLOSE_MODAL = 'trc_close_modal',
            dialogDiv = doc.createElement('div'), // the main div that contains the iframe
            maskDiv = doc.createElement('div'); // mask div to hide the browser page
        let isMarkupReady,
            augmentingPrefix = '';

        function closeDialog() {
            addClass(maskDiv, TRC_MODAL_HIDDEN);
            addClass(dialogDiv, TRC_MODAL_HIDDEN);
            trc.dom.off(doc, 'keyup', onDocumentKeyUp);
            trc.dom.off(doc, 'click', onDocumentClick);
            trc.dom.off(doc.getElementById(TRC_CLOSE_MODAL), 'click', onDocumentClick);
            trc.dom.off(win, 'message', handleDialogMessage);
        }

        function createDialogMarkup() {
            addClass(maskDiv, TRC_MODAL_MASK);
            addClass(maskDiv, TRC_MODAL_HIDDEN);
            addClass(dialogDiv, TRC_MODAL_DIALOG);
            addClass(dialogDiv, TRC_MODAL_HIDDEN);

            container3.appendChild(maskDiv);
            container3.appendChild(dialogDiv);
            doc.body.appendChild(container1);
            createCss(augmentingPrefix);
            isMarkupReady = true;
        }

        // generic functions
        const addClass = function (element, className) {
                if (element.classList) {
                    return element.classList.add(className);
                }
                trc.dom.removeClass(element, className);
                element.className += ` ${className}`;
            },

            // Deactivate on ESC
            onDocumentKeyUp = event => {
                const keyCode = event.which || event.keyCode;
                if (keyCode === 27) {
                    closeDialog();
                }
            },

            // Deactivate on click outside
            onDocumentClick = event => {
                const target = event.target || event.srcElement;
                if (target === maskDiv || target.id === TRC_CLOSE_MODAL) {
                    trc.dom.stopEvent(event);
                    closeDialog();
                }
            },

            handleDialogMessage = event => {
                // we listen only for messages from backstage
                if (!/http(s)?:\/\/www\.taboola\.com/.test(event.origin)) {
                    return;
                }

                if (event.data && +event.data === 1025) {
                    closeDialog();
                }
            },

            createContent = function (src, scrolling = 'no') {
                const text = [];

                text.push(`<a id="${TRC_CLOSE_MODAL}" class="trc_modal_close">&times;</a>
                <iframe class="trc_modal_frame" scrolling=${scrolling} frameborder=0 allowTransparency=true src="${src}"></iframe>`);
                return text.join('');
            },

            parentOrSelf = function (element, tag) {
                while (element.tagName.toUpperCase() !== tag.toUpperCase()) {
                    element = element.parentNode;
                }
                return element;
            },

            openDialog = function (event) {
                const link = parentOrSelf(event.target || event.srcElement, 'A');
                if (event) {
                    trc.dom.stopEvent(event);
                }

                // lazy load, only when needed.
                if (!isMarkupReady) {
                    createDialogMarkup();
                }

                const scrolling = link.getAttribute('tblEnablesScrolling');

                dialogDiv.innerHTML = createContent(link.href, scrolling);

                trc.dom.removeClass(maskDiv, 'trc_modal_hidden');
                trc.dom.removeClass(dialogDiv, 'trc_modal_hidden');
                trc.dom.on(doc, 'keyup', onDocumentKeyUp);
                trc.dom.on(doc, 'click', onDocumentClick);
                trc.dom.on(doc.getElementById('trc_close_modal'), 'click', onDocumentClick);

                // listen for postMessage from inside the taboola attribution iframe
                // message 1025 -> close request
                trc.dom.on(win, 'message', handleDialogMessage);
            },

            createAugmentingContainer = function (parent) {
                const div = doc.createElement('div');

                div.id = `tbl-aug-${Math.floor(Math.random() * 2147483648).toString(36)}`;
                augmentingPrefix = `#${div.id}`;
                if (parent) {
                    parent.appendChild(div);
                }
                return div;
            },

            // eslint-disable-next-line no-unused-vars
            createCss = function (prefix) {
                TRC.dom.injectStyle(`${prefix} .trc_modal_dialog { width: 660px; height: 550px; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; padding: 12px; border: 2px solid #417cc3; position: fixed; z-index: 9999999; background: #f7f9fc; top: 50%; left: 50%; margin-top: -250px; margin-left: -330px; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; -ms-box-sizing: content-box; -o-box-sizing: content-box; box-sizing: content-box; -webkit-box-shadow: black 0 0 18px 0; -moz-box-shadow: black 0 0 18px 0; -ms-box-shadow: black 0 0 18px 0; -o-box-shadow: black 0 0 18px 0; box-shadow: black 0 0 18px 0; -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px; }${prefix} .trc_modal_mask { z-index: 9999998; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #000; opacity: 0.5; filter: alpha(opacity=50); }${prefix} .trc_modal_close { font-family: sans-serif !important; width: 30px !important; height: 30px !important; font-size: 30px !important; font-weight: bold !important; line-height: 28px !important; color: #fff !important; text-shadow: 0 1px 0 #000; opacity: 0.9; filter: alpha(opacity=90); background: #417cc3; padding: 0; cursor: pointer; border: 0; -webkit-appearance: none; text-align: center; position: absolute !important; top: -13px; right: -13px; text-decoration: none !important; z-index: 9; -webkit-border-radius: 15px !important; -moz-border-radius: 15px !important; -ms-border-radius: 15px !important; -o-border-radius: 15px !important; border-radius: 15px !important; }${prefix} .trc_modal_hidden { display: none !important; }${prefix} .trc_modal_frame { width: 100% !important; height: 550px !important; }`, null);
            },
            container1 = createAugmentingContainer(),
            container2 = createAugmentingContainer(container1),
            container3 = createAugmentingContainer(container2);

        // public interface
        trc.aboutUs = {
            open: openDialog,
            close: closeDialog
        };

    })(window, document, TRC);

    /**
     * Created by yoni.f on 10/27/2014.
     */
    (function(win,doc) {
        /**
         * ad blocker utilities
         */
        TRC.blocker = TRC.blocker || {

                states : {
                    'ABP_DETECTION_DISABLED': -2,
                    'ABP_NOT_DETECTED' : 0,
                    'ABP_DETECTED' : 1
                },

                createBlockDetectionDiv: function(className){
                    var div = doc.createElement("div");
                    div.className = className;
                    div.style.fontSize = '12px'; // some publishers set default font size in their size to be "0" and then we don't get offsetHeight
                    div.style.lineHeight = '1'; // some publishers set default line height of their elements to be "0" and then we don't get offsetHeight
                    div.appendChild(doc.createTextNode("."));// now the text container will have offsetHeight if displayed
                    doc.documentElement.appendChild(div);
                    return div;
                },

                isBlockDetectedOnDiv: function(div) {
                    if (!div.offsetHeight) {
                        TRC.pConsole("page", "warn", "AdBlockPlus detected on div with class: " + div.className);
                        return true;
                    } else {
                        TRC.pConsole("page", "warn", "No AdBlockPlus detected on div with class: " + div.className);
                        return false;
                    }
                },

                isBlockDetectedOnClassNames: function(classNames){
                    var i,
                        len = classNames.length,
                        div;
                    for (i = 0; i < len; i++) {
                        if(classNames[i]){
                            div = this.createBlockDetectionDiv(classNames[i]);
                            try{
                                if (this.isBlockDetectedOnDiv(div)) {
                                    return true;
                                }
                            } catch (e) {
                                TRC.pConsole("page", "error", "unable to inspect offsetHeight of div with class: " + div.className);
                            } finally {
                                doc.documentElement.removeChild(div);
                            }
                        }
                    }
                    return false;
                },

                setTopDocument : function(){
                    try {
                        doc = top.document || doc;
                    } catch (e) {
                        // ignore and stay with current doc value
                    }
                },

                getBlockedState : function(classNames, ignoreCachedBlockedState){
                    //do not repeat check if we already know that ABP is active
                    if(this.blockedState === this.states.ABP_DETECTED && !ignoreCachedBlockedState) {
                        return this.blockedState;
                    }

                    this.setTopDocument();

                    if(classNames){
                        this.blockedState = this.isBlockDetectedOnClassNames(classNames) ?
                            this.states.ABP_DETECTED :
                            this.states.ABP_NOT_DETECTED;
                    } else {
                        this.blockedState = this.states.ABP_NOT_DETECTED;
                    }

                    return this.blockedState;
                }
            };
    })(window, document);

    /**
     * Created by yoni.f on 3/23/16.
     */

    (function() {
        TRC.amp = {};

        var amp = TRC.amp;

        var trcRboxContainer;
        var ampContainer;

        /**
         * refrence to the inner rbox container (not the client containers)
         * @returns {Element}
         */
        amp.getRboxContainer = function () {
            if (!trcRboxContainer){
                trcRboxContainer = document.getElementsByClassName('trc_rbox_container')[0];
            }
            return trcRboxContainer;
        };

        amp.getAMPContainer = function () {
            if (ampContainer) {
                return ampContainer;
            }
            return ampContainer = document.getElementById('c');
        };

        /**
         * set AMP behavior -
         * disable features, configure AMP behavior, register to (external) visible events and
         * @param {object}trc - TRC.manager instance
         */
        amp.setAMPmodule = function(trc){
            trc.manualVisibilityTrigger = true;
            trc.disableReadMore = true;
            trc.slider = false;
            var isFeed = null;

            var resizeHandler = this.sendAMPResize,
                resizeFeedHandler = this.sendAMPFeedResize,
                negativeThreshold = trc.global['amp-neg-threshold'] || 5,
                positiveThreshold = trc.global['amp-pos-threshold'] || 100,
                debounceTime = trc.global['amp-debounce-time'] || 200,
                disableResize = (typeof trc.amp_disable_resize !== 'undefined' ) ? trc.amp_disable_resize : trc.global['amp-disable-resize'],
                renderHook = (typeof trc.global['amp-onrender'] === 'function') ? trc.global['amp-onrender'] : function(){return true;};

            amp.getAMPContainer().classList.add('tbl-amp-container');
            TRC.eventDelegator.subscribe('onrender', function(data){
                var threshold = {negative : negativeThreshold, positive : positiveThreshold};
                if(!renderHook(data) || disableResize){
                    return false;
                }

                if (isFeed === null) {
                    isFeed = data.container.placementData && data.container.placementData.isFeedCard ? true : false;
                }

                if (!isFeed) {
                    resizeHandler(threshold, (TRC.lastVisibleRects ? TRC.lastVisibleRects : null));
                    TRC.listen('visible::' + data.placement, TRC.util.debounce(resizeHandler.trcBind(this, threshold), debounceTime, false, this));
                } else {
                    amp.getAMPContainer().style.position = 'static';
                    resizeFeedHandler();
                }
            });
        };

        /**
         * request AMP resize for regular widgets
         * @param {object} rects - AMP rect data
         * @param {object} threshold - negative and positive thresholds
         *
         */
        amp.sendAMPResize = function(threshold, rects){

            var vph = rects ? rects.boundingClientRect.height : TRC.dom.getWindowHeight(), //viewport height
                sh = amp.getRboxContainer().scrollHeight, // reflects the height of the entire content (i.e. the widget)
                dif = vph - sh,
                tolerance =  dif < 0 ? threshold.negative : threshold.positive;

            if (Math.abs(dif) >= tolerance){
                window.context.requestResize(undefined, sh);
            }
        };
        /**
         * request AMP resize for feed
         *
         */
        amp.sendAMPFeedResize = function() {
            window.context.requestResize(undefined,  amp.getAMPContainer().offsetHeight + 50);
            TRC.dispatch('ampFeedResize');
            return;
        };

    })();

    /**
     * Aspect-oriented programming utilities.
     * 
     * Namespace: TRC.aspect
     */
    (function(win,doc) {
    	// set up our name space
    	TRC.aspect = {
    	
    		/**
    		 * Execute the specified code block right before the specified method is called.
    		 * @param {Object} instance Object on which the method to pointcut is defined
    		 * @param {String} method Name of the function to add the aspect to. This should be the property name to override
    		 * in the above object
    		 * @param {Function} code Function to execute right before calling the original code
    		 * @param {Boolean} onetime If set, this is a single fire aspect and will be removed after the first time it runs
    		 */
    		before : function(instance, method, code, onetime) {
    			var original = instance[method];
    			instance[method] = function() {
    				if (onetime)
    					instance[method] = original;
    				code.apply(this,arguments);
    				return original.apply(this,arguments);
    			};
    		},
    		
    		
    		/**
    		 * Execute the specified code block right after the specified method was called.
    		 * @param {Object} instance Object on which the method to pointcut is defined
    		 * @param {String} method Name of the function to add the aspect to. This should be the property name to override
    		 * in the above object
    		 * @param {Function} code Function to execute right after calling the original code
    		 * @param {Boolean} onetime If set, this is a single fire aspect and will be removed after the first time it runs
    		 */
    		after : function(instance, method, code, onetime) {
    			var original = instance[method];
    			instance[method] = function() {
    				if (onetime)
    					instance[method] = original;
    				var ret = original.apply(this,arguments);
    				code.apply(this,arguments);
    				return ret;
    			};
    		}
    		
    	};
    })(window,document);

    const MODULE$1 = 'block-clicks';
    const PREFIX$1 = 'taboola';
    const SHORT_PREFIX$1 = 'tbl';
    const GLOBAL_PREFIX = 'unintentional-clicks';
    const GLOBAL_FRAUD_PREFIX$1 = `${GLOBAL_PREFIX}-fraud`;
    const GLOBAL_DEFAULT_PREFIX$1 = `${GLOBAL_PREFIX}-default`;
    const SHORT_NAME$1 = `${SHORT_PREFIX$1}-${MODULE$1}`;

    const getGlobalKey = (prefix, key) => [prefix, key].join('-');

    var CONSTANTS$2 = {
        SHORT_NAME: SHORT_NAME$1,
        MODULE_NAME: `${PREFIX$1}-${MODULE$1}`,
        GLOBAL_PREFIX,
        GLOBAL_FRAUD_PREFIX: GLOBAL_FRAUD_PREFIX$1,
        GLOBAL_DEFAULT_PREFIX: GLOBAL_DEFAULT_PREFIX$1,
        FORCE_PARAM: SHORT_NAME$1,
        EMULATE_PARAM: 'trc_block_clicks',
        SUPPLY_FEATURE: {
            TYPE: 'clickblocked',
            STATE: 'reported'
        },
        SELECTORS: {
            STORY_WIDGET_CTA: 'tbl-labels-arrow',
            TITLE: 'video-title'
        },
        DEFAULT_CONFIG: {
            MARGIN: '0.5',
            FRAUD_FASTCLICK: '3000',
            GENERAL_FASTCLICK: '500'
        },
        SOURCE_CONFIG: {
            FRAUD: 'fraud',
            FPP_ACTION: 'fpp-action',
            DEFAULT: 'default'
        },
        KEYS: {
            BLOCK_CLICKS_ACTION: 'bca',
            BLOCK_CLICKS_DISABLED: 'bcd',
            FAST_KEY: 'uics',
            MARGIN_KEY: 'uicm',
            RECURRING_KEY: 'uicr'
        },
        GLOBAL_KEYS: {
            FRAUD_ENABLED: getGlobalKey(GLOBAL_FRAUD_PREFIX$1, 'enable'),
            DEFAULT_ENABLED: getGlobalKey(GLOBAL_DEFAULT_PREFIX$1, 'enable'),
            SEND_INIT_EVENT: getGlobalKey(GLOBAL_DEFAULT_PREFIX$1, 'send-init-event')
        },
        TYPES: {
            MARGIN: 'MARGINAL_BLOCK_CLICKS',
            FAST: 'FAST_BLOCK_CLICKS'
        },
        EVENTS: {
            MARGINAL_BLOCK_CLICKS: 'marginal_click_blocked',
            FAST_BLOCK_CLICKS: 'fast_click_blocked',
            BLOCK_CLICKS_INIT: 'block_clicks_init'
        }
    };

    class ItemMeasurements {
        static isEnabled(trcManager) {
            return TRC.util.isPercentEnabled(trcManager.global, 'enable-item-measurements');
        }

        static setAppearanceTime(trcManager, item) {
            try {
                if (!ItemMeasurements.isEnabled(trcManager) || !item || item.appearanceTime) {
                    return;
                }
                item.appearanceTime = Date.now();
            } catch (e) {
                __trcError(`Error in ItemMeasurements.setAppearanceTime - ${e.message}`, e);
            }
        }

        static clearAppearanceTime(trcManager, item) {
            try {
                if (!ItemMeasurements.isEnabled(trcManager) || !item || !item.appearanceTime) {
                    return;
                }
                item.appearanceTime = null;
            } catch (e) {
                __trcError(`Error in ItemMeasurements.clearAppearanceTime - ${e.message}`, e);
            }
        }

        static getAppearanceTime(videoBoxContainer, event) {
            const appearanceTime = videoBoxContainer
                && videoBoxContainer.video_data
                && videoBoxContainer.video_data.appearanceTime;

            if (appearanceTime) {
                return appearanceTime;
            }

            const itemEl = TRC.dom.closest(event.target || event.srcElement, `.videoCube`);
            if (itemEl && itemEl.appearanceTime) {
                return itemEl.appearanceTime;
            }
            return null;
        }

        static shouldIgnoreLoggerUrlPrefix(trcManager, clickURLLength) {
            const splitFlag = TRC.util.isTrue(trcManager.global['enable-ie-split-click-event']);
            return splitFlag && TRC.Browser.ie && clickURLLength > 2048;
        }

        static getVisibleToClickTime(event, videoBoxContainer, video) {
            const appearanceTime = this.getAppearanceTime(videoBoxContainer, event);
            if (!this.isBlockClicksWorkingOnItem(video) || !appearanceTime) {
                return null;
            }
            return ((Date.now() - appearanceTime) / 1000).toFixed(2);
        }

        static setVisibleToClickTime(trcManager, video, e, videoBoxContainer) {
            try {
                if (!ItemMeasurements.isEnabled(trcManager) || !video) {
                    return;
                }
                video.visibleToClickTime = this.getVisibleToClickTime(e, videoBoxContainer, video);
            } catch (e) {
                __trcError(`Error in ItemMeasurements.setVisibleToClickTime - ${e.message}`, e);
            }
        }

        static isBlockClicksWorkingOnItem(video) {
            return !!video.blockClickOn;
        }

        static setVisibleToClickTimeParamObj(trcManager, dest, video) {
            try {
                if (!ItemMeasurements.isEnabled(trcManager) || !video || !video.visibleToClickTime || !dest) {
                    return;
                }
                __trcCopyProps({vct: video.visibleToClickTime}, dest);
            } catch (e) {
                __trcError(`Error in ItemMeasurements.setVisibleToClickTimeParamObj - ${e.message}`, e);
            }
        }

        static addVisibleToClickTimeToParamURL(trcManager, originalURL, event, videoBoxContainer, video) {
            try {
                if (!ItemMeasurements.isEnabled(trcManager) || typeof originalURL !== 'string' 
                    || originalURL.indexOf('&vct=') > -1) {
                    return originalURL;
                }
                const visibleToClickTime = this.getVisibleToClickTime(event, videoBoxContainer, video);
                const finalURL = `${originalURL}&vct=${visibleToClickTime}`;
                if (this.shouldIgnoreLoggerUrlPrefix(trcManager, finalURL.length)) {
                    return originalURL;
                }
                return finalURL;
            } catch (e) {
                __trcError(`Error in ItemMeasurements.addVisibleToClickTimeToParamURL - ${e.message}`, e);
                return originalURL;
            }
        }
    }

    (() => {
        TRC.ItemMeasurements = ItemMeasurements;
    })();

    const {
        SOURCE_CONFIG, DEFAULT_CONFIG, KEYS, SELECTORS: SELECTORS$1, EVENTS: EVENTS$1, SUPPLY_FEATURE, TYPES, GLOBAL_KEYS,
        GLOBAL_FRAUD_PREFIX, GLOBAL_DEFAULT_PREFIX, EMULATE_PARAM
    } = CONSTANTS$2;

    (() => {
        class BlockClicksManager {
            constructor(rbox, recItemContainer, itemData) {
                this.trcManager = rbox.trc;
                this.container = recItemContainer;
                this.itemData = itemData;
                this.itemBlockClicksOn();
                this.blockClicksSource = this.getBlockClicksSource();
                if (this.blockClicksSource) {
                    this.enableBlockingClicks(rbox);
                }
                this.firstClick = true;
                this.lastVisibleToClickTime = 0;
            }

            itemBlockClicksOn() {
                this.itemData.blockClickOn = true;
            }

            enableBlockingClicks(rbox) {
                TRC.dom.on(this.container, 'click', this.handleBlockClicks.trcBind(this), true);
                this.config = this.getConfig();
                this.isBlockingFastClicks = true;
                this.isRecommendationReel = TRC.RecommendationReel.shouldInitRecommendationReel(rbox);
                this.observeItem();
                if (this.isInitEventActive() && !BlockClicksManager.isInitEventSent) {
                    this.sendBlockClicksInitEvent();
                    BlockClicksManager.isInitEventSent = true;
                }
            }

            getConfig() {
                return {
                    marginValue: this.getBlockMarginalClicksValue(KEYS.MARGIN_KEY),
                    delayTimeValue: this.getBlockFastClicksTimeoutInMilliseconds(KEYS.FAST_KEY),
                    recurringClickDelay: this.getBlockFastClicksTimeoutInMilliseconds(KEYS.RECURRING_KEY)
                };
            }

            static getBlockClicksFromResponse(response) {
                if (!response || !response.trc) {
                    return;
                }
                const emulatedBlockClicks = TRC.URL.prototype.getParameter.call(location.href, EMULATE_PARAM);
                const blockClicksAction = emulatedBlockClicks || response.trc[KEYS.BLOCK_CLICKS_ACTION];
                if (blockClicksAction) {
                    BlockClicksManager.BCA = TRC.util.jsonParseSafe(blockClicksAction);
                }
            }

            isInitEventActive() {
                const {global} = this.trcManager;
                return TRC.util.isTrue(global[GLOBAL_KEYS.SEND_INIT_EVENT]);
            }

            getBlockMarginalClicksValue(key) {
                const clickValue = this.getClickValueByPriority(key);
                return BlockClicksManager.isValidClickValue(clickValue) ? clickValue : DEFAULT_CONFIG.MARGIN;
            }

            getBlockFastClicksTimeoutInMilliseconds(key) {
                const clickValue = this.getClickValueByPriority(key);
                if (BlockClicksManager.isValidClickValue(clickValue)) {
                    return parseFloat(clickValue) * 1000;
                }
                return this.blockClicksSource === SOURCE_CONFIG.FRAUD ? DEFAULT_CONFIG.FRAUD_FASTCLICK : DEFAULT_CONFIG.GENERAL_FASTCLICK;
            }

            getBlockClicksSource() {
                if (this.checkIsFraudEnabled()) {
                    return SOURCE_CONFIG.FRAUD;
                }
                if (BlockClicksManager.BCA) {
                    return BlockClicksManager.isBlockClicksActionEnabled()
                           && SOURCE_CONFIG.FPP_ACTION || null;
                }
                if (this.isEnabledByDefault()) {
                    return SOURCE_CONFIG.DEFAULT;
                }
                return null;
            }

            getClickValueByPriority(key) {
                switch (this.blockClicksSource) {
                    case SOURCE_CONFIG.FRAUD:
                        return this.trcManager.global[`${GLOBAL_FRAUD_PREFIX}-${key}`];
                    case SOURCE_CONFIG.FPP_ACTION:
                        return BlockClicksManager.BCA[key];
                    case SOURCE_CONFIG.DEFAULT:
                        return this.trcManager.global[`${GLOBAL_DEFAULT_PREFIX}-${key}`];
                    default:
                        return null;
                }
            }

            isEnabledByDefault() {
                const {global} = this.trcManager;
                return TRC.util.isTrue(global[GLOBAL_KEYS.DEFAULT_ENABLED]);
            }

            static isBlockClicksActionEnabled() {
                const blockClicksDisabled = BlockClicksManager.BCA[KEYS.BLOCK_CLICKS_DISABLED];
                return TRC.util.isFalse(blockClicksDisabled);
            }

            checkIsFraudEnabled() {
                const {global} = this.trcManager;
                return TRC.util.isTrue(global[GLOBAL_KEYS.FRAUD_ENABLED]);
            }

            sendBlockClickEvent(blockClickType, blockClickValue, msgData) {
                const {TYPE, STATE} = SUPPLY_FEATURE;
                const {visibleToClickTime, itemId} = msgData;
                let msg = `blocking type: ${EVENTS$1[blockClickType]}, `;
                msg += `blocking src: ${this.blockClicksSource}, `;
                msg += `vct: ${visibleToClickTime}, `;
                msg += `itemId: ${itemId}`;
                const value = `blocking value: ${blockClickValue}`;
                TRC.util.sendSupplyFeature(TYPE, STATE, msg, value);
            }

            sendBlockClicksInitEvent() {
                this.trcManager.sendAbTestEvent(EVENTS$1.BLOCK_CLICKS_INIT, 'block-clicks-manager');
            }

            getVisibleToClickTime() {
                const clickTime = Date.now();
                const appearanceTime = this.container
                    && this.container.video_data && this.container.video_data.appearanceTime;
                if (!appearanceTime) {
                    return null;
                }
                return ((clickTime - appearanceTime) / 1000).toFixed(2);
            }

            handleBlockClicks(e) {
                const {delayTimeValue, marginValue} = this.config || {};
                let msgData;
                try {
                    msgData = {
                        visibleToClickTime: this.getVisibleToClickTime(),
                        itemId: this.container.dataset.itemId
                    };
                } catch (e) {
                    __trcError(`Error in BlockClicksManager.handleBlockClicks - ${e.message}`, e);
                }

                if (this.shouldBlockFastClick()) {
                    BlockClicksManager.preventClickBubbling(e);
                    this.sendBlockClickEvent(TYPES.FAST, delayTimeValue, msgData);
                    if (this.firstClick) this.firstClick = false;
                    return;
                }

                if (BlockClicksManager.isLegitMarginalValue(marginValue) && this.isMarginalClick(e) && this.isBlockAbleClick(e)) {
                    BlockClicksManager.preventClickBubbling(e);
                    this.sendBlockClickEvent(TYPES.MARGIN, marginValue, msgData);
                }
            }

            static isLegitMarginalValue(marginalValue) {
                const parsedValue = parseFloat(marginalValue);
                return !isNaN(parsedValue) && parsedValue > 0;
            }

            shouldBlockFastClick() {
                if (!this.config) {
                    return false;
                }
                const visibleToClickTime = Number(this.getVisibleToClickTime());
                if (!visibleToClickTime) {
                    return true;
                }
                if (this.firstClick || !BlockClicksManager.BCA.enableRecurringClick) {
                    this.lastVisibleToClickTime = visibleToClickTime;
                    return visibleToClickTime <= (this.config.delayTimeValue / 1000);
                }
                return this.shouldBlockRecurringClick(visibleToClickTime);
            }

            shouldBlockRecurringClick(visibleToClickTime) {
                const clickInterval = visibleToClickTime - this.lastVisibleToClickTime;
                this.lastVisibleToClickTime = visibleToClickTime;
                return clickInterval <= (this.config.recurringClickDelay / 1000);
            }

            isBlockAbleClick(e) {
                if (this.isRecommendationReel && (e.target.parentNode.className.indexOf(SELECTORS$1.STORY_WIDGET_CTA) > -1)) {
                    return false;
                }

                return !(e.target.className.indexOf(SELECTORS$1.TITLE) > -1);
            }

            isMarginalClick(e) {
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                const transformedConfig = this.transformBlockMarginalClicksConfig(width, height);

                const rect = this.container.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                return (
                    // top margin
                    y < transformedConfig.top
                    // right margin
                    || x > width - transformedConfig.right
                    // left margin
                    || x < transformedConfig.left
                    // bottom margin
                    || y > height - transformedConfig.bottom
                );
            }

            static preventClickBubbling(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            transformBlockMarginalClicksConfig(width, height) {
                const {marginValue} = this.config;
                return {
                    top: BlockClicksManager.calculatePercentage(marginValue, height),
                    right: BlockClicksManager.calculatePercentage(marginValue, width),
                    bottom: BlockClicksManager.calculatePercentage(marginValue, height),
                    left: BlockClicksManager.calculatePercentage(marginValue, width)
                };
            }

            static calculatePercentage(value, compare) {
                return (parseFloat(value) / 100) * compare;
            }

            observeItem() {
                TRC.intersections.observe({
                    targetElement: this.container,
                    threshold: 0,
                    onExit: () => {
                        ItemMeasurements.clearAppearanceTime(this.trcManager, this.itemData);
                        this.lastVisibleToClickTime = 0;
                        this.firstClick = true;
                    },
                    onEnter: () => this.setAppearanceTime()
                });
            }

            setAppearanceTime() {
                ItemMeasurements.setAppearanceTime(this.trcManager, this.itemData);
            }

            static isValidClickValue(value) {
                return !isNaN(parseFloat(value));
            }
        }
        TRC.BlockClicksManager = BlockClicksManager;
    })();

    /**
     * Capability based browser detection
     *
     * This module exposes a singleton instance as its namespace and provides two mechanisms for building browser-specific
     * conditions:
     * 1. data fields for each supported browser which are set to the detected version of the browser or to the "false"
     * value if that browser was not detected. These fields are *not* mutually exclusive - for example Chrome is both
     * "chrome", "webkit" and "dom".
     * 2. utility methods that help check for a range of versions of a specific browser - there are two types: *Upto is
     * used to detect if the current browser is the specified browser with the specified version or lower; *Atleast is used
     * to detect if the current browser is the specified browser with the specified version or higher. These method return
     * a boolean value that is equivalent to 'TRC.Browser.somebrowser && TRC.Browser.somebrowser &gt;= someversion' (or
     * &lt;=, as appropriate).
     *
     * Please do not use this module in place of proper capability testing. For example, to decide whether to use the
     * IE-specific DOM event API or the standard DOM event API, check for <tt>document.attachEvent</tt> vs.
     * <tt>document.addEventListener</tt> and not for <tt>TRC.Browser.ie</tt>. Use this module only to test for divergant
     * behavior in a specific browser implementation, such as UI rendering quirks or, as a counter example, to test whether
     * to use the IE-specific DOM event API vs the standard DOM event API in IE 9 (where both APIs exist and do not
     * interoperate).
     *
     * Namespace: TRC.Browser
     */
    (function(win,doc) {

    	var BrowserDetection = function() {
    		this.dom = doc.getElementById ? 1 : false;
    		if (this.dom) {
    			if (doc.importNode?true:false) this.dom = 2;
    			/* The next line detects a DOM level 3 feature that is supported in most non-DOM-3
    			* conforming browsers, so its commented out. If you care about it, you probably
    			* want to do browser detection instead of DOM level detection */
    			//if (this.dom && document.adoptNode?true:false) this.dom = 3;
    			if (doc.normalizeDocument?true:false) this.dom = 3;
    		}

    		var opera = this.opera = win.opera ? 9 : false;
    		if (this.opera) {
    			if (navigator.geolocation?true:false) this.opera = 10;
    			if (win.opera.version?true:false) this.opera = parseFloat(win.opera.version());
    		}

    		this.webView = (function() {
    			if (navigator.userAgent.indexOf('; wv') > -1){
    				return true;
    			}
    			var isiPad = [
    							 'iPad Simulator',
    							 'iPad',
    						 ].indexOf(navigator.platform) > -1
    						 // iPad on iOS 13 detection
    						 || (navigator.userAgent.indexOf('Mac') > -1 && 'ontouchend' in document);
    			var isIOS = isiPad || /ip[honead]{2,4}(?:.*os\s(\w+)\slike\smac|;\sopera)/i.test(navigator.userAgent);
    			return isIOS && !(window.navigator).standalone && !/safari/i.test(navigator.userAgent);
    		})();

    		this.ie = (function() {
                if ( navigator.userAgent.match(/Trident/) && /rv:11.0/i.test(navigator.userAgent)) return 11;
    			if (typeof doc.all != 'object' || opera) return false;
    			if (doc.compatMode != 'CSS1Compat') return 6; // quirks mode always uses the lowest compatibility level
    			if (!win.XMLHttpRequest) return 6;
    			if (!Object.defineProperty) return 7; // Javascript 1.8.5
    			if (typeof DOMImplementation != 'object' || typeof DOMImplementation.prototype.createDocument != 'function') return 8; // DOM level 3
    			if (!win['msMatchMedia']) return 9; // CSSOM View Module
    			return 10;
    		})();

    		this.webkit = (win.openDatabase?true:false) && !this.opera; // Web SQL database is supported in webkit and Opera
    		this.chrome = this.webkit && win.chrome?true:false; // any chrome is full up to date

    		// Safari is a non-chrome webkit. I know its not 100% true, but the remains (non-chrome and non-safari) are
    		// almost negligable and they probably behave like safari < 5 anyway.
    		this.safari = this.webkit && !this.chrome;
    		if (this.safari) {
    			if (doc.compareDocumentPosition?true:false) this.safari = 4; // DOM Level 3
    			if (navigator['registerContentHandler']?true:false) this.safari = 5; // WHATWG Web Applications 1.0
    			if (win['matchMedia']?true:false) this.safari = 6; // CSSOM View Module
    		}

    		this.firefox = !!navigator.userAgent.match(/firefox/i);
    		if (this.firefox) {
    			try{if(typeof doc.createElement("canvas").getContext == 'function') this.firefox = 1.5; }catch(e){/**/} // introduces canvas tag
    			if (typeof win['globalStorage']=='object') this.firefox = 2; // WHATWG deprecated Storage spec
    			if (doc.elementFromPoint?true:false) this.firefox = 3; // IE extension supported in 3.0
    			if (doc.querySelector?true:false) this.firefox = 3.5; // W3 Selector API
    			if (doc.getElementsByTagName('head')[0]['mozMatchesSelector']?true:false) this.firefox = 3.6; // Experimental W3 Selector API 2
    			if (win.Uint8Array?true:false) this.firefox = 4.0; // Khronos Typed Arrays
    			if (Function.prototype['isGenerator']?true:false) this.firefox = 5; // detect generators, spec from Firefox 2 but detection only works from 5
    			if (win['matchMedia']?true:false) this.firefox = 6; // CSSOM View Module
    			if (win.FileReader && win.FileReader.prototype.readAsArrayBuffer?true:false) this.firefox = 7; // W3C FileAPI completion
    			if (doc.head && doc.head.insertAdjacentHTML?true:false) this.firefox = 8; // HTML 5 p3.4.7
    		}

    		// build Upto/Atleast methods for each supported browser type
    		var browsers = ['firefox','chrome','safari','webkit','khtml','ie','opera'];
    		for (var i = 0; i < browsers.length; i++) {
    			(function(obj,b) {
    				obj[b+'Upto'] = function(ver) { return this[b] && (typeof this[b] != 'number' || this[b] <= ver); };
    				obj[b+'Atleast'] = function(ver) { return this[b] && (typeof this[b] != 'number' || this[b] >= ver); };
    			})(this,browsers[i]);
    		}

            // Feature detection
            this.compatibility = {
                //line-clamp css support
                lineClamp: (function() {
                    return typeof (doc.createElement('div').style['webkitLineClamp']) != 'undefined';
                })(),
                cssTransforms: (function() {
                    var div = doc.createElement('div'),
                        props = ['transformProperty', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform'];

                        for(var i = 0; i < props.length; i++) {
                            if(typeof div.style[props[i]] != 'undefined') {
                                return true;
                            }
                        }

                    return false;
                })(),
              	passiveEvents: (function() {
                  var passiveSupported = false;

                  try {
                    window.addEventListener('test', null, Object.defineProperty({}, 'passive', { get: function() { passiveSupported = true; } }));
                  } catch(err) {}

                  return passiveSupported;
                })()
            };

    		return this;
    	};

        var DeviceDetection = function() {
            this.isTouchDevice = ('ontouchstart' in window); //detect touch device - not accurate, like hybrid laptops....
    		// *** this is a naive device type detection and currently detecting ios mobile devices only
    		// *** as this is for a very specific feature
    		this.deviceType = (function(){
    			var ios = navigator.userAgent.match(/iPhone|iPod|iPad/i);
    			if (ios){
    				return ios[0];
    			} else {
    				return "other"
    			}
    		})();


    	};

        var MobileSdk = {
    	    isEnabled: function () {
    		    return !!win.taboolaMobile;
    	    },
        };

    	TRC.Device = new DeviceDetection();
    	TRC.Browser = new BrowserDetection();
        TRC.MobileSdk = MobileSdk;
    })(window,document);

    (() => {

        class BulkLoggerManager {

            init() {
                this.bulkLoggers = {
                    availableBulkLogger: new TRC.TRCBulkLogger('bulk'),
                    metricBulkLogger: new TRC.TRCBulkLogger('bulk-metrics')
                };
                this.eventToLogger = {
                    available: this.bulkLoggers.availableBulkLogger,
                    metrics: this.bulkLoggers.metricBulkLogger,
                    'required-viewability-available': this.bulkLoggers.availableBulkLogger
                };
                this.initialized = true;
            }

            bulkPost(host, type, params, explicitPublisherId, queryParams) {
                if (!this.initialized) {
                    this.init();
                }
                const relevantBulkLogger = this.eventToLogger[type];
                if (!relevantBulkLogger) {
                    TRC.TRCLogger.post(host, type, params, explicitPublisherId, queryParams);
                    __trcWarn(`Failed sending bulk event for eventType: ${type}, bulk is not currently supported`);
                    return;
                }
                relevantBulkLogger.bulkPost(host, type, params, explicitPublisherId, queryParams);
            }

        }

        TRC.BulkLoggerManager = new BulkLoggerManager();

    })();

    (() => {
        class CacheUtils {
            constructor(localStorage, cacheName, cacheTtl) {
                this.localStorage = localStorage;
                this.cacheName = cacheName;
                this.cacheTtl = cacheTtl;
            }

            isOverTtl(stamp) {
                const cstamp = new Date().getTime();
                return (cstamp - stamp) > this.cacheTtl;
            }

            setCacheClean(key, cache) {
                const {localStorage, cacheName, cacheTtl} = this;
                TRC.Timeout.set(() => {
                    (TRC.tlf && console.time('in setCacheClean'));
                    cache.removeKey(key);
                    localStorage.setValue(cacheName, __trcJSONify(cache.getData()));
                    (TRC.tlf && console.timeEnd('in setCacheClean'));
                }, cacheTtl);
            }

            static removeKey(key, cache) {
                if (cache.getValue(key)) {
                    cache.removeKey(key);
                    return true;
                }
                return false;
            }

            cleanCache(keys, cache, cacheModule) {
                const lsKeys = keys || TRC.util.keys(cache.getData());
                let key;
                for (let i = 0; i < lsKeys.length; i++) {
                    key = lsKeys[i];
                    const cachedValue = cache.getValue(key);
                    if (!cachedValue) {
                        continue;
                    }
                    if (this.isOverTtl(cachedValue.s)) {
                        cacheModule.removeKey(key);
                    }
                }

                this.localStorage.setValue(this.cacheName, __trcJSONify(cache.getData()));
            }

            getCache(pageManager) {
                const cache = this.localStorage.getValue(this.cacheName) || {};
                try {
                    if (cache) {
                        return pageManager.getDummyStorage(TRC.util.jsonParseWithNative(cache));
                    }
                } catch (e) {
                    return pageManager.getDummyStorage();
                }
            }
        }

        TRC.CacheUtils = CacheUtils;  
    })();

    /* Category card will rendered after this validation:
       * source category exist
       * source category exist in the translation map in global config
       * only if all items equal to the source category
       * */

    (() => {
        const CATEGORY_MAP = 'allowed-categories-map';

        class CategoryCard {
            constructor(rbox) {
                const {sourceCategory, global} = rbox.trc;
                const {publisherId, dom: {addClass}} = TRC;
                const categoriesTranslationMap = global[CATEGORY_MAP];
                let allowedCategoriesTranslationMap = {};

                this.text = '';
                this.isCategoryCard = true;
                this.sourceCategory = sourceCategory;

                addClass(rbox.container, 'tbl-category-card-enabled');

                if (!sourceCategory) {
                    this.sendEvent('No Source Category');
                    return;
                }

                if (categoriesTranslationMap) {
                    allowedCategoriesTranslationMap = categoriesTranslationMap[publisherId] || categoriesTranslationMap;
                }

                // source category exist in the translation map in global config
                const categoryTranslation = allowedCategoriesTranslationMap[sourceCategory];
                if (!categoryTranslation) {
                    this.sendEvent('No category translation');
                    return;
                }
                
                this.render = this.validateCategoryLogic(rbox);
                if (this.render) {
                    addClass(rbox.container, 'tbl-category-card-rendered');
                    this.text = categoryTranslation.toUpperCase();
                }
              
            }

            sendEvent(result) {
                TRCImpl.sendAbTestEvent('category-card', `Channel: ${this.sourceCategory}, Result: ${result}`);
            }

            validateCategoryLogic(context) {
                const {length = 0} = context.recommendationList;
                if (!length) {
                    return false;
                }
                
                for (let i = 0; i < length; i++) {
                    const item = context.recommendationList[i];
                    if (item.category) {
                        if (this.sourceCategory !== item.category) {
                            this.sendEvent(`fallback. item category is: ${item.category}`);
                            return false;
                        }
                    } else {
                        this.sendEvent('No Category');
                        return false;
                    }
                }

                return true;
            }

            static enableCategoryCard(context) {
                return !!context.trc.getProperty(context.mode_name, 'enable-category-card', context.propertiesOverride);
            }
        }

        TRC.CategoryCard = CategoryCard;
    })();

    /**
     * ccpa.es6.js
     * The California Consumer Privacy Act (CCPA) created new consumer
     * rights relating to the access to, deletion of,
     * and sharing of personal information that is collected by businesses.
     */
    ((win, doc, trc) => {
        const init = (recommendations = [], config = {}) => {
            ccpa.isInitialized = true;
            setConfig(config);
            getTarget(recommendations);
            TRC.dom.injectStyle(`a.tbl-ccpa { font-weight: normal; font-size: 11px; Color: #999999; margin: 0 3px 0 0; text-decoration: none; font-family: Arial, Helvetica, sans-serif; float: right; } a.tbl-ccpa.tbl-ccpa-left { float: left; } a.tbl-ccpa.tbl-ccpa-right { float: right; }.logoDiv a.tbl-ccpa span { font-size: 11px; color: #999999; }div.tbl-feed-header.tbl-ccpa-container .tbl-ccpa { margin-top: 3px; }div.tbl-feed-header.tbl-ccpa-container div.tbl-feed-header-logo { display: inline-block; }.trc-widget-footer a.tbl-ccpa.tbl-cpa-pipe-before::before { content: '|'; margin-right: 2px; font-size: 11px; color: #999999; }.tbl-rtl .tb-ccpa-mobile { line-height: 11px; }.tbl-rtl .logoDiv.link-ccpa { display: inline-block; }.tbl-rtl div.tbl-feed-header .tbl-ccpa { margin-top: 0; }.tbl-rtl .trc-widget-footer a.tbl-ccpa { float: none; } .tbl-rtl .trc-widget-footer a.tbl-ccpa.tbl-cpa-pipe-before::before { content: ''; } .tbl-rtl .trc-widget-footer a.tbl-ccpa.tbl-cpa-pipe-before::after { content: '|'; margin-left: 2px; font-size: 11px; color: #999999; }`, null);
            sendCcpaEvent();
        };

        const getTarget = recommendations => {
            let placement = ccpa.config && ccpa.config.placement;
            if (placement) {
                trc.ccpa.placement = placement;
                return placement;
            }
          
            for (let i = 0; i < recommendations.length; i++) {
                const recommendation = recommendations[i];
                placement = recommendation.dc || recommendation.uuip || recommendation.uip;
                if (placement.toLowerCase().indexOf('below') > -1 && recommendation.v.length > 0) {
                    ccpa.placement = placement;
                    return placement;
                }
            }

            ccpa.placement = placement;
        };

        const setConfig = ({
            markup = 'CCPA Notice',
            href = 'https://ccparequest.taboola.com/',
            enableScrolling = 'yes',
            classList,
            style,
            inlineStyle = '',
            location = 'beforeend',
            renderOnce = true,
            placement = ''
        }) => {
            const classListStr = classList ? [...classList, 'tbl-ccpa'] : 'tbl-ccpa';
            ccpa.config = {
                markup,
                href,
                enableScrolling,
                classList: classListStr,
                style,
                inlineStyle,
                location,
                renderOnce,
                placement
            };
        };

        const shouldCreateCcpa = placementName => {
            const {config, placement} = ccpa;
            return (config && !config.renderOnce) || (placement === placementName);
        };

        const createCcpa = (container, moreConfigs = {}) => {
            let containerAdditionalClassNames = 'tbl-ccpa-container';

            if (TRC.dom.isSmartPhone()) {
                containerAdditionalClassNames += ' tb-ccpa-mobile';
            }

            TRC.dom.addClass(container, containerAdditionalClassNames);

            const cloneConfig = TRC.util.merge({}, ccpa.config, moreConfigs);
            TRC.PopupLink.create(container, cloneConfig);
        };

        const renderOnHeaderFeed = (headerContainer, unifiedPlacement, logoPosition) => {
            if (ccpa.shouldCreateCcpa(unifiedPlacement)) {
                const configs = {};
                let ccpaPosition = '';
                if (logoPosition === 'RIGHT') {
                    ccpaPosition = ' tbl-ccpa-left';
                } else if (logoPosition === 'LEFT') {
                    ccpaPosition = ' tbl-ccpa-right';
                }

                configs.classList = `${ccpa.config.classList}${ccpaPosition}`;

                ccpa.create(headerContainer, configs);
            }
        };

        const renderOnWidgetFooter = rbox => {
            if (rbox.isFeedCard || !shouldCreateCcpa(rbox.placement)) {
                return;
            }

            const footer = rbox.getWidgetFooter();

            let addPipe = '';
            if (footer.children.length > 0) {
                addPipe = ' tbl-cpa-pipe-before';
            }

            const configs = {
                markup: `<span>${ccpa.config.markup}</span>`,
                classList: `${ccpa.config.classList} tbl-ccpa-on-widget${addPipe}`,
                location: 'afterbegin',
                wrapper: {type: 'div', className: 'logoDiv link-ccpa'}
            };

            if (rbox.hasAdChoicesLogo) {
                configs.children = '<span class="trc_logos_v_align">&nbsp;</span>';
            }


            ccpa.create(footer, configs);
        };

        const sendCcpaEvent = function (value = 'taboola', state = 'Rendered', message = null) {
            if (TRC.dom.isInIframe()) {
                const inIframe = 'in-iframe';
                message = message ? [message, inIframe].join(', ') : inIframe;
            }

            const requestData = {
                event_type: 'ccpa', event_state: state, event_value: value, event_msg: message
            };

            TRCImpl.sendEvent('supply-feature', {d: JSON.stringify(requestData)}, null);
        };

        const ccpa = trc.ccpa = {
            placement: '',
            isInitialized: false,
            sendCcpaEvent,
            create: createCcpa,
            init,
            shouldCreateCcpa,
            renderOnWidgetFooter,
            renderOnHeaderFeed
        };

    })(window, document, TRC);

    (function () {
        var CMP_INTEGRATED = 0,
            CMP_INTEGRATED_NO_RESULT = 1,
            CMP_INTEGRATED_ERROR_ON_RESULT = 2, // NOT supported
            NO_CMP_INTEGRATION = 3,
            AMP_INTEGRATION = 5;
        var presets = {
            taboola_default: 'BOOx2jhOOx2mtAKABDENAqAAAAAYSAAA' // no-consent daisy bit
        };
        var consentState = {
            cmpStatus: NO_CMP_INTEGRATION
        };
        var currentSource = '';
        var callbacks = {
            'getConsentData': []
        };

        var supportedCommands = {'getConsentData': 1};

        TRC.consent = TRC.consent || {};

        function resetConsentState() {
            consentState.gdprApplies = true;
            consentState.consentData = presets.taboola_default;
            consentState.consentPreset = 'taboola_default';
        }

        function cmp(command, parameter, callback) {
            if (supportedCommands[command]) {
                callbacks[command].push(callback);
            } else {
                // TODO : support on demand
            }

            if (currentSource === 'tcf') {
                return setTCFConsent();
            } else if (currentSource === 'iab') {
                return setIABConsent();
            }
        }

        function IABCallback(consentState) {
            consentState.cmpStatus = CMP_INTEGRATED;
            setCallbacks(consentState);
        }

        function setIABConsent() {
            if (window.__cmp) {
                window.__cmp('getConsentData', null, IABCallback);
                return true;
            } else {
                return false;
            }
        }

        function TCFCallback(tcData, success) {
            if (success && (tcData.eventStatus === 'tcloaded' || tcData.eventStatus === 'useractioncomplete')) {
                setTcfData(tcData);
                setCallbacks(consentState);

                try {
                    window.__tcfapi('removeEventListener', 2, function () {
                    }, tcData.listenerId);
                } catch (e) {
                    __trcWarn('Error while calling __tcfapi:removeEventListener', e);
                }
            }
        }

        function setTcfData(tcData) {
            consentState.cmpStatus = CMP_INTEGRATED;
            consentState.gdprApplies = tcData.gdprApplies;
            consentState.tcString = tcData.tcString;
            consentState.consentData = null;
        }

        function setTCFConsent() {
            try {
                window.__tcfapi('addEventListener', 2, TCFCallback);
                return true;
            } catch (e) {
                __trcWarn('Error while calling __tcfapi:addEventListener', e);
            }

        }

        function setCallbacks(result) {
            consentState = TRC.util.merge(consentState, result);
            overridePush();
        }

        function overridePush() {
            var cb = callbacks['getConsentData'];
            if (cb.pushOverride === true) {
                return;
            }
            cb.push = function (callback) {
                if (typeof callback === 'function') {
                    callback(consentState);
                }
            };
            cb.pushOverride = true;
            for (var i = 0; i < cb.length; i++) {
                cb[i](consentState);
            }
        }

        TRC.consent.setPresets = function (_presets) {
            presets = TRC.util.merge(presets, _presets);
        };

        function getTcfSyncData(_consentState) {
            try {
                window.__tcfapi('getTCData', 2, function (tcData, success) {
                    if (success) {
                        setTcfData(tcData);
                        consentState = TRC.util.merge(consentState, _consentState);
                    }
                });
            } catch (e) {
                __trcWarn('Error while calling __tcfapi:getTCData', e);
            }
            setCallbacks();
        }

        TRC.consent.setConsent = function (_consentState) {
            if (currentSource === 'tcf') {
                getTcfSyncData(_consentState);
            } else if (TRC.consent.hasCMP()) {
                resetConsentState();
                if (_consentState) {
                    consentState.cmpStatus = _consentState.consentData ? CMP_INTEGRATED : consentState.cmpStatus;
                    consentState.consentPreset = _consentState.consentData ? '' : consentState.consentPreset;
                    consentState = TRC.util.merge(consentState, _consentState);
                    consentState.consentData = presets[_consentState.consentPreset] || consentState.consentData;
                }
                setCallbacks();
            } else {
                __trcError("TRC.consent.setConsent:- no consent source was set");
            }
        };

        TRC.consent.getConsentStatus = function () {
            return consentState.cmpStatus;
        };

        TRC.consent.hasCMP = function () {
            return !!(currentSource)
        };

        TRC.consent.setConsentSource = function (config, defaultPresets) {
            resetConsentState();
            currentSource = config.source.toLowerCase() || currentSource;
            presets = TRC.util.merge(presets, config.presets);
            TRC.cmp = cmp;
            consentState.cmpStatus = CMP_INTEGRATED_NO_RESULT;
            if (defaultPresets) {
                presets = defaultPresets;
            }
            return true;
        };

        TRC.consent.getAMPConsent = function (callback) {
            if (window.context) {
                if (!TRC.util.isEmptyString(window.context.initialConsentValue)) {
                    if (/\d[YN-]{3}$/.test(window.context.initialConsentValue)) {
                        consentState.ccpaString = window.context.initialConsentValue;
                        consentState.gdprApplies = null;
                        consentState.consentData = null;
                        consentState.tcString = null;
                    } else {
                        consentState.tcString = window.context.initialConsentValue;
                        consentState.gdprApplies = true;
                        consentState.consentData = null;
                    }
                    consentState.cmpStatus = AMP_INTEGRATION;
                    callback(null, consentState);

                } else if (typeof window.context.getConsentState === 'function') {
                    try {
                        window.context.getConsentState(function (ampConsentData) {
                            if (ampConsentData.consentState === 1) {
                                callback("true", null);
                            } else if (ampConsentData.consentState === 2) {
                                callback("false", null);
                            } else {
                                callback(null, null);
                            }
                        });
                    } catch (e) {
                        __trcError('Error while calling AMP getConsentState', e);
                        callback(null, null);
                    }
                } else {
                    callback(null, null);
                }
            } else {
                callback(null, null);
            }
        };

        /* public methods for UT */
        if (window._trcIsUTactive) {
            TRC.consent.setCurrentSource = function (source) {
                currentSource = source;
                callbacks = {
                    'getConsentData': []
                };
                consentState = {
                    cmpStatus: NO_CMP_INTEGRATION
                };

            };
        }
    })();

    (win => {
        TRC.CLSReporter = {
            listenStarted: false,
            CLSEventsFilters: [],
            maxSelectors2Send: 100,
            CLSSelectorsEnabled: false,
            CLSSelectorsMessage: '',
            CLSSelectorsFilter: 'selectors',
            generateQuerySelector(node) {
                if (!node) {
                    return null;
                }
                let selector = node.tagName;
                if (node.id) {
                    selector += `#${node.id}`;
                } else if (node.className) {
                    selector += `${node.className}`;
                }
                return selector;
            },
            getSelectorEventData(event) {
                let data = '';
                for (let i = 0; i < event.sources.length; i++) {
                    const source = event.sources[i];
                    const {node} = source;
                    if (node) {
                        const selector = TRC.CLSReporter.generateQuerySelector(node);
                        if (selector) {
                            data += `selector='${selector}',val=${event.value}|`;
                        }
                    }
                }
                return data;
            },
            push(data) {
                if (data && data.prefixMessage) {
                    TRC.CLSReporter.reportFilteredCLS(data.prefixMessage, data.eventFilter);
                }
            },
            addCLSEventFilter(prefixMessage, eventFilter) {
                if (eventFilter === TRC.CLSReporter.CLSSelectorsFilter) {
                    if (!TRC.CLSReporter.CLSSelectorsEnabled) {
                        TRC.CLSReporter.CLSSelectorsEnabled = true;
                        TRC.CLSReporter.CLSSelectorsMessage = prefixMessage;
                    }
                } else {
                    TRC.CLSReporter.CLSEventsFilters.push({prefixMessage, eventFilter, clsValue: 0});
                }
            },
            reportFilteredCLS(prefixMessage, eventFilter) {
                TRC.CLSReporter.addCLSEventFilter(prefixMessage, eventFilter);
                TRC.CLSReporter.listenToCLSEventsAndReport();
            },
            listenToCLSEventsAndReport() {
                if (!TRC.CLSReporter.listenStarted && TRC.performance) {
                    TRC.CLSReporter.listenStarted = true;
                    let clsSelectorsCount = 0;
                    TRC.listen('onCls', event => {
                        TRC.CLSReporter.CLSEventsFilters.forEach(CLSEventFilter => {
                            if (!CLSEventFilter.eventFilter || CLSEventFilter.eventFilter(event)) {
                                CLSEventFilter.clsValue += event.value;
                            }
                        });
                        if (TRC.CLSReporter.CLSSelectorsEnabled && TRC.CLSReporter.maxSelectors2Send > clsSelectorsCount++) {
                            TRC.CLSReporter.CLSSelectorsMessage += TRC.CLSReporter.getSelectorEventData(event);
                        }
                    });
                    win.addEventListener('beforeunload', TRC.CLSReporter.fireCLSBeaconOnUnload.bind(this));
                }
            },
            fireCLSBeaconOnUnload() {
                TRC.CLSReporter.CLSEventsFilters.forEach(CLSEventFilter => {
                    __trcWarnUsingBeacon(`${CLSEventFilter.prefixMessage}:${CLSEventFilter.clsValue.toFixed(6)}`);
                });
                if (TRC.CLSReporter.CLSSelectorsEnabled) {
                    __trcWarnUsingBeacon(TRC.CLSReporter.CLSSelectorsMessage);
                }
            },
            init() {
                TRC.CLSEvents && TRC.CLSEvents.forEach(e => {
                    TRC.CLSReporter.push(e);
                });
                if (TRCImpl.global['cls-max-selectors']) {
                    TRC.CLSReporter.maxSelectors2Send = TRCImpl.global['cls-max-selectors'];
                }
                if (TRCImpl.global['enable-cls-selectors']) {
                    TRC.CLSReporter.push({prefixMessage: 'accumulating cls selectors:', eventFilter: TRC.CLSReporter.CLSSelectorsFilter});
                }
            }
        };
    })(window);

    (() => {
        TRC.CustomModulesManager = {
            registeredModules: {},

            getPath(path, folder) {
                switch (path) {
                    case undefined:
                    case 'ui-innovation':
                        return `${this.PATH.UI}/${folder}`;
                    case 'demand-formats':
                        return `${this.PATH.DEMAND}/${folder}`;
                    default:
                        return path;
                }
            },

            setGlobalPaths(trcImpl) {
                const cdnHostUrl = trcImpl.global['cdn-taboola-path'] || 'cdn.taboola.com';
                this.setGlobal = true;
                this.CDN = TRC.shiftDomain(cdnHostUrl);
                this.PATH = {
                    UI: trcImpl.global['ui-innovation-modules-path'] || 'ui-ab-tests',
                    DEMAND: 'demand-formats'
                };
            },

            getCustomModulesFromResponse(response, trcManager) {
                if (!response || !response.trc) {
                    return;
                }
                
                this.customModuleCga = TRC.Manager.prototype.parseClientGenericAction(response, 'cga');
                
                const modulesMap = {
                    feedExtension: this.createModuleMap(response.trc.f, true, 'drp'),
                    demandGenericAction: this.createModuleMap(response.trc.dcga, false),
                    clientGenericActionPageLevel: this.createModuleMap(this.customModuleCga, false),
                    clientGenericActionPlacementLevel: this.createModuleMap(response.trc.vl, true, 'cga'),
                    externalVideoReel: this.createModuleMap(response.trc.vl, true, 'evr')
                };
                this.loadModules(modulesMap, trcManager);
            },

            createModuleMap(root, loop, key) {
                return {
                    root,
                    loop,
                    key
                };
            },

            loadModules(modulesMap, trcImpl) {
                !this.setGlobal && this.setGlobalPaths(trcImpl);
                const moduleNames = Object.keys(modulesMap);
                moduleNames.forEach(moduleName => {
                    const module = modulesMap[moduleName];
                    if (module.root) {
                        if (module.loop) {
                            this.loadModulesFromChildren(module);
                        } else {
                            this.loadModulesFromRoot(module);

                        }
                    }
                });
            },

            loadModulesFromChildren(module) {
                Object.keys(module.root).forEach(key => {
                    const data = module.root[key];
                    if (data && data[module.key] && data[module.key].customModules) {
                        this.loadCustomModules(data[module.key].customModules, key);
                    }
                });
            },

            loadModulesFromRoot(module) {
                if (module.root && module.root.customModules) {
                    this.loadCustomModules(module.root.customModules);
                }
            },

            loadCustomModules(modulesData, feedPlacement) {
                try {
                    const modules = __trcUnJSONify(modulesData);
                    Object.keys(modules).forEach(property => {
                        if (property !== 'dependencies') {
                            const moduleName = property;
                            this.loadModule(moduleName, modules[moduleName], feedPlacement);
                        }
                    });
                } catch (e) {
                    __trcError(`Error while trying to parse json custom module, error msg: ${e} ,module data: ${modulesData}`);
                }
            },

            loadModule(moduleName, moduleOptions, feedPlacement) {
                let moduleInfo = this.getModuleInfo(moduleName);
                const isPlacementNotExistInModulesList = moduleInfo && (moduleInfo.feedsOriginPlacementNames.indexOf(feedPlacement) === -1);

                if (isPlacementNotExistInModulesList) {
                    moduleInfo.feedsOriginPlacementNames.push(feedPlacement);
                }

                if (moduleInfo || moduleOptions.disable === true) {
                    return;
                }

                moduleInfo = this.registeredModules[moduleName] = {
                    options: moduleOptions,
                    moduleName,
                    feedsOriginPlacementNames: [feedPlacement]
                };

                const path = this.getPath(moduleOptions.path, moduleName);

                if (this.shouldLoadResource(moduleOptions.js) && !moduleInfo.jsRequested) {
                    if (!TRC.customHooks) {
                        TRC.customHooks = {};
                    }
                    const jsFileName = moduleOptions.js || moduleName;
                    this.loadModuleResource(`${path}/${jsFileName}`, 'js', moduleName, moduleInfo);
                    moduleInfo.jsRequested = true;
                }

                if (this.shouldLoadResource(moduleOptions.css) && !moduleInfo.cssRequested) {
                    const cssFileName = moduleOptions.css || moduleName;
                    this.loadModuleResource(`${path}/${cssFileName}`, 'css', moduleName, moduleInfo);
                    moduleInfo.cssRequested = true;
                }
            },
            shouldLoadResource(resource) {
                if (typeof resource !== 'undefined') {
                    return !TRC.util.isFalse(resource);
                }
                return true;
            },
            /**
           * @param {string} hookName
           * @param {string} contextIdentifier can be placement name or ui-mode or null
           * @param {object} context the caller function instance ("this")
           * @param {object} hookArgs rest params - for each hook can be different like the internalc for list suffix or
           *                 placement data for after-card-created
           */
            runHook(hookName, contextIdentifier, context, ...hookArgs) { // contextIdentifier
                this.dispatchHook(hookName, contextIdentifier, context, hookArgs);
            },

            dispatchHook(hookName, contextIdentifier, context, hookArgs) {
                Object.keys(this.registeredModules).forEach(moduleName => {
                    const moduleInfo = this.getModuleInfo(moduleName);

                    if (!this.isRelevantType(contextIdentifier, moduleInfo, context)) {
                        return;
                    }
                    this.runCBOnModuleReady(moduleName, () => {
                        const moduleHookCallback = this.getModuleHook(moduleInfo, hookName, context, ...hookArgs);
                        moduleHookCallback && moduleHookCallback();
                    });
                });
            },

            getModuleInfo(moduleName) {
                return this.registeredModules[moduleName];
            },

            runCBOnModuleReady(moduleName, cb) {
                const moduleInfo = this.getModuleInfo(moduleName);
                if (moduleInfo && moduleInfo.ready) {
                    cb();
                } else {
                    this.listenToModuleReady(moduleName, cb);
                }
            },

            listenToModuleReady(moduleName, handler) {
                TRC.listen(`TRC.${moduleName}.ready`, handler);
            },

            waitForModule(moduleFileName, callback) {
                const {customModules: {dependencies} = {}} = this.customModuleCga || {};
                if (!dependencies) {
                    return callback;
                }
                const customModuleName = dependencies[moduleFileName];
                if (!customModuleName) {
                    return callback;
                }
                return () => {
                    TRC.CustomModulesManager.runCBOnModuleReady(customModuleName, callback.trcBind(this));
                };
            },

            isRelevantType(type, moduleInfo, context) {
                const {uiModes, placements} = moduleInfo.options;
                if (!type) {
                    return true;
                }

                if (context instanceof TRC.Feed) {
                    if (moduleInfo.feedsOriginPlacementNames.indexOf(context.mainContainerPlacement) === -1) {
                        return false;
                    }

                    if (!placements) {
                        return true;
                    }
                    return type && placements && (placements.indexOf(type) > -1);
                }

                if (context instanceof TRC.implClasses.TRCRBox) {
                    if (!uiModes) {
                        return true;
                    }
                    return type && uiModes && (uiModes.indexOf(type) > -1);
                }
            },

            getModuleHook(moduleInfo, hookName, context, ...hookArgs) {
                const module = TRC.customHooks[moduleInfo.moduleName];
                return module && module.hooks && module.hooks[hookName] && module.hooks[hookName].trcBind(context, ...hookArgs, context);
            },

            isEveryModuleNeededLoaded(moduleInfo) {
                const isJsNeeded = this.shouldLoadResource(moduleInfo.options.js);
                const isCssNeeded = this.shouldLoadResource(moduleInfo.options.css);

                return ((!isJsNeeded || !!moduleInfo.jsReady) && (!isCssNeeded || !!moduleInfo.cssReady));
            },

            loadModuleResource(fileName, fileType, moduleName, moduleInfo, retryCount = 0) {
                const fileURL = `${TRC.PROTOCOL}//${this.CDN}/${fileName}.${fileType}`;
                const maxRetries = TRCImpl.global['module-load-retry'] || 2;

                TRC.net.loadScript(fileURL, fileType, e => {
                    if (e.type === 'error') {
                        if (retryCount >= maxRetries) {
                            __trcError(`Failed to load custom module resource ${fileURL}`);
                        } else {
                            TRC.CustomModulesManager.loadModuleResource(fileName, fileType, moduleName, moduleInfo, ++retryCount);
                        }
                    } else {
                        moduleInfo[`${fileType}Ready`] = true;
                        if (this.isEveryModuleNeededLoaded(moduleInfo)) {
                            moduleInfo.ready = true;
                            TRC.dispatch(`TRC.${moduleName}.ready`);
                        }
                    }
                }, true);
            }
        };
    })();

    ((win, doc) => {
        TRC.docVisibilityUtil = (function () {
            let hidden = '';
            let visibilityChangeEvent = '';
            if (typeof doc.hidden !== 'undefined') {
                hidden = 'hidden';
                visibilityChangeEvent = 'visibilitychange';
            } else if (typeof doc.msHidden !== 'undefined') {
                hidden = 'msHidden';
                visibilityChangeEvent = 'msvisibilitychange';
            } else if (typeof doc.webkitHidden !== 'undefined') {
                hidden = 'webkitHidden';
                visibilityChangeEvent = 'webkitvisibilitychange';
            }

            if (!hidden) {
                return {
                    addEventListener: () => {
                    },
                    isVisible: () => null
                };
            }

            function isVisible() {
                return !doc[hidden];
            }

            function addEventListener(callback) {
                doc.addEventListener(visibilityChangeEvent, () => {
                    callback(isVisible());
                }, false);
            }

            return {
                addEventListener,
                isVisible
            };
        }());
    })(window, document);

    (function () {

        TRC.lazyLoadingDependencies = {
            'distance-from-article': [
                {
                    fileName: 'article-detection',
                    objectName: 'ArticleDetection'
                }
            ],
            'share-buttons-detection': [
                {
                    fileName: 'article-detection',
                    objectName: 'ArticleDetection'
                }
            ],
            'bid-detection': [
                {
                    fileName: 'distance-from-article',
                    objectName: 'DistanceFromArticle'
                }
            ],
            'stories-vertical-ui': [
                {
                    fileName: 'stories-transition-manager',
                    objectName: 'StoriesTransitionsManager',
                    isMandatory: true
                },
                {
                    fileName: 'stories-video-manager',
                    objectName: 'StoriesVideoManager'
                }
            ]
        };

    }());

    (() => {
        TRC.ModuleLoader = {
            requestedModules: {},
            load(moduleFile, moduleObj, callback, isRetry, retryCount) {
                // this only related to custom module, we delay callback when there is a dependency.
                callback = TRC.CustomModulesManager.waitForModule(moduleFile, callback);
                retryCount = typeof retryCount === 'undefined'
                    ? (window.TRCImpl && TRCImpl.global && TRCImpl.global['module-load-retry']) || 2
                    : retryCount;

                if (moduleObj) {
                    callback();
                } else if (this.requestedModules[moduleFile] && !isRetry) {
                    this.requestedModules[moduleFile].callbacks.push(callback);
                } else {

                    if (!isRetry) {
                        this.requestedModules[moduleFile] = {
                            callbacks: [this.logSuccessToPerformance.trcBind(this, moduleFile), callback]
                        };
                        (TRC.performance && TRC.performance.mark(`moduleLazyLoad${moduleFile}start`, null, '', moduleFile, 'moduleLazyLoadTime', TRC.PerfEvenType.START));
                    }

                    const fingerPrintedFileName = this.toFingerPrintedName(moduleFile);
                    const dependencies = TRC.lazyLoadingDependencies[moduleFile];
                    if (!dependencies || dependencies.length <= 0) {
                        TRC.loadTaboolaScript(
                            fingerPrintedFileName, true,
                            this.requestedModules[moduleFile].callbacks,
                            e => {
                                this.loadErrorCallback(e, retryCount, moduleFile, moduleObj, callback, fingerPrintedFileName);
                            }
                        );
                    } else {
                        const loadModuleScript = () => {
                            TRC.loadTaboolaScript(
                                fingerPrintedFileName, true,
                                e => {
                                    this.invokeCallbackUponFullLoad(++modulesLoaded, dependencies.length, moduleFile, e);
                                },
                                e => {
                                    this.loadErrorCallback(e, retryCount, moduleFile, moduleObj, callback, fingerPrintedFileName);
                                }
                            );
                        };
                        const mandatoryModules = this.createMandatoryTable(dependencies) || {};
                        let modulesLoaded = 0;
                        if (Object.keys(mandatoryModules).length === 0) {
                            loadModuleScript();
                        }
                        if (!isRetry) {
                            dependencies.forEach(dependency => {
                                const {fileName} = dependency;
                                this.load(dependency.fileName, TRC[dependency.objectName], e => {
                                    this.invokeCallbackUponFullLoad(++modulesLoaded, dependencies.length, moduleFile, e);
                                    try {
                                        if (mandatoryModules[fileName] === false) {
                                            mandatoryModules[fileName] = true;
                                            if (this.isMandatoryModulesLoaded(mandatoryModules)) {
                                                loadModuleScript();
                                            }
                                        }
                                    } catch (error) {
                                        __trcError(`failed to check mandatory module ${fileName}. Error is: ${error.message}`, error);
                                    }
                                });
                            });
                        }
                    }
                }
            },
            createMandatoryTable(dependencies) {
                if (!Array.isArray(dependencies)) {
                    return {};
                }
                return dependencies.reduce((a, b) => {
                    if (b.isMandatory) {
                        a[b.fileName] = false;
                    }
                    return a;
                }, {});
            },
            isMandatoryModulesLoaded(mandatoryModules) {
                return Object.keys(mandatoryModules).every(module => mandatoryModules[module]);
            },
            invokeCallbackUponFullLoad(modulesLoaded, numOfDependencies, moduleFile, event) {
                if (modulesLoaded < numOfDependencies + 1) {
                    return;
                }
                const chainedCallback = this.chainCallbacks(this.requestedModules[moduleFile].callbacks);
                chainedCallback(event);
            },
            logSuccessToPerformance(moduleFile) {
                (TRC.performance && TRC.performance.mark(`moduleLazyLoad${moduleFile}stop`, null, '', moduleFile, 'moduleLazyLoadTime', TRC.PerfEvenType.STOP));
            },
            toFingerPrintedName(file) {
                const fileExtension = `${(TRC.hasES6Support() ? 'es6' : 'es5')}.js`;
                return `${file}.${TRC.version}.${fileExtension}`;
            },
            chainCallbacks(callbacks) {
                if (Array.isArray(callbacks)) {
                    return e => {
                        callbacks.forEach(cb => cb(e));
                    };
                }
                return typeof callbacks === 'function' ? callbacks : () => {};
            },
            loadErrorCallback(e, retryCount, moduleFile, moduleObj, callback, fingerPrintedFileName) {
                if (retryCount > 0) {
                    TRC.ModuleLoader.load(moduleFile, moduleObj, callback, true, --retryCount);
                } else {
                    this.logError(e, fingerPrintedFileName);
                    this.requestedModules[moduleFile] = null;
                    TRC.dispatch('module-loader-failure', {moduleFile, moduleObj, fingerPrintedFileName});
                }
            },
            logError(error, fileName) {
                __trcError(`failed to load module ${fileName}. Error is: ${error.message}`, error);
            }
        };
    })();

    (win => {
        // TODO: If need to use window.fetch API if beacon is not present you can add the code here and it will be transparant to the current usage.
        const hasBeaconSupport = !!win.navigator.sendBeacon;

        TRC.hasNetworkAsyncSupport = () => hasBeaconSupport;

        TRC.sendPostAsyncCall = (url, body) => {
            if (hasBeaconSupport) {
                win.navigator.sendBeacon(url, body);
                return true;
            }
            return false;
        };

    })(window);

    /**
     * This module allows logging usage of RBox features to the TRC, using the "debug" event.
     * Use this module if, for example, you would like to know if a certain
     * point in the code is ever reached, in which publishers and how much (recommended to use  in
     * conjunction with ElasticSearch / Kusto).
     *
     * NOTE: use wisely, every log is a new network call which may effect page performance.
     *       For example, if you are logging a code path that is be called to happen several times
     *       in a single page view, consider caching the logging and making it happen only once.
     *
     */
    (() => {
        TRC.RBoxUsage = {
            /**
             * logs usage of code to TRC using debug event
             *
             * @param feature - the name of the feature, a unique way to tag the feature in the logs
             * @param [file] (optional) - the file name of the module that runs the logged code
             * @param [method] (optional) - the name of the method that runs the logged code
             * @param [position] (optional) - the position in the method (can be a named tag or number) - use if
             *                  you intend to add several logs in the same method
             * @param [skipCaching] (optional) - whether to skip protection from repetitive logging of the same feature
             *                  if it happens more than twice in a page view (see logMessageToServer in debug.js), to protect from
             *                  bombarding with network calls.
             *                  Defaults to false - set to true only if you know what you are doing!
             */
            logUsage(feature, {
                file = '', method = '', position = '', skipCaching, extraData = {}
            } = {}) {
                if (TRCImpl && TRCImpl.global && TRCImpl.global['disable-rbox-usage-logging']) {
                    return;
                }
                
                TRC.modDebug.logMessageToServer(
                    4,
                    feature,
                    {
                        file,
                        method,
                        position,
                        extraData: __trcJSONify(extraData)
                    },
                    skipCaching
                );
            }
        };
    })();

    (win => {
        /**
         * This module is used to report total blocking time (TBT) on the page
         * The report is sent on pagehide event
         * The report is only set when performance reporting is enabled
         */
        function extractJsUrlFromText(str) {
            const urlMatch = str.match(/http.*?\.js/);
            return urlMatch ? urlMatch[0] : '';
        }

        function isPercentEnabledEnableLoaf() {
            return TRC.util.isPercentEnabled(TRCImpl.global, 'enable-loaf');
        }
        /**
         * Taboola is major if its scripts are in charge of more than half of the duration or it has a script with duration > 50ms
         * @param originDurations
         * @param script
         * @param entryDuration
         */
        function isTaboolaMajor(originDurations, script, entryDuration) {
            const scriptIsTaboola = script.sourceLocation ? script.sourceLocation.indexOf(TABOOLA_DOMAIN) > -1 : false;
            if (!scriptIsTaboola) {
                return false;
            }
            const scriptIsBlocking = script.duration > TRC.TBTReporter.MAX_MS_FOR_SHORT_TASK;
            const taboolaDurationIsMoreThanHalf = originDurations[TABOOLA_DOMAIN] > entryDuration / 2;
            const taboolaIsResponsibleForTheEntry = scriptIsBlocking || taboolaDurationIsMoreThanHalf;
            return taboolaIsResponsibleForTheEntry;
        }
        function addEffectiveBlockingTimeToEntity(options) {
            const {
                parentEntity,
                entityId,
                effectiveBlockingTimeDelta,
                count
            } = options;
            if (!parentEntity[entityId]) {
                parentEntity[entityId] = win.__trcCopyProps(initialPerformanceData, {});
            }
            const entity = parentEntity[entityId];
            entity.duration += effectiveBlockingTimeDelta;
            entity.count += count;
            if (options.hasInteraction) {
                entity.countwithinteraction += count;
                entity.durationwithinteraction += effectiveBlockingTimeDelta;
            }
            if (options.taboolaIsMajor) {
                entity.majorcount += count;
                entity.majorduration += effectiveBlockingTimeDelta;
                if (options.hasInteraction) {
                    entity.majorcountwithinteraction += count;
                    entity.majordurationwithinteraction += effectiveBlockingTimeDelta;
                }
            }
        }

        const AGGREGATED_PERFORMANCE_DATA_ENTITY_ID = 'total';
        const TABOOLA_DOMAIN = 'taboola.com';
        const initialPerformanceData = {
            count: 0,
            countwithinteraction: 0,
            duration: 0,
            majorcountwithinteraction: 0,
            majorcount: 0,
            durationwithinteraction: 0,
            majorduration: 0,
            majordurationwithinteraction: 0
        };
        TRC.TBTReporter = {
            MAX_MS_FOR_SHORT_TASK: 50,
            TBT: 0,
            LOAF_ENTRY_TYPE: 'long-animation-frame',
            TBT_REPORTED: false,
            loafReport: {},
            loafCulpritsReport: {},
            getTBT() {
                return this.TBT;
            },
            setTBT(duration) {
                this.TBT = duration;
            },
            isEntryTypeSupported(metric) {
                if (metric === this.LOAF_ENTRY_TYPE) {
                    // hack because of Google origin-trial bug
                    const longAnimationFramesSupported = window.PerformanceLongAnimationFrameTiming;
                    return !!longAnimationFramesSupported;
                }
                const supportedEntryTypes = win.PerformanceObserver && win.PerformanceObserver.supportedEntryTypes;
                return !(!supportedEntryTypes || supportedEntryTypes.indexOf(metric) === -1);

            },
            isLoafSupported() {
                return this.isEntryTypeSupported(this.LOAF_ENTRY_TYPE);

            },
            addLongTasksObserver() {
                const observer = new PerformanceObserver(this.longTasksListener.bind(this));
                try {
                    observer.observe({type: 'longtask', buffered: true});
                    return true;
                } catch (e) {
                    if (e.message && e.message.indexOf('entryTypes') === -1) {
                        win.__trcError(`error in addLongTasksObserver: ${e.message}`);
                    }
                    return false;
                }
            },
            addLoafExperimentMetaTag() {
                const otMeta = document.createElement('meta');
                otMeta.httpEquiv = 'origin-trial';
                otMeta.content = TRCImpl.global['loaf-token'];
                document.head.appendChild(otMeta);
            },
            handleLongAnimationFrameScript(taboolaLoafReport, nonTaboolaLoafReport, script) {
                const LOAF_THRESHOLD = TRCImpl.global['loaf-threshold'] || 50;
                const effectiveBlockingTime = Math.max(script.duration - LOAF_THRESHOLD, 0);
                const source = script.sourceLocation;
                if (!source) {
                    return 'no_sourcelocation';
                }
                const sourceUrl = extractJsUrlFromText(source);
                if (!sourceUrl) {
                    return 'no_sourceurl';
                }
                const url = new URL(sourceUrl);
                const domainName = url.hostname;
                if (!domainName) {
                    return 'no_hostname';
                }
                const scriptBelongsToTaboola = domainName.indexOf(TABOOLA_DOMAIN) !== -1;
                const addTaboolaScriptToLoafReport = () => {
                    const scriptName = url.pathname.split('/').pop();
                    if (!scriptName) {
                        return;
                    }
                    if (!taboolaLoafReport[domainName]) {
                        taboolaLoafReport[domainName] = {[scriptName]: win.__trcCopyProps(initialPerformanceData, {})};
                    }
                    addEffectiveBlockingTimeToEntity({
                        parentEntity: taboolaLoafReport[domainName],
                        entityId: scriptName,
                        effectiveBlockingTimeDelta: effectiveBlockingTime,
                        count: 1
                    });
                };
                if (scriptBelongsToTaboola) {
                    addTaboolaScriptToLoafReport();
                } else {
                    addEffectiveBlockingTimeToEntity({
                        count: 1,
                        parentEntity: nonTaboolaLoafReport,
                        entityId: domainName,
                        effectiveBlockingTimeDelta: effectiveBlockingTime
                    });
                }
                return domainName;
            },
            summarizeNonTaboolaLoafReport(nonTaboolaLoafReport, hasInteraction) {
                let nonTaboolaDuration = 0;
                TRC.util.objectForEach(nonTaboolaLoafReport, domainName => {
                    nonTaboolaDuration += nonTaboolaLoafReport[domainName].duration;
                    if (nonTaboolaLoafReport[domainName]) {
                        addEffectiveBlockingTimeToEntity({
                            parentEntity: this.loafReport.withtaboola,
                            entityId: domainName,
                            count: nonTaboolaLoafReport[domainName].count,
                            effectiveBlockingTimeDelta: nonTaboolaLoafReport[domainName].duration,
                            hasInteraction
                        });
                    }
                });
                addEffectiveBlockingTimeToEntity({
                    parentEntity: this.loafReport.withtaboola,
                    entityId: AGGREGATED_PERFORMANCE_DATA_ENTITY_ID,
                    count: 1,
                    effectiveBlockingTimeDelta: nonTaboolaDuration,
                    hasInteraction
                });
            },
            summarizeTaboolaLoafReport(taboolaLoafReport, hasInteraction, taboolaIsMajor) {
                let taboolaDuration = 0;
                TRC.util.objectForEach(taboolaLoafReport, domainName => {
                    let domainDuration = 0;
                    TRC.util.objectForEach(taboolaLoafReport[domainName], scriptName => {
                        taboolaDuration += taboolaLoafReport[domainName][scriptName].duration;
                        domainDuration += taboolaLoafReport[domainName][scriptName].duration;
                        if (!this.loafReport.taboola.domains[domainName]) {
                            this.loafReport.taboola.domains[domainName] = {};
                        }
                        addEffectiveBlockingTimeToEntity({
                            parentEntity: this.loafReport.taboola.domains[domainName],
                            entityId: scriptName,
                            count: taboolaLoafReport[domainName][scriptName].count,
                            effectiveBlockingTimeDelta: taboolaLoafReport[domainName][scriptName].duration,
                            hasInteraction,
                            taboolaIsMajor
                        });
                    });
                    addEffectiveBlockingTimeToEntity({
                        parentEntity: this.loafReport.taboola.domains[domainName],
                        entityId: AGGREGATED_PERFORMANCE_DATA_ENTITY_ID,
                        count: 1,
                        effectiveBlockingTimeDelta: domainDuration,
                        hasInteraction,
                        taboolaIsMajor
                    });
                });
                addEffectiveBlockingTimeToEntity({
                    parentEntity: this.loafReport.taboola,
                    entityId: AGGREGATED_PERFORMANCE_DATA_ENTITY_ID,
                    count: 1,
                    effectiveBlockingTimeDelta: taboolaDuration,
                    hasInteraction,
                    taboolaIsMajor
                });
            },
            getCulpritRegex() {
                return TRCImpl.global['loaf-culprits-regex'];
            },
            addToCustomLoafReport(list) {
                list.getEntries().forEach(entry => {
                    entry.scripts.forEach(script => {
                        const {sourceLocation} = script;
                        if (!new RegExp(this.getCulpritRegex()).test(sourceLocation)) {
                            return;
                        }
                        const urlParts = sourceLocation.match(/(\w+@)?(http.:\/\/)?(\w+\.\w+\.\w+)\/(.+)/);
                        let pathname;
                        let protocol;
                        let hostname;
                        let funcName = '';
                        if (!urlParts || urlParts.length < 5) {
                            pathname = sourceLocation;
                        } else {
                            [, funcName, protocol, hostname, pathname] = urlParts;
                        }
                        if (!pathname) {
                            pathname = sourceLocation;
                        }
                        const name = script.name ? script.name.replace(protocol + hostname, '') : '';
                        if (!this.loafCulpritsReport[pathname]) {
                            this.loafCulpritsReport[pathname] = {
                                count: 1,
                                funcName,
                                name,
                                totalDuration: script.duration
                            };
                        } else {
                            this.loafCulpritsReport[pathname].count++;
                            this.loafCulpritsReport[pathname].totalDuration += script.duration;
                        }
                        if (script.duration > 50) {
                            if (!this.loafCulpritsReport[pathname].bd) {
                                this.loafCulpritsReport[pathname].bd = [];
                            }
                            this.loafCulpritsReport[pathname].bd.push(script.duration - 50);
                        }
                    });
                });
            },
            addToAggLoafReport(list) {
                list.getEntries().forEach(entry => {
                    if (entry.blockingDuration === 0) {
                        return;
                    }
                    let majorOrigin = 'no_scripts';
                    const hasInteraction = entry.firstUIEventTimestamp > 0;
                    const originDurations = {};
                    const nonTaboolaLoafReport = {};
                    const taboolaLoafReport = {};
                    let taboolaIsMajor;
                    entry.scripts.forEach((script, index) => {
                        const domainName = this.handleLongAnimationFrameScript(taboolaLoafReport, nonTaboolaLoafReport, script);
                        if (!originDurations[domainName]) {
                            originDurations[domainName] = 0;
                        }
                        originDurations[domainName] += script.duration;
                        const scriptIsFirst = index === 0;
                        const originDurationIsMax = scriptIsFirst || (originDurations[domainName] > originDurations[majorOrigin]);
                        if (originDurationIsMax) {
                            majorOrigin = domainName;
                        }
                        if (isTaboolaMajor(originDurations, script, entry.duration)) {
                            taboolaIsMajor = true;
                        }
                    });

                    const foundTaboola = Object.keys(taboolaLoafReport).length;
                    if (foundTaboola) {
                        if (Object.keys(nonTaboolaLoafReport).length) {
                            this.summarizeNonTaboolaLoafReport(nonTaboolaLoafReport, hasInteraction);
                        }
                        this.summarizeTaboolaLoafReport(taboolaLoafReport, hasInteraction, taboolaIsMajor);
                    }
                    addEffectiveBlockingTimeToEntity({
                        parentEntity: this.loafReport,
                        entityId: 'global',
                        effectiveBlockingTimeDelta: entry.blockingDuration,
                        count: 1,
                        hasInteraction,
                        taboolaIsMajor
                    });
                    if (hasInteraction) {
                        const globalLoaf = this.loafReport.global;
                        if (entry.blockingDuration > globalLoaf.inpBlockingDuration) {
                            globalLoaf.inpBlockingDuration = entry.blockingDuration;
                            globalLoaf.inpOrigin = majorOrigin;
                        }

                        if (taboolaIsMajor) {
                            globalLoaf.taboolaInpBlockingDuration = Math.max(globalLoaf.taboolaInpBlockingDuration, entry.blockingDuration);
                        }
                    }
                });
            },
            longAnimationFramesHandler(list) {
                if (isPercentEnabledEnableLoaf()) {
                    this.addToAggLoafReport(list);
                }
                if (this.getCulpritRegex()) {
                    this.addToCustomLoafReport(list);
                }
            },
            observeLoaf() {
                if (!isPercentEnabledEnableLoaf() && !this.getCulpritRegex()) {
                    return false;
                }
                const loafObserver = new PerformanceObserver(this.longAnimationFramesHandler.bind(this));
                loafObserver.observe({
                    type: this.LOAF_ENTRY_TYPE,
                    buffered: true
                });
                return true;
            },
            addLongAnimationFramesObserver() {
                try {
                    this.loafReport = {
                        taboola: {
                            domains: {},
                            total: win.__trcCopyProps(initialPerformanceData, {})
                        },
                        withtaboola: {
                            total: win.__trcCopyProps(initialPerformanceData, {})
                        },
                        global: win.__trcCopyProps(initialPerformanceData, {
                            inpBlockingDuration: 0,
                            taboolaInpBlockingDuration: 0
                        })
                    };
                    this.loafCulpritsReport = {};
                    this.addLoafExperimentMetaTag();
                    if (!this.isLoafSupported()) {
                        __trcWarn(`loafSupported:false`);
                        return false;
                    }
                    __trcWarn(`loafSupported:true`);
                    return this.observeLoaf();
                } catch (error) {
                    if (win.__trcWarn) {
                        win.__trcWarn('failed to add taboola loaf to perf', error);
                    }
                    return false;
                }
            },
            addPerfMetric(metric, start, duration) {
                const data = {
                    name: `generalMeasure_${metric}`,
                    entryType: 'measure',
                    startTime: start,
                    duration
                };
                TRC.performance.measurements.push(data);
            },
            logLongAnimationFrames() {
                if (!this.isLoafSupported()) {
                    return;
                }
                if (isPercentEnabledEnableLoaf()) {
                    win.__trcWarn(`loaf:${JSON.stringify(this.getLoAFReport())}`);
                }
                if (this.getCulpritRegex()) {
                    win.__trcWarn(`loafCulprits:${JSON.stringify(this.loafCulpritsReport)}`);
                }
            },
            addTBT(duration) {
                this.setTBT(this.TBT + duration);
            },
            isPerfActivated() {
                return TRC.performance && TRC.Performance && TRC.performance instanceof TRC.Performance;
            },
            longTasksListener(longTaskEntryList) {
                longTaskEntryList.getEntries().forEach(entry => this.processLongTask(entry));
            },
            getLoAFReport() {
                return this.loafReport;
            },
            processLongTask(longTask) {
                const overhead = longTask.duration - this.MAX_MS_FOR_SHORT_TASK;
                this.addTBT(overhead);
            },
            logMeasurements() {
                this.addPerfMetric('TBT', performance.now(), this.TBT);
                TRC.performance.logMeasurements(true, true);
            },
            reportTBT() {
                let experiments = '';
                win.removeEventListener('visibilitychange', this.visibilityListener, true);
                if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-warn-tbt')) {
                    if (win.TRCImpl.tbtExperimentsVariantIdsStr) {
                        experiments = `&${win.TRCImpl.tbtExperimentsVariantIdsStr}`;
                    }

                    win.__trcWarn(`TBT=${this.TBT}${experiments}`);
                }

                if (!this.isPerfActivated()) {
                    return;
                }
                this.logMeasurements();
            },
            reportLoAF() {
                win.removeEventListener('visibilitychange', this.visibilityListener, true);
                this.logLongAnimationFrames();
            },
            scheduleTbtReport() {
                this.visibilityListener = () => {
                    if (document.visibilityState !== 'hidden') {
                        return;
                    }
                    if (this.TBT_REPORTED) {
                        return;
                    }
                    this.TBT_REPORTED = true;
                    if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-warn-tbt') || this.isPerfActivated()) {
                        this.reportTBT();
                    }
                    if (isPercentEnabledEnableLoaf() || this.getCulpritRegex()) {
                        this.reportLoAF();
                    }
                };
                win.addEventListener('visibilitychange', this.visibilityListener, true);
            },
            init() {
                if (TRC._trecsInit) {
                    return;
                }
                if (!win.PerformanceObserver) {
                    return;
                }
                if (benchMarkBrowser() > TRCImpl.global['browser-benchmark']) {
                    return;
                }
                let tbtObserved = false;
                let loafObserved = false;

                if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-warn-tbt') || this.isPerfActivated()) {
                    tbtObserved = this.addLongTasksObserver();
                }
                if (isPercentEnabledEnableLoaf() || this.getCulpritRegex()) {
                    loafObserved = this.addLongAnimationFramesObserver();
                }
                if (tbtObserved || loafObserved) {
                    this.scheduleTbtReport();
                }
            }
        };
        function benchMarkBrowser() {
            const {performance} = window;
            const now = performance.now.bind(performance);
            const start = now();
            for (let i = 0; i < 1000000; i++) {
                // eslint-disable-next-line no-unused-vars
                const a = i * i;
            }
            return now() - start;
        }
    })(window);

    (() => {
        TRC.unifiedPlacementsProductsUtil = {
            containersReset: (productsList, productSelectorAttr) => {
                Object.keys(productsList).forEach(key => {
                    const containerId = productsList[key].mainContainerId,
                        productToReset = document.querySelectorAll(`[${productSelectorAttr}=${containerId}]`);

                    for (let index = 0; index < productToReset.length; index++) {
                        const currentContainer = productToReset[index];
                        const productObserver = currentContainer.getAttribute(TRC.intersections.TARGET_ATTRIB);

                        if (index > 0) {
                            currentContainer.remove();
                            continue;
                        }

                        currentContainer.className = currentContainer.origClassName;
                        currentContainer.innerHTML = '';

                        if (productObserver) {
                            TRC.intersections.unobserveAll(productObserver);
                        }
                    }
                });
            }
        };
    })();

    let isAvailable = false;
    try {
        isAvailable = !!window.HTMLElement && (!!window.customElements || !!document.registerElement);
    // eslint-disable-next-line no-empty
    } catch (error) {}

    const HTMLElementClass = isAvailable ? window.HTMLElement : class HTMLElementMOCK {};

    class GenericWebComponent extends HTMLElementClass {
        static get isAvailable() {
            return isAvailable;
        }

        attachShadow({mode = 'open'} = {}) {
            if (super.attachShadow) {
                return super.attachShadow({mode});
            }

            if (super.createShadowRoot) {
                super.createShadowRoot();
                const {shadowRoot} = this;
                if (mode !== 'open') {
                    this.shadowRoot = null;
                }
                return shadowRoot;
            }

            return null;
        }

        static checkRegistration({name, component} = {}) {
            if (!isAvailable) {
                return false;
            }

            try {
                return document.createElement(name) instanceof component;
            // eslint-disable-next-line no-empty
            } catch (error) {}

            return false;
        }

        static registerElement({name, component} = {}) {
            if (!isAvailable) {
                return false;
            }

            let successfullyRegister = false;
            try {
                if (window.customElements) {
                    window.customElements.get(name)
                    || window.customElements.define(name, component);
                    successfullyRegister = GenericWebComponent.checkRegistration({name, component});
                } else if (document.registerElement && document.isRegistered) {
                    document.isRegistered(name) || document.registerElement(name, component);
                    successfullyRegister = GenericWebComponent.checkRegistration({name, component});
                }
                // eslint-disable-next-line no-empty
            } catch (error) {}

            if (!successfullyRegister) {
                isAvailable = false;
            }

            return successfullyRegister;
        }
    }

    try {
        // Check if shadow root is supported, if not change isAvailable to be false.
        const closedShadowDiv = document.createElement('div');
        const openedShadowDiv = document.createElement('div');
        const closedShadowRoot = GenericWebComponent.prototype.attachShadow.call(closedShadowDiv, {mode: 'closed'});
        const openedShadowRoot = GenericWebComponent.prototype.attachShadow.call(openedShadowDiv);
        if (!closedShadowRoot || closedShadowDiv.shadowRoot !== null || !openedShadowRoot || openedShadowDiv.shadowRoot !== openedShadowRoot) {
            isAvailable = false;
        }
    } catch (error) {
        isAvailable = false;
    }

    const attributes = {
        rating: 'rating',
        postRatingNumber: 'post-rating-number',
        price: 'price',
        separatedBy: 'separated-by'
    };
    let styleHasLoaded$1 = false;

    class TblStarRating extends GenericWebComponent {
        connectedCallback() {
            loadedStyle$1();
            this.classList.add('video-branding-flex-cta-rating');
            this.render();
        }

        static get observedAttributes() { return Object.values(attributes); }

        attributeChangedCallback(name, oldValue, newValue) {
            if (newValue === oldValue) { return; }
            this.render();
        }

        render() {
            this.innerHTML = '';
            const elements = [];
            try {
                if (this.hasAttribute(attributes.price)) {
                    elements.push(this.generatePriceElement());
                }
                if (this.hasAttribute(attributes.rating)) {
                    elements.push(this.generateStarElement());
                    if (this.hasAttribute(attributes.postRatingNumber)) {
                        elements.push(this.generateStarNumberElement());
                    }
                }
                const separatedBy = this.getAttribute(attributes.separatedBy);
                elements.forEach((element, index) => {
                    if (index) {
                        const span = createSeparator(separatedBy);
                        this.appendChild(span);
                    }
                    this.appendChild(element);
                });
                // eslint-disable-next-line no-empty
            } catch (error) { }
        }

        get rating() {
            const rating = (+`${this.getAttribute(attributes.rating)}`) || 0;
            return rating;
        }

        generatePriceElement() {
            const price = this.getAttribute(attributes.price);
            const span = document.createElement('span');
            span.innerText = price;
            span.classList.add('video-branding-flex-cta-price-wrapper');
            return span;
        }

        generateStarElement() {
            return drawStars({
                rating: this.rating
            });
        }

        generateStarNumberElement() {
            const span = document.createElement('span');
            span.innerText = this.rating.toFixed(1);
            return span;
        }
    }
    GenericWebComponent.registerElement({name: 'tbl-star-rating', component: TblStarRating});


    function loadedStyle$1() {
        if (!styleHasLoaded$1) {
            try {
                TRC.dom.injectStyle(`.videoCube .video-branding-flex-cta-stars-wrapper { display: inline-block; display: inline-flex; flex-direction: row; align-items: center; } .videoCube .video-branding-flex-cta-stars-wrapper .cta-rating-star { margin-right: 4px; height: 1em; width: 1em; }.videoCube .video-branding-flex-cta-rating { flex-basis: 100%; padding-bottom: 2px; padding-top: 2px; margin-top: 5px; direction: ltr; } .videoCube .video-branding-flex-cta-rating .video-branding-flex-cta-oval-wrapper { margin-left: 6px; margin-right: 6px; } .videoCube .video-branding-flex-cta-rating .video-branding-flex-cta-oval-wrapper .cta-rating-oval { vertical-align: middle; margin-bottom: 1px; height: 3px; width: 3px; } .videoCube .video-branding-flex-cta-rating .video-branding-flex-cta-price-wrapper { font-family: Helvetica Bold; font-size: 10px; color: #737373; }`, null);
            // eslint-disable-next-line no-empty
            } catch (error) {}
            styleHasLoaded$1 = true;
        }
    }

    const drawStars = ({rating = 0}) => {
        const randomId = `${Date.now().toString(34)}-${Math.random().toString(34)}`.replaceAll('.', '');// to disable index collisions
        const drawSingleStar = (percentage, index) => `
        <svg class="cta-rating-star"
            height="9px"
            version="1.1"
            viewBox="0 0 9 9"
            width="9px"
            xmlns="http://www.w3.org/2000/svg">
            <g fill="none" fill-rule="evenodd" stroke="none" stroke-width="1">
                <linearGradient id="lg${index}-${randomId}" x1="0" x2="1" y1="0.5" y2="0.5">
                    <stop offset="0" stop-color="#737373" stop-opacity="1" />
                    <stop offset="${percentage}" stop-color="#737373" stop-opacity="1" />
                    <stop offset="${percentage}" stop-color="#737373" stop-opacity="0.5" />
                    <stop offset="1" stop-color="#737373" stop-opacity="0.5" />
                </linearGradient>
                <g fill="url(#lg${index}-${randomId})" fill-rule="nonzero" transform="translate(-21, -19)">
                    <polygon points="25.5 26.4626165 22.7188471 28 23.25 24.7437694 21 22.4376941 24.1094235 21.9626165 25.5 19 26.8905765 21.9626165 30 22.4376941 27.75 24.7437694 28.2811529 28">
                    </polygon>
                </g>
            </g>
        </svg>`;
        const span = document.createElement('span');
        span.classList.add('video-branding-flex-cta-stars-wrapper');
        span.innerHTML = Array(5)
            .fill(0)
            .map((_, index) => drawSingleStar(Math.min(Math.max(rating - index, 0), 1), index))
            .join('');
        return span;
    };

    const createSeparator = type => {
        switch (type) {
            case 'oval': return createSvgOval();
            default:
        }
        const span = document.createElement('span');
        span.innerHTML = '&emsp;';
        return span;
    };

    const createSvgOval = () => {
        const span = document.createElement('span');
        span.classList.add('video-branding-flex-cta-oval-wrapper');
        span.innerHTML = `
        <svg class="cta-rating-oval"
            width="3px"
            height="3px"
            viewBox="0 0 3 3"
            version="1.1"
            xmlns="http://www.w3.org/2000/svg">
            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                <g transform="translate(-172, -485)" fill="#666666" fill-rule="nonzero">
                    <circle cx="173.5" cy="486.5" r="1.5">
                    </circle>
                </g>
            </g>
        </svg>`;
        return span;
    };

    /**
     * Created by dotan.l on 17/09/2020.
     */
    (() => {
        class CTAManager {
            constructor() {
                this.cardIndexOnPage = 0;
                this.globalConfig = [];
                this.horizontalMarginToFilter = 0.1;
                this.ctaChildrenParentGap = 10;
                this.videoLabelBoxWidthRatio = 0.98;
                this.ctaButtonTextAmountOfChars = 15;
                this.maxCharsForItemId = 40; // found containing the unique item id
                this.urlParams = {};
                this.ctaButtons = {};
            }

            static initialize(rbox, itemContainer) {
                if (!TRC.ctaManager) {
                    if (!CTAManager.shouldCreateCTAManager(rbox, itemContainer)) {
                        return;
                    }

                    TRC.ctaManager = new CTAManager();
                    TRC.ctaManager.setupFromConfig(rbox);
                }

                TRC.ctaManager.prepareDataForCTA(rbox, itemContainer);
            }

            static shouldCreateCTAManager(rbox, itemContainer) {
                if (!rbox.trc.global['enable-cta-component']) {
                    return false;
                }

                const isCallToActionEnable = TRC.CTAManager.getPubConfigOverrideFromRboxResponse('enable-call-to-action-creative-component', rbox);
                if (!isCallToActionEnable || isCallToActionEnable !== 'true') {
                    return false;
                }

                if (!itemContainer.video_data['cta-text']) {
                    return false;
                }

                return true;
            }

            static isCtaEnabledOnCurrentMode(rbox) {
                try {
                    if (rbox.trc.getProperty(rbox.mode_name, 'ctaWidget')) {
                        return true;
                    }

                    // report when cta is disabled on mode
                    if (TRC.MetricsManager.isMetricsEnabled(TRCImpl, TRC)) {
                        const eventName = CTAManager.createEventName('disabled_by_cp');
                        CTAManager.prototype.reportMetrics.call({shouldReportUsageAndMetricEvent: true}, eventName);
                        TRC.RBoxUsage.logUsage(`cta-_${new Date().getTime()}`, {extraData: {event: eventName, mode: rbox.mode_name, v: '2'}, file: 'cta-manager'});
                    }
                } catch (err) {
                    // on err return false
                }

                return false;
            }

            static getButtonInnerHeight() {
                return 24;
            }

            static getButtonHeight() {
                return TRC.CTAManager.getButtonInnerHeight() + 7; // 24 for button + 5 margin + 2 grace
            }

            static getPriceRatingHeight() {
                return 22; // 13 + 4 padding + 5 margin
            }

            static getPubConfigOverrideFromRboxResponse(configAttribute, rbox) {
                const pubConfigOverride = rbox && rbox.globalTrcResponseJSON
                                          && rbox.globalTrcResponseJSON.dcga
                                          && rbox.globalTrcResponseJSON.dcga.pubConfigOverride;

                return pubConfigOverride && pubConfigOverride[configAttribute];
            }

            setupFromConfig(rbox) {
                this.shouldReportAppInstall = (TRC.util.isPercentEnabled(rbox.trc.global, 'app-install-report'));
                this.shouldReportAbTestEvent = Math.random() < (rbox.trc.global['cta-abtest-report-percent'] || 0.03);
                this.shouldReportRenderedEvent = Math.random() < (rbox.trc.global['cta-render-report-percent'] || 0.05);
                this.shouldReportUsageAndMetricEvent = Math.random() < (rbox.trc.global['cta-metric-report-percent'] || 0.03);
                this.shouldReportUsageAndMetricEvent = this.shouldReportUsageAndMetricEvent
                  && (TRC.MetricsManager && TRC.MetricsManager.isMetricsEnabled(TRCImpl, TRC));
                this.shouldReport = this.shouldReportAbTestEvent || this.shouldReportUsageAndMetricEvent || this.shouldReportRenderedEvent;
                this.windowLocation = this.shouldReport ? (window.location.href || '').slice(0, 200) : '';
                this.moduleName = CTAManager.getPubConfigOverrideFromRboxResponse('module-name', rbox);
                this.options = {
                    isInheritTitleColor: this.getPubConfigOverride('inherit-title-color', rbox, true),
                    style: {
                        borderColor: this.getPubConfigOverride('border-color', rbox, true),
                        color: this.getPubConfigOverride('title-color', rbox, true),
                        fontSize: this.getPubConfigOverride('cta-font-size', rbox, true),
                        fontWeight: this.getPubConfigOverride('font-weight', rbox, true)
                    }
                };
            }

            getPubConfigOverride(configAttribute, rbox, isGlobal) {
                const pubConfigValue = CTAManager.getPubConfigOverrideFromRboxResponse(configAttribute, rbox);

                if (pubConfigValue != null && isGlobal) {
                    this.globalConfig[configAttribute] = pubConfigValue;
                }

                return pubConfigValue != null ? pubConfigValue : this.globalConfig[configAttribute];
            }

            renderCTAItems(internalc, myOrigin) {
                if (!this.ctaButtons || !Object.keys(this.ctaButtons).length) {
                    return;
                }

                TRC.ModuleLoader.load('cta-component', TRC.CallToActionComponent, () => {
                    const placementItems = myOrigin.boxes;
                    const context = {
                        shouldAdjustHeight: false,
                        maxDesiredHeight: 0
                    };

                    placementItems.forEach(itemContainer => {
                        try {
                            const ctaData = this.getCtaData(itemContainer);
                            if (!ctaData) {
                                return;
                            }

                            const callToActionComponent = new TRC.CallToActionComponent(itemContainer, ctaData);
                            ctaData.callToActionComponent = callToActionComponent;

                            callToActionComponent.renderCTAButton(context, myOrigin);
                        } catch (err) {
                            this.sendEvent({
                                itemContainer,
                                name: err.message,
                                type: CTAManager.sendEventTypes.error
                            });
                            throw err;
                        }
                    });

                    if (context.shouldAdjustHeight) {
                        placementItems.forEach(itemContainer => {
                            const videoLabelBox = itemContainer.querySelector('.video-label-box');
                            if (!videoLabelBox) { return; }
                            context.maxDesiredHeight = Math.max(videoLabelBox.offsetHeight, context.maxDesiredHeight);
                        });
                        placementItems.forEach(itemContainer => {
                            const ctaData = this.getCtaData(itemContainer);
                            this.fixVideoBoxHeight(itemContainer, context.maxDesiredHeight, ctaData);

                            if (!ctaData) {
                                return;
                            }

                            const {callToActionComponent} = ctaData;
                            if (!callToActionComponent) {
                                return;
                            }

                            callToActionComponent.reportBack(itemContainer, ctaData);
                        });
                    }
                });
            }

            fixVideoBoxHeight(itemContainer, allItemsHeight, ctaData) {
                const videoLabelBox = itemContainer.querySelector('.video-label-box');

                if (!videoLabelBox
                    || (itemContainer.video_data && itemContainer.video_data['is-app-install'] === 'true')) {
                    return;
                }

                if (itemContainer.rbox.ctaData.shouldAdjustAllItemsHeight) {
                    if (allItemsHeight <= 0) {
                        return;
                    }
                    const overflowLabel = CTAManager.getReportOnOverflow(videoLabelBox, () => {
                        videoLabelBox.style['min-height'] = `${allItemsHeight}px`;
                    });
                    if (overflowLabel) {
                        this.sendEvent({
                            itemContainer,
                            ctaData,
                            name: `fix_all_video_box_${overflowLabel}`,
                            type: CTAManager.sendEventTypes.report
                        });
                    }
                    return;
                }

                const branding = videoLabelBox.querySelector('.branding');
                const videoBoxHeight = CTAManager.getDesiredVideoBoxHeight(videoLabelBox, branding, ctaData, itemContainer.rbox);

                if (videoBoxHeight <= 0) {
                    return;
                }
                const overflowLabel = CTAManager.getReportOnOverflow(videoLabelBox, () => {
                    videoLabelBox.style['min-height'] = `${videoBoxHeight}px`;
                    const maxHeightForItem = CTAManager.getComputedStyleProp(videoLabelBox, 'max-height', 0);
                    if (maxHeightForItem > 0 && maxHeightForItem < videoBoxHeight) {
                        videoLabelBox.style.maxHeight = `${videoBoxHeight}px`;
                    }
                });
                if (overflowLabel) {
                    this.sendEvent({
                        itemContainer,
                        ctaData,
                        name: `fix_video_box_${overflowLabel}`,
                        type: CTAManager.sendEventTypes.report
                    });
                }
            }

            static getReportOnOverflow(element, callback) {
                const previewOverflowLabel = CTAManager.getOverflowLabel(element);
                callback();
                const overflowLabel = CTAManager.getOverflowLabel(element);
                switch (true) {
                    case !!overflowLabel && (previewOverflowLabel === overflowLabel):
                        return `${overflowLabel}_still_overflowing`;
                    case !previewOverflowLabel && !!overflowLabel:
                        return `${overflowLabel}_overflowing`;
                    case !!previewOverflowLabel && !overflowLabel:
                        return `${previewOverflowLabel}_stopped_overflowing`;
                    default:
                        return '';
                }
            }

            static getOverflowLabel(element) {
                if (!element) {
                    return '';
                }
                const width = (element.offsetWidth + 1) < element.scrollWidth;
                const height = (element.offsetHeight + 1) < element.scrollHeight;
                switch (true) {
                    case (width && height):
                        return 'width_and_height_are';
                    case width:
                        return 'width_is';
                    case height:
                        return 'height_is';
                    default:
                        return '';
                }
            }

            static getDesiredVideoBoxHeight(videoLabelBox, branding, ctaData, rbox) {
                let videoLabelBoxHeightBefore = CTAManager.getVideoLabelBoxChildrenWithoutButtonHeight(videoLabelBox);
                if (!videoLabelBoxHeightBefore || videoLabelBoxHeightBefore === 0) {
                    videoLabelBoxHeightBefore = CTAManager.getComputedStyleProp(videoLabelBox, 'height');
                    if (videoLabelBoxHeightBefore <= 0) {
                        return 0;
                    }
                }

                if ((ctaData != null && !ctaData.shouldRenderAsCTA) || !branding) {
                    return rbox.ctaData.shouldAdjustAllItemsHeight ? videoLabelBoxHeightBefore : 0;
                }

                const appInstallHeight = (ctaData != null && ctaData.isPriceRating) ? CTAManager.getPriceRatingHeight() : 0;
                const totalHeightOfBranding = CTAManager.getHeightOfElementIncludeMargin(branding);
                const videoLabelBoxHeightAfter = videoLabelBoxHeightBefore + appInstallHeight - totalHeightOfBranding
                                                 + Math.max(CTAManager.getButtonHeight(), totalHeightOfBranding);

                if (videoLabelBoxHeightAfter <= videoLabelBoxHeightBefore) {
                    return rbox.ctaData.shouldAdjustAllItemsHeight ? videoLabelBoxHeightBefore : 0;
                }

                return videoLabelBoxHeightAfter;
            }

            prepareDataForCTA(rbox, itemContainer) {
                if (!itemContainer.video_data['cta-text'] || !CTAManager.isCtaEnabledOnCurrentMode(rbox)) {
                    return false;
                }

                this.ctaButtons[CTAManager.getItemId(itemContainer)] = this.getCtaData(itemContainer) || {};
                const ctaData = this.getCtaData(itemContainer);

                try {
                    rbox.ctaData = rbox.ctaData || {};
                    const itemData = itemContainer.video_data;

                    ctaData.cardIndex = this.cardIndexOnPage++;
                    ctaData.index = itemData.itemIndex;
                    ctaData.placement = rbox.placement;
                    ctaData.itemId = this.shouldReport ? (itemData['item-id'] || itemData.id || '').slice(0, this.maxCharsForItemId) : '';

                    this.sendEvent({
                        itemContainer,
                        ctaData,
                        name: 'has_cta_text'
                    });

                    const filterOutReason = this.getFilterOutItemForCTAReason(rbox, itemContainer);
                    if (filterOutReason) {
                        this.sendEvent({
                            itemContainer,
                            ctaData,
                            name: filterOutReason,
                            type: CTAManager.sendEventTypes.filter
                        });
                        return;
                    }

                    ctaData.shouldRenderAsCTA = true;
                    ctaData.actionText = TRC.util.getHtmlDecodeText(itemData['cta-text']).slice(0, this.ctaButtonTextAmountOfChars);

                    ctaData.price = itemData.fpr || itemData['cta-price'];
                    const ctaRating = itemData['stars-rating'];
                    if (ctaRating) {
                        ctaData.rating = CTAManager.roundHalf(ctaRating);
                    }

                    ctaData.isPriceRating = ctaData.rating || ctaData.price;

                    const renderCandidateEvent = ctaData.isPriceRating ? 'cta_app_render_candidate' : 'cta_render_candidate';
                    this.sendEvent({
                        itemContainer,
                        ctaData,
                        name: renderCandidateEvent
                    });

                    if (rbox.ctaData.isInit) {
                        return;
                    }

                    rbox.ctaData.isInit = true;
                    rbox.ctaData.hasCTAItem = true;
                    rbox.ctaData.isStream = CTAManager.isStream(rbox);
                    rbox.ctaData.shouldAdjustAllItemsHeight = !rbox.ctaData.isStream && !CTAManager.isSingleColumnWidget(rbox);
                } catch (err) {
                    this.sendEvent({
                        itemContainer,
                        ctaData,
                        name: err.message,
                        type: CTAManager.sendEventTypes.error
                    });
                    __trcError('Error on prepareDataForCTA', err);

                    throw err;
                }
            }

            getCtaData(itemContainer) {
                return this.ctaButtons[CTAManager.getItemId(itemContainer)];
            }

            static getItemId(itemContainer) {
                return itemContainer.video_data.id;
            }

            getFilterOutItemForCTAReason(rbox, itemContainer) {
                const itemData = itemContainer.video_data;

                return CTAManager.isNotSyndicated(itemData)
                       || CTAManager.isInNetwork(itemData)
                       || CTAManager.isNextUp(rbox)
                       || CTAManager.isDescriptionBlocked(itemData)
                       || CTAManager.isDetailOrderBlocked(itemContainer)
                       || CTAManager.hasLink(itemContainer)
                       || this.areVideoLabelBoxOrBrandingBlocked(itemContainer)
                       || CTAManager.isBelowMinWidth(itemContainer)
                       || CTAManager.isHeroWidget(itemContainer)
                       || CTAManager.isStoryWidget(itemContainer)
                       || CTAManager.isNextUpWidget(itemContainer)
                       || CTAManager.hasIcon(itemContainer);
            }

            static isNotSyndicated(itemData) {
                return !itemData.isSyndicated ? 'non_sc' : null;
            }

            static isInNetwork(itemData) {
                return itemData['is-in-network'] ? 'in_network' : null;
            }

            static isNextUp(rbox) {
                const isNextUp = rbox.options && rbox.options.trcResponse && !!rbox.options.trcResponse.nup;
                return isNextUp ? 'next_up' : null;
            }

            static isDescriptionBlocked(itemData) {
                const allowCtaWithDescription = !window.TRCImpl || !window.TRCImpl.global || CTAManager.nullish(window.TRCImpl.global['enable-cta-with-description'], true);
                if (itemData.description && !allowCtaWithDescription) {
                    return 'item_with_description';
                }

                return null;
            }

            static isDetailOrderBlocked(itemContainer) {
                const detailOrder = itemContainer.detail_order;
                if (detailOrder && detailOrder.length && detailOrder[0] === 'branding') {
                    return 'item_branding_before_title';
                }

                return null;
            }

            static hasLink(itemContainer) {
                const titleLink = itemContainer.link;
                if (!titleLink) {
                    return 'no_link';
                }

                return null;
            }

            areVideoLabelBoxOrBrandingBlocked(itemContainer) {
                const videoLabelBox = itemContainer.querySelector('.video-label-box');
                if (!videoLabelBox) {
                    return 'no_video_label_box';
                }

                const branding = videoLabelBox.querySelector('.branding');
                if (!branding) {
                    return 'no_branding';
                }

                return this.isVideoLabelBoxHeightBlocked(videoLabelBox)
                       || this.isVideoLabelBoxBoxSizingBlocked(videoLabelBox)
                       || this.isBrandingMarginBlocked(branding)
                       || CTAManager.isBrandingPositionBlocked(branding)
                       || CTAManager.isBrandingInnerPositionBlocked(branding)
                       || CTAManager.isBrandingLogoPositionBlocked(branding);
            }

            isVideoLabelBoxHeightBlocked(videoLabelBox) {
                const videoLabelBoxHeight = CTAManager.getComputedStyleProp(videoLabelBox, 'height');
                if (!videoLabelBoxHeight) {
                    return null;
                }

                const sumHeightOfChildren = CTAManager.getVideoLabelBoxChildrenWithoutButtonHeight(videoLabelBox);
                if ((videoLabelBoxHeight + this.ctaChildrenParentGap) < sumHeightOfChildren) {
                    return 'videoLabelBox_smaller_than_children';
                }

                return null;
            }

            isVideoLabelBoxBoxSizingBlocked(videoLabelBox) {
                const videoLabelBoxBoxSizing = CTAManager.getComputedStyleProp(videoLabelBox, 'boxSizing', null);
                if (videoLabelBoxBoxSizing && videoLabelBoxBoxSizing === 'border-box') {
                    return null;
                }

                const videoLabelBoxClientRect = videoLabelBox.getBoundingClientRect();
                if (!videoLabelBoxClientRect || videoLabelBoxClientRect.width <= 0) {
                    return null;
                }

                const videoLabelBoxWidthPercentage = parseFloat(CTAManager.getComputedStyleProp(videoLabelBox, 'width', 0)) / videoLabelBoxClientRect.width;
                if (videoLabelBoxWidthPercentage <= this.videoLabelBoxWidthRatio) {
                    return null;
                }

                const videoLabelBoxPaddingLeft = CTAManager.getComputedStyleProp(videoLabelBox, 'paddingLeft', 0);
                const videoLabelBoxPaddingRight = CTAManager.getComputedStyleProp(videoLabelBox, 'paddingRight', 0);
                if (videoLabelBoxPaddingLeft > 0 || videoLabelBoxPaddingRight > 0) {
                    return 'padding_on_full_width';
                }

                return null;
            }

            isBrandingMarginBlocked(branding) {
                const brandingClientRect = branding.getBoundingClientRect();
                if (!(brandingClientRect && brandingClientRect.width > 0)) {
                    return null;
                }

                const marginLeftPercentage = parseFloat(CTAManager.getComputedStyleProp(branding, 'margin-left', 0)) / brandingClientRect.width;
                if (marginLeftPercentage > this.horizontalMarginToFilter) {
                    return 'high_margin_left';
                }

                const marginRightPercentage = parseFloat(CTAManager.getComputedStyleProp(branding, 'margin-right', 0)) / brandingClientRect.width;
                if (marginRightPercentage > this.horizontalMarginToFilter) {
                    return 'high_margin_right';
                }

                return null;
            }

            static isBrandingInnerPositionBlocked(branding) {
                const brandingInner = branding.querySelector('.branding-inner');
                if (brandingInner && CTAManager.isElementPositionAbsolute(brandingInner)) {
                    return 'branding_inner_absolute_position';
                }

                return null;
            }

            static isBrandingLogoPositionBlocked(branding) {
                const brandingLogoDivInner = branding.querySelector('div.logoDiv');
                if (brandingLogoDivInner && CTAManager.isElementPositionAbsolute(brandingLogoDivInner)) {
                    return 'branding_logo_div_inner_absolute_position';
                }

                return null;
            }

            static isBrandingPositionBlocked(branding) {
                if (CTAManager.isElementPositionAbsolute(branding)) {
                    return 'branding_absolute_position_item_renderer';
                }

                return null;
            }

            static isElementPositionAbsolute(element) {
                const elementPosition = CTAManager.getComputedStyleProp(element, 'position');
                if (elementPosition && elementPosition === 'absolute') {
                    return true;
                }

                return false;
            }

            static isBelowMinWidth(itemContainer) {
                const itemContainerWidth = itemContainer.getBoundingClientRect().width;
                if (itemContainerWidth > 0 && itemContainerWidth < 170) {
                    return 'below_min_width';
                }

                return null;
            }

            static isHeroWidget(itemContainer) {
                if (itemContainer.rbox.mode_name && itemContainer.rbox.mode_name.indexOf('hero') > -1) {
                    return 'item_in_hero_widget';
                }

                return null;
            }

            static isStoryWidget(itemContainer) {
                if (itemContainer.rbox.container.querySelector('.story-widget')) {
                    return 'item_in_reco_reel_story_widget';
                }

                return null;
            }

            static isNextUpWidget(itemContainer) {
                if (TRC.dom.containsClass(itemContainer, 'tbl-next-up-widget-item')) {
                    return 'item_next_up';
                }

                return null;
            }

            static hasIcon(itemContainer) {
                if (itemContainer.querySelector('.added-icon-svg')) {
                    return 'item_branding_has_icon';
                }

                return null;
            }

            static getVideoLabelBoxChildrenWithoutButtonHeight(videoLabelBox) {
                let sumHeightOfChildren = 0;
                const cssAttributesAffectingHeight = ['border-bottom-width', 'border-top-width', 'padding-bottom', 'padding-top'];
                cssAttributesAffectingHeight.forEach(attr => {
                    sumHeightOfChildren += CTAManager.getComputedStyleProp(videoLabelBox, attr) || 0;
                });

                if (videoLabelBox.hasChildNodes()) {
                    const children = videoLabelBox.childNodes;

                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];
                        if (TRC.dom.containsClass(child, 'video-cta-href')) {
                            continue;
                        }

                        const heightOfElementIncludeMargin = CTAManager.getHeightOfElementIncludeMargin(child);
                        sumHeightOfChildren += heightOfElementIncludeMargin;
                    }
                }
                return sumHeightOfChildren;
            }

            static getComputedStyleProp(element, propName, defaultValue) {
                const computesStyle = window.getComputedStyle(element),
                    prop = computesStyle[propName];

                if (!prop) {
                    return defaultValue || null;
                }

                const number = parseInt(computesStyle[propName], 10);
                return isNaN(number) ? computesStyle[propName] : number;
            }

            static getHeightOfElementIncludeMargin(element) {
                const {offsetHeight} = element;
                const marginTopForChild = CTAManager.getComputedStyleProp(element, 'margin-top', 0);
                const marginBottomForChild = CTAManager.getComputedStyleProp(element, 'margin-bottom', 0);

                return offsetHeight + marginTopForChild + marginBottomForChild;
            }

            static nullish(value, defaultValue) {
                return value == null ? defaultValue : value;
            }

            sendEvent({
                itemContainer, ctaData, name, type, description, eventNamePrefix, force
            } = {}) {

                ctaData = ctaData || {};
                __trcDebug(`${this.moduleName} ${name} ${type} ${description} ${itemContainer.innerText}`);

                if ((!this.shouldReport || !ctaData) && !force) {
                    return;
                }

                const eventName = eventNamePrefix ? `${eventNamePrefix}${name}` : CTAManager.createEventName(name, type);
                const data = this.createReportData(itemContainer, ctaData, eventName, type, description);
                const settings = {force};
                this.reportAbTestEvent(data, name, settings);
                this.reportUsage(data, settings);
                this.reportMetrics(eventName, settings);
            }

            static createEventName(name, type) {
                if (!TRC.CTAManager.sendEventTypes[type]) {
                    type = TRC.CTAManager.sendEventTypes.event;
                }
                return `CTA-${type}-${name}`;
            }

            createReportData(itemContainer, ctaData, name, type, description) {
                const style = this.options.style || {};

                return {
                    v: '2',
                    location: this.windowLocation,
                    itemId: ctaData.itemId,
                    rating: ctaData.rating,
                    price: ctaData.price,
                    text: ctaData.actionText,
                    type: type != null ? type : 'event',
                    description,
                    module: this.moduleName,
                    event: name,
                    cardIndexOnPage: ctaData.cardIndex,
                    index: ctaData.index,
                    placement: ctaData.placement,
                    innerText: itemContainer.innerText,
                    config: {
                        borderColor: style.borderColor,
                        color: style.color,
                        fontSize: style.fontSize,
                        fontWeight: style.fontWeight,
                        isInheritTitleColor: this.options.isInheritTitleColor
                    }
                };
            }

            reportAbTestEvent(data, name, settings) {
                settings = settings || {};
                const reportRendered = name === 'rendered' ? this.shouldReportRenderedEvent : false;

                if (this.shouldReportAbTestEvent || reportRendered || settings.force) {
                    window.TRCImpl.sendAbTestEvent(this.moduleName, JSON.stringify(data));
                }
            }

            reportUsage(data, settings) {
                settings = settings || {};
                if (this.shouldReportUsageAndMetricEvent || settings.force) {
                    TRC.RBoxUsage.logUsage(`cta-_${new Date().getTime()}`, {extraData: data, file: 'cta-manager'});
                }
            }

            reportMetrics(metricName, settings) {
                settings = settings || {};
                if (settings.force || (this.shouldReportUsageAndMetricEvent && metricName)) {
                    TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: metricName, value: '1', type: 'counter'}, null);
                }
            }

            static roundHalf(num) {
                return Math.round(num * 2) / 2;
            }

            static isStream(rbox) {
                const widgetCreatorLayout = rbox.trc.getProperty(rbox.mode_name, 'widget-creator-layout', rbox.propertiesOverride);

                return widgetCreatorLayout === 'autowidget-template-stream';
            }

            static isSingleColumnWidget(rbox) {
                const responsiveRule = rbox.getEffectiveResponsiveRule();
                if (responsiveRule && responsiveRule.cells === 1) {
                    return true;
                }

                return false;
            }
        }

        CTAManager.sendEventTypes = {
            report: 'report',
            filter: 'filter',
            error: 'error',
            event: 'event'
        };

        TRC.CTAManager = CTAManager;

    })();

    // https://gist.github.com/mpgn/2f990997b9aa5fad3f90ff94546fae1e
    (() => {

        const existingKeys = {};
        const FIXED_PVUID_STR = 'page view Id str';

        function generateKey() {
            return window.crypto.subtle.generateKey(
                {
                    name: 'AES-GCM',
                    length: 256 // can be  128, 192, or 256
                },
                true, // whether the key is extractable (i.e. can be used in exportKey)
                ['encrypt', 'decrypt'] // can "encrypt", "decrypt", "wrapKey", or "unwrapKey"
            );
        }

        function encrypt(data, key, iv) {
            return window.crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',

                    // Don't re-use initialization vectors!
                    // Always generate a new iv every time your encrypt!
                    // Recommended to use 12 bytes length
                    iv,

                    // Additional authentication data (optional)
                    // additionalData: ArrayBuffer,

                    // Tag length (optional)
                    tagLength: 128 // can be 32, 64, 96, 104, 112, 120 or 128 (default)
                },
                key, // from generateKey or importKey above
                data // ArrayBuffer of data you want to encrypt
            );
        }

        function buf2hex(buffer) { // buffer is an ArrayBuffer
            return [...new Uint8Array(buffer)].map(x => x.toString(16).padStart(2, '0')).join('');
        }


        const getPageViewUniqueID = (function () {
            let keyPromise = null;

            if (window._trcIsUTactive) {
                TRC.cryptoKeysUtils = {
                    resetPageViewUniqueIdPromise() {
                        keyPromise = null;
                    }
                };
            }

            return function () {
                if (existingKeys.pvuid) {
                    return Promise.resolve(existingKeys.pvuid);
                }

                if (keyPromise) {
                    return keyPromise;
                }

                keyPromise = keyPromise || generateKey()
                    .then(keys => {
                        const iv = new Uint8Array([188, 185, 57, 146, 246, 194, 114, 34, 12, 80, 198, 77]);
                        const encoder = new TextEncoder();
                        const data = encoder.encode(FIXED_PVUID_STR);
                        return encrypt(data, keys, iv);
                    })
                    .then(buffer => {
                        const keyString = buf2hex(buffer);
                        existingKeys.pvuid = keyString;
                        return existingKeys.pvuid;
                    });
                return keyPromise;
            };
        }());
        
        TRC.cryptoKeysManager = {
            getPageViewUniqueID
        };

        if (window._trcIsUTactive) {
            TRC.cryptoKeysUtils.setPageViewUniqueID = function (key, value) {
                existingKeys[key] = value;
            };
            TRC.cryptoKeysUtils.PVUID_STR_LEN = 32 + (2 * FIXED_PVUID_STR.length);
        }

    })();

    TRC.css = TRC.css || {};
    TRC.css.utils = (() => {
        let ruleCounter = 0,
            modesNum = 0,
            template = '';
        const RULES_THRESHOLD = 4040, // for supporting  IE9-- bug
            STYLE_SPLIT = ' style_split', // delimiter string for over 4040 rules in style text
            TEMPLATE_MACRO = '{class},',
            classExclusion = 'vidiscovery-note';
        /**
         * classSplit - splits a rule to separated classes
         * @ {String} rule - css rule
         */
        function classSplit(rule, modes) {
            // detect media queries prefixes
            const mediaPrefix = (rule.indexOf('@media') >= 0) ? `${rule.split('{')[0]}{` : '';

            // extract the media queries prefixes - not need to be agumented
            rule = (mediaPrefix) ? rule.substring(rule.indexOf('{') + 1) : rule;

            const tempArr = rule.split('{'), // defense against splits inside the {....} section of a rule
                classArr = (tempArr.length > 1) ? tempArr[0].split('.') : rule.split('.'),
                len = classArr.length;

            if (len < 2) { // no class found or top container class;
                return mediaPrefix + rule;
            }
            // we need the first class only (it is the second cell in the splited array )
            const subClassArr = classArr[1];

            // special exclusion for CEO's related containers
            // TODO : if other exclusions are needed make this as a formal function
            if (__trcTrim(subClassArr) === classExclusion) {
                return mediaPrefix + rule;
            }

            // make the prefixes augmentation
            // TODO : subClassArr!!! - check for empty strings
            if (modes[__trcTrim(subClassArr)]) {
                addRuleCounter(1);
                // TODO: cache ""#" + modes[i].cssDivsArr.join(" #") + " "
                classArr[0] = `#${modes[__trcTrim(subClassArr)].cssDivsArr.join(' #')} ${classArr[0]}`; // a unqiue mode needs only his relevant div id's as prefixes
            } else {
                addRuleCounter(modesNum);
                // otherwise make multiply rules for the global class
                classArr[0] = duplicateGlobalRules(classArr.join('.')) + classArr[0];
            }
            if (tempArr.length > 1) {
                tempArr[0] = classArr.join('.');
                return mediaPrefix + tempArr.join('{');
            }
            return mediaPrefix + classArr.join('.');
        }

        /**
         * multiRuleSplit -splits the rule to multiply rules (',' delimiter)
         * @param {String} rules
         * @param modes
         */
        function multiRuleSplit(rules, modes) {
            const multiRuleArr = rules.split(','),
                len = multiRuleArr.length;

            let styleSplit = '';

            // mark style element split - solve the IE9-- bug
            if (getRuleCounter() > RULES_THRESHOLD) {
                styleSplit = STYLE_SPLIT;
                __trcDebug(`Number of augmented css rules before Split : ${getRuleCounter()}`);
                setRuleCounter(0);
            }

            // we are in a mode that only splits rules to different stylesheets group if needed
            if (modes === null) {
                // this method only counts the css rules in the 'rules' string argument
                // and adds the styleSplit ("" || STYLE_SPLIT)
                return getNewStyleSheet((len < 2) ? rules : multiRuleArr, styleSplit);
            }

            if (len < 2) {
                return styleSplit + classSplit(rules, modes);
            }
            for (let i = 0; i < len; i++) {
                multiRuleArr[i] = classSplit(multiRuleArr[i], modes);
                // defense against splits inside the {....} section of a rule
                if ((multiRuleArr[i].indexOf('{') >= 0) && i < len - 1) {
                    break;
                }
            }
            return styleSplit + multiRuleArr.join(',');
        }

        /**
         * returns a new group of new css style sheet if the styleSplit has a split value
         * @param {String || Array} rules
         * @param {String} styleSplit
         * @returns {String}
         */
        function getNewStyleSheet(rules, styleSplit) {
            const len = rules.length;

            if (typeof rules === 'string') {
                addRuleCounter(1);
                return styleSplit + rules;
            }
            for (let i = 0; i < len; i++) {
                addRuleCounter(1);
                // defense against splits inside the {....} section of a rule
                if ((rules[i].indexOf('{') >= 0) && i < len - 1) {
                    break;
                }
            }
            return styleSplit + rules.join(',');
        }

        /**
         * splitRules - splits an entire style text to multiply rules
         * @param {String} styleText - a complete style inner text
         * @param modes
         */
        function splitRules(styleText, modes) {
            const ruleSplitArr = styleText.split('}'),
                len = ruleSplitArr.length;

            if (len < 2) {
                return multiRuleSplit(styleText, modes);
            }

            ruleSplitArr.forEach(ruleSplit => multiRuleSplit(ruleSplit, modes));

            return ruleSplitArr.join('}');
        }

        function addRuleCounter(n) {
            ruleCounter += n;
        }

        function setRuleCounter(n) {
            ruleCounter = n;
        }
        function getRuleCounter() {
            return ruleCounter;
        }


        /**
         * duplicateGlobalRules - augments a rule with all the modes div id's)
         * it uses a preset template with all the div's id's register from each mode
         * @param {String} rule
         */
        function duplicateGlobalRules(rule) {
            return getCssIdsTemplate(false, false).replace(new RegExp('{class}', 'gm'), rule);
        }

        /**
         * getCssIdsTemplate - set a template that contains all the mode div's id's
         * a placeholder for the class name. Ot uses a preset template with all
         * the div's id's register from each mode
         * @param modes - the modes object form the client properties
         * @param lb
         */
        function getCssIdsTemplate(modes, lb) {
            let idStr;
            if (typeof modes === 'object') {
                template = '';
                Object.keys(modes).forEach(i => {
                    if (typeof i === 'string' && i !== '') {
                        idStr = `#${modes[i].cssDivsArr.join(' #')} `;
                        template = `${template}${idStr} ${TEMPLATE_MACRO}`;
                    }
                    modesNum++;
                });

                const iframePart = `#${lb.iframe.join(' #')} ${TEMPLATE_MACRO}`,
                    topDivPart = `#${lb.topDiv.join(' #')} ${TEMPLATE_MACRO}`,
                    templateSuffix = template.slice(0, template.length - TEMPLATE_MACRO.length);

                return template = `${iframePart}${topDivPart}${templateSuffix}`;
            }
            return template;
        }

        /**
         * inflates the aggregated style per mode in the list of modes to render ('vl')
         * @param placements - vl array in the response
         * @param hasCustomModeCss - true/false if enabled 'enable-custom-injection' - if mode configuration contains custom css for each mode
         * @param trcManager
         * @returns {{inflatedStyle: string, customCss: string}}
         */
        function inflateStylePerMode(response, hasCustomModeCss, trcManager) {
            const placements = response.trc.vl;
            const {modes} = trcManager;
            const commonMode = modes[TRC.inflate.COMMON];
            let inflatedStyle = '';
            let customCss = '';

            placements && placements.forEach((placement, index) => {
                const modeNames = getPlacementModes(response, placement, index, trcManager);
                modeNames.forEach(modeName => {
                    if (TRC.injectedModes.indexOf(modeName) < 0 && modes[modeName]) {
                        inflatedStyle += TRC.inflate.inflateStyle(modeName,
                            TRC.inflate.inflateObject(commonMode[TRC.inflate.STYLE], modes[modeName][TRC.inflate.STYLE]));
                        if (hasCustomModeCss && modes[modeName].mode_custom) {
                            customCss += modes[modeName].mode_custom;
                        }
                        TRC.injectedModes.push(modeName);
                    }
                });
            });
            return {inflatedStyle, customCss};
        }

        /**
         * return the modes name that are relevant for the placement - the placement may use widget connector modes
         * @param placement
         * @param trcManager
         * @returns {Array}
         */
        function getPlacementModes(response, placement, index, trcManager) {
            const {TRCRBox} = TRC.implClasses;
            const placementData = trcManager.preloadRequest[placement.fpl || placement.uuip || placement.uip];
            const baseOrVariantMode = TRCRBox.prototype.calcModeName(trcManager.addVariantProperties(null, response, index).trc,
                placementData ? placementData.mode : undefined);
            const mainModeName = resolveModeName(baseOrVariantMode, placement, placementData, trcManager);
            let modes = mainModeName ? [mainModeName] : [];
            if (placement.multiWidget && placement.multiWidget.children) {
                modes = [...modes, ...getChildrenModes(placement.multiWidget.children)]; // push the multi widget(a.k.a widget connector) mode names
            }
            return modes;
        }

        /**
         * return a valid base mode - has exciting configurations
         * @param baseOrVariantMode
         * @param placement
         * @param trcManager
         * @returns string
         */
        function resolveModeName(baseOrVariantMode, placement, placementData, trcManager) {
            if (trcManager.modes[baseOrVariantMode]) {
                return baseOrVariantMode;
            }
            if (trcManager.modes[placement.m]) {
                return placement.m;
            }
            if (placementData && trcManager.modes[placementData.mode]) {
                return placementData.mode;
            }
            return undefined;
        }

        /**
         * return array with all children mode names
         * @param children
         * @returns {Array}
         */
        function getChildrenModes(children) {
            let modeNames = [];

            children.forEach(child => {
                if (child.children) {
                    modeNames = [...modeNames, ...getChildrenModes(child.children)];
                } else if (child.name) {
                    modeNames.push(child.name);
                }
            });
            return modeNames;
        }

        return {
            /**
             * injects general/global styles and  aggregated styles only for the modes that are going to be rendered plus general css
             * @param response
             * @param trcManager
             */
            bakeCss(response, trcManager) {
                const hasCustomModeCss = trcManager.global['enable-custom-injection'];
                TRC.injectedModes = TRC.injectedModes || [];
                let inflatedStyle = TRC.injectedCustomStyle ? '' : trcManager.defaults.style + trcManager.global.style.rtl;
                const inflateStyles = inflateStylePerMode(response, hasCustomModeCss, trcManager);
                inflatedStyle += inflateStyles.inflatedStyle;
                // custom css for the publisher
                inflatedStyle += trcManager.global.style.custom && !TRC.injectedCustomStyle ? trcManager.global.style.custom : '';
                // if the feature is enabled the modes will contain modes custom css for each modes
                // otherwise in will contain custom mode baked for all modes in the publisher level by default
                if (hasCustomModeCss) {
                    inflatedStyle += inflateStyles.customCss ? inflateStyles.customCss : '';
                } else {
                    inflatedStyle += trcManager.global.style.mode_custom && !TRC.injectedCustomStyle ? trcManager.global.style.mode_custom : '';
                }
                // pullAggregatedStyle will return css that is blocked for modules that by default inject styles before rendering
                inflatedStyle += TRC.injectedCustomStyle ? '' : TRC.dom.pullAggregatedStyle();
                // when feature is on we disable APB class swaps on its original flow and we do it here.

                if (inflatedStyle) {
                    TRC.dom.injectStyle(inflatedStyle, null);
                    TRC.injectedCustomStyle = true;
                }
            },
            setStyleTextIdPrefix(styleText, modes, lb) {
                // if modes is not null it indicates we are in css reset mode
                // (not only stylesheet split)
                if (modes) {
                    getCssIdsTemplate(modes, lb);
                }
                const str = splitRules(styleText, modes);
                __trcDebug(`Number of augmented css rules left : ${getRuleCounter()}`);
                setRuleCounter(0);
                return str;
            },
            setStyleElements(styleText) {
                const styleTextArr = styleText.split(STYLE_SPLIT),
                    len = styleTextArr.length;

                if (len > 1) {
                    TRC.pConsole('page', 'debug', 'splitting css', '');
                }

                styleTextArr.forEach(styleText => TRC.dom.injectStyle(styleText));
            },
            /**
             * set a value of a style property fo an element
             * @method setStyleProperty
             * @param {HTMLElement} elem
             * @param {String} prop
             * @param {String} value
             * @param {Boolean} important
             */
            setStyleProperty(elem, prop, value, important) {
                let {cssText} = elem.style;
                cssText += `;${prop}:${value}${(important ? '!important' : '')}`;
                elem.style.cssText = cssText;
            },
            /**
             * A naive method that generates a string of CSS rules with vendor prefixes
             * from a given CSS rule
             * @param property - the CSS property
             * @param value - the CSS property value
             * @returns {string}
             */
            generateCssRuleWithVendorPrefixes(property, value) {
                const vendorPrefixes = [
                        ' -webkit-',
                        '-moz-',
                        '-ms-',
                        '-o-'
                    ],
                    rulePattern = '{property}: {value};',
                    originalRule = rulePattern.replace('{property}', property).replace('{value}', value),
                    rulesArr = [];

                vendorPrefixes.forEach(prefix => rulesArr.push(prefix + originalRule));

                rulesArr.push(originalRule);

                return rulesArr.join(' ');
            },

            // http://dev.w3.org/csswg/cssom/#serialize-an-identifier
            escape: (() => (window.CSS && window.CSS.escape) || function (value) {
                const InvalidCharacterError = function (message) {
                    this.message = message;
                };
                InvalidCharacterError.prototype = new Error();
                InvalidCharacterError.prototype.name = 'InvalidCharacterError';

                const string = String(value),
                    {length} = string;
                let index = -1,
                    codeUnit,
                    result = '';
                const firstCodeUnit = string.charCodeAt(0);
                while (++index < length) {
                    codeUnit = string.charCodeAt(index);
                    // Note: there’s no need to special-case astral symbols, surrogate
                    // pairs, or lone surrogates.

                    // If the character is NULL (U+0000), then throw an
                    // `InvalidCharacterError` exception and terminate these steps.
                    if (codeUnit === 0x0000) { // jshint ignore:line
                        throw new InvalidCharacterError(
                            'Invalid character: the input contains U+0000.'
                        );
                    }

                    if (
                        // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
                    // U+007F, […]
                        (codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit === 0x007F
                        // If the character is the first character and is in the range [0-9]
                        // (U+0030 to U+0039), […]
                        || (index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039)
                        // If the character is the second character and is in the range [0-9]
                        // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
                        || (
                            index === 1
                            && codeUnit >= 0x0030 && codeUnit <= 0x0039
                            && firstCodeUnit === 0x002D
                        )
                    ) {
                        // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point
                        result += `\\${codeUnit.toString(16)} `;
                        continue;
                    }

                    // If the character is not handled by one of the above rules and is
                    // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
                    // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
                    // U+005A), or [a-z] (U+0061 to U+007A), […]
                    if (
                        codeUnit >= 0x0080
                        || codeUnit === 0x002D
                        || codeUnit === 0x005F
                        || codeUnit >= 0x0030 && codeUnit <= 0x0039
                        || codeUnit >= 0x0041 && codeUnit <= 0x005A
                        || codeUnit >= 0x0061 && codeUnit <= 0x007A
                    ) {
                        // the character itself
                        result += string.charAt(index);
                        continue;
                    }

                    // Otherwise, the escaped character.
                    // http://dev.w3.org/csswg/cssom/#escape-a-character
                    result += `\\${string.charAt(index)}`;
                }
                return result;
            }
            )()
        };
    })(window);
    /**
     * constructor for a handling a stack of style elements with rbox css
     * @param {Object} config
     * @param {Boolean} signEntryPoint - if true adds a empty style element for signing
     *                  the entry point for the styles fragment
     * @constructor
     */
    TRC.css.Stack = function (config, signEntryPoint) {
        const {stack, idPrefix = 'tab_'} = config,
            styleSheetRef = {},
            docfrag = document.createDocumentFragment(),
            injectPoint = (signEntryPoint) ? document.head.appendChild(document.createElement('style')) : null;

        stack.forEach(style => styleSheetRef[style.type] = TRC.dom.injectStyle(style.cssText || '', docfrag, idPrefix + style.type));

        /**
         * inject the style elements document fragments
         * it should be call once per session
         */
        this.injectAllStyles = function () {
            if (injectPoint) {
                document.head.insertBefore(docfrag, injectPoint);
            } else {
                document.head.appendChild(docfrag);
            }
            TRC.styleInjected = true;
        };

        /**
         * add a css text into a existing style element(by type) or a new style element
         * @param type
         * @param cssText
         * @param styleInjected
         */
        this.addStyle = function (type, cssText, styleInjected) {
            const styleElement = styleSheetRef[type],
                injectionTarget = styleInjected ? document : docfrag,
                styleId = idPrefix + type;

            if (cssText) {
                if (styleElement) {
                    if (styleElement.styleSheet) {
                        styleElement.styleSheet.cssText += cssText;
                    } else {
                        styleElement.appendChild(document.createTextNode(cssText));
                    }
                } else {
                    styleSheetRef[type] = TRC.dom.injectStyle(cssText, injectionTarget, styleId);
                }
            }
        };
    };

    /**
     * responsive related method
     */
    TRC.css.responsive = (function () {
        function getRulePercentageWidth(cells, margin) {
            return (99.99 - cells * margin) / cells;
        }

        /**
         * @param {Number} rule
         * @param {String} rulePrefix
         * @param {Array} text
         * @param {Boolean} cssReset
         * @param {String} direction
         */
        function setBoxDimensions(rule, rulePrefix, text, cssReset, direction) {
            const {rows, cells, margin} = rule;
            const width = getRulePercentageWidth(cells, margin);
            const boxDirection = direction === 'rtl' ? 'right' : 'left';
            let boxRules = `.${rulePrefix} .videoCube{width: ${width}%; position: relative; float: ${boxDirection}; margin: 0 0 ${margin}% 0; margin-${boxDirection}: ${margin}%;}`;
            if (TRC && TRCImpl && TRC.util.isPercentEnabled(TRCImpl.global, 'enable-responsive-float-fix') && (cells !== 1) && (rows !== 1)) {
                boxRules += `.${rulePrefix} :nth-child(${cells}n+1 of .videoCube):not(:nth-child(1 of .videoCube)){clear:both;}`;
            }
            text.push(boxRules);
        }
        /**
         *
         * @param {Object} rule
         * @param {String} rulePrefix
         * @param {Array} text
         * @param {Boolean} cssReset
         * @param {String} direction
         */
        function generateWCTextLinksCssRules(rule, rulePrefix, text, cssReset, direction) {
            const videoCubeDirection = direction === 'rtl' ? 'right' : 'left',
                leftColClearDirection = direction === 'rtl' ? 'left' : 'right',
                videoCubeRule = `.${rulePrefix} .trc_rbox_div .videoCube {width: ${(+rule.cells === 1 ? '100' : '48')}%;}`,
                leftHeaderRule = `.${rulePrefix} .trc_header_left_column {width: ${(+rule.cells === 1 ? '100' : '48')}%;}`,
                rightHeaderRule = `.${rulePrefix} .trc_header_right_column {display: ${(+rule.cells === 1 ? 'none' : 'inline')};}`,
                rightColRule = `.${rulePrefix} .trc_rbox_div div.videoCube:nth-of-type(-n+${rule.rows}){float:${videoCubeDirection};clear:${videoCubeDirection};}`,
                leftColRule = `.${rulePrefix} .trc_rbox_div div.videoCube:nth-of-type(n+${(rule.rows + 1)}){float:none;clear:${leftColClearDirection};margin-${videoCubeDirection}:auto;}`;

            text.push(leftColRule);
            text.push(rightColRule);
            text.push(videoCubeRule);
            text.push(leftHeaderRule);
            text.push(rightHeaderRule);
        }

        /**
         *
         * @param {Object} rule
         * @param {String} rulePrefix
         * @param {Array} text
         * @param {Number} listSize
         * @param {Boolean} cssReset
         * @param isHScrolling
         * @param hScrollMinItems
         */
        function generateCssRules(rule, rulePrefix, text, listSize, cssReset, isHScrolling, hScrollMinItems) {
            const numItems = rule.rows * rule.cells,
                visibleCubesRule = `.${rulePrefix} div.videoCube:nth-of-type(-n+${numItems}){display:block;visibility:visible;}`,
                invisibleCubesRule = `.${rulePrefix} div.videoCube:nth-of-type(n+${(numItems + 1)}){display:none;visibility:hidden;}`;

            text.push(visibleCubesRule);
            text.push(invisibleCubesRule);

            if (isHScrolling) {
                addHscrollToRule(rule, rulePrefix, text, hScrollMinItems);
            }
        }

        function addHscrollToRule(rule, rulePrefix, text, hScrollMinItems) {
            const cols = rule.cells,
                percentage = (cols / hScrollMinItems) * 100;

            text.push(`.${rulePrefix} .trc_rbox_div { width: ${percentage}%; }`);
            text.push(`.${rulePrefix} .trc_rbox_outer { overflow-x: scroll; -webkit-overflow-scrolling: touch; }`);
        }

        function getContainerMarginRule(rule, rulePrefix, direction, isHScrolling, hScrollMinItems) {
            const marginDirection = direction === 'rtl' ? 'right' : 'left';

            if (isHScrolling) {
                return `.${rulePrefix} .trc_rbox_div{margin-${marginDirection}:-${(rule.margin * rule.cells / hScrollMinItems)}%;}`;
            }

            return `.${rulePrefix} .trc_rbox_outer{margin-${marginDirection}:-${rule.margin}%;}`;
        }

        function generateMarginCSSRules(rule, rulePrefix, text, cssReset, direction, isHScrolling, hScrollMinItems) {
            const labelBoxClass = +rule.cells === 1 ? 'video-label-box' : 'trc-main-label', // in rules with more than one column we should never apply auto height to the pre label box, only to main label box (otherwise it will may cause the items to not be aligned to each other when the pre label is at the top).
                labelMarginRule = `.${rulePrefix} .trc_rbox_outer .videoCube .${labelBoxClass} {height:auto;}`,
                cubeHeightRule = `.${rulePrefix} .trc_rbox_outer .videoCube {margin-bottom:10px;}`,
                containerMarginRule = getContainerMarginRule(rule, rulePrefix, direction, isHScrolling, hScrollMinItems),
                disableOneRowWidgetAutoHeight = TRCImpl.global['disable-one-row-widget-auto-height'],
                shouldSetOneRowWidgetAutoHeight = (isHScrolling || !disableOneRowWidgetAutoHeight) && +rule.rows === 1;

            // we dont want any fixed height for the titles container when we have 1 column widget
            // or 1 row horizontal carousel widgets (optimization for mobile and / or carousel widgets)
            // we can pass the need for fixed label height because it was meant to protect from breaking the widget due to
            // floating elements with different heights
            if (+rule.cells === 1 || shouldSetOneRowWidgetAutoHeight) {
                text.push(labelMarginRule);
                text.push(cubeHeightRule);
            }

            text.push(containerMarginRule);

            text.push(`.${rulePrefix} .videoCube_aspect{padding-bottom:${rule.ratio}%; width: 100%;}`);
            setBoxDimensions(rule, rulePrefix, text, cssReset, direction);
        }

        return {
            injectedStyles: {},
            rulesToCssText(rulePrefix, rules, listSize, cssReset, isWCTextLinks,
                direction, isHScrolling, hScrollMinItems) {
                const text = [];

                let i,
                    rule,
                    isQuery;

                for (i = 0; rule = rules[i]; i++) {
                    isQuery = typeof rule.min !== 'undefined' || typeof rule.max !== 'undefined';
                    if (isQuery) {
                        text.push('@media screen and ');
                    }
                    if (typeof rule.min !== 'undefined') {
                        text.push(`(min-width: ${rule.min}px) `);
                        if (rule.max) {
                            text.push('and ');
                        }
                    }
                    if (typeof rule.max !== 'undefined') {
                        text.push(`(max-width: ${rule.max}px) `);
                    }
                    if (isQuery) {
                        text.push('{');
                    }

                    if (isWCTextLinks) {
                        generateWCTextLinksCssRules(rule, rulePrefix, text, cssReset, direction);
                    } else {
                        generateMarginCSSRules(rule, rulePrefix, text, cssReset, direction, isHScrolling, hScrollMinItems);
                    }

                    generateCssRules(rule, rulePrefix, text, listSize, cssReset, isHScrolling, hScrollMinItems);

                    if (isQuery) {
                        text.push('} ');
                    }
                }
                return text.join('');
            },
            getRulePercentageWidth
        };
    }());

    (() => {

        const xTimeAgolanguageConvertors = {
            now: 'Now',
            today: 'Today',
            yesterday: 'Yesterday',
            minutes: '{0} minutes ago',
            hour: '1 hour ago',
            hours: '{0} hours ago',
            days: '{0} days ago'
        };

        TRC._translationQueue = TRC._translationQueue || [];
        TRC._translationQueue.push({
            'time-ago': xTimeAgolanguageConvertors
        });

        class DateUtils {

            /**
             * Will be removed after phase 1.
             * All custom languages added through hooks are included in the above list.
             * Disabled for compatibility with translation manager
             */
            static setTimeAgoCustomLanguage() {
                __trcWarn('TRCRbox.dateFormatDays - custom language is depreciated');
            }

            /**
             *
             * @param publishedDateMs - article published date
             * @param lang - publisher language
             * @param trcInstance - trc instance to access formatData method
             * @returns {string}
             */
            static dateFormatTimeAgo(publishedDateMs, lang, trcInstance) {
                let _publishedDate;
                if (publishedDateMs && parseInt(publishedDateMs, 10) !== 0 && !isNaN(publishedDateMs)) {
                    _publishedDate = new Date(parseInt(publishedDateMs, 10) * 1000);
                } else {
                    __trcWarn(`TRCRbox.dateFormatDays - published_date cannot be parsed, it is ${publishedDateMs}`);
                    return '';
                }

                const timeAgo = 'time-ago';
                const {getLabel} = TRC.translationManager;
                const translationsManager = getLabel({feature: 'time-ago'}) || xTimeAgolanguageConvertors;

                const currentDate = new Date();
                const timeDifference = Date.now() - _publishedDate.getTime();
                try {
                    if (timeDifference < (30 * DateUtils.minute)) {
                        return getLabel({feature: timeAgo, label: 'now'});
                    }
                    if (timeDifference < DateUtils.hour) {
                        const minutesAgo = Math.floor(timeDifference / DateUtils.minute);
                        return getLabel({
                            feature: timeAgo, label: 'minutes', data: [minutesAgo]
                        });
                    }
                    if (timeDifference < (7 * DateUtils.hour)) {
                        const hoursAgo = Math.floor(timeDifference / DateUtils.hour);
                        if (hoursAgo === 1) {
                            return getLabel({feature: timeAgo, label: 'hour'});
                        }
                        if (!translationsManager['hours-above5'] || hoursAgo < 5) {
                            return getLabel({
                                feature: timeAgo, label: 'hours', data: [hoursAgo]
                            });
                        }
                        return getLabel({
                            feature: timeAgo, label: 'hours-above5', data: [hoursAgo]
                        });
                    }
                    if (timeDifference < (24 * DateUtils.hour)) {
                        if (currentDate.getDate() === _publishedDate.getDate()) {
                            return getLabel({feature: timeAgo, label: 'today'});
                        }
                    }
                    if (TRC.util.isTrue(TRCImpl.global['timeago-string-dates'])) {
                        return trcInstance.formatData('published-date', publishedDateMs);
                    }
                    if (timeDifference < (48 * DateUtils.hour)) {
                        return getLabel({feature: timeAgo, label: 'yesterday'});
                    }
                    const daysAgo = Math.floor(timeDifference / DateUtils.day);
                    if (!translationsManager['days-above5'] || daysAgo < 5) {
                        return getLabel({
                            feature: timeAgo, label: 'days', data: [daysAgo]
                        });
                    }
                    return getLabel({
                        feature: timeAgo, label: 'days-above5', data: [daysAgo]
                    });
                } catch (e) {
                    __trcError(`TRCRbox.dateFormatDays - error in calculating time ago. this might be due to bad date or custom lang not properly init. date: ${publishedDateMs} lang: ${lang}`);
                    return '';
                }
            }

            /* eslint-disable camelcase */
            static dateFormatISO(published_date) {
                const publish_date = new Date(parseInt(published_date, 10) * 1000);
                const publish_date_year = publish_date.getFullYear();
                let publish_date_month = publish_date.getMonth() + 1;
                let publish_date_days = publish_date.getDate();
                if (publish_date_days < 10) { publish_date_days = `0${publish_date_days}`; }
                if (publish_date_month < 10) { publish_date_month = `0${publish_date_month}`; }
                return `${publish_date_year}-${publish_date_month}-${publish_date_days}`;
            }

            static dateFormatAmerican(published_date) {
                const publish_date = new Date(parseInt(published_date, 10) * 1000);
                const publish_date_year = publish_date.getFullYear();
                const publish_date_month = publish_date.getMonth() + 1;
                const publish_date_days = publish_date.getDate();
                return `${publish_date_month}/${publish_date_days}/${publish_date_year}`;
            }

            static dateFormatEuropean(published_date) {
                const publish_date = new Date(parseInt(published_date, 10) * 1000);
                const publish_date_year = publish_date.getFullYear();
                const publish_date_month = publish_date.getMonth() + 1;
                const publish_date_days = publish_date.getDate();
                return `${publish_date_days}/${publish_date_month}/${publish_date_year}`;
            }

        }

        DateUtils.millisecond = 1;
        DateUtils.second = 1000 * DateUtils.millisecond;
        DateUtils.minute = 60 * DateUtils.second;
        DateUtils.hour = 60 * DateUtils.minute;
        DateUtils.day = 24 * DateUtils.hour;

        TRC.DateUtils = DateUtils;

    })();

    /**
     *  debug module  
    */
    TRC.modDebug = function (win, doc){

            var MAX_LOGS = 2,  // limit logs to server per message
    	    modObject,
    		messageCache = function(){
    			var arrLoggedMsg = {};
    			return { 
    				// hash of logged messages
    				setMessageCache : function (msg){
    					if (arrLoggedMsg[msg]){
    						arrLoggedMsg[msg] += 1;			
    					} else {
    		    			arrLoggedMsg[msg] = 1;	// new message 	   
    					}							
    				},
    				getMessageCount : function(msg){
    					if ((arrLoggedMsg[msg])){
    						return arrLoggedMsg[msg];
    					} else {
    						return 0;
    					}	
    				}				
    			}	
    		}();
    	
    	function getType(level){
    		switch (level) {
    			case 0: return "error";
                case 0.5: return "perf";
    			case 1: return "warn";
    			case 2: return "info";
    			case 3: return "debug";
                case 4: return "usage";
    			default: return;
    		}
    	}

    	modObject = {
    		logMessageToServer : function(level, msg, extraUrlParams, ignoreLogsPerMessageLimit, shouldUseBeacon){
    			messageCache.setMessageCache(msg);
    			if ( messageCache.getMessageCount(msg) <= MAX_LOGS || ignoreLogsPerMessageLimit){
    				var domain = (win.TRCImpl && TRCImpl.domain) ? TRCImpl.domain : 'trc.taboola.com',
    				    pubId = (win.TRCImpl) ? TRCImpl['normalize-log-param']('publisher', TRC.publisherId) : TRC.publisherId,
    					timestamp = __trcClientTimestamp(),
                        logMsg = TRC.newDebugLogger.logMsg.bind(TRC.newDebugLogger);

    				if(win.TRCImpl && win.TRCImpl.trcEventRoute && win.TRCImpl.eventTypesToRoute.indexOf('debug') > -1) {
    					logMsg(win.TRCImpl.trcEventRoute, level, msg, timestamp, pubId, extraUrlParams, shouldUseBeacon);

    					if(win.TRCImpl.enableTrcEventRouteExperiment) { // :todo *remove if block* after events route bypass experiment is over
                            logMsg(domain, level, msg, timestamp, pubId, extraUrlParams, shouldUseBeacon);
                        }
    				} else {
    				    logMsg(domain, level, msg, timestamp, pubId, extraUrlParams, shouldUseBeacon);
                    }
    			}
    		},
            getType : getType
    	};

    	return modObject;
    	
    }(window, document);

    /* TEMPORARY CODE FOR DELTA / TRANSFORMER SIDE-BY-SIDE TESTING */
    (() => {
        const DELTA_MODE_NAME_SUFFIX = '-delta';
        const multiWidgetRecursiveRename = (widgetConf, trcManager) => {
            if (widgetConf.children) {
                widgetConf.children.forEach(childWidgetConf => {
                    multiWidgetRecursiveRename(childWidgetConf, trcManager);
                });
            } else if (widgetConf.name && !isAlreadyDeltaModeName(widgetConf.name) && widgetConf.dlt) {
                const widgetDeltaModeName = widgetConf.name + DELTA_MODE_NAME_SUFFIX;

                if (trcManager.modes[widgetDeltaModeName]) {
                    widgetConf.name = widgetDeltaModeName;
                } else if (trcManager.modes[widgetConf.name]) {
                    __trcWarn(`Could not resolve Multi-Widget delta mode name ${widgetDeltaModeName}`);
                }
            }
        };
        const feedCardRename = (placementData, trcManager) => {
            const feedDeltaModeName = placementData.m + DELTA_MODE_NAME_SUFFIX;

            if (isAlreadyDeltaModeName(placementData.m)) {
                return;
            }

            if (trcManager.modes[feedDeltaModeName]) {
                placementData.m = feedDeltaModeName;
            } else if (trcManager.modes[placementData.m]) {
                __trcWarn(`Could not resolve Feed / Added Widget delta mode name ${feedDeltaModeName}`);
            }
        };

        const singleWidgetRename = (placementData, trcManager) => {
            const pushedPlacementData = trcManager.preloadRequest[placementData.uip];

            if (pushedPlacementData) {
                if (isAlreadyDeltaModeName(pushedPlacementData.mode)) {
                    return;
                }

                const widgetDeltaModeName = pushedPlacementData.mode + DELTA_MODE_NAME_SUFFIX;
                if (trcManager.modes[widgetDeltaModeName]) {
                    pushedPlacementData.mode = pushedPlacementData.mode_name = widgetDeltaModeName;
                } else if (trcManager.modes[pushedPlacementData.mode]) {
                    __trcWarn(`Could not resolve Widget delta mode name ${widgetDeltaModeName}`);
                }
            } else {
                __trcWarn(`Delta mode replace: placement ${placementData.uip} is missing from preloadRequest`);
            }
        };

        const isAlreadyDeltaModeName = modeName => new RegExp(`${DELTA_MODE_NAME_SUFFIX}$`).test(modeName);

        TRC.deltaModeAdapter = {
            switchModeNamesIfInDeltaTest(trcManager, response) {
                if (response && response.trc && response.trc.vl && response.trc.vl.length) {
                    response.trc.vl.forEach(placementData => {
                        if (TRC.util.isTrue(placementData.dlt)) {
                            if (placementData.multiWidget) { // Multi Widget scenario
                                multiWidgetRecursiveRename(placementData.multiWidget, trcManager);
                            } else if (placementData.m) { // Feed / Added Widget scenario
                                feedCardRename(placementData, trcManager);
                            } else { // Pushed Widget scenario
                                singleWidgetRename(placementData, trcManager);
                            }
                        }    
                    });
                }
            }
        };    
    })();

    /**
     * DOM Utilities
     *
     * Namespace: TRC.dom
     */
    (function(win,doc){
    	/* DOM readiness detection */
    	var domReadyHandlers = [], // list of handlers waiting for DOM readiness
    		/** @type Function */ readyStateChangeHandler = null,
            initDone = false;

    	/**
    	 * Complete DOM readyness processing when the DOM is ready
    	 * @param Boolean directCall whether this was called directly by our own code or triggered by a DOM ready event
    	 */
    	function domReady(event) {
    		try {
                if (readyStateChangeHandler) {
    				// remove ready state detection as it is no longer needed
                    if(TRC.Browser['ieUpto'](10)){
                        doc.detachEvent('onreadystatechange', readyStateChangeHandler);
                    } else {
                        doc.removeEventListener("DOMContentLoaded", arguments.callee, false);
                        TRC.Interval.clear(readyStateChangeHandler);
    				}
    			}
    			if (TRC.dom.isReady) {
                    return; // fail fast - no point in being here if DOM was already readied.
                }
    			TRC.dom.isReady = true;

    			// convert ready state handler registrar to immediately fire any late-to-register
    			// handler, as we are already ready.
    			TRC.dom.onReady = function(func) { func(); };
    			// fire all DOM ready handlers
    			for ( var i = 0; i < domReadyHandlers.length; i++) {
    				domReadyHandlers[i]();
                }
    		} catch (e) {
    			__trcError("Error in DOMReady processing",e);
    		}
    	};
    	/**
    	 * returns the horizontal scroll of the page
    	 * @return {Number} pixels
    	 */
    	function getPageHorizontalScroll(){
    		return win.pageXOffset || doc.body.scrollLeft;
    	};

    	TRC.dom = {
    		injectedStyles: [],
    		aggregatedStyles: '',
    		isReady: false, // public API

    		/* Namespaced helper method to emulate the 'DOMContentLoaded' event handling */
    		onReady: function(func, fake) {
    			if (fake) {
    				TRC.Timeout.set(func, 10);
    				return;
    			}
    			domReadyHandlers.push(func);
    		},

    		/**
    		 * Cross platform test & register for the DOM readiness
    		 */
    		init: function() {
                if(initDone){ // dom readiness detection should  occur only once during a page life cycle
                    return;
                } else {
                    initDone = true;
                }
    			if (doc.readyState && /loaded|complete/.test(doc.readyState)) {
    				domReady(true);
    				return;
    			}
    			if (TRC.Browser['ieUpto'](10)) { // Explorers are hard
    				var pd = doc.createElement('div');
    				(function() {
    					try {
    						pd.doScroll('left');
    					} catch (e) {
    						pd.to = TRC.Timeout.set(arguments.callee, 10);
    						return;
    					}
    					domReady();
    				})();
    				doc.attachEvent('onreadystatechange', readyStateChangeHandler = function() {
    					if (/loaded|complete/.test(doc.readyState)) {
    						TRC.Timeout.clear(pd.to);
    						domReady();
    					}
    				});
    			} else {
    			   /*
    				* rely on DOMContentLoaded(when supported) and the document readyState attribute.
    				*/
    				if (/interactive/.test(doc.readyState)){ // FF 3.5-- does not support document.readyState
    					domReady(true);
    					return;
    				}
    				doc.addEventListener("DOMContentLoaded", domReady, false);
    				readyStateChangeHandler = TRC.Interval.set(function() {
    					if (/loaded|complete|interactive/.test(doc.readyState)) {
    						domReady();
    					}
    				}, 10);
    			}

    			// for all browsers, and just in case, we fire DOM ready automatically when
    			// window.onload fires. This should be later then DOM readiness as external resources
    			// can finish loading later.

    			// Use DOM0 (old style) event registration which is unsafe for multiple runners,
    			// so save any old onload handlers.
    			var oldHandler = win.onload;
    			win.onload = function() {
    				domReady();
    				if (oldHandler)
    					try {
    						oldHandler();
    					} catch (e) {
    						// ignore errors from publisher's onload
    					}
    			};
    		},

    		on: (function () {
    			// DOM1 event handling where supported
    			if (win.addEventListener) {
    				return function(el, sType, fn, useCapture) {
    					var options = {};
    					if ((sType === 'touchstart' || sType === 'touchmove') && TRC.Browser.compatibility.passiveEvents) {
    						options['passive'] = true;
    					}
    					if(typeof useCapture === "boolean"){
    						options['capture'] = useCapture;
    					}
    					if(Object.keys(options).length === 0){
    						el.addEventListener(sType, fn);
    					} else {
    						el.addEventListener(sType, fn, options);
    					}
    				}
    			}

    			// IE DOM-like event handling in IE8 and below
    			if (win.attachEvent) {
    				return function(el, sType, fn) {
    					el.attachEvent("on" + sType, fn);
    				};
    			}
    			// for everything else, well.. there shouldn't be everything else, so just play dumb
    			el['on' + sType] = fn;
    		}()),
    		off: (function () {
                // DOM1 event handling where supported
                if (win.removeEventListener) {
                    return function(el, sType, fn) {
                        el.removeEventListener(sType, fn, false);
                    };
                }

                // IE DOM-like event handling in IE8 and below
                if (win.detachEvent) {
                    return function(el, sType, fn) {
                        el.detachEvent("on" + sType, fn);
                    };
                }
                // for everything else, well.. there shouldn't be everything else, so just play dumb
                el['on' + sType] = fn;
            }()),

    		/**
    		 * Get the text content of an element in a cross-browser way, falls back to .innerHTML.
    		 * @param {HTMLElement} element
    		 * @returns {string}
             */
    		getText: function(element) {
    			return element.textContent || element.innerText || element.innerHTML;
    		},
    		/**
    		 * determine the height of a single line
    		 * @param {HTMLElement} element
    		 * @returns {number} line height in pixels
    		 */
    		lineHeight: function (element) {
    			var originalDisplay;

    			/* since we must reflow by setting the display to inline-block,
    			 lets cache the results for repeating use */
    			if (!element.computedClientHeight) {
    				originalDisplay = element.style.display;
    				element.style.display = "inline-block";
    				element.computedClientHeight = parseFloat(getComputedStyle(element).height);
    				element.style.display = originalDisplay;
    			}
    			return element.computedClientHeight;
    		},

    		/**
    		 * Check if specified container contains specified child.
    		 * @param container Supposed container element
    		 * @param child Supposed child element
    		 * @param isSelf (optional) check against the parent of "child" instead of "child" itself.
    		 * 	Not setting this will cause the check to fail when checking against itself: TRC.dom.isAncestor(block,block) => false
    		 * @returns {Boolean}
    		 */
    		isAncestor: function(container, child, isSelf) {
    			child = isSelf ? child : child.parentNode;

    			while (child && child !== container && child.nodeType != 9){
    				child = child.parentNode;
    			}
    			return container === child;
    		},
    		/**
    		 * Get the aggregated style and reset the aggregator
    		 *
    		 */
    		pullAggregatedStyle:  function() {
    			var style = this.aggregatedStyles;
    			this.aggregatedStyles = '';
    			return style;
    		},
    		/**
    		 *
    		 */
    		aggregateStyles: function(styleText) {
    			if (!TRC.styleInjected) {
    				this.aggregatedStyles += styleText;
    			} else {
    				this.injectStyle(styleText);
    	        }
    		},
    		/**
    		 * Inject the specified CSS text into the DOM
    		 * @param styleText text of CSS rules to inject
    		 * @param refDocument (optional) - the document to inject the style to (supports injecting style to iframe, defaults to current document)
    		 * @param id - id value
    		 */
    		injectStyle: function(styleText, refDocument, id) {
    			var style = document.createElement("style"),
                    refDocument = refDocument || doc;

    			style.type = "text/css";

    			if(id){
    					style.id = id;
    			}

    			if(refDocument.head){
    					refDocument.head.appendChild(style);
    			} else {
    					refDocument.appendChild(style);
    			}

    			if (style.styleSheet) {
    				style.styleSheet.cssText = styleText;
    			} else {
    				style.appendChild(document.createTextNode(styleText));
    			}

    			this.injectStyleOverflowFix(styleText);
                TRC.styleInjected = true;

    			//save for future cleanup in newPageLoad
    			this.injectedStyles.push(style);

          return style;
    		},
    		injectStyleOverflowFix: function(styleText) {
    			if (!TRC.Browser.ie)
    				return;
    			if(document.styleSheets.length == 31){
    				var rbox_css_loaded = document.getElementById('trc_rbox_css_loaded');
    				if(rbox_css_loaded == null){
    					rbox_css_loaded = document.createElement('div');
    					rbox_css_loaded.id = 'trc_rbox_css_loaded';
    					doc.body.appendChild(rbox_css_loaded);
    				}
    				if(document.trcGetCurrentStyle(rbox_css_loaded,'overflow') != "hidden"){
    					var myrules = styleText.split('}');
    					var myStyleSheet = null;
    					try{
    						for (var i=0; i<document.styleSheets.length; i++){
    							var styleSheet = document.styleSheets[i];
    								if((myrules.length + styleSheet.rules.length) <= 4096){
    									myStyleSheet = styleSheet;
    									break;
    								}
    						}
    						if(myStyleSheet != null){
    							myStyleSheet.cssText += styleText;
    						}
    					}catch(e){
    						__trcError("Error in injectStyleOverflowFix processing",e);
    					}
    				}
    			}
    		},
    		removeAllInjectedStyleSheets: function() {
    			var currentStyleSheet;

    			for(var i = 0; i < this.injectedStyles.length; i++) {
    				currentStyleSheet = this.injectedStyles[i];

    				if(currentStyleSheet.parentNode) {
    					currentStyleSheet.parentNode.removeChild(currentStyleSheet);
    				}
    			}

    			this.injectedStyles = [];
    			this.aggregatedStyles = '';
    			TRC.styleInjected = false;
                TRC.css.responsive.injectedStyles = [];
    		},
    		swapElements : function(oldElement, newElement, purge){
    			if (purge){
    				TRC.dom.purgeEventHandlers(oldElement);
    			}
    			if(oldElement && oldElement.parentNode) {
    				oldElement.parentNode.replaceChild(newElement, oldElement);
    			}
    			return newElement;
    		},
    		iterateOnNode : function(node, func) {
        		func(node);
        		node = node.firstChild;
        		while (node) {
            		arguments.callee(node, func);
            		node = node.nextSibling;
        		}
    		},
    		purgeEventHandlers : function (node) {
    			try{
    				TRC.dom.iterateOnNode(node, function (o) {
    					for (var n in o) {
    						if (typeof o[n] === 'function') {
    							o[n] = null;
    						}
    					}
    				});
    			}catch (e) {
    				__trcError("TRC.dom.purgeEventHandlers : ", e.message);
    			}
    		},
    		clearInnerElements : function (node){
    			var el;
    			while (el = node.firstChild){
    				this.purgeEventHandlers(el);
    				node.removeChild(el);
    			}
    		},
    		stopEvent: function(event) {
    			event.cancelBubble = true;
    			event.returnValue = false;
    			event.preventDefault && event.preventDefault();
    			event.stopPropagation && event.stopPropagation();
    			return false;
    		},
    		addClass : function(elem, name){
    			if(elem) {
    				elem.className += " " + name + " ";
    			}
    		},
    		removeClass: function(elem, name) {
    			var re;
    			if(!elem) {
    				return;
    			}

    			if (elem.classList) {
    				return elem.classList.remove(name);
    			}
    			re = new RegExp("\s*" + name, "g");
    			elem.className = elem.className.replace(re, "");

    		},
    		containsClass: function(elem, name){
    			return elem && elem.className.split(' ').indexOf(name) > -1;
    		},
        	detectAnimationEvent: function(element, type) {
          var animationEvent = 'animation' + type;
          var animations = {
            animation: 'animation' + type,
            WebkitAnimation: 'webkitAnimation' + type.charAt(0).toUpperCase() + type.slice(1), //capital first letter
            OAnimation: 'oanimation' + type,
            MozAnimation: 'animation' + type,
            MSAnimation: 'MSAnimation' + type
          };
          Object.keys(animations).some(function(key) {
              if (typeof element.style[key] !== 'undefined') {
                animationEvent = animations[key];
                return true;
              }
            });

            return animationEvent;
          },

            /**
             * creates HTML element
             * @param tag the HTML tag to create
             * @param options (optional) object with attributes for the HTML element.
             * @returns {HTMLElement}
             */
            createHTMLElement: function(tag, options) {
                var element;

            element = document.createElement(tag);

            if (options &&Object.keys(options).length) {
                Object.keys(options).forEach(function(key) {
                    element[key] = options[key];
                });
            }

            return element;
        },
    		/**
    		 * Shim for [Element.matches]{@link https://developer.mozilla.org/en/docs/Web/API/Element/matches} method
    		 * @param {Element} element - the element on which the "matches" check should be performed
    		 * @param {String} selector - the query selector to check against
    		 * @returns {Boolean|null} - null if no "matches" implementation found
    		 */
    		elementMatchesSelector: function(element, selector) {
    			var matchesImplementations = ['matches', 'msMatchesSelector', 'oMatchesSelector', 'mozMatchesSelector', 'webkitMatchesSelector'],
    			  matchesImpl;

    			matchesImplementations.some(function(impl) {
    				if(typeof element[impl] === 'function') {
    				  matchesImpl = impl;
    				}
    				return element[impl];
    			});

    			if(matchesImpl) {
    				return element[matchesImpl](selector);
    			}

    			return null;
    		},
    		/**
    		 * Get the closest element of a given element by selector
    		 *
    		 * Take an element (the first param), and traverse the DOM upward from it
    		 * until it hits the element with a given selector (second parameter).
    		 * This mimics jQuery's `.closest()`.
    		 *
    		 * @param {Element} el The element to start from
    		 * @param {String} selector Element's selector
    		 * @return {Element} The closest element
    		 */
    		closest: function (el, selector) {
    			if (TRC.util.isNativeFunction(el.closest)) {
    				return el.closest(selector);
    			}
    			// Traverse the DOM up with a while loop
    			while (!this.elementMatchesSelector(el, selector)) {
    				// Increment the loop to the parent node
    				el = el.parentElement;
    				if (!el) {
    					return null;
    				}
    			}
    			return el;
    		},
    		/**
    		 * returns the current window (a.k.a viewport) width.
    		 * @return {Number} pixels
    		 */
    		getWindowWidth :  function(){
    			if(!window.innerWidth){ //IE
    			    if(!(document.documentElement.clientWidth == 0)){
            			//strict mode
            			this.getWindowWidth = function(){
            				return document.documentElement.clientWidth;
            			};
        			} else {
        				//quirks mode
    			        this.getWindowWidth = function(){
            				return document.body.clientWidth;
            			};
    			    }
    			} else {
        			//standard
        			this.getWindowWidth = function(){
        				return window.innerWidth;
        			};
    			}
    			return this.getWindowWidth();
    		},
    		/**
    		 * returns the current window (a.k.a viewport) Height.
    		 * @return {Number} pixels
    		 */
    		getWindowHeight :  function(){
    			if(!window.innerHeight){ //IE
    			    if(!(document.documentElement.clientHeight == 0)){
            			//strict mode
            			this.getWindowHeight = function(){
            				return document.documentElement.clientHeight;
            			};
        			} else {
        				//quirks mode
    			        this.getWindowHeight = function(){
            				return document.body.clientHeight;
            			};
    			    }
    			} else {
        			//standard
        			this.getWindowHeight = function(){
        				return window.innerHeight;
        			};
    			}
    			return this.getWindowHeight();
    		},
        	/**
             * returns the current document Width.
             * @return {Number} pixels
             */
            getDocumentWidth :  function(){
                return Math.max(
                    Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
                    Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
                    Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
                );
            },
            /**
             * returns the current document Height.
             * @return {Number} pixels
             */
            getDocumentHeight :  function(){
                return Math.max(
                    Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
                    Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
                    Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
                );
            },
            /**
             * returns the ratio of pixel sizes: the size of one CSS pixel / to the size of one physical pixel
             *  screen density as ppi(pixel per inch) ratio.
             * @return {Number} pixels
             */
            getScreenDensity :  function() {
                var screenDensity = window.devicePixelRatio && window.devicePixelRatio.toFixed(3);
                if (!screenDensity) {
                    screenDensity = -1;
                }
                return screenDensity;
            },
            /**
         * returns the vertical scroll of the page
         * @return {Number} pixels
         */
        	getPageVerticalScroll: function() {
            return win.pageYOffset || doc.body.scrollTop;
        },

    		getScrollTop: function(element) {
    			return element === win ?
    				(this.getPageVerticalScroll() || document.documentElement.scrollTop)
    				: element.scrollTop;
    		},

    		/**
    		 * returns the vertical range of the viewport position relative to the current document
    		 * @return {Object} - {min : yMin, max : yMax};
    	 	*/
    		getViewportVerticalRange : function(){
    			var yMin = this.getPageVerticalScroll(),
    				yMax = yMin + this.getWindowHeight();
    		    return {min : yMin, max : yMax};
    		},
    		/**
    	 	* returns the horizontal range of the viewport position relative to the current document
    	 	* @return {Object} - {min : Number, max : Number};
    	 	*/
    		getViewportHorizontalRange : function(){
    			var xMin = getPageHorizontalScroll(),
    				xMax = xMin + this.getWindowWidth();
    		    return {min : xMin, max : xMax};
    		},
    		/**
    		* returns an object describing the an elements position( relative to the top left corner of the document)
    	 	*  and its dimensions
    	 	* @param {Object} elem -  nodeElement
    	 	* @return {Object} - {top : Number, bottom : Number, left : Number, right : Number}
    	 	*/
    		getElementRect : function(elem){
    			return elem.getBoundingClientRect();
    		},
    		/**
    		 * detects if current window is inside an iframe
    		 * @param onErrorValue {Boolean} - return value if failure in iframe detection
    		 * @returns {Boolean}
    		 */
    		isInIframe : function(onErrorValue){
    			try{
    				if(win.top === win.self){
    					return false;
    				} else {
    					return true;
    				}
    			} catch (e){
    				if (typeof onErrorValue === "boolean"){
    					return onErrorValue;
    				} else {
    					return false;
    				}
    			}
    		},
    		/**
    		 * Wraps a given element with CSS augmentation containers
    		 * @param depth - number of containers to create
    		 * @param element (optional) - the element to wrap. if not provided, wrapping should be done from outside
    		 * @returns {Array} - array of augmenting containers ordered from outermost to innermost
    		 */
    		createAugmentingContainers: function(depth, element) {
    			var containersArr = [],
    				parent = null,//initialized as null, most outer container should not have a parent
    				container;

    			for(var i = 0; i < depth; i++) {
    				container = this.createAugmentingContainer(parent);
    				parent = container;
    				containersArr.push(container);
    			}

    			if(element) {
    				containersArr[depth - 1].appendChild(element);
    			}

    			return containersArr;
    		},
    		/**
    		 * Wraps an element with a new div container, used for css augmentation.
    		 * generateAugmentationPrefix() method should be called afterwards in order to get the prefix
    		 * that should be used for CSS rules.
    		 * @param parent
    		 * @returns {HTMLElement}
    		 */
    		createAugmentingContainer: function(parent) {
    			var div = doc.createElement('div');

    			div.id = 'tbl-aug-' + Math.floor(Math.random() * 2147483648).toString(36);

    			if (parent) {
    				parent.appendChild(div);
    			}
    			return div;
    		},
    		/**
    		 * Generates a CSS augmentation prefix for rules, generated from the ids of a given array of
    		 * containers (containers are usually created using createAugmentingContainer() method).
    		 * The array of containers should be ordered by by order of ancestry (most outer container is first,
    		 * as in CSS rules)
    		 * @param containersArr
    		 * @returns {string}
    		 */
    		generateAugmentationPrefix: function(containersArr) {
    			var prefix = '';
    			for(var i = 0; i < containersArr.length; i++) {
    				prefix += '#' + containersArr[i].id + ' ';
    			}

    			return prefix;
    		},

    		isHighDensity : (function() {
    			var highDensity = ((window.matchMedia && (window.matchMedia('only screen and (min-resolution: 124dpi), only screen and (min-resolution: 1.3dppx), only screen and (min-resolution: 48.8dpcm)').matches ||
    					window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3), only screen and (-o-min-device-pixel-ratio: 2.6/2), only screen and (min--moz-device-pixel-ratio: 1.3), only screen and (min-device-pixel-ratio: 1.3)').matches)) ||
    					(window.devicePixelRatio && window.devicePixelRatio > 1.3));
    			return function() {
    				return highDensity;
    			}
    		}()),
    		isSmartPhone: (function() {
    			var smartPhone = ((window.matchMedia && (window.matchMedia(' only screen and (min-device-width : 320px) and (max-device-width : 480px)').matches)) || /(iPhone|iPod)/g.test(navigator.userAgent));
    			return function() {
    				return smartPhone;
    			}
    		}()),
    		isTablet: (function() {
    			var isTablet = ((window.matchMedia && (window.matchMedia(' only screen and (min-device-width : 768px) and (max-device-width : 1024px)').matches)) || /(iPhone|iPod)/g.test(navigator.userAgent));
    			return function() {
    				return isTablet;
    			}
    		}()),
    		isDesktop: function(){
    			return !(this.isTablet() || this.isSmartPhone());
    		},
    		getOuterWidth:  function(container ){
    			var containerWidth = container.getBoundingClientRect().width,
    				containerMarginLeft = parseFloat(getComputedStyle(container).marginLeft),
    				containerRight = parseFloat(getComputedStyle(container).marginRight);

    			return  containerWidth + containerMarginLeft + containerRight;
    		},

    		/**
    		 * Check if the content text contain HTML sign (not only standard text).
    		 * @param {string} content
    		 * @return {boolean}
    		 */
    		isHtmlContent: function (content) {
    			return /(?:%3C|[<>&])/.test(content);
    		},

    		/**
    		 * Set content to element depend if it HTML or plain text
    		 * @param {HTMLElement|Element} element
    		 * @param {string} content
    		 */
    		setContentToElement: function (element, content) {
    			if (TRC.dom.isHtmlContent(content)) {
    				element.innerHTML = content;
    			}
    			else {
    				element.innerText = content;
    			}
    		},
    		/**
    		 * Get meta tag content attribute value from property attribute value
    		 * @param {string} metaProperty
    		 * @param {string} content
    		 */
    		getPageMetaPropertyValue: function(metaProperty) {
    			var metaTagArr = document.head.getElementsByTagName('meta');
    			for (var i = 0; i < metaTagArr.length; i++) {
    				if (metaTagArr[i].getAttribute('property') === metaProperty) {
    					return  metaTagArr[i].content;
    				}
    			}
    			__trcDebug("Failed finding meta tag property : " + metaProperty + " value");
    			return null;
    		},

    		/**
    		 * Get json ld value from property key
    		 * @param {string} jsonLdKey
    		 * @param {string} content
    		 */
    		getJsonLdValueFromKey: function(jsonLdKey) {
    			var jsonLdScriptElements = document.querySelectorAll('script[type="application/ld+json"]');
    			for (var i = 0; i < jsonLdScriptElements.length; i++) {
    				var jsonLdScript = jsonLdScriptElements[i];
    				var jsonLd;
    				try {
    					jsonLd = JSON.parse(jsonLdScript.innerText);
    				} catch (e) {
    					__trcWarn('Failed to parse json ld script: ' + e);
    					return null;
    				}
    				var jsonLdArr = Array.isArray(jsonLd) ? jsonLd : [jsonLd];
    				for (var j = 0; j < jsonLdArr.length; j++) {
    					var jsonLdDataItem = jsonLdArr[j];
    					if (jsonLdDataItem[jsonLdKey]) {
    						return jsonLdDataItem[jsonLdKey];
    					}
    				}
    			}
    			__trcDebug("Failed finding json ld property : " + jsonLdKey + " value");
    			return null;
    		},

    		decodeHtmlEntities: function(encodedString) {
    			var element = document.createElement("textarea");
    			element.innerHTML = encodedString;
    			return  element.value;
    		}
        };

    })(window, document);

    (() => {
        const ITEM_META_DATA_TYPES = {
            ID: 'id',
            TITLE: 'title',
            THUMBNAIL: 'thumb',
            FOUND: 'found'
        };

        class DuplicatedItemsMonitor {
            constructor(trcManager, options) {
                this.trcManager = trcManager;
                this.parentContainerSelector = options.parentContainerSelector;
                this.additionalLogDataBuilder = options.additionalLogDataBuilder;
                this.isDedupEventSent = false;
                this.initReportedItemsMap();

                this.trcManager.sendPubsGenericEvent('DEDUP_DEBUG', 'true');
                TRC.modDebug.logMessageToServer(1, 'Duplicated items monitoring enabled', {
                    pcs: this.parentContainerSelector,
                    vi: TRC.pageManager.getPageData()
                });
            }

            initReportedItemsMap() {
                this.reportedItems = {};

                Object.keys(ITEM_META_DATA_TYPES).forEach(key => {
                    const metaDataType = ITEM_META_DATA_TYPES[key];
                    this.reportedItems[metaDataType] = [];
                });
            }

            checkForDuplicatedItems() {
                if (this.isDedupEventSent) {
                    return;
                }
                const allItems = [].slice.call(document.querySelectorAll(`${this.parentContainerSelector} .videoCube`));
                if (!this.checkAndNotifyMetaDataDuplication(allItems, ITEM_META_DATA_TYPES.ID)) {
                    this.checkAndNotifyMetaDataDuplication(allItems, ITEM_META_DATA_TYPES.TITLE);
                    this.checkAndNotifyMetaDataDuplication(allItems, ITEM_META_DATA_TYPES.THUMBNAIL);
                }
            }

            checkAndNotifyMetaDataDuplication(allItems, metaDataType) {
                const metaDataTypeHtmlAttribute = `data-item-${metaDataType}`,
                    allItemsMetaData = allItems.map(item => item.getAttribute(metaDataTypeHtmlAttribute)),
                    itemsWithDuplicatedMetaData = allItems.filter(
                        item => DuplicatedItemsMonitor.isItemMetaDataFoundMoreThanOnce(
                            item, allItemsMetaData, metaDataTypeHtmlAttribute
                        )
                    );

                if (!itemsWithDuplicatedMetaData.length) {
                    return;
                }

                itemsWithDuplicatedMetaData.forEach(
                    item => this.notifyItemMetaDataDuplication(item, metaDataTypeHtmlAttribute, metaDataType)
                );

                return true;
            }

            static isItemMetaDataFoundMoreThanOnce(item, allItemsMetaData, metaDataTypeHtmlAttribute) {
                const itemMetaData = item.getAttribute(metaDataTypeHtmlAttribute);

                // if the first and the last occurrence of an element are same
                // then this element occurs only once, so it is unique
                return allItemsMetaData.indexOf(itemMetaData) !== allItemsMetaData.lastIndexOf(itemMetaData);
            }


            notifyItemMetaDataDuplication(item, metaDataHtmlAttribute, metaDataType) {
                if (this.reportedItems[metaDataType].indexOf(item) !== -1 || this.isDedupEventSent) {
                    return;
                }

                const eventName = `DUP_${ITEM_META_DATA_TYPES.FOUND.toUpperCase()}`,
                    itemId = item.getAttribute('data-item-id'),
                    metaData = item.getAttribute(metaDataHtmlAttribute),
                    logData = {
                        mdt: metaDataType,
                        md: metaData,
                        ii: itemId,
                        pcs: this.parentContainerSelector,
                        vi: TRC.pageManager.getPageData()
                    };

                this.trcManager.sendPubsGenericEvent(eventName, itemId);

                if (typeof this.additionalLogDataBuilder === 'function') {
                    __trcCopyProps(this.additionalLogDataBuilder(item), logData);
                }

                TRC.modDebug.logMessageToServer(1, 'Duplicated item served', logData, true);

                this.reportedItems[metaDataType].push(item);
                this.isDedupEventSent = true;
            }
        }
        
        TRC.DuplicatedItemsMonitor = DuplicatedItemsMonitor;

    })();

    (() => {
        /**
         * returns relevant modules to the calling hook
         */
        const getDynamicModules = hookType => {
            if (TRC.DynamicModulesHooks) {
                const DynamicModulesFilteredHooks = TRC.DynamicModulesHooks.filter(mod => (mod.type === hookType));
                if (DynamicModulesFilteredHooks) return DynamicModulesFilteredHooks;
            }
            return [];
        };

        /**
         * executes relevant modules
         */
        const executeDynamicModules = (hookType, config) => {
            TRC.DynamicModulesHooks && TRC.DynamicModulesHooks.forEach(mod => {
                if (mod.type === hookType && mod.callback) {
                    mod.callback(config);
                }
            });
        };

        const sendEvent = (moduleName, data) => {
            try {
                const eventData = {
                    moduleName,
                    data
                };

                const requestData = {
                    data: eventData,
                    type: 'fallback'
                };

                TRCImpl.sendEvent('pubs-generic', {d: JSON.stringify(requestData)}, {});
            } catch (e) {
                __trcError(`error in DynamicModulesManager.sendEvent: ${e.message}`);
            }
        };

        const normalizePathName = pathname => {
            const isEmptyPathname = pathname.length <= 1;
            if (isEmptyPathname) {
                return '/';
            }
            const shouldAddPrefixSlash = pathname[0] !== '/';
            if (shouldAddPrefixSlash) {
                return `/${pathname}`;
            }
            return pathname;
        };

        let _parserLink;
        const parseUrlParts = url => {
            if (!_parserLink) {
                _parserLink = document.createElement('a');
            }

            _parserLink.href = url;
            const result = {};
            if (_parserLink.search !== '') {
                let searchItem;
                const regexPattern = /\??&?([^=]+)=([^&]+)/gi;
                while (searchItem = regexPattern.exec(_parserLink.search)) {
                    // eslint-disable-next-line prefer-destructuring
                    result[searchItem[1]] = searchItem[2];
                }
            }

            return {
                hash: _parserLink.hash,
                host: _parserLink.host,
                hostname: _parserLink.hostname,
                href: _parserLink.href,
                origin: _parserLink.origin,
                pathname: normalizePathName(_parserLink.pathname),
                search: result
            };
        };

        const parseArticleUrl = (url, articleParam) => {
            const urlParts = parseUrlParts(url);

            if (Object.keys(urlParts.search).length === 0 || !articleParam) {
                return urlParts.pathname;
            }

            let parsedUrl = `${urlParts.pathname}?`;
            const articleParamsSplitArr = articleParam.split(',');
            const articleParamsArr = articleParamsSplitArr.map(element => element.trim());
            articleParamsArr.forEach(param => {
                if (urlParts.search[param]) {
                    parsedUrl += `${param}=${urlParts.search[param]}`;
                }
            });
            return parsedUrl;
        };

        TRC.DynamicModulesManager = {
            getDynamicModules,
            executeDynamicModules,
            sendEvent,
            parseArticleUrl
        };
    })();

    (function (win, doc) {
        "use strict";

        var Ellipsis = {};
        var TRC = win.TRC;

        // Because typing the whole thing is a PITA, findElement is stateless and has no this, so I can do this.
        // Is defined in doEllipsis because this file is loaded before TRC.implClasses.TRCRBox.prototype.findElement is defined.
        var findElement;

        TRC.Ellipsis = Ellipsis;

        /**
         * Iterate the boxes collection and perform overflow fix on each.
         * Important: This assumes that Ellipsis.tokenize() ran on each of the boxes in the collection. Will otherwise throw.
         * @param {Object.<string, TRCRBox>|TRCRBox[]} boxes
         */
        Ellipsis.doEllipsis = function (boxes) {
            findElement = findElement || TRC.implClasses.TRCRBox.prototype.findElement;
            if (TRC.ellipsisPerf) { console.timeStamp("Taboola new ellipsis"); }
            // (TRC.performance && TRC.performance.mark("7.2.1"));
            (TRC.performance && TRC.performance.mark("7.2.1", null, "Ellipsis", "all", 'SmartEllipsis', TRC.PerfEvenType.START));
            Ellipsis.measure(boxes);
            Ellipsis.renderEllipsis(boxes);
            // (TRC.performance && TRC.performance.mark("7.2.9"));
            (TRC.performance && TRC.performance.mark("7.2.9", null, "Ellipsis", "all", 'SmartEllipsis', TRC.PerfEvenType.STOP));
        };


        function _tokenizeSingleElement(title, tokenizeStrategy) {
            title.innerHTML = Ellipsis._tokenizeSingle(TRC.dom.getText(title), tokenizeStrategy);
        }

        /**
         * Tokenize the words in all of the items of all of the boxes.
         * Involves adding <span>s around "tokens", to allow for measurements and text-overflow: ellipsis.
         * @see Ellipsis.doEllipsis
         *
         * @param {Object<string, TRCRBox>|TRCRBox[]} boxes
         * @param {string} strategyName
         */
        Ellipsis.tokenize = function (boxes, strategyName) {
            strategyName = strategyName in Ellipsis._tokenizeStrategies ? strategyName : "word";
            return withBoxesIteration(function (labelsBox, title, description) {
                if (labelsBox.trcEllipsisTokenized) {
                    delete labelsBox.trcEllipsisTokenized;
                }

                var tokenizeStrategy = Ellipsis._tokenizeStrategies[strategyName];
                if (title) {
                    _tokenizeSingleElement(title, tokenizeStrategy);
                }
                if (description) {
                    _tokenizeSingleElement(description, tokenizeStrategy);
                }

                labelsBox.trcEllipsisTokenized = true;
            })(boxes); // withBoxesIteration returns a function, (boxes) actually calls it and sets things in motion.
        };

        Ellipsis.verifyTokenized = function(boxes) {
            var valid = true;
            withBoxesIteration(function(labelsBox) {
                valid = valid && labelsBox.trcEllipsisTokenized;
            })(boxes);
            return valid;
        };

        /**
         * Measures and stores size and word position information on each item.
         * Note: Ellipsis.tokenize *must* be called on each box before calling Ellipsis.measure on it.
         *
         * @param {Object<string, TRCRBox>|TRCRBox[]} boxes - Recall, withBoxesIteration returns a function that accepts this param.
         */
        Ellipsis.measure = withBoxesIteration(function (labelsBox, title, description) {
            var titleResult = title && Ellipsis._measureSingleElementSizes(title);
            var descriptionResult = description && Ellipsis._measureSingleElementSizes(description);

            labelsBox.trcEllipsisPositions = {title: titleResult, description: descriptionResult};
        });

        Ellipsis.renderEllipsis = withBoxesIteration(function(labelsBox, title, description) {
            var measurementResults = labelsBox.trcEllipsisPositions;
            if (!measurementResults || // Measure was not called.
                (title && !measurementResults.title) || // Measure was not called on title, but title exists
                (description && !measurementResults.description)) { // Measure was not called on description, but description exists
                __trcDebug("Calling renderEllipsis without measuring first. Skipping");
                return;
            }

            try {
                if(title) {
                    Ellipsis._repaintSingleEllipsis(title, measurementResults.title);
                }
                if (description) {
                    Ellipsis._repaintSingleEllipsis(description, measurementResults.description);
                }
            } catch (err) {
                __trcDebug(err.message + ". Skipping");
            }
        });

        /**
         * @type {Object<string, function(string) : {spaces: bool, tokens: string[]}>}
         */
        Ellipsis._tokenizeStrategies = {
            "word": function(str) {
                return {spaces: true, tokens: str.split(/\s+/)};
            },
            /**
             * Splits by letter, considers HTML entities such as &amp; to be a single letter.
             * @param str
             * @returns {{spaces: boolean, tokens: string[]}}
             */
            "letter": function(str) {
                return {spaces: false, tokens: str.match(/&[\w#]+;|./g)};
            }
        };

        /**
         * @param {string} text
         * @param {Object<string, function(string) : {spaces: boolean, tokens: string[]}>} strategy
         * @private
         * @returns {string} Tokenized string
         */
        Ellipsis._tokenizeSingle = function (text, strategy) {
            var tokenizeResult = strategy.call(this, text);
            /*
             Here we assume that the <ins>s are inline-blocks
             Probably with .trc_ellipsis span {} CSS rule
             Else, measuring them becomes inaccurate.
             */
            return TRC.util.map(tokenizeResult.tokens, function(token) {
                return token === ' ' ? token : '<ins>' + token + '</ins>';
            }).join(tokenizeResult.spaces ? ' ' : '');
        };

        /**
         * Measure a single element and return the results.
         * @param element
         * @returns {?{lastLineStartsAt: HTMLElement, lastVisibleWord: HTMLElement, singleLineContent: string[]}}
         * @private
         */
        Ellipsis._measureSingleElementSizes = function(element) {
            if (!element || !element.offsetHeight) {
                return null;
            }
            if (!element.firstChild || element.firstChild.tagName != "INS") {
                return __trcDebug("Attempted to call measure on element before tokenize. Skipping");
            }
            var singleLineDiv = findElement(function elementIsEllipsisShim(el) {
                return el.className.search("lastLineEllipsis") >= 0;
            }, element, 'ins');
            if (singleLineDiv) {
                var list = element.getElementsByTagName('ins');
                if (singleLineDiv.className.replace(/[\t\r\n\f]/g, " ").indexOf("tblHideAllButFirst") >= 0){
                    for (var i = 0; i < list.length; i++) {
                        var token = list[i];
                        token.style.display = '';
                    }
                }
                singleLineDiv.parentNode.removeChild(singleLineDiv);
            }

            var list = element.getElementsByTagName('ins');
            var lineHeight = TRC.dom.lineHeight(list[0]);
            var height = Math.floor(parseFloat(getComputedStyle(element).height) / lineHeight) * lineHeight;
            var lastLineTop = height - lineHeight;
            var elementWidth = element.offsetWidth;
            var firstWordWidth =   list[0].offsetWidth;
            var singleLineContent = [],
                lastLineStartsAt,
                lastVisibleWord;

            for (var i = 0; i < list.length; i++) {
                var token = list[i];

                //Finds first token on the last line
                if (lastLineStartsAt === undefined && token.offsetTop >= lastLineTop) {
                    lastLineStartsAt = list[i];
                }

                //Push words of last line into array
                if (lastLineStartsAt !== undefined) {
                    singleLineContent.push(TRC.dom.getText(token));
                }

                if (!lastVisibleWord && token.offsetTop >= height) {
                    lastVisibleWord = list[i-1];
                }
            }

            return {
                lastLineStartsAt: lastLineStartsAt,
                lastVisibleWord: lastVisibleWord,
                singleLineContent: singleLineContent,
                elementWidth: elementWidth,
                firstWordWidth: firstWordWidth
            }

        };

        /**
         * This will not include measurements.
         * If measurement results are not stored on element, will throw.
         * @param {HTMLElement} element
         * @param {{lastLineStartsAt: HTMLElement, lastVisibleWord: HTMLElement, singleLineContent: string[], elementWidth: Number,firstWordWidth: Number}} measurements
         * @private
         */
        Ellipsis._repaintSingleEllipsis = function(element, measurements) {
            if (measurements.lastVisibleWord) {
                var singleLineDiv = doc.createElement("ins");
                TRC.dom.addClass(singleLineDiv, "lastLineEllipsis");
                var strategyName = element.tokenizeStrategy || "word";
                var needSpaces = Ellipsis._tokenizeStrategies[strategyName]('').spaces;
                singleLineDiv.appendChild(document.createTextNode(measurements.singleLineContent.join(needSpaces ? " " : "")));
                element.insertBefore(singleLineDiv, measurements.lastLineStartsAt);
                if(strategyName === "word" && (measurements.firstWordWidth >= measurements.elementWidth) ){
                    var list = element.getElementsByTagName('ins');
                    for (var i = 0; i < list.length; i++) {
                        var token =  list[i];
                        if (token.className.replace(/[\t\r\n\f]/g, " ").indexOf("lastLineEllipsis") == -1){
                            token.style.display = 'none';
                        } else {
                            token.className += " tblHideAllButFirst";
                        }
                    }

                }
            }
        };

        /**
         * Apply the ellipsis callback to every title and description label
         * in a given labels box
         * @param labelsBox
         * @param callback
         */
        function applyEllipsisToLabels(labelsBox, callback) {
            if(!labelsBox) {
                return;
            }

            var title = findElement(function elementIsTitle(e) {
                    return e.className.search("title") >= 0;
                }, labelsBox, 'span'),
                description = findElement(function elementIsDescription(e) {
                    return (e.className.search("description") >= 0);
                }, labelsBox, 'span');

            callback.call(this, labelsBox, title, description);
        }

        /**
         * Helper function to save typing
         * Generate a function accepting a boxes collection, and applying the callback on each item in the box.
         *
         * Automatically finds title and description for you, because there's no real usecase to seperate those concerns.
         *
         * @param {function(HTMLElement, HTMLElement, ?HTMLElement)} callback - Higher order function to call on each item
         * @returns {function(Object<string, TRCRBox>|TRCRBox[])} - Generated function.
         */
        function withBoxesIteration(callback) {
            return function(boxes) {
                for (var key in boxes) {
                    if (boxes.hasOwnProperty(key)) {
                        var box = boxes[key];
                        box.boxes.forEach(function measureTokenPositioning(item) {
                            applyEllipsisToLabels(item.labelsBox, callback);
                            applyEllipsisToLabels(item.preLabelsBox, callback);
                        });
                    }
                }
            };
        }
    })(window, document);

    TRC.eventDelegator = function(win,doc) {
    	var delegatorsStack = [],// first level member : event name. second level members : 1. "_all" - array of all page level handlers , 2. mode_name {String} - array of mode level handlers  
    		eventsStack = {}, // first level member : event name fired. second level member : mode name that fired the event
    		eventSubsc;
    	/**
    	 * parse the delegators stack and find the handlers that should be called.
    	 * @param {String} - event
    	 * @param {Object } - modeObj  (e.g. {name : mode-name, container : html container }) but can be any object the handler is aware of
    	 */
    	function processDelegatorsStack(event, modeObj){
    		var handlers;
    		if(delegatorsStack[event]){
    			handlers = delegatorsStack[event]["_all"];
    			executeHandlers(handlers, (modeObj) ? modeObj : "");
    		} else {
    			return;
    		}
    		if(modeObj && delegatorsStack[event][modeObj.container.id]){
    			handlers = delegatorsStack[event][modeObj.container.id];
    			executeHandlers(handlers, modeObj);
    		}		
    	}
    	/**
    	 * execute list of handlers subscribed to a specific  mode.
    	 * the call is through setTeimeout to break the execution of the publisher handler from our scope.
    	 * @param {Array} handlers - [function, function, ...]
    	 * @param {Object} modeObj - {name : mode-name, container : html container }
     	 */	
    	function executeHandlers(handlers, modeObj){
            if (!handlers){
                return;
            }
    		var i, len = handlers.length;
    		for(i = 0; i < len; i++){
    			try{
    				if (typeof handlers[i] === "function"){
    					setTimeout(function(func, _modeObj){
    						return function(){
    							func(_modeObj);
    						}						
    					}(handlers[i], modeObj), 0);
    				}
    			} catch(e){
    				__trcError("executeHandlers", e);
    			}
    		}
    	}
    	/**
    	 * execute a specific handler subscribed to the page level or a specific  mode.
    	 * the call is through setTeimeout to breake the execution of the publisher handler from our scope.
    	 * @param {Function} handler
    	 * @param {Object} modeObjs  -  (e.g. {name : mode-name, container : html container }) but can be any object the handler is aware of
    	 */
    	function executePreviousEvents(handler, modeObjs){
    		var mode;
    		if(!modeObjs){
    			setTimeout(handler, 0);
    			return;
    		}
    		for(mode in modeObjs){
    			try{
    				if (typeof handler === 'function'){
    					setTimeout(function(func, modeObj){
    						return function(){
    							func(modeObj);
    						}
    					}(handler, modeObjs[mode]), 0);
    				}
    			} catch(e){
    				__trcError("executeHandlers", e);
    			}
    		}
    	}
    	
    	function setNewDelegatorsStackEevent(event){
    		delegatorsStack[event] = []; 
    		delegatorsStack[event]["_all"] = []; // per event handlers
    	}
    	
    	function setNewDelegatorsStackModeEvent(event, container){
    		delegatorsStack[event][container] = []; // per mode handlers
    	}
    							
    	var modObject = {
    		/**
    		 * subscribe to an event
     		 * @param {String} event
     		 * @param {Function} handler
     		 * @param {String} mode
    		 */
    		subscribe : function(event, handler, container){
    			if(!delegatorsStack[event]){
    				setNewDelegatorsStackEevent(event);
    			}	
    			if(container){
    				if(!delegatorsStack[event][container]){
    					setNewDelegatorsStackModeEvent(event, container);
    				}	
    				delegatorsStack[event][container].push(handler);
    				if(eventsStack[event] && eventsStack[event][container]){
    					executePreviousEvents(handler, {"mode" : eventsStack[event][container]});
    				}
    			} else {
    				delegatorsStack[event]["_all"].push(handler);
    				if( eventsStack[event] ){
    					executePreviousEvents(handler, eventsStack[event]);
    				}										
    			}
    		},
    		/**
    		 * dispatch an event
     		 * @param {String} event
     		 * @param {String} mode_name
    		 */
    		dispatch : function(event, modeObj){
    			eventsStack[event] = eventsStack[event] || {};
    			
    			if (modeObj){
    				eventsStack[event][modeObj.container.id] = modeObj;
                } else {
                    eventsStack[event]['_all'] = {};
    			}
    			processDelegatorsStack(event, (modeObj) ? modeObj : null);								
    		},
    		resetEvents : function(){
    			eventsStack = {};
    		}
    	};
    	// expose private methods for UT 
    	if (win._trcIsUTactive){
    		modObject.processDelegatorsStack = processDelegatorsStack;
    		modObject.executeHandlers = executeHandlers;
    		modObject.executePreviousEvents = executePreviousEvents;
    		modObject.delegatorsStack = delegatorsStack;
    		modObject.eventsStack = eventsStack;
    	}
    	
    	if (TRC.subscriptionRegister){
    		while (TRC.subscriptionRegister.length){
    			eventSubsc = TRC.subscriptionRegister.shift();
    			modObject.subscribe(eventSubsc.event, eventSubsc.handler, eventSubsc.container);
    		}
    	}
    	return modObject;
    	
    }(window,document);

    /**
     * This module handles dispatching of specific events aimed at 3rd-parties.
     * This module also includes an interface to listen to specific events, via the
     * TRC.EventsAPI.listen() method.
     *
     * This moduels depends on events.js module and the TRC.dispatch() and
     * TRC.listen() methods.o
     *
     * Initial ticket: DEV-5847
     */
    (function (win, doc) {
        function wrapObject(o) {
            return {detail: o};
        }

        function prefixName(name) {
            return 'api::' + name;
        }

        function dispatchEvent(topic, data) {
            TRC.dispatch(prefixName(topic), wrapObject(data));
        }

        function getRelevantDataForRenderAndVisible(trcResponse, box) {
            var parser = TRC.TRCParser,
                data;
            trcResponse = trcResponse || {};
            data = {
                mode: parser.parseModeName(trcResponse),
                placement: parser.parsePlacementName(trcResponse),
                baseMode: parser.parseBaseModeName(trcResponse),
                variant: parser.parseTestVariant(trcResponse),
                itemCount: parser.getItemCount(trcResponse)
            };

            if (box) {
                data.container = box.container;
                data.items = box.apiData;
            }

            return data;
        }

        TRC.EventsAPI = {
            dispatchClick: function (item, trcResponse) {
                var trcParser = TRC.TRCParser;
                var parser;
                item = item || {};
                parser = new TRC.ItemParser(item);
                trcResponse = trcResponse || {};

                dispatchEvent('click', {
                    slot: parser.getSlot(),
                    id: parser.getId(),
                    type: parser.getType(),
                    title: parser.getTitle(),
                    url: parser.getUrl(),
                    linkTarget: parser.getLinkTarget(),
                    mode: trcParser.parseModeName(trcResponse),
                    placement: trcParser.parsePlacementName(trcResponse),
                    baseMode: trcParser.parseBaseModeName(trcResponse),
                    variant: trcParser.parseTestVariant(trcResponse),
                    itemCount: trcParser.getItemCount(trcResponse)
                });
            },
            dispatchVisible: function (trcResponse, box) {
                var data = getRelevantDataForRenderAndVisible(trcResponse, box);
                dispatchEvent('visible', data);
            },
            dispatchRender: function (trcResponse, box) {
                var data = getRelevantDataForRenderAndVisible(trcResponse, box);
                dispatchEvent('render', data);
            },
            dispatchNoContent: function (_reason, _placement, isFeedCard) {
                var data = {
                    reason: _reason
                };

                if (_placement) {
                    data.placement = _placement;
                }

                data.isFeedCard = isFeedCard || false;

                dispatchEvent('nocontent', data);
            },
            listen: function (topic, handler) {
                TRC.listen(prefixName(topic), handler, true);
            },
            dispatchStoriesLoaded: function () {
                dispatchEvent('storiesLoaded');
            },
            dispatchStoriesCloseVerticalUi: function () {
                dispatchEvent('closedVerticalUI');
            },
            dispatchStoriesSwipeVerticalUi: function (videoData) {
                dispatchEvent('swipeVerticalUI', videoData);
            },
            dispatchTrcImplAvailable: function () {
                dispatchEvent('trcImplAvailable');
            },
            dispatchPlacementNoRendered: function (trcResponse, reason) {
                var parser = TRC.TRCParser, data;
                trcResponse = trcResponse || {};
                data = {
                    mode: parser.parseModeName(trcResponse),
                    placement: parser.parsePlacementName(trcResponse),
                    unifiedPlacement: trcResponse.unifiedPlacement || null,
                    reason: reason || null
                };

                dispatchEvent('trcPlacementNotRendered', data);
            },
            readmore: function (eventName, trcResponse) {
                var parser = TRC.TRCParser;
                trcResponse = trcResponse || {};

                dispatchEvent('readmore.' + eventName, {
                    mode: parser.parseModeName(trcResponse),
                    placement: parser.parsePlacementName(trcResponse),
                    variant: parser.parseTestVariant(trcResponse)
                });
            },
            dispatchHp4uEvent: function (data) {
                dispatchEvent('hp4uEvents', data);
            }
        };
    })(window, document);

    /**
     * Internal event dispatch mechanism for inter-module communication.
     * 
     * Using this mechanism is preferred over exposing an API when the connection between caller and callee is transient
     * and not known ahead of time. A good example is the OVP integration glue where multiple event types may come from
     * the OVP and our code may or may not be interested in some events vs other events, depending on internal conditions
     * (such as whether the publisher wants an overlay UI, and auto playlist UI or just a tracking code).
     * 
     * TODO: This module exposes methods directly on the TRC namespace instead of using its own name space. As such it is
     * in contradiction with the coding style guide, and is kept as is for backward compatibility. We should fix this at
     * some point.
     * 
     * This module is not about DOM events - for DOM events look at TRC.dom.
     * 
     * Namespace: TRC
     */
    (function(win,doc){
    	var eventCreate, eventDispatcher, // place holder for the implementation-specific logic
    		eventMap = {},
    		eventHandlerCounter = 0;
    	
    	/*
    	 * Internal custom events implementation, based on Dean Edwards's "Callbacks vs. Events" article
    	 * http://dean.edwards.name/weblog/2009/03/callbacks-vs-events/
    	 */
    	function eventInit(event) {
    		if (typeof eventMap[event] == 'undefined')
    			eventMap[event] = [];
    	}
    	
    	function eventUnlisten(event, id) {
    		eventInit(event);
            eventMap[event] = eventMap[event].filter(function(b){
                return id !== b.id
    		});
    	}
    	
    	
    	/**
    	 * Add a an event handler to the current object
    	 * @param event name of the event to listen on (without 'on' prefix)
    	 * @param handler method to execute when the event happens
    	 * @param sync (optional) - whether the handler should be executed synchronously
    	 * @returns event handler resource. use resource.remove() to cancel the listener
    	 */
    	TRC.listen = TRC.listen || function(event, handler, sync) {
    		if (typeof event == 'object' && event.length) {
    			event.forEach(function(n) {TRC.listen(n,handler);});
    			return null;
    		}
    		eventInit(event);
    		var handlerBlock = {
    				id: eventHandlerCounter++,
    				handler: handler,
    				eventName: event,
    				sync: sync,
    				remove: function(){
    					eventUnlisten(this.eventName, this.id);
    				}
    		};
    		eventMap[event].push(handlerBlock);
    		return handlerBlock;
    	};
    	
    	/**
    	 * Dispatch a new event on the current object
    	 * @param event name of the event to dispatch on
    	 * @param data custom data to send to all event handlers
    	 */
    	TRC.dispatch = TRC.dispatch || function(event, data) {
    		eventInit(event);
    		var eventObj = eventCreate(event, data);
    		
    		// go over all event handlers for this event and dispatch them
    		eventMap[event].forEach((function(handlerBlock) {
    			if(handlerBlock.sync) {
                    try {
                        handlerBlock.handler.call(this,eventObj);
                    }
                    catch (e) {}
    			} else {
    				eventDispatcher((function(){
    					handlerBlock.handler.call(this,eventObj);
    				}).trcBind(this));
    			}
    		}).trcBind(this));
    	};

    	TRC.hasEvent = TRC.hasEvent || function(event) {
    		var eventCalllbacks = eventMap[event];
    		return Array.isArray(eventCalllbacks) && eventCalllbacks.length > 0;
    	};

    	// setup the custom events for standard DOM level 1 browsers
    	if (doc.addEventListener && doc.dispatchEvent) {
    		doc.addEventListener("trcFakeEvents", function(event) {
    			event.cx();
    		}, false);
    		
    		eventCreate = function(name, data) {
    			var newEvent = doc.createEvent("Event");
    			newEvent.initEvent(name, false, false);
                if ( Object.prototype.toString.call(data) === "[object Array]" ) {
                    newEvent.data = data;
                } else if (typeof data == 'object'){
    				__trcCopyProps(data, newEvent);
    			} else {
    				newEvent.data = data;
    			}
    			return newEvent;
    		};
    		eventDispatcher = function(callback) {
    			var fakeEvent = eventCreate("trcFakeEvents");
    			fakeEvent.cx = callback;
    			doc.dispatchEvent(fakeEvent);
    		};
    		return;
    	}
    	
    	// setup the custom events for Internet Explorer (8 and below)
    	doc.documentElement.attachEvent("onpropertychange", function(event) {
    		if (event.propertyName == "trcFakeEvents") // execute the callback
    			event.cx();
    	});
    	
    	eventCreate = function(name, data) {
    		var newEvent;
    			
    		// is the data already an event ?
    		if (data && data.generator && data.generator === 'ceo') {
    			data.type = name;
    			return data;
    		}
    		newEvent = doc.createEventObject();
    		newEvent.generator ='ceo'; // mark the event as created by createEventObject
    		newEvent.type = name;
            if ( Object.prototype.toString.call(data) === "[object Array]" ){
                newEvent.data = data;
            } else if (typeof data == 'object'){
    			__trcCopyProps(data, newEvent);
    		} else {
    			newEvent.data = data;
    		}
    			
    		return newEvent;
    	};
    	eventDispatcher = function(callback) {
    		var fakeEvent = eventCreate("trcFakeEvents");
    		fakeEvent.cx = callback;
    		fakeEvent.propertyName = "trcFakeEvents";
    		doc.documentElement.fireEvent("onpropertychange",fakeEvent);
    	};

    })(window,document);

    /* Added "expandable" (descender) animation to RBox container */
    (function(win){
        var ExpandAnimationManager = TRC.ExpandAnimationManager = function(rbox) {
            TRC.RBoxUsage.logUsage('ExpandAnimationManager');
                this.rbox = rbox;
                this.container = rbox.container;
                this.trcContainer = this.container._trc_container;

                TRC.css.utils.setStyleElements(this.createCSS());

                this.trcContainer.className += ' trc_expandable';
                this.throttledExpandScrollHandler = this.scrollHandler.trcBind(this).trcThrottle(10);
                TRC.dom.on(win, 'scroll', this.throttledExpandScrollHandler);
            };

        ExpandAnimationManager.prototype.scrollHandler = function() {
            if(this.rbox.isInViewPort(this.container, 0)) {
                if(this.trcContainer.wasOutOfViewPort) {
                    this.trcContainer.className += ' trc_show';
                    TRC.dom.off(window, 'scroll', this.throttledExpandScrollHandler);
                }
            } else {
                this.trcContainer.wasOutOfViewPort = true;
            }
        };

        ExpandAnimationManager.prototype.createCSS = function() {
            var css = [],
                containerIdPrefix = '#' +  TRC.css.utils.escape(this.container.id),
                transitionDuration = this.rbox.trc.getProperty(this.rbox.mode_name, "expand-animation-duration"),
                expansionMaxHeight = this.rbox.trc.getProperty(this.rbox.mode_name, "expand-animation-max-height"),
                cssRules = [
                    containerIdPrefix + ' .trc_rbox_container.trc_expandable {' + TRC.css.utils.generateCssRuleWithVendorPrefixes('transition-duration', transitionDuration + 'ms') + '}',
                    containerIdPrefix + ' .trc_rbox_container.trc_expandable.trc_show { max-height: ' + expansionMaxHeight + 'px;}'
                ];

            for(var i = 0; i < cssRules.length; i++) {
                css.push(cssRules[i]);
            }

            return css.join('');
        };

    })(window);

    (() => {
        const DEFAULTS = {
            collapsedHeight: 490,
            expandButtonCaption: 'Show More',
            collapseButtonCaption: 'Show Less',
            fadeBackgroundColor: '#fff',
            fadeHeight: 60,
            buttonTop: 28,
            buttonBottom: 10,
            fadeGradient: 40
        };

        class ExpandableBox {

            constructor(trcManager, boxId, options) {
                this.externalCardMaxRetries = trcManager.global['external-card-max-retries'] || 5;
                this.externalCardRetryInterval = trcManager.global['external-card-retry-interval'] || 1000;

                options = __trcCopyProps(DEFAULTS, {}, options);
                this.init(boxId, options);
            }

            init(boxId, options, numRetries = 0) {
                this.boxElement = document.getElementById(boxId);

                if (this.boxElement) {
                    if (this.boxElement.getBoundingClientRect().height < options.collapsedHeight) {
                        if (numRetries < this.externalCardMaxRetries) {
                            numRetries++;
                            setTimeout(this.init.trcBind(this, boxId, options, numRetries), this.externalCardRetryInterval);
                        } else {
                            TRC.dom.addClass(this.boxElement, 'tbl-expandable-box-inactive');
                        }
                        return;
                    }

                    TRC.dom.addClass(this.boxElement, 'tbl-collapsed');
                    TRC.dom.injectStyle(ExpandableBox.getExpandableBoxCSS(boxId, options));
                    this.boxElement.appendChild(this.createExpandButton(options));
                    this.boxElement.appendChild(this.createCollapseButton(options));
                    this.listenToBoxClick();

                } else {
                    __trcError(`Cannot find expandable box element by ID: ${boxId}`);
                }
            }

            createExpandButton(options) {
                return this.createButton(options.expandButtonCaption, this.handleExpandClick, 'tbl-expand-btn-container');
            }

            createCollapseButton(options) {
                return this.createButton(options.collapseButtonCaption, this.handleCollapseClick, 'tbl-collapse-btn-container');
            }

            createButton(caption, clickHandler, containerClass) {
                const btnContainer = document.createElement('div'),
                    linkBtn = document.createElement('a');

                linkBtn.className += 'tbl-expandable-box-btn';
                if (linkBtn.textContent) {
                    linkBtn.textContent = caption;
                } else {
                    linkBtn.innerText = caption;
                }

                TRC.dom.on(linkBtn, 'click', clickHandler.trcBind(this));

                btnContainer.className = `tbl-expandable-box-btn-container ${containerClass}`;
                btnContainer.appendChild(linkBtn);

                return btnContainer;
            }

            addExpandClasses() {
                TRC.dom.addClass(this.boxElement, 'tbl-expanded');
                TRC.dom.removeClass(this.boxElement, 'tbl-collapsed');
                this.isExpanded = true;
            }

            addCollapseClasses() {
                TRC.dom.addClass(this.boxElement, 'tbl-collapsed');
                TRC.dom.removeClass(this.boxElement, 'tbl-expanded');
                this.isExpanded = false;
            }

            handleExpandClick(event) {
                event.preventDefault();
                event.stopPropagation();

                if (this.isExpanded) {
                    return;

                }

                this.addExpandClasses();
            }

            handleCollapseClick(event) {
                event.preventDefault();
                event.stopPropagation();
                this.addCollapseClasses();

                this.boxElement.scrollIntoView && this.boxElement.scrollIntoView();
            }

            // eslint-disable-next-line no-unused-vars
            static getExpandableBoxCSS(boxId, options) {
                return `#${boxId}.tbl-expanded { max-height: inherit; } #${boxId}.tbl-expanded .tbl-collapse-btn-container { display: block; padding: 0 5px; }#${boxId}.tbl-collapsed { max-height: ${options.collapsedHeight}px; overflow: hidden; position: relative; } #${boxId}.tbl-collapsed .tbl-expand-btn-container { display: block; }#${boxId} .tbl-expandable-box-btn { margin: ${options.buttonTop}px 0 ${options.buttonBottom}px !important; display: inline-block !important; line-height: 38px !important; text-align: center !important; white-space: nowrap !important; vertical-align: middle !important; cursor: pointer !important; -webkit-touch-action: manipulation; -moz-touch-action: manipulation; -ms-touch-action: manipulation; -o-touch-action: manipulation; touch-action: manipulation; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; color: #326891 !important; background: #edf2f5 none !important; border: 1px solid #93abbc !important; height: 38px !important; width: 100% !important; font-size: 15px !important; font-weight: bold !important; border-radius: 3px !important; font-family: sans-serif !important; } #${boxId} .tbl-expandable-box-btn:hover { background-color: #bed0dc !important; border-color: #7399b3 !important; color: #326891 !important; }#${boxId} .tbl-expandable-box-btn-container { display: none; text-align: center; }#${boxId} .tbl-expand-btn-container { position: absolute; z-index: 100; left: 0; right: 0; bottom: 0; padding: ${options.fadeHeight}px 10px 0px 10px; box-sizing: border-box; background: -moz-linear-gradient(top, rgba(255, 255, 255, 0) 0%, ${options.fadeBackgroundColor} ${options.fadeGradient}%, ${options.fadeBackgroundColor} 100%); background: -webkit-gradient(linear, left top, left bottom, color-stop(0%, rgba(255, 255, 255, 0)), color-stop(50%, ${options.fadeBackgroundColor}), color-stop(100%, ${options.fadeBackgroundColor})); background: -webkit-linear-gradient(top, rgba(255, 255, 255, 0) 0%, ${options.fadeBackgroundColor} ${options.fadeGradient}%, ${options.fadeBackgroundColor} 100%); background: -o-linear-gradient(top, rgba(255, 255, 255, 0) 0%, ${options.fadeBackgroundColor} ${options.fadeGradient}%, ${options.fadeBackgroundColor} 100%); background: -ms-linear-gradient(top, rgba(255, 255, 255, 0) 0%, ${options.fadeBackgroundColor} ${options.fadeGradient}%, ${options.fadeBackgroundColor} 100%); background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%, ${options.fadeBackgroundColor} ${options.fadeGradient}%, ${options.fadeBackgroundColor} 100%); }`;
            }

            listenToBoxClick() {
                TRC.listen('expandableBoxChildIFrameClick', e => {
                    if (e.container === this.boxElement && !this.isExpanded) {
                        this.addExpandClasses();
                    }
                });
            }
        }

        TRC.ExpandableBox = ExpandableBox;

    })();

    (() => {
        TRC.ExternalContainerAppender = {
            MAX_RETRIES: 50,
            TIMEOUT: 100,
            move(cssSelector, targetContainer, retries = 0) {
                if (!document.querySelector) {
                    return;
                }

                if (targetContainer) {
                    let element,
                        querySelectorException = false;

                    try {
                        element = document.querySelector(cssSelector);
                    } catch (e) {
                        __trcWarn(`Exception while trying to find external container with selector ${cssSelector}: ${e}`);
                        querySelectorException = true;
                    }

                    if (element) {
                        targetContainer.appendChild(element);
                        TRC.dispatch('trcContentReady', {container: targetContainer});
                    } else if (retries < this.MAX_RETRIES && !querySelectorException) {
                        TRC.Timeout.set(
                            this.move.trcBind(this, cssSelector, targetContainer, retries + 1),
                            this.TIMEOUT
                        );
                    } else {
                        __trcWarn(`Could not find external container with selector ${cssSelector} to move`);
                    }
                } else {
                    __trcError(`Could not find target container for external container move`);
                }
            }
        };
    })();

    /* eslint-disable camelcase */

    /*
    * This module is handling placements that are configured as "fallback placements".
    * "fallback placements" are rendered instead of the publisher main content and hiding the original
    * content of the publisher.
    * */
    (function () {

        let fallbackPlacements = {};
        const onErrorFunctions = {};

        const nonFallbackPlacement = {
            isPlacementApprovedToRender() {
                return true;
            },
            hideFallbackElements() {
                return this;
            },
            reportTimeToRender() {}
        };

        class Fallback {

            constructor(
                originalPlacementName,
                {enable, elements_to_hide} = {},
                {should_render} = {}
            ) {
                this.originalPlacementName = originalPlacementName;
                this.isApprovedToRender = null;
                this.triedToHideFallbackElements = false;
                this.enable = enable;
                this.elements_to_hide = elements_to_hide;
                this.should_render = should_render;
            }

            setIsApprovedToRender() {
                if (this.isApprovedToRender === null && this.enable && typeof this.should_render === 'function') {
                    try {
                        if (this.should_render()) {
                            this.isApprovedToRender = true;
                        } else {
                            this.isApprovedToRender = false;
                            fallbackUtils.report({
                                type: 'ERROR',
                                reason: 'notAllowedToRender',
                                originalPlacementName: this.originalPlacementName
                            });
                        }
                    } catch (e) {
                        this.isApprovedToRender = false;
                        __trcError('Fallback Error in should_render', e);
                    }
                }
            }

            isPlacementApprovedToRender() {
                this.setIsApprovedToRender();
                return this.isApprovedToRender;
            }

            hideFallbackElements({placement}) {
                if (this.isApprovedToRender && !this.triedToHideFallbackElements) {
                    this.triedToHideFallbackElements = true;
                    this.hideElements(placement);
                }
                return this;
            }

            reportTimeToRender({isCache, placement, recommendationList}) {
                fallbackUtils.report({
                    type: 'placementData',
                    timeToRendered: performance.now && performance.now(),
                    originalPlacementName: this.originalPlacementName,
                    placementName: placement,
                    items: recommendationList ? recommendationList.length : null,
                    isCache: !!isCache
                });
            }

            hideElements(placementName) {
                if (Array.isArray(this.elements_to_hide)) {
                    this.elements_to_hide.forEach(
                        selector => {
                            const elements = document.querySelectorAll(selector);
                            if (!elements.length) {
                                fallbackUtils.report({
                                    type: 'ERROR',
                                    reason: 'noFallbackElements',
                                    placement: placementName
                                });
                            } else {
                                for (let i = 0; i < elements.length; ++i) {
                                    elements[i].style.display = 'none';
                                }
                            }
                        }
                    );
                }
            }
        }

        const shouldRenderPlacementByRequest = (recommendation, preloadRequest) => {
            try {
                const originalPlacementName = recommendation.fpl || recommendation.uip;
                const placementRequest = preloadRequest[originalPlacementName];

                if (placementRequest && placementRequest.skip_dom_render) {
                    /* todo: from talking to guy.g seems like this scenario can be preformed using laz-render. 
                    consider remove this logic and use the lzr module. */
                    return false;
                }
            } catch (e) {
                __trcError('Fallback shouldRenderPlacementByRequest Error', e);
            }
            // in any case of error in this method we return true,
            // because if we return false it will prevent placements from rendering
            return true;
        };

        const shouldRenderPlacement = (recommendation, preloadRequest) => {
            try {
                return build(recommendation, preloadRequest)
                    .isPlacementApprovedToRender();
            } catch (e) {
                __trcError('Fallback shouldRenderPlacement Error', e);
            }
            // in any case of error in this method we return true,
            // because if we return false it will prevent placements from rendering
            return true;
        };

        const finalize = placementData => {
            try {
                getFallbackPlacement(placementData)
                    .hideFallbackElements(placementData)
                    .reportTimeToRender(placementData);
            } catch (e) {
                __trcError('Fallback Error in finalize', e, 0.2);
            }
        };

        const build = (
            {
                cga: serverConfig,
                fpl: feedOriginalPlacementName,
                uip: widgetOriginalPlacementName
            },
            preloadRequest = {}
        ) => {
            const originalPlacementName = feedOriginalPlacementName || widgetOriginalPlacementName;
            const fallbackPlacement = fallbackPlacements[originalPlacementName];

            if (fallbackPlacement) { // feed card, already has related feed placement
                return fallbackPlacement;
            }

            const serverFallbackConfig = serverConfig && serverConfig.fallback;
            if (serverFallbackConfig && !fallbackPlacement) { // new fallback placement feed/widget
                fallbackPlacements[originalPlacementName] = new Fallback(
                    originalPlacementName,
                    serverFallbackConfig,
                    preloadRequest[originalPlacementName]
                );
                return fallbackPlacements[originalPlacementName];
            }

            return nonFallbackPlacement;
        };

        const getFallbackPlacement = ({response, placement}) => {
            const originalPlacementName = response.feedPlacement || placement;
            return fallbackPlacements[originalPlacementName] || nonFallbackPlacement;
        };

        const fallbackUtils = {
            report: data => {
                if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-fallback-events')) {
                    const requestData = {
                        data: JSON.stringify(data),
                        type: 'fallback'
                    };
                    TRCImpl.sendEvent('pubs-generic', {d: JSON.stringify(requestData)}, {});
                }
            },
            runOnError: event => {
                const {placement} = event;
                const conf = fallbackPlacements[placement];
                const onError = onErrorFunctions[placement];
                if (onError && typeof onError === 'function') {
                    try {
                        onError();
                    } catch (e) {
                        __trcError('Fallback Error in on_error', e);
                    }
                }

                if (conf && conf.enable) {
                    fallbackUtils.report({type: 'ERROR', reason: 'failedToRender', placement});
                }
            },
            setOnError: ({placement, on_error}) => {
                onErrorFunctions[placement] = on_error;
            }
        };

        TRC.listen('onRboxFlowError', fallbackUtils.runOnError);

        TRC.fallbackApi = {
            shouldRenderPlacement,
            shouldRenderPlacementByRequest,
            finalize,
            setOnError: fallbackUtils.setOnError
        };

        /* public methods for unitests */
        if (window._trcIsUTactive) {
            TRC.fallbackApi.unitestsHelpers = {
                fallbackUtils,
                getFallbackPlacement,
                build,
                clearFallbackPlacements: () => {
                    fallbackPlacements = {};
                }
            };
        }
    }());

    /**
     * feed-view-in-iframe-report.es6.js
     * This module is responsible to check feed view in iframe and sending events.
     */
    (function () {
        let isFeedViewEventBeenSent = false;

        function report() {
            try {
                if (!isFeedViewEventBeenSent && isFeedViewIframe()) {
                    TRCImpl.sendAbTestEvent('isFeedViewIframe', window.top.TRC.pageManager.getPageData());
                    isFeedViewEventBeenSent = true;
                }
            } catch (e) {
                __trcError('Error in TRC.FeedViewInIframeReport.report(): ', e);
            }
        }

        function isFeedViewIframe() {

            let isFeedViewInIframe = false,
                feedViewInstance,
                feedViewSelectors;

            try {
                if (TRC.dom.isInIframe(true)) {
                    feedViewInstance = window.top && window.top.TRC && window.top.TRC.FeedView;
                    if (feedViewInstance) {
                        feedViewSelectors = feedViewInstance.getSelectors();
                        isFeedViewInIframe = window.frames && (window.frames.name === feedViewSelectors.IFRAME_ID);
                    }
                }
                return isFeedViewInIframe;
            } catch (e) {
                __trcError('Error in TRC.FeedViewInIframeReport.isFeedViewIframe(): ', e);
            }
        }

        TRC.FeedViewInIframeReport = {
            report
        };
        /* public methods for UT */
        if (window._trcIsUTactive) {
            TRC.FeedViewInIframeReport.isFeedViewIframe = isFeedViewIframe;
        }
    }());

    (() => {
        class FeedViewWidgetLoaderManager {
            constructor(placementData) {
                FeedViewWidgetLoaderManager.loadFeedViewModuleWhenNeeded();
                placementData.feedViewConfig = true;
                TRC.hasFeedView = true;
            }

            static loadFeedViewModuleWhenNeeded() {
                const isRboxEncapsulated = TRC.util.isRboxEncapsulated(TRC);
                const isInIframe = TRC.dom.isInIframe(true);

                if (!isRboxEncapsulated && !isInIframe && !TRC.feedViewModuleLoaded) {
                    TRC.ModuleLoader.load('feed-view', TRC.FeedView, () => {
                        TRC.feedViewModuleLoaded = true;
                    });
                }
            }

            static isFeedViewWidget(trc, placementData) {
                const publisherDevices = trc.getProperty(null, 'feed-view-devices');
                const isFeedViewEnabled = trc.getProperty(null, 'feed-view-enable');
                const isEnabledDevice = device => publisherDevices === 'all' || publisherDevices === device;
                if (
                    TRC.util.isFalse(isFeedViewEnabled)
                        || TRC.util.isTrue(TRC.dom.isSmartPhone()) && TRC.util.isFalse(isEnabledDevice('smart_phone'))
                        || TRC.util.isFalse(TRC.dom.isSmartPhone()) && TRC.util.isFalse(isEnabledDevice('desktop'))
                        || TRC.util.isFalse(trc.getProperty(placementData.mode_name, 'mode-enable-feed-view'))
                        || TRC.util.isTrue(TRC.hasFeedView)
                        || trc.global['disable-feed-view-top-referrer']
                ) {
                    return false;
                }
                return true;
            }
        }

        TRC.FeedViewWidgetLoaderManager = FeedViewWidgetLoaderManager;
    })();

    /**
     * Created by alex.brown on 4/17/19
     */

    (() => {
        class AmpSplitFeedManager {
            constructor(trcManager, isFirstIframe) {
                this.trcManager = trcManager;
                this.trcCache = trcManager.trcCache;
                this.firstIframe = isFirstIframe;
                this.renderedCardsPreviously = false;
                this.feedContainerNum = TRC.feedContainerNum;
                this.shouldBreakForAMPSplitFeed = false;
                this.CACHE_KEYS = {
                    F: 'tbl_f',
                    SYNC_FI: 'tbl_syncFi',
                    SYNC_FB: 'tbl_syncFb',
                    SYNC_VIEW_ID: 'tbl_syncViewID',
                    PUB_CARD_LOCS: 'tbl_pubCardLocs',
                    NEXT_IFRAME_TO_LOAD: 'tbl_nextIframeToLoad',
                    CURRENT_AMP_FRAME_NUM: 'tbl_currentAmpFrameNum'
                };
            }

            /**
             * In a normal feed the f styling object only appears in the
             * first response from the TRC (i.e. the first batch). In AMP split feed
             * only the top iframe gets the first batch, which means subsequent iframes
             * will not receive the f object. This method manually passes the f object
             * between iframes via caching.
             */
            cacheOrAssignFeedResponseData(response) {
                if (this.firstIframe === true && this.renderedCardsPreviously === false) {
                    this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.F, response.trc.f);
                    this.renderedCardsPreviously = true;
                } else if (this.renderedCardsPreviously === false && this.firstIframe === false) {
                    response.trc.f = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.F);
                    this.renderedCardsPreviously = true;
                }
            }

            // This logic is used to correct the feed index ('fi') parameter in AMP split feed
            handleFeedIndexOffset(mode) {
                mode.fi = this.syncFi + 1;
                return mode.fi;
            }

            /**
             * This method is called in trc.js's parseResponse() when it encounters
             * a publisher card in an AMP split feed. It caches all the cards after
             * the publisher card in the cache for the subsequent iframe to render.
             */
            cacheLeftoverCards(response, feedIndex) {
                const slicedResponse = {};
                __trcCopyProps(response, slicedResponse);
                const myKey = TRC.TrcCache.extractKey(this.reqForCacheKey);

                if (this.trcCache) {
                    this.trcCache.enableCacheViaStorageFlag();
                }

                slicedResponse.trc.vl.splice(0, feedIndex + 1);
                if (this.trcCache) {
                    this.trcCache.cacheResponse(myKey, slicedResponse);
                }
            }

            /**
             * In AMP Split Feed, when the code encounters a publisher card, it stops all rendering, meaning the rest
             * of the cards in the page are not displayed. This code adds these leftover cards to the following
             * response so that they can be rendered.
             */
            handlePubCardInResponse(response, i) {
                const pubCardLocs = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.PUB_CARD_LOCS);
                const nextIframeToLoad = parseInt(TRC.pageManager.sessionStorageGetValue(this.CACHE_KEYS.NEXT_IFRAME_TO_LOAD), 10);
                if (nextIframeToLoad === parseInt(this.feedContainerNum, 10)) {
                    TRC.pageManager.sessionStorageSetValue(this.CACHE_KEYS.NEXT_IFRAME_TO_LOAD, nextIframeToLoad + 1);
                }

                const pubCardIndex = i + 1 + this.oldSyncFi;
                if ((pubCardLocs.indexOf(pubCardIndex) === -1) && this.currentAmpFrameNum <= this.feedContainerNum) {
                    pubCardLocs.push(pubCardIndex);
                }
                this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.PUB_CARD_LOCS, pubCardLocs);
                this.currentAmpFrameNum = pubCardLocs.length + 1;
                TRC.currentAmpFrameNum = this.currentAmpFrameNum;
                this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.CURRENT_AMP_FRAME_NUM, this.currentAmpFrameNum);
                TRC.keyWriting = true;
                this.cacheLeftoverCards(response, i);
                this.shouldBreakForAMPSplitFeed = true;
            }

            updateFeedIndexAndBatch(response) {
                let syncFi;
                let numStoredCards;

                this.oldSyncFi = this.syncFi;
                syncFi = Number(this.oldSyncFi) + response.trc.vl.length;

                const feeds = Object.keys(response.trc.f);
                const firstFeed = feeds[0];
                this.syncFb = parseInt(response.trc.f[firstFeed].nb, 10);

                if (response.cached === true) {
                    numStoredCards = response.trc.vl.length;
                    syncFi -= numStoredCards;
                }

                this.syncFi = syncFi;
                this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.SYNC_FI, syncFi);
                this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.SYNC_FB, this.syncFb);
            }

            copyReqToReqForCacheKey(req) {
                this.reqForCacheKey = {};
                __trcCopyProps(req, this.reqForCacheKey);
            }

            /**
             * This method returns the card's placement id
             * @param {object} card
             * @returns {string}
             */
            static getPlacementId(card) {
                if (!card || !card.placement) return '';
                return card.placement.split('|').pop().trim();
            }

            /**
             * This method ensures a card being rendered
             * is not a duplicate. It's called in each iteration of
             * the for loop in trc.js's parseResponse().
             */
            detectDuplicateCards(card) {
                const placementId = AmpSplitFeedManager.getPlacementId(card);
                if (this.ampSplitFeedCache.getCacheData(placementId) !== null) {
                    __trcError('Duplicate Card Index In AMP Split Feed');
                } else {
                    this.ampSplitFeedCache.cacheData(placementId, true);
                }
            }

            /**
             * This method ensures a card has not been skipped. It's called
             * in each iteration of the for loop in trc.js's parseResponse().
             */
            detectSkippedCard(card) {
                const curPlacementId = AmpSplitFeedManager.getPlacementId(card);
                // the last placement id should be identical to the current placement Id, only with a different number.
                const curPlacementIdParts = curPlacementId.split(' ');
                const curPlacementType = curPlacementIdParts[0];
                const curPlacementNumber = curPlacementIdParts[1];

                if (isNaN(curPlacementNumber)) {
                    __trcError('Card name doesn\'t contain numeric index In AMP Split Feed');
                    return;
                }

                const lastPlacementId = `${curPlacementType} ${parseInt(curPlacementNumber, 10) - 1}`;
                // if the last placements id is not in the cache, the last placement was skipped.
                if (curPlacementNumber > 1 && this.ampSplitFeedCache.getCacheData(lastPlacementId) === null) {
                    __trcError('Card(s) Skipped In AMP Split Feed');
                }
            }


            // init parameters for split feed iframes
            initParametersForSplitFeedFrames() {
                const syncFi = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.SYNC_FI);
                const syncFb = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.SYNC_FB);
                this.syncFi = syncFi === null ? null : parseInt(syncFi, 10);
                this.syncFb = syncFb === null ? null : parseInt(syncFb, 10);

                const syncViewID = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.SYNC_VIEW_ID);
                if (syncViewID === null) {
                    this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.SYNC_VIEW_ID, TRC.pageManager.getPageData());
                } else {
                    TRC.syncViewID = syncViewID;
                }

                let pubCardLocs = this.ampSplitFeedCache.getCacheData(this.CACHE_KEYS.PUB_CARD_LOCS);
                if (!pubCardLocs) {
                    pubCardLocs = [];
                    this.ampSplitFeedCache.cacheData(this.CACHE_KEYS.PUB_CARD_LOCS, pubCardLocs);
                }

                this.currentAmpFrameNum = pubCardLocs.length + 1;
            }

            checkAMPSplitFeedFlagsAndInit(request, cb) {
                this.nextIframeToLoad = TRC.pageManager.sessionStorageGetValue(this.CACHE_KEYS.NEXT_IFRAME_TO_LOAD);
                this.sentIframeLoadFailed = false;
                this.attemptCounter = 0;
                this.MAX_ATTEMPTS = 20;

                if (!this.nextIframeToLoad && this.firstIframe) {
                    this.nextIframeToLoad = '1';
                    TRC.pageManager.sessionStorageSetValue(this.CACHE_KEYS.NEXT_IFRAME_TO_LOAD, this.nextIframeToLoad);
                }

                if (this.nextIframeToLoad !== this.feedContainerNum) {
                    this.timeoutID = setTimeout(this.delayInit.trcBind(this, request, cb), 300);
                } else {
                    this.didInit = true;
                    cb(request);
                }
            }

            static sendIframeLoadFailed(i) {
                TRC.pConsole('errors', 'error', 'AMP split feed iframe', i, 'blocked from out of order loading');
            }

            delayInit(request, cb) {
                try {
                    this.attemptCounter++;
                    if (!this.sentIframeLoadFailed && this.attemptCounter >= this.MAX_ATTEMPTS) {
                        AmpSplitFeedManager.sendIframeLoadFailed(TRC.feedContainerNum);
                        this.sentIframeLoadFailed = true;
                    }
                    this.nextIframeToLoad = TRC.pageManager.sessionStorageGetValue(this.CACHE_KEYS.NEXT_IFRAME_TO_LOAD);
                    if (this.nextIframeToLoad === TRC.feedContainerNum) {
                        this.didInit = true;
                        clearTimeout(this.timeoutID);

                        cb(request);
                    } else {
                        this.timeoutID = setTimeout(this.delayInit.trcBind(this, request, cb), 300);
                    }
                } catch (e) { __trcError('AMP split feed - error in delaying iframe init', e); }
            }

            /**
             * This method is called when it is an iframe's turn to load in an AMP split feed.
             * The caches we use must be created after the previous iframe has finished storing data, immediately
             * before the current iframe begins to send requests. This is why we call trcCache.reloadCache() and
             * create a KeyValueCache here.
             */
            initAmpSplitFeedIframe(request) {
                if (this.trcManager.trcCache) {
                    this.trcManager.trcCache.reloadCache();
                }
                this.ampSplitFeedCache = new TRC.KeyValueCache({cacheName: 'trc_amp_split_feed_cache', noTtl: true});
                this.initParametersForSplitFeedFrames();
                this.trcManager.dispatchRequestWrapper(request);
            }

            /**
             * This static method is used to get the appropriate constructor for the AmpSplitFeedManager.
             * If there is no session storage, it returns a specific manager that can handle this scenario.
             * @param shouldEnableAmpSplitFeedFix
             * @returns {*|AmpSplitFeedManager|AmpSplitFeedManagerNoStorage}
             */
            static getAmpSplitFeedManager(shouldEnableAmpSplitFeedFix) {
                const useSessionStorage = TRC.pageManager.sessionStorageIsSupported();
                if (TRC.util.isTrue(shouldEnableAmpSplitFeedFix) && !useSessionStorage) {
                    return TRC.AmpSplitFeedManagerNoStorage;
                }
                return TRC.AmpSplitFeedManager;
            }
        }

        /**
         * When sessionStorage is not valid, we only show the first container
         * A request is not sent for the other frames, and the cards that should appear bellow the publisher card are not displayed.
         * The height of the other amp containers is set to 0
         */
        class AmpSplitFeedManagerNoStorage extends AmpSplitFeedManager {
            constructor(trcManager, isFirstIframe) {
                super(trcManager, isFirstIframe);
                this.cache = {};
                if (!isFirstIframe) {
                    AmpSplitFeedManagerNoStorage.hideContainer();
                }
            }

            static hideContainer() {
                window.context && window.context
                    .requestResize(1, 1)
                    .catch(() => {
                        __trcWarn('AmpSplitFeedManagerNoStorage: resize request rejected');
                    });
            }

            checkAMPSplitFeedFlagsAndInit(request, callback) {
                this.didInit = true;
                if (this.firstIframe) {
                    return callback(request);
                }
            }

            initAmpSplitFeedIframe(request) {
                this.ampSplitFeedCache = {
                    cacheData: (key, val) => {
                        this.cache[key] = val;
                    },
                    getCacheData: key => (this.cache[key] === undefined ? null : this.cache[key])
                };
                this.initParametersForSplitFeedFrames();
                this.trcManager.dispatchRequestWrapper(request);
            }

            handlePubCardInResponse() {
                this.shouldBreakForAMPSplitFeed = true;
            }
        }

        TRC.AmpSplitFeedManager = AmpSplitFeedManager;
        TRC.AmpSplitFeedManagerNoStorage = AmpSplitFeedManagerNoStorage;

    })();

    (() => {
        const AVAILABLE_EVENT_NAME = 'card-available',
            VISIBLE_EVENT_NAME = 'card-visible',
            INTERACTION_EVENT_NAME = 'card-interaction',
            CARD_INTERACTION_EVENTS_TYPE = ['click'];

        class CardEventsManager {
            constructor(trcManager, options, cardPlacementData, elementContainer) {
                const {feedDynamicParameters} = options;

                this.trcManager = trcManager;
                this.cardPlacementData = cardPlacementData;
                this.exactVisibleDistanceThresholdFromTop = (feedDynamicParameters && feedDynamicParameters.exactVisibleDistanceThresholdFromTop) || this.trcManager.global['exact-visible-distance-threshold-from-top'] || 200;

                this.listenToCardInteractionEvents(elementContainer);
            }

            sendEvent(event, params) {
                TRC.TrcEventsLogger.sendPlacementEvent(this.trcManager, this.cardPlacementData, event, params);
            }

            handleRenderedCard(elementContainer) {
                elementContainer.style.position = 'relative'; // support parent element without height

                this.sendEvent(AVAILABLE_EVENT_NAME);
                this.observeCardVisibility(elementContainer);
            }

            listenToCardInteractionEvents(elementContainer) {
                CARD_INTERACTION_EVENTS_TYPE.forEach(eventType => {
                    TRC.dom.on(elementContainer, eventType, this.sendCardInteractionEvent.trcBind(this, eventType));

                    // workaround for supporting iframe clicks
                    if (eventType === 'click' && elementContainer.querySelector('iframe')) {
                        TRC.dom.on(window, 'blur', this.checkIfCardIFrameClickedAndLog.trcBind(this, elementContainer));
                    }
                });
            }

            checkIfCardIFrameClickedAndLog(elementContainer) {
                const {activeElement} = document;

                if (activeElement && activeElement.tagName.toLowerCase() === 'iframe'
                    && (activeElement === elementContainer || elementContainer.contains(activeElement))) {
                    this.sendCardInteractionEvent('click');
                }
            }

            sendCardInteractionEvent(eventType) {
                const cardData = {id: Date.now(), type: eventType},
                    params = {
                        d: JSON.stringify(cardData)
                    };

                this.sendEvent(INTERACTION_EVENT_NAME, params); // send for every card interaction
            }

            observeCardVisibility(elementContainer) {
                const observerParams = {
                    targetElement: elementContainer,
                    enableDelayedVisibilityCheck: true,
                    exactVisibleThresholdFromTop: this.exactVisibleDistanceThresholdFromTop,
                    onTrigger: this.sendEvent.trcBind(this, VISIBLE_EVENT_NAME, null)
                };

                TRC.intersections.isInViewPort(observerParams);
            }
        }

        TRC.CardEventsManager = CardEventsManager;

    })();

    (() => {
        const FEED_CONTAINER_CSS_CLASS = 'tbl-feed-container',
            FEED_CARD_CSS_CLASS = 'tbl-feed-card',
            FEED_FULL_WIDTH_CSS_CLASS = 'tbl-feed-full-width',
            FEED_PARTIAL_WIDTH_CSS_CLASS = 'tbl-feed-partial-width',
            FEED_ABP_CSS_CLASS = 'tbl-feed-abp',
            FEED_CONTAINER_NUM_ATT = 'data-feed-container-num',
            FEED_MAIN_CONTAINER_ID_ATT = 'data-feed-main-container-id',
            FEED_PARENT_CONTAINER_PLACEMENT_ATT = 'data-parent-placement-name',
            PUBLISHER_LANGUAGE_ATT = 'data-pub-lang',
            MOBILE_LAYOUTS = {
                FULL_WIDTH: 'FULL_WIDTH',
                PARTIAL_WIDTH: 'PARTIAL_WIDTH'
            };

        class Feed {
            constructor(trcManager, parentPlacementData, options) {
                const infiniteScrollOptions = __trcCopyProps(options, {});

                this.trcManager = trcManager;
                this.container = parentPlacementData.container;
                this.origContainer = this.container;
                this.mainContainerId = this.container.id;
                this.mainContainerPlacement = parentPlacementData.placement;
                this.numContainers = 1;
                this.testData = trcManager.testData;
                this.experimentsData = trcManager.experimentsData;
                this.experimentsHash = trcManager.experimentsHash;
                this.options = options;
                this.numPendingPublisherCards = 0;
                this.layout = options.mobileLayout || (options.feedUi && options.feedUi.layout);
                this.shouldDisableScopeCss = this.trcManager.global['disable-scope-feed-css'];
                this.firstCardRequestId = parentPlacementData.firstCardRequestId;
                this.unifiedPlacement = parentPlacementData.unifiedPlacement;
                this.feedInViewPort = false;

                if (options.wasWidget) {
                    this.widgetToFeedHelper = new TRC.WidgetToFeedHelper(this, trcManager, options.hasFeedUI);
                }

                if (options.videoSingleManager) {
                    this.loadVideoSingleManager(parentPlacementData, trcManager, options);
                }

                if (options.hasFeedUI !== false) {
                    TRC.dom.injectStyle(this.createCss(options), null);
                }

                infiniteScrollOptions.afterPlacementContainerCreated = Feed.addFeedCardAttributes.trcBind(this);
                infiniteScrollOptions.itemsParentContainerSelector = `[${FEED_MAIN_CONTAINER_ID_ATT}="${this.mainContainerId}"]`;

                this.infiniteScrollEngine = new TRC.InfiniteScrollEngine(trcManager, parentPlacementData, infiniteScrollOptions);
                this.publisherCardsManager = new TRC.PublisherCardsManager(this, trcManager, parentPlacementData, options);

                const footerOverlayConfig = Feed.getFeedConfig(options, 'footerOverlayConfig', 'footerOverlay');
                if (footerOverlayConfig) {
                    TRC.ModuleLoader.load('feed-footer-overlay', TRC.FooterOverlay, () => {
                        this.footerOverlay = new TRC.FooterOverlay(trcManager, footerOverlayConfig);
                    });
                }

                if (TRC.isAMPSplitFeed) {
                    this.numContainers = this.trcManager.ampSplitFeedManager.feedContainerNum;
                }

                this.setMainContainerCssClassesAndAttributes(this.container, options);
                this.listenToCardContentReady();
                this.header = this.createHeader(options.feedUi);
                if (TRC.Heatmap.isEnabled(this.trcManager)) {
                    this.heatmap = new TRC.Heatmap(trcManager);
                    TRC.dom.on(this.container, 'click', event => {
                        this.heatmap.captureAndSendClickData(event);
                    });
                }
                this.observeFeed();
            }

            handlePlacement(placementData) {
                const isLegacySplit = placementData.trcResponse && placementData.trcResponse.spl,
                    publisherCardInstruction = placementData.trcResponse && placementData.trcResponse.pcp,
                    publisherCardNum = (placementData.trcResponse && placementData.trcResponse.scac) ? null : this.infiniteScrollEngine.numPlacements;

                if (isLegacySplit) {
                    this.infiniteScrollEngine.handlePlacement(placementData);
                    this.publisherCardsManager.registerPublisherCardForHandling(placementData);
                    this.publisherCardsManager.handlePendingPublisherCards(0, publisherCardNum, null, isLegacySplit);
                    return;
                }

                if (TRC.isAMPSplitFeed) {
                    this.trcManager.ampSplitFeedManager.detectDuplicateCards(placementData);
                    this.trcManager.ampSplitFeedManager.detectSkippedCard(placementData);
                }

                if (publisherCardInstruction) {
                    if (TRC.isAMPSplitFeed) {
                        this.stopScrolling();
                        return;
                    }

                    this.publisherCardsManager.registerPublisherCardForHandling(placementData);
                    this.infiniteScrollEngine.numPlacements++;
                    this.numPendingPublisherCards++;
                    return;
                }

                if (this.numPendingPublisherCards > 0) {
                    this.publisherCardsManager.handlePendingPublisherCards(0, publisherCardNum, null, isLegacySplit);
                    this.numPendingPublisherCards = 0;
                }

                this.infiniteScrollEngine.handlePlacement(placementData);

                this.trcManager['after-card-created'](placementData, publisherCardNum, this);
                TRC.CustomModulesManager.runHook('after-card-created', this.mainContainerPlacement, this, placementData, publisherCardNum, this);
            }

            stopScrolling() {
                this.infiniteScrollEngine.stopScrolling();
            }

            setIsAllowedToRequestMoreContent(isAllowedToRequestMoreContent) {
                this.infiniteScrollEngine.setIsAllowedToRequestMoreContent(isAllowedToRequestMoreContent);
            }

            updateNextBatchNumber(nextBatchNumber) {
                this.infiniteScrollEngine.updateNextBatchNumber(nextBatchNumber);
            }

            setMainContainerCssClassesAndAttributes(container, options) {
                const cssClasses = [FEED_CONTAINER_CSS_CLASS];

                switch (this.layout) {
                    case MOBILE_LAYOUTS.FULL_WIDTH:
                        cssClasses.push(FEED_FULL_WIDTH_CSS_CLASS);
                        break;
                    case MOBILE_LAYOUTS.PARTIAL_WIDTH:
                        cssClasses.push(FEED_PARTIAL_WIDTH_CSS_CLASS);
                        break;
                    default:
                        break;
                }

                if (options.feedUi && options.feedUi.cardFrame) {
                    cssClasses.push(`tbl-feed-frame-${options.feedUi.cardFrame}`);
                }

                if (TRC.blocker.blockedState > 0) {
                    cssClasses.push(FEED_ABP_CSS_CLASS);
                }

                TRC.dom.addClass(this.container, cssClasses.join(' '));

                if (this.numContainers > 1) {
                    this.container.id = `${this.mainContainerId}-split-num-${this.numContainers - 1}`;
                }
                container.setAttribute(FEED_CONTAINER_NUM_ATT, this.numContainers);
                container.setAttribute(FEED_MAIN_CONTAINER_ID_ATT, this.mainContainerId);
                container.setAttribute(FEED_PARENT_CONTAINER_PLACEMENT_ATT, this.mainContainerPlacement);

                if (this.trcManager.language) {
                    container.setAttribute(PUBLISHER_LANGUAGE_ATT, this.trcManager.language);
                }
            }

            createHeader(feedUi) {
                if (TRC.isAMPSplitFeed && this.trcManager.ampSplitFeedManager && Number(this.trcManager.ampSplitFeedManager.feedContainerNum) !== 1) {
                    return;
                }

                const headerContainer = document.createElement('div'),
                    headerImage = document.createElement('div'),
                    shouldCreateFeedHeaderTitle = !!(feedUi && feedUi.feedHeaderData),
                    logoPosition = feedUi && feedUi.logoPosition && feedUi.logoPosition !== 'NONE' ? feedUi.logoPosition : null,
                    logoPositionClassName = logoPosition ? `tbl-logo-${logoPosition.toLowerCase()}-position` : '';

                headerImage.className = 'tbl-feed-header-logo';
                headerContainer.className = ` tbl-feed-header ${logoPositionClassName}`;

                headerContainer.appendChild(headerImage);

                TRC.ccpa.renderOnHeaderFeed(headerContainer, this.unifiedPlacement, logoPosition);

                if (shouldCreateFeedHeaderTitle) {
                    const headerText = Feed.createFeedHeaderTextElement(feedUi.feedHeaderData.headerText);
                    headerContainer.className += ' tbl-header-with-text';
                    headerContainer.appendChild(headerText);
                }

                this.container.insertBefore(headerContainer, this.container.firstChild);

                return headerContainer;
            }

            static createFeedHeaderTextElement(headerText) {
                const headerTextElm = document.createElement('div');
                headerTextElm.className = 'tbl-feed-header-text';
                headerTextElm.innerText = headerText;

                return headerTextElm;
            }

            static addFeedCardAttributes(cardContainer, cardPlacementData) {
                cardContainer.setAttribute('tbl-feed-card', '');

                if (cardPlacementData.isStandaloneVideo) {
                    Feed.setFeedVideoCardAttribute(cardContainer);
                }

                Feed.setFeedCardVideoIndication(cardContainer, cardPlacementData);
            }

            static setFeedCardVideoIndication(cardContainer, cardPlacementData) {
                if (cardPlacementData.trcResponse.nvb) {
                    cardContainer.setAttribute('no-vbelow', '');
                }

                if (cardPlacementData.trcResponse.nva) {
                    cardContainer.setAttribute('no-vabove', '');
                }
            }

            static setFeedVideoCardAttribute(cardContainer) {
                cardContainer.setAttribute('tbl-feed-video', '');
            }

            listenToCardContentReady() {
                TRC.listen('trcContentReady', this.onTrcContentReady.trcBind(this));
            }

            onTrcContentReady(e) {
                const {container} = e;
                if (container && container.placementData) {
                    const {placementData: cardPlacementData} = container;

                    if (!cardPlacementData.isFeedCard) {
                        return;
                    }

                    this.onCardContentReady(container, cardPlacementData);
                }
            }

            onCardContentReady(container, cardPlacementData) {
                const {style: containerStyle, id} = container;
                const {trcResponse, expandOptions} = cardPlacementData;

                TRC.dom.addClass(container, FEED_CARD_CSS_CLASS);

                if (trcResponse.cpad) {
                    containerStyle.padding = trcResponse.cpad;
                }

                if (expandOptions) {
                    container.expandableBox = new TRC.ExpandableBox(this.trcManager, id, expandOptions);
                    this.listenToBoxChildIFrameClick();
                }
            }


            listenToBoxChildIFrameClick() {
                if (!this.expandableBoxIFrameClickListener) {
                    this.expandableBoxIFrameClickListener = true;

                    TRC.dom.on(window, 'blur', () => {
                        const {activeElement} = document;

                        if (activeElement && TRC.dom.elementMatchesSelector(activeElement, `[${FEED_MAIN_CONTAINER_ID_ATT}="${this.mainContainerId}"] .${FEED_CARD_CSS_CLASS} iframe`)) {
                            TRC.dispatch('expandableBoxChildIFrameClick', {container: TRC.dom.closest(activeElement, ` .${FEED_CARD_CSS_CLASS}`)});
                        }
                    });
                }
            }

            createCss(options) {
                const css = [];

                if (options.feedCss) {
                    css.push(options.feedCss.replace(/{FEED_MAIN_CONTAINER_ID_ATT}/g, `[${FEED_MAIN_CONTAINER_ID_ATT}="${this.mainContainerId}"]`));
                } else {
                    css.push(Feed.getDefaultFeedCSS());
                }

                if (this.isFullWidthMobileFeed(options)) {
                    css.push(this.getMobileFullWidthMarginsCss());
                }

                if (options.feedUi) {
                    css.push(Feed.getFeedUiCss(options.feedUi, this.mainContainerId));
                }


                if (options.publisherFeedCss) {
                    css.push(options.publisherFeedCss);
                }

                css.push(options.feedCssOverride);

                let feedCss = css.join('');

                if (!this.shouldDisableScopeCss) {
                    feedCss = Feed.scopeCss(feedCss, this.mainContainerId);
                }

                return feedCss;
            }

            static scopeCss(css, mainContainerId) {
                return css.replace(new RegExp(`.${FEED_CONTAINER_CSS_CLASS}`, 'g'), `[${FEED_MAIN_CONTAINER_ID_ATT}="${mainContainerId}"]`);
            }

            getTestData() {
                return this.testData;
            }

            getExperimentsData() {
                return this.experimentsData;
            }

            getExperimentsHash() {
                return this.experimentsHash;
            }

            static getFeedUiCss(feedUi, mainContainerId) {
                const css = [],
                    backgroundColor = feedUi.feedBackgroundColor || feedUi.feedBackground,
                    feedIdSelector = `[${FEED_MAIN_CONTAINER_ID_ATT}="${mainContainerId}"]`;

                css.push(`${feedIdSelector}[${FEED_CONTAINER_NUM_ATT}] {background-color: ${backgroundColor}; padding: ${feedUi.feedPadding};}`);

                if (feedUi.logoPosition === 'NONE') {
                    css.push(`${feedIdSelector} .tbl-feed-header .tbl-feed-header-logo {display:none;}`);
                } else {
                    css.push(`${feedIdSelector} .tbl-feed-header {padding: 0px 5px 10px 5px; background: transparent; text-align: initial; display: table; width: 100%;}`);
                }

                if (feedUi.feedHeaderData) {
                    const {
                        headerFontSize = '20px', headerFontFamily = 'Arial, Helvetica, sans-serif', headerColor = '#000000', headerFontStyle = 'normal'
                    } = feedUi.feedHeaderData;
                    css.push(`${feedIdSelector} .tbl-feed-header .tbl-feed-header-text {font-size: ${headerFontSize}; color: ${headerColor}; line-height: ${headerFontSize}; font-family: ${headerFontFamily}; font-weight: ${headerFontStyle}}`);
                }

                return css.join('');
            }

            getMobileFullWidthMarginsCss(feedContainerNum) {
                const feedCurrentContainer = feedContainerNum ? this.container.parentNode : this.container,
                    feedContainerClientRect = feedCurrentContainer.getBoundingClientRect(),
                    leftMargin = feedContainerClientRect.left * -1,
                    rightMargin = (document.documentElement.clientWidth - feedContainerClientRect.width - Math.abs(leftMargin)) * -1;

                let feedContainerSelector = `#${this.container.id}.${FEED_CONTAINER_CSS_CLASS}.${FEED_FULL_WIDTH_CSS_CLASS}`;

                if ((!leftMargin && !rightMargin) || !feedCurrentContainer.offsetParent) {
                    return '';
                }

                if (feedContainerNum) {
                    feedContainerSelector += `[${FEED_CONTAINER_NUM_ATT}="${feedContainerNum}"]`;
                }

                return `@media screen and (max-width: 480px) {
                        ${feedContainerSelector} {
                            margin-left: ${leftMargin}px;
                            margin-right: ${rightMargin}px;
                        }
                    }`;
            }

            static getDefaultFeedCSS() {
                return `.${FEED_CONTAINER_CSS_CLASS} { position: relative; margin-top: 20px; margin-bottom: 20px; -webkit-text-size-adjust: 100%; clear: both; } .${FEED_CONTAINER_CSS_CLASS} .tbl-feed-header { padding: 5px; background-color: #ffffff; display: inline-block; } .${FEED_CONTAINER_CSS_CLASS} .tbl-feed-header-logo { background: url(//cdn.taboola.com/static/f8/f89e1763-220d-4e09-ba69-9e040548fb7a.svg) no-repeat 0 0; background-size: contain; height: 11px; width: 76px; display: inline-block; } .${FEED_CONTAINER_CSS_CLASS} .tbl-loading-spinner { margin-bottom: 10px; } .${FEED_CONTAINER_CSS_CLASS} .${FEED_CARD_CSS_CLASS} { margin-bottom: 10px; background-color: #ffffff; border: 1px solid #f1f1f1; } .${FEED_CONTAINER_CSS_CLASS} .${FEED_ABP_CSS_CLASS} { max-width: 770px; margin: 20px auto 0; }/** Mobile CSS Rules **/@media screen and (max-width: 480px) { .${FEED_CONTAINER_CSS_CLASS} { padding: 0; background-color: #ffffff; } .${FEED_CONTAINER_CSS_CLASS} .tbl-feed-header { margin-left: 2px; padding: 5px 0; } .${FEED_CONTAINER_CSS_CLASS} .${FEED_CARD_CSS_CLASS} { margin-bottom: 5px; padding-bottom: 5px; border-width: 0; border-bottom: 4px solid #f1f1f1; } .${FEED_CONTAINER_CSS_CLASS} .trc_header_ext, .${FEED_CONTAINER_CSS_CLASS} .trc-widget-footer { padding-right: 3px; } }/** End of Mobile CSS Rules **/`;
            }

            getVideoManagerRequestData() {
                return {
                    'session-data': TRC.pageManager.getPublisherValue(TRC.publisherId, 'session-data'),
                    req: this.firstCardRequestId
                };
            }

            loadVideoSingleManager(placement, trcManager, options) {
                const vsmPlacementData = __trcCopyProps(placement, {}, null),
                    vsmOptions = __trcCopyProps(options.videoSingleManager, {});

                vsmOptions.parentFeedOptions = options;

                this.videoManager = new TRC.VideoTagLoader(trcManager, vsmOptions, vsmPlacementData, null, this.getVideoManagerRequestData());
                this.videoManager.loadVideo();
            }

            switchMainContainer(newFeedContainer) {
                this.container = newFeedContainer;
                this.infiniteScrollEngine.switchMainContainer(this.container);
            }

            isFullWidthMobileFeed(options) {
                const layout = options.mobileLayout || this.layout;
                return layout === MOBILE_LAYOUTS.FULL_WIDTH;
            }

            getIsFirstBatch() {
                return this.infiniteScrollEngine.getIsFirstBatch();
            }

            static getFeedConfig(options, parameterName, optionName) {
                if (options) {
                    const config = this.getFeedDynamicParameter(options.feedDynamicParameters, parameterName);
                    if (!config) {
                        return options[optionName];
                    }
                    return config;
                }
                return null;
            }

            static getFeedDynamicParameter(feedDynamicParameters, parameterName) {
                if (feedDynamicParameters) {
                    const dynamicParam = feedDynamicParameters[parameterName];
                    if (dynamicParam) {
                        return JSON.parse(dynamicParam);
                    }
                }
                return null;
            }

            observeFeed() {
                TRC.intersections.observe({
                    targetElement: this.container,
                    onEnter: this.onFeedEnterViewport.trcBind(this),
                    onExit: this.onFeedExitViewport.trcBind(this),
                    rootMargin: '0px'
                });
            }

            onFeedEnterViewport() {
                this.feedInViewPort = true;
                TRC.dispatch('feed-present-in-viewport', true);
            }

            onFeedExitViewport() {
                this.feedInViewPort = false;
                TRC.dispatch('feed-present-in-viewport', false);
            }
        }

        TRC.Feed = Feed;

    })();

    (() => {
        class FeedsManager {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.feeds = {};
                this.invalidFeedsMap = {};
                this.configs = {};
            }

            handleFeedCardPlacement(currentPlacementResponseData, currentPlacementData) {
                currentPlacementData.isFeedCard = true;
                FeedsManager.setScaArray(currentPlacementData, currentPlacementResponseData);
                const currentFeed = this.getOrCreateFeed(currentPlacementResponseData),
                    currentFeedOptions = currentFeed && currentFeed.options,
                    feedViewDynamicParameter = currentFeedOptions && (TRC.Feed.getFeedDynamicParameter(currentFeedOptions.feedDynamicParameters, 'feedViewConfig')),
                    feedViewCurrentOptions = currentFeedOptions && currentFeedOptions.feedView,
                    feedViewConfig = currentFeedOptions && (feedViewDynamicParameter || feedViewCurrentOptions),
                    enableFeedView = feedViewDynamicParameter
                                && TRC.util.isFalse(feedViewDynamicParameter.isFeedView) ? feedViewDynamicParameter.isFeedView : feedViewConfig;

                if (!currentFeed) {
                    return;
                }
                if (enableFeedView) {
                    if (!TRC.hasFeedView && !this.trcManager.global['disable-feed-view-top-referrer']) { // support changing referrer to not getting it from top window
                        TRC.hasFeedView = true;
                    }
                    TRC.FeedViewWidgetLoaderManager.loadFeedViewModuleWhenNeeded();

                    if (feedViewConfig) {
                        if (feedViewConfig.enableAEClicks) {
                            currentFeed.enableAEClicks = true;
                        }
                    }
                    currentPlacementData.feedViewConfig = feedViewConfig;
                }

                currentPlacementData.parentFeed = currentFeed;
                currentPlacementData.parentFeed.handlePlacement(currentPlacementData);
            }

            getOrCreateFeed(cardPlacementResponseData) {
                const feedParentPlacement = cardPlacementResponseData.fpl,
                    feedConfig = this.getFeedConfig(feedParentPlacement),
                    relatedFeedInstance = this.feeds[feedParentPlacement]
                        || this.createNewFeed(feedConfig, feedParentPlacement, cardPlacementResponseData);
                // send "f" response to server
                window.__trcInfo(JSON.stringify({
                    name: feedParentPlacement,
                    nb: feedConfig.nb || '',
                    eof: feedConfig.eof || '',
                    fti: feedConfig.fti || '',
                    vsm: !!feedConfig.vsm
                }));

                if (!(relatedFeedInstance instanceof TRC.Feed)) return;

                if (feedConfig.eof) {
                    relatedFeedInstance.stopScrolling();
                }

                if (feedConfig.nb) {
                    relatedFeedInstance.updateNextBatchNumber(feedConfig.nb);
                }

                return relatedFeedInstance;
            }

            createNewFeed(feedConfig, feedParentPlacement, cardPlacementResponseData) {
                const {
                    uuip: feedUnifiedPlacement, ri: feedFirstCardRequestId, sca
                } = cardPlacementResponseData;
                const {fcs: containerSelectors, rooc: shouldCreateContainer, exm: shouldEnableExploreMore} = feedConfig;
                const feedOptions = FeedsManager.parseFeedOptionsFromResponse(feedConfig);

                if (shouldEnableExploreMore) {
                    TRC.util.sendSupplyFeature('EXPLORE_MORE', 'ADOPTED');
                    this.trcManager.enableExploreMore(feedConfig, feedParentPlacement);
                }

                TRC.VirtualPlacementsManager.handleVirtualPlacement(this.trcManager, feedParentPlacement);

                const feedPlacementData = this.trcManager.preloadRequest[feedParentPlacement];
                if (!feedPlacementData) {
                    // the response contains placements that are not in the request, probably from cache
                    __trcDebug(`'createNewFeed' : placement '${feedParentPlacement}' was not in the request - ignore`);
                    return;
                }
                feedPlacementData.isFeed = true;

                if (containerSelectors) { // Move Feed Action
                    feedPlacementData.container = this.getNewFeedContainer(
                        feedPlacementData.container, feedParentPlacement,
                        containerSelectors, shouldCreateContainer
                    );

                    if (!feedPlacementData.container) {
                        return;
                    }
                }

                feedPlacementData.fti = feedConfig.fti;
                feedPlacementData.unifiedPlacement = feedUnifiedPlacement;
                feedPlacementData.firstCardRequestId = feedFirstCardRequestId;
                feedPlacementData.sca = sca;

                return this.feeds[feedParentPlacement] = new TRC.Feed(this.trcManager, feedPlacementData, feedOptions);
            }

            getNewFeedContainer(feedOrigContainer, feedPlacement, containerSelectors, shouldCreateContainer) {
                const moveFeedWarnMsg = 'feed',
                    moveFeedContainerSelector = {
                        container: feedOrigContainer,
                        'container-selectors': containerSelectors,
                        'render-on-orig-container': shouldCreateContainer
                    };

                const newFeedContainer = this.trcManager.getWidgetContainer(moveFeedContainerSelector, moveFeedWarnMsg);

                if (!newFeedContainer) {
                    this.invalidFeedsMap[feedPlacement] = true;
                    return;
                }

                return newFeedContainer;
            }

            getFeedConfig(feedPlacement) {
                if (this.configs && this.configs[feedPlacement]) {
                    return this.configs[feedPlacement];
                }
                return {};
            }

            hasFeedConflict(placement, feedPlacement) {
                return this.feeds[placement] || this.hasFeedTestDataMismatch(feedPlacement);
            }


            hasFeedTestDataMismatch(feedPlacement) {
                const feedInstance = this.feeds[feedPlacement];

                if (!feedInstance) {
                    return false;
                }
                // By test data:
                if (feedInstance.getTestData() !== this.trcManager.testData) {
                    return true;
                }
                // By experiments hash ('evh')
                // null and undefined are considered the same
                const feedHash = feedInstance.getExperimentsHash();
                const managerHash = this.trcManager.experimentsHash;
                return (feedHash && !managerHash) || (!feedHash && managerHash) || (feedHash && managerHash && feedHash !== managerHash);
            }

            static setScaArray(currentPlacementData, currentPlacementResponseData) {
                if (currentPlacementData && currentPlacementData.globalTrcResponseJSON && currentPlacementData.globalTrcResponseJSON.sca) {
                    currentPlacementResponseData.sca = currentPlacementData.globalTrcResponseJSON.sca;
                }
            }

            static isExperimentDataEqual(experimentsData1, experimentsData2) {
                const data1 = JSON.stringify(experimentsData1);
                const data2 = JSON.stringify(experimentsData2);
                return data1 === data2;
            }

            static parseFeedOptionsFromResponse(feedConfig) {
                return {
                    nextBatchDistanceThreshold: feedConfig.nbdt,
                    feedCss: feedConfig.css,
                    feedCssOverride: feedConfig.fcss,
                    publisherFeedCss: feedConfig.pfcss,
                    mobileLayout: feedConfig.fml,
                    videoSingleManager: feedConfig.vsm,
                    feedUi: feedConfig.fui,
                    feedNextUp: feedConfig.fnu,
                    exploreMore: feedConfig.exm,
                    footerOverlay: feedConfig.fov,
                    feedDynamicParameters: feedConfig.drp,
                    videoDisclosurePosition: feedConfig.vdp,
                    uiDesignVersion: feedConfig.udv,
                    wasWidget: TRC.util.isTrue(feedConfig.ww),
                    firstBatchLazyLoadingEnabled: TRC.util.isTrue(feedConfig.fbll),
                    hasFeedUI: typeof feedConfig.hfu === 'undefined' || TRC.util.isTrue(feedConfig.hfu),
                    hasPreventReachingFooter: TRC.util.isTrue(feedConfig.prf),
                    preventReachingFooterData: feedConfig.prfd,
                    feedView: TRC.util.isTrue(feedConfig.fv)
                };
            }

            static createFeedScriptWidgetData(placement, recommendation) {
                return {
                    placement,
                    scriptData: recommendation,
                    addWidget: true
                };
            }

            static createFeedIframe(placement, recommendation) {
                return {
                    placement,
                    iframeData: recommendation,
                    addWidget: true,
                    isIframeCard: true,
                    mode: recommendation.m,
                    mode_name: recommendation.m
                };
            }

            static createPublisherCardData(placement, recommendation) {
                return {
                    placement,
                    addWidget: true,
                    publisherCardData: recommendation.pcp
                };
            }

            static createExternalWidgetData(placement, recommendation) {
                return {
                    placement,
                    externalContainerSelector: recommendation.es
                };
            }

            static isExternalContainerWidget(recommendation) {
                return typeof recommendation.es !== 'undefined' && recommendation.es !== null;
            }

            static isFeedScriptWidget(recommendation) {
                return recommendation.fpl && recommendation.js;
            }

            static isFeedIframe(recommendation) {
                return recommendation.fpl && recommendation.ifr;
            }

            static isPublisherCard(recommendation) {
                return recommendation.fpl && recommendation.pcp;
            }
        }

        TRC.FeedsManager = FeedsManager;
    })();

    (() => {
     
        const isMobileSDKEnabled = !!window.taboolaMobile;
        const isMobileSDKScrollSwitchEnabled = window.taboolaMobile
            && window.taboolaMobile.isScrollSwitchEnabled
            && window.taboolaMobile.isScrollSwitchEnabled();

        class InfiniteScrollEngine {
            constructor(trcManager, parentPlacementData, options) {
                this.trcManager = trcManager;
                this.parentPlacementData = parentPlacementData;
                this.parentPlacementName = parentPlacementData.placement;
                this.container = parentPlacementData.container;
                this.origContainer = this.container;
                this.parentContainerId = this.container.id;
                this.afterPlacementContainerCreated = options.afterPlacementContainerCreated;
                this.nextBatchDistanceThreshold = options.nextBatchDistanceThreshold || 2000;
                this.numPlacements = 1;
                this.scAdjacencyPlacements = 0;
                this.feedDynamicParameters = options.feedDynamicParameters;
                this.uiBatchNumberCounter = 1;
                this.isPendingNextBatch = true;
                this.numOfConsecutiveFailedRequests = 0;
                this.maxNumOfConsecutiveFailedRequests = this.trcManager.global['feed-max-num-of-consecutive-failed-requests'] || 10;
                this.nbLoaderLayerEnabled = this.trcManager.global['enable-cls-loader-optim'];
                this.firstBatchLazyLoadingEnabled = options.firstBatchLazyLoadingEnabled;
                this.isFirstBatchRequest = true;
                this.isRequestSent = true;
                this.isLoadNextBatchAnchorObserveEnter = false;
                this.currentBatchSuccessful = false;
                this.enableManualLoadNextBatch = (this.trcManager.manualVisibilityTrigger && this.trcManager.global['enable-manual-visible'])
                                                 || (this.feedDynamicParameters && this.feedDynamicParameters.manualLoadNextBatch);
                this.numPlaceholderItems = (this.feedDynamicParameters && this.feedDynamicParameters.numPlaceholderItems) || 3;
                this.itemsParentContainerSelector = options.itemsParentContainerSelector || `#${this.parentContainerId}`;

                const globalObserverRootSelector = (this.feedDynamicParameters && this.feedDynamicParameters.rootSelectorScrollElement) || this.trcManager.global['feed-load-next-batch-root-selector'];
                this.observerRootSelector = globalObserverRootSelector || null;
                this.observerScrollElement = (globalObserverRootSelector && document.querySelector(globalObserverRootSelector)) || window;
                this.feedObserverLoadNextBatch = (this.feedDynamicParameters && this.feedDynamicParameters.feedObserverLoadNextBatch);
                this.firstBatchDistanceThresholdFromTop = this.feedDynamicParameters && this.feedDynamicParameters.firstBatchDistanceThresholdFromTop || this.trcManager.global['first-batch-distance-threshold-from-top'];
                const globalFeedObserverLoadNextBatch = TRC.util.isTrue(this.trcManager.global['feed-observer-load-next-batch']);
                if (globalFeedObserverLoadNextBatch || (this.feedObserverLoadNextBatch && !this.enableManualLoadNextBatch)) {
                    this.isLoadNextBatchUsingObserver = true;
                }

                if (isMobileSDKEnabled && !isMobileSDKScrollSwitchEnabled) {
                    this.isLoadNextBatchUsingObserver = false;
                }

                if (this.firstBatchDistanceThresholdFromTop && !this.enableManualLoadNextBatch) {

                    this.throttledLoadRestOfBatchScrollHandler = this.loadRestOfBatchScrollHandler
                        .trcBind(this, this.firstBatchDistanceThresholdFromTop)
                        .trcThrottle(10);
                    TRC.dom.on(this.observerScrollElement, 'scroll', this.throttledLoadRestOfBatchScrollHandler);
                }

                if (this.enableManualLoadNextBatch) {
                    this.lastManualRectsTop = 0;
                    this.listenToManualLoadNextBatchEvent();
                }

                if (this.feedDynamicParameters && this.feedDynamicParameters.enableHistory) {
                    this.historyManager = new TRC.HistoryManager(trcManager);
                }

                if (this.isLoadNextBatchUsingObserver) {
                    this.createLoadNextBatchObserverAnchorElement();
                }

                const preventReachingFooterConfig = TRC.Feed.getFeedConfig(options, 'preventReachingFooterConfig', 'preventReachingFooterData');
                this.hasPreventReachingFooter = (preventReachingFooterConfig && typeof preventReachingFooterConfig.enable !== 'undefined')
                    ? TRC.util.isTrue(preventReachingFooterConfig.enable) : options.hasPreventReachingFooter;

                if (preventReachingFooterConfig && this.hasPreventReachingFooter) {
                    TRC.PreventReachingTheFooter.init(this, preventReachingFooterConfig);
                }

                this.listenToTrcResponse();
                this.createLoadingIndicator();
                this.initMonitoringOfDuplicatedItemsIfNeeded();
            }

            loadRestOfBatchScrollHandler(earlyLoadingNextBatchDistanceThreshold) {
                const shouldLoadRestOfBatch = this.isNearingStartOfPage(earlyLoadingNextBatchDistanceThreshold);

                if (this.restOfFirstBatchLoaded || this.isCache) {
                    TRC.dom.off(this.observerScrollElement, 'scroll', this.throttledLoadRestOfBatchScrollHandler);
                    return;
                }

                if (!this.restOfFirstBatchLoaded && shouldLoadRestOfBatch) {
                    this.getNextBatch();
                    TRC.dom.off(this.observerScrollElement, 'scroll', this.throttledLoadRestOfBatchScrollHandler);
                }

            }

            createNewNextBatchAnchorObserver() {
                TRC.dom.off(this.observerScrollElement, 'scroll', this.nextBatchObserverCreator);
                TRC.intersections.unobserve(this.loadNextBatchAnchorObserverId);

                if (this.ampFeedResizeListener) {
                    this.ampFeedResizeListener.remove();
                }

                this.nextBatchObserverCreator = null;
                this.isLoadNextBatchAnchorObserveEnter = false;

                this.observeNextBatchAnchor();
            }

            observeNextBatchAnchor() {
                
                if (isMobileSDKEnabled && !isMobileSDKScrollSwitchEnabled) {
                    return;
                }

                const nextBatchThreshold = this.getNextBatchDistanceThreshold(),
                    anchorObserverParams = {
                        rootSelector: this.observerRootSelector,
                        targetElement: this.loadNextBatchAnchorContainer,
                        threshold: [0, 0.25, 0.5, 0.75, 1],
                        rootMargin: `0px 0px ${nextBatchThreshold}px 0px`,
                        onEnter: this.getNextBatch.trcBind(this)
                    };

                this.loadNextBatchAnchorObserverId = TRC.intersections.observe(anchorObserverParams);
            }

            createLoadingSpinner() {
                this.spinnerContainer = document.createElement('div');
                this.spinnerContainer.className += 'tbl-loading-spinner tbl-hidden';
                this.container.appendChild(this.spinnerContainer);
            }

            createLoadingCardPlaceholder() {
                this.spinnerContainer = document.createElement('div');
                TRC.ModuleLoader.load('feed-card-placeholder', TRC.FeedCardPlaceHolder, () => {
                    TRC.FeedCardPlaceHolder.createLoadingCardPlaceholder({
                        direction: this.trcManager.direction,
                        container: this.container,
                        cardPlaceholder: this.spinnerContainer,
                        numPlaceholderItems: this.numPlaceholderItems
                    });
                });
            }

            reserveSpaceForLoader(isSpinner, oldContainer, newContainer) {
                if (this.nbLoaderLayerEnabled) {
                    if (oldContainer) {
                        const paddingBottom = oldContainer.style.getPropertyValue('padding-bottom');
                        oldContainer.style.removeProperty('padding-bottom');
                        newContainer.style.setProperty('padding-bottom', `${paddingBottom}`, 'important');
                    } else {
                        let reservedHeight;
                        if (isSpinner) {
                            // spinner is 50px height
                            reservedHeight = 50;
                        } else if (TRC.dom.isSmartPhone()) {
                            const placeholderHeight = 95;
                            const placeholderMargin = 8;
                            reservedHeight = this.numPlaceholderItems * placeholderHeight + placeholderMargin;
                        } else {
                            const placeholderHeight = 173;
                            const placeholderMargin = 40;
                            reservedHeight = this.numPlaceholderItems * placeholderHeight + placeholderMargin;
                        }

                        newContainer.style.setProperty('padding-bottom', `${reservedHeight}px`, 'important');
                        this.spinnerContainer.style.setProperty('position', 'absolute', 'important');
                    }

                }
            }

            createLoadingIndicator() {
                const shouldDisableAnimation = this.trcManager.global['disable-nb-anim'];
                if (!shouldDisableAnimation) {
                    const shouldCreateSpinner = (this.feedDynamicParameters && this.feedDynamicParameters.disableLoadingCardsPlaceholder === 'true') || this.trcManager.global['disable-loading-cards-placeholder'];
                    if (shouldCreateSpinner) {
                        this.createLoadingSpinner();
                    } else {
                        this.createLoadingCardPlaceholder();
                    }
                    this.reserveSpaceForLoader(shouldCreateSpinner, null, this.container);
                }

            }

            createLoadNextBatchObserverAnchorElement() {
                this.loadNextBatchAnchorContainer = document.createElement('div');
                this.loadNextBatchAnchorContainer.className = 'tbl-batch-anchor';
                this.container.appendChild(this.loadNextBatchAnchorContainer);

                this.observeNextBatchAnchor();
            }

            stopScrolling() {
                if (this.preventReachingTheFooter) {
                    this.preventReachingTheFooter.disable();
                }

                if (this.isLoadNextBatchUsingObserver) {
                    this.isAllowedToRequestMoreContent = false;
                    TRC.intersections.unobserve(this.loadNextBatchAnchorObserverId);
                    return;
                }

                if (this.enableManualLoadNextBatch) {
                    this.isAllowedToRequestMoreContent = false;
                    return;
                }

                TRC.dom.off(this.observerScrollElement, 'scroll', this.throttledScrollHandler);
            }

            hideLoadingSpinner() {
                if (this.spinnerContainer && this.spinnerContainer.className.indexOf('tbl-hidden') === -1) {
                    TRC.dom.addClass(this.spinnerContainer, 'tbl-hidden');
                }
            }

            showLoadingSpinner() {
                if (this.spinnerContainer) {
                    TRC.dom.removeClass(this.spinnerContainer, 'tbl-hidden');
                }
            }

            listenToTrcResponse() {
                let trcResponseHandler;
                if (this.hasPreventReachingFooter) {
                    trcResponseHandler = this.onTrcResponsePreventReachingFooterWrapper.trcBind(this);
                } else {
                    trcResponseHandler = this.onTrcResponse.trcBind(this);
                }

                TRC.EventsAPI.listen('nocontent', this.onTrcNoContent.trcBind(this));
                TRC.listen('trcResponseHandled', trcResponseHandler);
                TRC.listen('resumeFeedRendering', trcResponseHandler);
            }

            listenToManualLoadNextBatchEvent() {
                TRC.listen(`visible::${this.parentPlacementName}`, this.manualLoadNextBatchHandler.trcBind(this));
            }

            shouldEnableLoadNextBatch(rects) {
                const isScrollDirectionDown = rects.boundingClientRect.top < this.lastManualRectsTop,
                    endOfContentPos = (rects.boundingClientRect.top + rects.boundingClientRect.height) - rects.rootBounds.height,
                    isNearingEndOfContent = endOfContentPos <= this.getNextBatchDistanceThreshold();

                return isNearingEndOfContent && isScrollDirectionDown;
            }

            manualLoadNextBatchHandler(rects) {
                if (this.shouldEnableLoadNextBatch(rects)) {
                    this.getNextBatch();
                }
                this.lastManualRectsTop = rects.boundingClientRect.top;
            }

            isNearingStartOfPage(earlyLoadingNextBatchDistanceThreshold) {
                return earlyLoadingNextBatchDistanceThreshold <= this.getScrollTop();
            }

            getNextBatchDistanceThreshold() {
                if (!this.isFirstBatchRequest) {
                    return this.nextBatchDistanceThreshold;
                }
                const threshold = this.firstBatchLazyLoadingEnabled ? this.trcManager.global['feed-first-batch-distance-threshold']
                    || this.nextBatchDistanceThreshold : this.nextBatchDistanceThreshold;
                if (this.trcManager.renderController.isLazyRenderEnabled) {
                    return this.trcManager.renderController.getBatchThreshold(this, threshold);
                }
                return threshold;
            }

            updateNextBatchNumber(nextBatchNumber) {
                this.trcNextBatchNumber = +nextBatchNumber;
            }

            getNextBatch(forceGetNextBatch) {
                try {
                    if (this.preventReachingTheFooter && this.preventReachingTheFooter.lateRenderEnabled) {
                        this.preventReachingTheFooter.handleGetNextBatch();
                    }
                    const request = {};

                    if (this.isAllowedToRequestMoreContent === false || this.isPendingNextBatch) {
                        return;
                    }

                    if (this.isLoadNextBatchUsingObserver) {
                        if (!forceGetNextBatch && this.isLoadNextBatchAnchorObserveEnter) {
                            return;
                        }
                        this.isLoadNextBatchAnchorObserveEnter = true;
                    }

                    this.isFirstBatchRequest = false;
                    this.parentPlacementData.fb = this.trcNextBatchNumber || ++this.uiBatchNumberCounter;
                    this.restOfFirstBatchLoaded = true;
                    this.parentPlacementData.fi = this.numPlacements + this.scAdjacencyPlacements;

                    request[this.parentPlacementName] = this.parentPlacementData;

                    this.isPendingNextBatch = true;
                    this.showLoadingSpinner();
                    this.trcManager.dispatchLoadRequest(request);
                    this.isRequestSent = true;
                } catch (e) {
                    __trcError('Failed to load next batch in getNextBatch()', e);
                }
            }

            getScrollTop() {
                return TRC.dom.getScrollTop(this.observerScrollElement);
            }

            static isVideoItemPreviewOn(feedDynamicParameters, placementData) {
                return !!(feedDynamicParameters.uimvip === placementData.mode || feedDynamicParameters.evip);
            }

            handlePlacement(placementData) {
                const placementContainer = document.createElement('div');
                const isScAdjacencyCard = placementData.trcResponse.scac;

                if (this.feedDynamicParameters && InfiniteScrollEngine.isVideoItemPreviewOn(this.feedDynamicParameters, placementData)) {
                    placementContainer.className = 'tbl-preview';
                }

                if (placementData.isCache) {
                    this.isCache = true;
                    this.cachedViewId = placementData.cachedViewId;

                    if (!this.loadFromCacheEventSent) {
                        const eventName = 'backToFeed_loadFromCache',
                            eventType = __trcJSONify({
                                origViewId: this.cachedViewId,
                                placement: placementData.placement,
                                cardIndex: isScAdjacencyCard ? null : this.numPlacements
                            });

                        this.trcManager.sendAbTestEvent(eventName, eventType);
                        this.loadFromCacheEventSent = true;
                    }
                } else if (this.isCache && !this.loadNotFromCacheEventSent) {
                    const eventName = 'backToFeed_loadNotFromCache',
                        eventType = __trcJSONify({
                            origViewId: this.cachedViewId,
                            placement: placementData.placement,
                            cardIndex: isScAdjacencyCard ? null : this.numPlacements
                        });

                    this.trcManager.sendAbTestEvent(eventName, eventType);
                    this.loadNotFromCacheEventSent = true;
                }

                placementData.container = placementContainer;
                placementData.modeGroupOrder = this.numPlacements;

                if (!isScAdjacencyCard) {
                    placementContainer.setAttribute('data-card-index', this.numPlacements);
                }

                placementContainer.placementData = placementData;

                this.uiBatchNumberCounter = +(placementData.trcResponse.fb) || this.uiBatchNumberCounter;

                if (this.parentContainerId) {
                    placementContainer.id = `${this.parentContainerId}${isScAdjacencyCard ? `-sca${this.scAdjacencyPlacements + 1}` : `-pl${this.numPlacements}`}`;
                    placementContainer.setAttribute('data-batch-num', this.uiBatchNumberCounter);
                }

                if (typeof this.afterPlacementContainerCreated === 'function') {
                    this.afterPlacementContainerCreated(placementContainer, placementData);
                }

                if (this.isLoadNextBatchUsingObserver) {
                    this.container.insertBefore(placementContainer, this.container.querySelector('.tbl-batch-anchor'));
                } else {
                    this.container.insertBefore(placementContainer, this.container.querySelector('.tbl-loading-spinner'));
                }


                if (this.historyManager) {
                    this.historyManager.trackElement(placementContainer);
                    this.historyManager.scrollToElementIfWasLastInViewPort(placementContainer);
                }

                if (!isScAdjacencyCard) {
                    this.numPlacements++;
                } else {
                    this.scAdjacencyPlacements++;
                }

                if (!placementData.trcResponse.v || placementData.trcResponse.v.length > 0) {
                    this.currentBatchSuccessful = true;
                }
            }

            switchMainContainer(newContainer) {
                if (this.nbLoaderLayerEnabled) {
                    this.reserveSpaceForLoader(null, this.container, newContainer);
                }
                this.container = newContainer;

                if (this.isLoadNextBatchUsingObserver) {
                    this.container.appendChild(this.loadNextBatchAnchorContainer);
                }

                this.container.appendChild(this.spinnerContainer);
            }

            onTrcResponsePreventReachingFooterWrapper(e) {
                this.preventReachingTheFooter && this.preventReachingTheFooter.preparePreventScroll(e);
            }

            onTrcNoContent(e) {
                if (!e.detail.placement) {
                    this.currentBatchSuccessful = false;
                    this.onTrcResponse();
                }
            }

            onTrcResponse() {
                if (!this.isRequestSent) return;
                this.isRequestSent = false;
                if (!this.currentBatchSuccessful) {
                    this.numOfConsecutiveFailedRequests++;
                    if (this.numOfConsecutiveFailedRequests >= this.maxNumOfConsecutiveFailedRequests) {
                        this.stopScrolling();
                        this.hideLoadingSpinner();
                        return;
                    }
                } else {
                    this.numOfConsecutiveFailedRequests = 0;
                }
                this.currentBatchSuccessful = false;

                this.isPendingNextBatch = false;

                if (this.preventReachingTheFooter && this.preventReachingTheFooter.isWaitToHide === true) {
                    this.preventReachingTheFooter.isWaitToHide = false;
                } else {
                    this.hideLoadingSpinner();
                }

                if (this.isLoadNextBatchUsingObserver && !this.nextBatchObserverCreator && this.isAllowedToRequestMoreContent !== false) {
                    this.nextBatchObserverCreator = this.createNewNextBatchAnchorObserver.trcBind(this).trcThrottle(10);
                    TRC.dom.on(this.observerScrollElement, 'scroll', this.nextBatchObserverCreator);
                    this.ampFeedResizeListener = TRC.listen('ampFeedResize', this.nextBatchObserverCreator);
                }

                if (this.duplicatedItemsMonitor) {
                    this.duplicatedItemsMonitor.checkForDuplicatedItems();
                }

                if (this.preventReachingTheFooter && this.preventReachingTheFooter.isEnableLateRender) {
                    this.preventReachingTheFooter.isEnableLateRender = false;
                    this.getNextBatch(true);
                }
            }

            setIsAllowedToRequestMoreContent(isAllowedToRequestMoreContent) {
                this.isAllowedToRequestMoreContent = isAllowedToRequestMoreContent;
            }

            getIsFirstBatch() {
                return this.isFirstBatchRequest;
            }

            initMonitoringOfDuplicatedItemsIfNeeded() {
                if (this.shouldMonitorForDuplicatedItems()) {
                    const options = {
                        parentContainerSelector: this.itemsParentContainerSelector,
                        additionalLogDataBuilder: item => ({cardIndex: TRC.dom.closest(item, '[data-card-index]').getAttribute('data-card-index')})
                    };

                    this.duplicatedItemsMonitor = new TRC.DuplicatedItemsMonitor(this.trcManager, options);
                }
            }

            shouldMonitorForDuplicatedItems() {
                return (this.trcManager.global['monitor-dup-items-traffic-pct'] > (Math.random() * 100))
                    || ['yes', 'true', '1'].indexOf(TRC.URL.prototype.getParameter.call(location.href, 'taboola_dedup_debug')) !== -1;
            }
        }

        TRC.InfiniteScrollEngine = InfiniteScrollEngine;

    })();

    (() => {

        class PreventReachingTheFooter {
            constructor(options) {
                this.getConfig(options);
                this.trackFastScroller();
            }

            getConfig(options) {
                this.lateRenderTimeout = parseInt(options.timeout, 10) || 5000;
                this.fastScrollerTime = parseInt(options.fastScrollerTime, 10) || 10000;
                this.maxCards = parseInt(options.maxCards, 10) || 5;
                this.detectCardNumber = parseInt(options.detectCardNumber, 10) || 5;
                this.trcManager = options.trcManager;
                this.infiniteScrollEngine = options.infiniteScrollEngine;
                this.cardOneTime = null;
                this.detectCardTime = null;
                this.observerTargets = [];
                this.onScroll = this.observeScroll.trcBind(this).trcThrottle(50);
                this.onEndKey = this.endKeyHandler.trcBind(this);
                this.isFastScroller = false;

                // Prevent scroll
                this.prevPosition = window.pageYOffset;
                this.scrollThrottleTime = parseInt(options.scrollThrottleTime, 10) || 10;
                this.timeout = null;
                this.scrollTimeoutLength = parseInt(options.scrollTimeoutLength, 10) || 5000;
                this.timeoutEnabled = false;
                this.stopListenToBatch = true;
                this.shouldPreventScrolling = true;
                this.loadNextBatchAnchorContainer = options.infiniteScrollEngine.loadNextBatchAnchorContainer;
                this.isPreventScroll = false;
            }

            trackFastScroller() {
                TRC.dom.on(window, 'scroll', this.onScroll);
                TRC.dom.on(document, 'keydown', this.onEndKey);
            }

            unTrackFastScroller() {
                TRC.dom.off(window, 'scroll', this.onScroll);
                TRC.dom.off(document, 'keydown', this.onEndKey);
                this.observerTargets.forEach(targetId => {
                    TRC.intersections.unobserve(targetId);
                });
            }

            enableLateRender() {
                this.isFastScroller = true;
                this.lateRenderEnabled = true;
            }

            observeScroll() {
                if (!this.cardOne || this.cardOne.length === 0) {
                    this.cardOne = this.infiniteScrollEngine.origContainer.querySelector('[data-card-index="1"]');
                    if (this.cardOne) {
                        this.observeCard(this.cardOne, this.saveCardVisibilityTime.trcBind(this, 'cardOneTime'));
                    }
                }

                if (!this.detectCard || this.detectCard.length === 0) {
                    this.detectCard = this.infiniteScrollEngine.origContainer.querySelector(`[data-card-index="${this.detectCardNumber}"]`);
                    if (this.detectCard) {
                        this.observeCard(this.detectCard, this.saveCardVisibilityTime.trcBind(this, 'detectCardTime'));
                    }
                }

                if (this.detectCardTime && this.cardOneTime) {
                    if ((this.detectCardTime - this.cardOneTime) < this.fastScrollerTime) {
                        this.enableLateRender();
                    }
                    this.unTrackFastScroller();
                }
            }

            observeCard(card, callback) {
                const observerParams = {
                    targetElement: card,
                    onEnter: callback,
                    threshold: 0.5
                };

                const observerTarget = TRC.intersections.observe(observerParams);
                this.observerTargets.push(observerTarget);
            }

            saveCardVisibilityTime(prop) {
                if (this[prop]) {
                    return;
                }
                this[prop] = new Date().getTime();
            }

            endKeyHandler() {
                const e = window.event;
                const {keyCode, metaKey} = e;

                if (this.lateRenderEnabled) {
                    return;
                }

                if (keyCode === 35 || (metaKey && keyCode === 40)) {
                    this.unTrackFastScroller();
                    this.enableLateRender();
                }
            }

            handleGetNextBatch() {
                this.getNextBatchTime = new Date().getTime();
            }

            handleBatch(cacheKey, response) {
                const batchNumOfCards = response.trc.vl.length;

                if (typeof this.numOfCards === 'undefined') {
                    this.numOfCards = 0;
                }

                this.numOfCards += batchNumOfCards;
                this.isPreventScroll = false;
                if (this.numOfCards >= this.maxCards) {
                    this.numOfCards = 0;
                    this.isPreventScroll = true;
                    this.isEnableLateRender = true;
                    this.preventScrollBelowAnchor();
                }

                if (!this.stopListenToBatch) {
                    this.stopListenToScrollForPrevent();
                }
            }

            /*-----------------------------
                Prevent scroll methods
             -----------------------------*/
            listenToScrollForPrevent() {
                this.onScrollForPrevent = this.observeScrollForPrevent.trcBind(this);
                TRC.dom.on(window, 'scroll', this.onScrollForPrevent);
                this.stopListenToBatch = false;
            }

            stopListenToScrollForPrevent() {
                TRC.dom.off(window, 'scroll', this.onScrollForPrevent);
                TRC.dom.off(document, 'keydown', this.onEndKeyOnPreventScroll);
                this.stopListenToBatch = true;
                clearTimeout(this.timeout);
            }

            observeScrollForPrevent() {
                const now = new Date().getTime();
                if (now - this.scrollEventTime < this.scrollThrottleTime) {
                    return;
                }
                const windowScrollTop = TRC.dom.getScrollTop(window);
                const isScrollingUp = this.prevPosition > windowScrollTop;

                const feedContainerId = this.infiniteScrollEngine.parentContainerId;
                const previousWidgetHeight = document.getElementById(`${feedContainerId}-pl${this.infiniteScrollEngine.numPlacements - 1}`).scrollHeight;
                const topOffset = window.innerHeight - (previousWidgetHeight / 1.5);
                
                const elementTop = TRC.PreventReachingTheFooter.getOffsetFromTopOfPage(this.loadNextBatchAnchorContainer);
                const elemIsAbove = elementTop < windowScrollTop + topOffset;

                if (!isScrollingUp && elemIsAbove) {
                    if (this.shouldPreventScrolling) {
                        const scrollToY = elementTop - topOffset;
                        window.scrollTo(TRC.PreventReachingTheFooter.getWindowScrollLeft(), scrollToY);

                        if (!this.timeoutEnabled) {
                            this.enableScrollBelowAnchorOnTimeout();
                        }
                    }
                }
                this.prevPosition = TRC.dom.getScrollTop(window);
                this.scrollEventTime = new Date().getTime();
            }

            enableScrollBelowAnchorOnTimeout() {
                this.timeout = setTimeout((() => {
                    this.shouldPreventScrolling = false;
                }), this.scrollTimeoutLength);
                this.timeoutEnabled = true;
            }

            preventScrollBelowAnchor() {
                this.shouldPreventScrolling = true;
                clearTimeout(this.timeout);
                this.timeoutEnabled = false;
            }

            static getWindowScrollLeft() {
                return window.scrollX ? window.scrollX : document.documentElement.scrollLeft;
            }

            static getOffsetFromTopOfPage(element) {
                return element.getBoundingClientRect().top + window.pageYOffset;
            }

            listenToKeysOnPreventScroll() {
                this.onEndKeyOnPreventScroll = this.endKeyHandlerOnPreventScroll.trcBind(this);
                TRC.dom.on(document, 'keydown', this.onEndKeyOnPreventScroll);
            }

            endKeyHandlerOnPreventScroll(e) {
                const event = e || window.event;
                const {keyCode, metaKey} = event;
                if (keyCode === 35 || (metaKey && keyCode === 40)) {
                    window.scrollTo(0, TRC.PreventReachingTheFooter.getOffsetFromTopOfPage(this.loadNextBatchAnchorContainer) - window.innerHeight);
                }
            }

            shouldLateRender(newBatchTime) {
                return this.isFastScroller && this.isEnableLateRender && newBatchTime < this.lateRenderTimeout;
            }

            preparePreventScroll(e) {
                this.trcResponseTime = new Date().getTime();
                const newBatchTime = this.trcResponseTime - this.getNextBatchTime;

                if (!this.shouldLateRender(newBatchTime)) {
                    this.infiniteScrollEngine.onTrcResponse(e);                
                    return;
                }

                const differenceTime = this.lateRenderTimeout - newBatchTime;
                setTimeout(this.infiniteScrollEngine.onTrcResponse.trcBind(this.infiniteScrollEngine, e), differenceTime);
                this.trcResponseTime = null;
                this.getNextBatchTime = null;
                this.isWaitToHide = true;

                if (this.isPreventScroll) {
                    this.listenToScrollForPrevent();
                    this.listenToKeysOnPreventScroll();
                }
            }

            disable() {
                this.infiniteScrollEngine.hideLoadingSpinner();
                this.isPreventScroll = false;
                this.stopListenToScrollForPrevent();
            }

            static init(infiniteScrollEngine, config) {
                infiniteScrollEngine.preventReachingTheFooter = new TRC.PreventReachingTheFooter({
                    timeout: config.timeout,
                    fastScrollerTime: config.fastScrollerTime,
                    maxCards: config.maxCards,
                    detectCardNumber: config.detectCardNumber,
                    infiniteScrollEngine,
                    trcManager: TRCImpl,
                    scrollTimeoutLength: config.scrollTimeoutLength,
                    scrollThrottleTime: config.scrollThrottleTime
                });
            }
        }

        TRC.PreventReachingTheFooter = PreventReachingTheFooter;
    })();

    (() => {
        const MAX_RETRIES = 5,
            RETRY_INTERVAL = 1000,
            MIN_CARD_CONTAINER_HEIGHT = 100;

        class PublisherCardsManager {
            constructor(parentFeed, trcManager, parentPlacementData, options) {
                this.parentFeed = parentFeed;
                this.trcManager = trcManager;
                this.options = options;
                this.container = parentFeed.container;
                this.origContainer = this.container;
                this.pendingPublisherCardsList = [];

                this.feedDynamicParameters = this.options.feedDynamicParameters;
                this.shouldStopFeedOnMissingPublisherCard = (this.feedDynamicParameters && this.feedDynamicParameters.missingPublisherCardFeedStrategy === 'STOP') || this.trcManager.global['missing-publisher-card-feed-strategy'] === 'STOP';
                this.shouldSendCardEvents = !((this.feedDynamicParameters && this.feedDynamicParameters.disableSendingCardEvents) || this.trcManager.global['disable-sending-card-events']);

                this.publisherCardMaxRetries = trcManager.global['feed-split-max-retries'] || MAX_RETRIES;
                this.publisherCardRetryInterval = trcManager.global['feed-split-retry-interval'] || RETRY_INTERVAL;
                this.feedCardEventsMaxRetries = trcManager.global['feed-card-events-max-retries'] || MAX_RETRIES;
                this.feedCardEventsRetryInterval = trcManager.global['feed-card-events-retry-interval'] || RETRY_INTERVAL;
                this.feedCardEventsMinContainerHeight = trcManager.global['feed-card-events-min-container-height'] || MIN_CARD_CONTAINER_HEIGHT;
            }

            handlePendingPublisherCards(numRetries = 0, publisherCardNum, publisherCardPlacementData, isLegacySplit) {
                publisherCardPlacementData = publisherCardPlacementData || this.pendingPublisherCardsList[0];

                const publisherCardPlacementResponse = publisherCardPlacementData.trcResponse,
                    publisherCardKey = isLegacySplit ? 'spl' : 'pcp',
                    publisherCardInstructions = publisherCardPlacementResponse[publisherCardKey],
                    anchorElementSelector = publisherCardInstructions.tps,
                    publisherCardUnitName = publisherCardInstructions.sun || publisherCardInstructions.pun;

                let anchorElement,
                    querySelectorException = false;

                try {
                    anchorElement = document.querySelector(anchorElementSelector);
                } catch (e) {
                    __trcWarn(`Exception while trying to find publisher card with selector ${anchorElementSelector}: ${e}`);
                    querySelectorException = true;
                }

                if (!anchorElement || !anchorElement.parentNode) {
                    this.parentFeed.setIsAllowedToRequestMoreContent(false);

                    if (numRetries < this.publisherCardMaxRetries && !querySelectorException) {
                        numRetries++;

                        setTimeout(
                            this.handlePendingPublisherCards.trcBind(this, numRetries, publisherCardNum, publisherCardPlacementData, isLegacySplit),
                            this.publisherCardRetryInterval
                        );
                    } else {
                        numRetries = 0;
                        this.pendingPublisherCardsList.shift();

                        if (this.pendingPublisherCardsList.length) {
                            setTimeout(
                                this.handlePendingPublisherCards.trcBind(
                                    this, numRetries, publisherCardNum, this.pendingPublisherCardsList[0], isLegacySplit
                                ),
                                this.publisherCardRetryInterval
                            );
                        } else {
                            if (isLegacySplit || this.shouldStopFeedOnMissingPublisherCard) {
                                this.parentFeed.stopScrolling();
                            } else {
                                this.pendingPublisherCardsList = [];
                                this.parentFeed.setIsAllowedToRequestMoreContent(true);
                                TRC.dispatch('resumeFeedRendering');
                            }
                            TRC.modDebug.logMessageToServer(
                                1,
                                `Load publisher card: ${publisherCardUnitName} on Card: ${publisherCardNum} with the anchor element selector: ${anchorElementSelector} failed after ${this.publisherCardMaxRetries} retries`,
                                {
                                    idx: 'pc', pc: publisherCardUnitName, st: 0, sel: anchorElementSelector, slot: publisherCardNum, plat: this.trcManager.getPlatformCode()
                                }
                            );
                        }
                    }

                    return;
                }

                this.createFeedContainerForResumeAfterPublisherCard(anchorElement, publisherCardInstructions);

                if (this.shouldSendCardEvents && !isLegacySplit) {
                    this.pendingPublisherCardsList.forEach(this.initCardEventsManager.trcBind(this));
                }

                TRC.modDebug.logMessageToServer(
                    2,
                    `Load publisher card: ${publisherCardUnitName} on Card: ${publisherCardNum} with the anchor element selector: ${anchorElementSelector} succeed`,
                    {idx: 'pc', pc: publisherCardUnitName, st: 1}
                );

                this.pendingPublisherCardsList = [];

                this.parentFeed.setIsAllowedToRequestMoreContent(true);

                const {expandOptions} = publisherCardPlacementData;

                if (expandOptions) {
                    anchorElement.id = anchorElement.id 
                        ? anchorElement.id : `${Math.floor(Math.random() * 2147483648).toString(36)}`;
                    anchorElement.expandableBox = new TRC.ExpandableBox(this.trcManager, anchorElement.id, expandOptions);
                }

                if (numRetries > 0) {
                    TRC.dispatch('resumeFeedRendering');
                }
            }

            initCardEventsManager(cardPlacementData, numRetries = 0) {
                const cardElementSelector = cardPlacementData.trcResponse.pcp.tps,
                    cardElementContainer = document.querySelector(cardElementSelector);

                if (!cardElementContainer) {
                    if (numRetries < this.publisherCardMaxRetries) {
                        numRetries++;
                        setTimeout(this.initCardEventsManager.trcBind(this, cardPlacementData, numRetries), this.feedCardEventsRetryInterval);
                    }

                    return;
                }

                const cardEventsManager = new TRC.CardEventsManager(this.trcManager, this.options, cardPlacementData, cardElementContainer);
                this.checkIfCardRendered(cardEventsManager, cardElementContainer);
            }

            createFeedContainerForResumeAfterPublisherCard(anchorElement, instructions) {
                const newFeedContainer = document.createElement('div');

                const previousFeedContainer = this.parentFeed.container;

                this.parentFeed.numContainers++;

                this.parentFeed.switchMainContainer(newFeedContainer);
                this.parentFeed.setMainContainerCssClassesAndAttributes(newFeedContainer, this.options);

                anchorElement.parentNode.insertBefore(newFeedContainer, anchorElement.nextElementSibling);

                if (instructions && (TRC.util.isTrue(instructions.scw) || TRC.util.isTrue(instructions.acw))) {
                    this.setPublisherCardContainerStyle(newFeedContainer);

                    // listen to origin container width change on resize
                    TRC.dom.on(window, 'resize', this.setPublisherCardContainerStyle.trcBind(this, newFeedContainer));
                }

                PublisherCardsManager.sendWarnIfAnchorIsIncorrectlyPositioned(previousFeedContainer, anchorElement);

                if (this.parentFeed.isFullWidthMobileFeed(this.options)) {
                    const publisherCardFullWidthPartsCss = this.parentFeed.getMobileFullWidthMarginsCss(this.parentFeed.numContainers);

                    if (publisherCardFullWidthPartsCss) {
                        TRC.dom.injectStyle(publisherCardFullWidthPartsCss, null);
                    }
                }
            }

            static sendWarnIfAnchorIsIncorrectlyPositioned(previousFeedContainer, anchorElement) {
                const PublisherCardTopPosition = anchorElement.getBoundingClientRect().top;
                const FeedContainerTopPosition = previousFeedContainer.getBoundingClientRect().top;
                if (PublisherCardTopPosition < FeedContainerTopPosition) {
                    __trcWarn('anchor element is above the original feed container');
                }
            }

            static getContainerWidth(feedContainer) {
                return getComputedStyle(feedContainer).width;
            }

            getPageDirection() {
                if (this.trcManager.direction === 'rtl') {
                    return 'right';
                }
                return 'left';
            }
            
            setPublisherCardContainerMargin(feedContainer) {
                const pageDirection = this.getPageDirection(),
                    originContainerOffset = this.origContainer.getBoundingClientRect()[pageDirection],
                    publisherCardContainerOffset = feedContainer.getBoundingClientRect()[pageDirection];

                let marginDirection,
                    directionSignFactor = 1;

                if (originContainerOffset === publisherCardContainerOffset) {
                    return;
                }

                if (pageDirection === 'right') {
                    marginDirection = 'marginRight';
                    directionSignFactor = -1;
                } else {
                    marginDirection = 'marginLeft';
                }

                const publisherCardContainerCurrentMargin = parseInt(getComputedStyle(feedContainer)[marginDirection], 10);
                const offset = originContainerOffset - publisherCardContainerOffset;
                const publisherCardContainerNewMargin = (offset + publisherCardContainerCurrentMargin) * directionSignFactor;

                feedContainer.style[marginDirection] = `${publisherCardContainerNewMargin}px`;
            }

            setPublisherCardContainerStyle(feedContainer) {
                const originContainerWidth = PublisherCardsManager.getContainerWidth(this.origContainer),
                    newContainerWidth = PublisherCardsManager.getContainerWidth(feedContainer),
                    {feedDynamicParameters} = this.options,
                    disableFeedSplitContainerAlignment = (feedDynamicParameters && feedDynamicParameters.disableFeedSplitContainerAlignment) || this.trcManager.global['disable-feed-split-container-alignment'],
                    isContainersEqual = originContainerWidth === newContainerWidth;

                if (isContainersEqual && disableFeedSplitContainerAlignment) {
                    return;
                }
                if (!isContainersEqual) {
                    feedContainer.style.width = originContainerWidth;
                }

                if (!disableFeedSplitContainerAlignment) {
                    this.setPublisherCardContainerMargin(feedContainer);
                }
            }

            registerPublisherCardForHandling(placementData) {
                this.pendingPublisherCardsList.unshift(placementData);
            }

            checkIfCardRendered(cardEventsManager, cardElementContainer, numRetries = 0) {
                if (cardElementContainer.getBoundingClientRect().height < this.feedCardEventsMinContainerHeight) {
                    if (numRetries < this.feedCardEventsMaxRetries) {
                        numRetries++;

                        setTimeout(
                            this.checkIfCardRendered.trcBind(this, cardEventsManager, cardElementContainer, numRetries),
                            this.feedCardEventsRetryInterval
                        );
                    }
                    return;
                }

                cardEventsManager.handleRenderedCard(cardElementContainer); // send available event only if the card container have height
            }
        }

        TRC.PublisherCardsManager = PublisherCardsManager;

    })();

    (() => {
        const WIDGET_TO_FEED_CSS_CLASS = 'trc-w2f',
            WIDGET_TO_FEED_NO_FEED_UI_CSS_CLASS = 'trc-w2f-no-ui';

        class WidgetToFeedHelper {
            constructor(parentFeed, trcManager, hasFeedUI) {
                this.parentFeed = parentFeed;
                this.trcManager = trcManager;
                this.hasFeedUI = hasFeedUI;

                this.setUpFeedContainer();

                TRC.listen('trcResponseHandled', this.setContentTypeCssClass.trcBind(this));
            }

            setUpFeedContainer() {
                const feedContainer = this.parentFeed.container;

                feedContainer.className += ` ${WIDGET_TO_FEED_CSS_CLASS}`;

                if (this.hasFeedUI === false) {
                    feedContainer.className += ` ${WIDGET_TO_FEED_NO_FEED_UI_CSS_CLASS}`;
                }
            }

            setContentTypeCssClass() {
                const feedContainer = this.parentFeed.container,
                    hasSponsored = feedContainer.querySelectorAll('.videoCube.syndicatedItem').length,
                    hasOrganic = feedContainer.querySelectorAll('.videoCube:not(.syndicatedItem)').length;

                let contentType = 'sponsored';

                if (hasOrganic) {
                    if (hasSponsored) {
                        contentType = 'hybrid';
                    } else {
                        contentType = 'organic';
                    }
                }

                this.parentFeed.container.className = this.parentFeed.container.className.replace(/\btrc-content-(hybrid|sponsored|organic)\b/g, '');
                this.parentFeed.container.className += ` trc-content-${contentType}`;
            }

            addHeaderToFeed(firstWidgetHeader) {
                this.parentFeed.header.appendChild(firstWidgetHeader);
                this.header = firstWidgetHeader;
            }

            addFooterToFeed(FirstWidgetFooter) {
                this.footer = document.createElement('div');

                this.footer.className = 'tbl-feed-footer';
                this.footer.appendChild(FirstWidgetFooter);

                this.parentFeed.container.appendChild(this.footer);
            }

            getHeader() {
                return this.header;
            }

            getFooter() {
                return this.footer;
            }

            applyWidgetHeaderAndFooterStylesToFeed(firstWidgetUiMode) {
                if (this.headerAndFooterStylesApplied) {
                    return;
                }

                const widgetStylesRegExp = new RegExp(`(\\.${firstWidgetUiMode})([^{]+\\.(trc_rbox_header|logoDiv|trc-widget-footer))`, 'g'),
                    irrelevantStylesRegExp = new RegExp(`^(?![^}]*.${WIDGET_TO_FEED_CSS_CLASS}[^{]+).*$`, 'gm');

                TRC.dom.injectedStyles.forEach(style => {
                    if (!widgetStylesRegExp.test(style.innerText)) {
                        return;
                    }

                    let styleText = style.innerText.replace(widgetStylesRegExp, `.${WIDGET_TO_FEED_CSS_CLASS}$2`);
                    styleText = styleText.replace(/\n/g, '');
                    styleText = styleText.replace(/}/g, '}\n');
                    styleText = styleText.replace(irrelevantStylesRegExp, '');
                    styleText = styleText.replace(/\n/g, '');

                    TRC.dom.injectStyle(styleText, document);
                });

                this.headerAndFooterStylesApplied = true;
            }
        }

        TRC.WidgetToFeedHelper = WidgetToFeedHelper;

    })();

    (() => {

        const FLOATING_UNITS = {
            TABOOLA_REMINDER: {
                name: 'taboola_reminder',
                responseKey: 'taboola-reminder',
                contentElementId: 'tbl-taboola-reminder-inner',
                moduleFileName: 'taboola-reminder',
                moduleClass: 'TaboolaReminder',
                closeBtn: 'tbl-taboola-reminder-closeBtn',
                closeBtnWrapper: 'tbl-taboola-reminder-closeBtn-wrapper'
            },
            NEXT_UP: {
                name: 'next_up',
                responseKey: 'next-up-widget',
                contentElementId: 'tbl-next-up-inner',
                moduleFileName: 'next-up-widget',
                moduleClass: 'NextUpWidget',
                closeBtn: 'tbl-next-up-closeBtn',
                closeBtnWrapper: 'tbl-next-up-closeBtn-wrapper'
            }
        };

        class FloatingUnitGenerator {
            constructor(formattedResponse, placementData, trcManager) {
                // prevent from creating more than 1 floating unit.
                // This is NOT protecting from inserting more than 1 widget into
                // the floating unit.
                if (FloatingUnitGenerator.isFloatingUnitOn) {
                    __trcWarn('Floating Unit: Trying To Add More Than One Floating Unit');
                    return;
                }
                FloatingUnitGenerator.isFloatingUnitOn = true;

                this.formattedResponse = formattedResponse;
                this.placementData = placementData;
                this.trcManager = trcManager;
                this.videoList = this.formattedResponse.trc['video-list'];
                this.unit = FloatingUnitGenerator.getUnitByResponseKey(this.videoList);
                this.contentSelector = `#${this.unit.contentElementId}`;
                this.sendSupplyEvent('RENDERED');
                this.initFloatingUnit();
            }

            sendSupplyEvent(state, value = null, message = null) {
                const requestData = {
                    event_type: this.unit.name, event_state: state, event_value: value, event_msg: message
                };
                TRCImpl.sendEvent('supply-feature', {d: JSON.stringify(requestData)}, null);
            }

            static getUnitByResponseKey(videoList) {
                let unit;
                Object.keys(FLOATING_UNITS).some(unitKey => {
                    const currentUnit = FLOATING_UNITS[unitKey];
                    if (videoList[currentUnit.responseKey]) {
                        unit = currentUnit;
                        return true;
                    }
                    return false;
                });        
                return unit;
            }

            initFloatingUnit() {
                this.createElementForFloatingUnitContent();
                this.setFloatingUnitOptions();
                this.definePlacementDataContainerSelector();
                this.lazyLoadModules();
            }

            definePlacementDataContainerSelector() {
                this.placementData['container-selectors'] = [{
                    container: this.contentSelector,
                    location: 'first',
                    shouldCreateContainer: true,
                    isFloatingUnit: true
                }];
            }

            setFloatingUnitOptions() {
                this.floatingUnitOptions = this.videoList[this.unit.responseKey] || {};
                this.floatingUnitOptions.unit = this.unit;
            }

            setNextUpSpecificOptions() {    
                this.floatingUnitOptions.nupOverlayConfig = this.trcManager.global['nup-overlay-config']
                    ? JSON.parse(this.trcManager.global['nup-overlay-config'])
                    : {};
            }

            lazyLoadModules() {
                TRC.ModuleLoader.load('floating-unit', TRC.FloatingUnit, (() => {
                    this.lazyLoadChildClass();
                }).trcBind(this));
            }

            lazyLoadChildClass() {
                if (this.unit.responseKey === FLOATING_UNITS.NEXT_UP.responseKey) {
                    this.setNextUpSpecificOptions();
                }
                TRC.ModuleLoader.load(this.unit.moduleFileName, TRC[this.unit.moduleClass], (() => {
                    const Unit = TRC[this.unit.moduleClass];
                    new Unit(this.floatingUnitOptions, this.trcManager, this.contentElement, this.placementData);
                    this.trcManager.initRBoxDrawingIfPlacementEligible(this.placementData);
                }).trcBind(this));
            }

            createElementForFloatingUnitContent() {
                const floatingUnitContent = document.createElement('div');
                floatingUnitContent.id = this.unit.contentElementId;
                floatingUnitContent.className = this.unit.contentElementId;
                TRC.dom.addClass(floatingUnitContent, 'tbl-hidden');
                this.contentElement = document.body.appendChild(floatingUnitContent);
            }

            static isFloatingUnit(videoList) {
                return videoList && !!FloatingUnitGenerator.getUnitByResponseKey(videoList);
            }
        }

        FloatingUnitGenerator.isFloatingUnitOn = false;

        TRC.FloatingUnitGenerator = FloatingUnitGenerator;
    })();

    /**
     * fraud.js
     * This module is responsible to load 3rd party fraud company script
     * and call the company's function  when a user clicks on sponsored item
     */
    (function () {
        var TABOOLA_ID = 1000075;
        var initParams = {};
        var currentURL = "";
        var sdkData;

        function init(publisherId, uid, ref, trcManager, viewId) {
            var fraudScriptPath;
            currentURL = getCurrentURL();
            sdkData = (TRCImpl.additional_data && TRCImpl.additional_data.sdkd) || {};
            var pubDomain = getPubDomain();
            var path = trcManager.global['fraud-detection-script-url'] || 'https://js.ad-score.com/score.min.js?pid=' + TABOOLA_ID + '#';
            var params = initParams = {
                tid: getTID(),
                l1: publisherId,
                l4: ref,
                uid: uid,
                tt: 'g',
                pub_domain: pubDomain,
                ref: ref,
            };
            if (sdkData.appid) {
                params["l3"] = params["pub_app"] = sdkData.appid;
            }
            else {
                params["l3"] = TRC.platform_code;
            }

            fraudScriptPath = TRC.URL.prototype.switchProtocol.call(path, TRC.PROTOCOL) + TRC.util.keys(params).map(function (k) {
                return encodeURIComponent(k) + '=' + encodeURIComponent(params[k]);
            }).join('&');

            this.isInitialized = true;
            loadFraudScript(fraudScriptPath, {
                impressionUTID: {
                    enabled: trcManager.global['fraud-enable-impression-utid'] === true,
                    publisherId: publisherId,
                    userId: uid,
                    viewId: viewId
                }
            });
        }

        function fraudScriptCallback(placement, uid, UTID, referrer, itemIndex, isTRCUrl) {
            setTimeout(function () {
                try {
                    if (TRC.clickFraudDetect.isLoaded) {
                        var params = {};
                        var impUTID = TRC.clickFraudDetect.impressionUTID;
                        TRC.util.keys(initParams).forEach(function (key) {
                            params[key] = initParams[key];
                        });
                        params['pid'] = '' + TABOOLA_ID + '';
                        params['l2'] = placement;
                        params['l3'] = params['l3'] || TRC.platform_code;
                        params['l4'] = referrer;
                        params['l5'] = itemIndex;
                        params['l6'] = 'clicked';
                        params['uid'] = uid;
                        params['utid'] = impUTID ? impUTID + '_' + UTID : UTID;
                        params['isTRCUrl'] = isTRCUrl;

                        //call Protected Media click function
                        adScore('send', 'adclick', {}, params);
                    }
                    else {
                        __trcWarn('Fraud script did not render', e);
                    }
                }
                catch (e) {
                    __trcWarn('fraudScriptCallback: Error in fraud detection', e);
                }
            }, 0);
        }

        function hasMobileSDK() {
            return TRC.MobileSdk.isEnabled();
        }

        function getCurrentURL() {
            if (!hasMobileSDK()) {
                return (TRC.isAMP && window.context && window.context.canonicalUrl) || TRC.pageManager.getTopMostWindow().location.href;
            }

            var urlData = TRC._taboolaClone && TRC._taboolaClone.filter(function (data) {
                return !!data.url;
            });
            return (urlData && urlData.url) || window.location.href;
        }

        function getPubDomain() {
            var linkElement = document.createElement("a");
            linkElement.href = currentURL || getCurrentURL();
            return linkElement.hostname;
        }

        function getTID() {
            if (hasMobileSDK()) {
                return "_InAPP";
            }
            if (TRC.platform_code === "PHON") {
                return "_MW";
            }
            return "_Desktop";
        }

        function onFraudScriptLoaded(config) {
            TRC.clickFraudDetect.isLoaded = true;
            // send a warning message in order to monitor how often we load protected media
            __trcWarn('protected media: onFraudScriptLoaded');
            if (config.impressionUTID.enabled) {
                setImpressionUTID(config.impressionUTID);
            }
        }

        function setImpressionUTID(config) {
            var impUTID = [config.viewId, config.publisherId, config.userId].join('-');

            if (!config.publisherId || !config.userId || !config.viewId) {
                __trcError('Error in clickFraudDetect.setImpressionUTID: missing parameters');
                return;
            }

            try {
                window.adScore('set', 'utid', {}, {
                    pid: TABOOLA_ID,
                    utid: impUTID
                });
                TRC.clickFraudDetect.impressionUTID = impUTID;
            }
            catch (e) {
                __trcError('Failed to set fraud UTID on impression', e);
            }
        }

        function loadFraudScript(fraudScriptPath, config) {
            // send report to monitor how much we  load protected media
            __trcWarn('protected media: loadFraudScript');
            if (TRC.botDetected) {
                return;
            }
            try {
                TRC.net.loadScript(
                    fraudScriptPath,
                    'js',
                    onFraudScriptLoaded.bind(null, config),
                    null,
                    true
                ); //load Protected Media script on the page
            }
            catch (e) {
                __trcWarn('loadFraudScript: Error appending fraud script', e);
            }
        }

        TRC.clickFraudDetect = {
            init: init,
            fraudScriptCallback: fraudScriptCallback,
            isInitialized: false,
            isLoaded: false,
            impressionUTID: null
        };
    })();

    TRC.util = (function(win, doc) {
    	var modObject = {
    		/**  core Types
    		 * @method isType
    		 * @param {any} arg - all types
    		 * @param {String} type
    		 * @return {Boolean}
    		 **/
    		isType :  function(arg, type) {
        		type = type.charAt(0).toUpperCase() + type.substr(1);
        		return Object.prototype.toString.call(arg) == '[object ' + type + ']';
    		},
    		/** check if an object has own properties
    		 *  @method hasOwnProperties
    		 *  @param {Object} obj
    		 *  @return {Boolean}
    		 */
    		 hasKeys : function(obj){
    		     var i;
    		     if(this.isType(obj, "object")){
                    if(Object.keys && !Object.propertyIsEnumerable("keys")){
                        if(Object.keys(obj).length > 0){
                            return true;
                        }
                    } else {
                        for (i in obj){
                            if (obj.hasOwnProperty (i)){
                                return true;
                            }
                        }
                    }
    		     }
    		     return false;
    		 },
    		getRandomIds : function(conf){// arr, len, strength,prefix, suffix
    			for(var i = 0;  i < conf.len; i++){
    				conf.arr[i] = conf.prefix + Math.floor(Math.random()*(Math.pow(10,conf.strength))+1) + conf.suffix;
    			}
    		},
            /**
             * getHtmlDecodeText - remove Html entities
             * @param {String} - text
             */
            getHtmlDecodeText : (function() {
                var element = doc.createElement("div");

                // Try to decode HTML characters without innerHTML (which is super slow).
    	        var decodeSpecialCharacters = (function () {
    		        var DecodeHTMLMap = {
    			        "amp": "&",
    			        "apos": "'",
    			        "#x27": "'",
    			        "#x2F": "/",
    			        "#39": "'",
    			        "#47": "/",
    			        "lt": "<",
    			        "gt": ">",
    			        "nbsp": " ",
    			        "quot": "\"",
    		        };
    		        var RegexSpecialCharacters = /&(#(?:x[0-9a-f]+|\d+)|[a-z]+);?/gi;

    		        function _replaceSpecial($0, $1) {
    			        if ($1[0] === "#") {
    				        return String.fromCharCode($1[1].toLowerCase() === "x" ? parseInt($1.substr(2), 16) : parseInt($1.substr(1), 10));
    			        }
    			        else {
    				        return DecodeHTMLMap[$1] || $0;
    			        }
    		        }

    		        return function (text) {
    			        return text.replace(RegexSpecialCharacters, _replaceSpecial);
    		        };
    	        }());

    	        return function (text) {
    				if (typeof text !== 'string') {
    					return '';
    				}

    				if (!TRC.dom.isHtmlContent(text)) {
    					return text;
    				}

    				var elementText = decodeSpecialCharacters(text);
    		        if (!TRC.dom.isHtmlContent(elementText)) {
    			        return elementText;
    		        }

    				element.innerHTML = encodeURI(text);
    				elementText = element.textContent || element.innerText;
    				return decodeURI(elementText);
    			};
    		})(),
            /**
             * test if the entire string is blank, null or undefined
             * @param str
             * @returns {boolean}
             */
            isEmptyString : function(str){
                return (!str || /^\s*$/.test(str));
            },
            /**
             * polyfill to Object.keys
             * From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
             */
            keys : (function() {
                "use strict";
                if(Object.keys){
                    return function(obj){
                        if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                            return []; // modified from source - don't want to throw an error on the publisher's page
                        }
                       return Object.keys(obj);
                    }
                }

                var hasOwnProperty = Object.prototype.hasOwnProperty,
                    hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'), // for IE8-
                    dontEnums = [
                        'toString',
                        'toLocaleString',
                        'valueOf',
                        'hasOwnProperty',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'constructor'
                    ],
                    dontEnumsLength = dontEnums.length;

                return function(obj) {
                    if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                        return []; // modified from source - don't want to throw an error on the publisher's page
                    }

                    var result = [], prop, i;

                    for (prop in obj) {
                        if (hasOwnProperty.call(obj, prop)) {
                            result.push(prop);
                        }
                    }

                    if (hasDontEnumBug) {
                        for (i = 0; i < dontEnumsLength; i++) {
                            if (hasOwnProperty.call(obj, dontEnums[i])) {
                                result.push(dontEnums[i]);
                            }
                        }
                    }
                    return result;
                };
            }()),

            /**
             * merge copy own properties from objects to a target a object
             * @param to {Object} - target object
             * @returns {Object} - target object
             */
            merge : function(to /*, {Object} , ... */) {
                "use strict";
                if (to === undefined || to === null) {
                    return null;
                }
                var util = TRC.util;

                for (var i = 1; i < arguments.length; i++) {
                    var nextSource = arguments[i];
                    if (nextSource === undefined || nextSource === null) {
                        continue;
                    }

                    var keysArr = util.keys(nextSource);
                    for (var y = 0, nextKey, len = keysArr.length; y < len; y++) {
                        nextKey = keysArr[y];
                        to[nextKey] = nextSource[nextKey];
                    }
                }
                return to;
            },
            debounce : function(func, wait, immediate, ctx) {
            var timeout;
                return function() {
                    var context = ctx || window, args = arguments;
                    var later = function() {
                        timeout = null;
                        if (!immediate) func.apply(context, args);
                    };
                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                };
            },
    		retry: function(cb, delay, maxRetryCount, argsArray) {
    			var retryCount = 0;
    			var isSuccess = false;
    			return function perform() {
    				setTimeout(function() {
    					isSuccess = cb.apply(cb, argsArray);
    					retryCount++;
    					if (retryCount < maxRetryCount && !isSuccess) perform();
    				}, delay);
    			}
    		},
    		/**
    		 * Preprocess JSON string and convert all keys/values with Single Quote (') to Double Quote ("). In addition,
    		 * it replace all Double Quote inside a word to `\"` as part of the string if exist.
    		 * @param {string} jsonContent
    		 * @return {string}
    		 */
    		preprocessJsonString: function (jsonContent) {
            	if (typeof jsonContent !== "string") {
            		return "";
    	        }

            	var JSON_SINGLE_QUOTE = [
    		        {
    		        	regex: /({|\[)\s*'/g,
    			        replace: '$1"',
    		        },
    		        {
    		        	regex: /'\s*(:|}|,|\])/g,
    			        replace: '"$1',
    		        },
    		        {
    		        	regex: /(:|,)\s*'/g,
    			        replace: '$1"',
    		        },
    		        {
    		        	regex: /(?:([^"\s:\[{,])"([^"\s:,\]}]))/g,
    			        replace: '$1\\"$2',
    		        },
    	        ];

    			JSON_SINGLE_QUOTE.forEach(function(search) {
    				jsonContent = jsonContent.replace(search.regex, search.replace);
    			});

            	return jsonContent;
    		},
            jsonParseWithNative: function(text){
                try{
                    return JSON.parse(text);
                } catch(e){
                    return TRC.util.jsonParseWithEval(text);
                }
            },
            jsonParseCustomNative: function(text){
    			if (win.TRCImpl && win.TRCImpl.global && TRC.util.isTrue(TRCImpl.global['enable-json-parse-preprocess'])) {
    				try{
    					return JSON.parse(TRC.util.preprocessJsonString(text));
    				} catch(e){
    					__trcWarn("JSON Preprocess failed: '" + text + "'");
    					return null;
    				}
    			}
                return TRC.util.jsonParseWithEval(text);
            },
            jsonParseWithEval: function(text){
                try{
                    return eval('(' + String(text) + ')');
                } catch(e){
                    throw new Error("JSON parse error - invalid input!");
                }
            },
    		jsonParseSafe: function (text, prop) {
    			try {
    				return typeof text === 'string' ? JSON.parse(text) : text;
    			} catch (e) {
    				__trcDebug('invalid json in: ' + ((prop) ? text[prop] : text));
    				return {};
    			}

    		},
    		isNativeFunction: function(fn) {
    			return (/\{\s*\[native code\]\s*\}/).test('' + fn);
    		},
    		/**
    		 * Filters an object based on a predicate. Retaining keys and order.
    		 * @param {function(any, string, object)} predicate. Called with the value, the key, and the original object.
    		 * @param obj
             * @returns {{}}
             */
    		filterObj: function(predicate, obj) {
    			var result = {};
    			for (var key in obj) {
    				if (obj.hasOwnProperty(key) && predicate.call(this, obj[key], key, obj)) {
    					result[key] = obj[key];
    				}
    			}
    			return result;
    		},
    		/**
    		 * Determines whether a string should be rendered in RTL or LTR based on the characters.
    		 * @param {string} str
    		 * @returns {boolean}
             */
    		textIsRTL: function(str) {
    			if (!str) { return false; }
    			var ltrChars = 'A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02B8\u0300-\u0590\u0800-\u1FFF\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';
    			var rtlChars = '\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC';
    			var matches = str.match(new RegExp('^[^' + ltrChars + rtlChars + ']*(?:([' +
    				ltrChars + ']+)|([' + rtlChars + ']+))'));
    			return !!(matches && matches[2]);
    		},
    		/**
    		 *  return true if testArray is an Array
    		 * @param {object} testArray
    		 * @returns {boolean}
             */
    		isArray: function(testArray){
    			if(testArray && Array === testArray.constructor){
    				return true;
    			} else {
    				return false;
    			}
    		},
    		toArray: function(nodeList) {
    			return [].slice.call(nodeList);
    		},
    		// .map() polyfill from MDN
    		map: function (array, callback, thisArg) {
    			// Production steps of ECMA-262, Edition 5, 15.4.4.19
    			// Reference: http://es5.github.io/#x15.4.4.19
    			if (Array.prototype.map) {
    				return array.map(callback, thisArg);
    			}

    			var T, A, k;

    			if (array == null) {
    				throw new TypeError(' array is null or not defined');
    			}

    			// 1. Let O be the result of calling ToObject passing the |this|
    			//    value as the argument.
    			var O = Object(array);

    			// 2. Let lenValue be the result of calling the Get internal
    			//    method of O with the argument "length".
    			// 3. Let len be ToUint32(lenValue).
    			var len = O.length >>> 0;

    			// 4. If IsCallable(callback) is false, throw a TypeError exception.
    			// See: http://es5.github.com/#x9.11
    			if (typeof callback !== 'function') {
    				throw new TypeError(callback + ' is not a function');
    			}

    			// 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    			if (arguments.length > 1) {
    				T = thisArg;
    			}

    			// 6. Let A be a new array created as if by the expression new Array(len)
    			//    where Array is the standard built-in constructor with that name and
    			//    len is the value of len.
    			A = new Array(len);

    			// 7. Let k be 0
    			k = 0;

    			// 8. Repeat, while k < len
    			while (k < len) {

    				var kValue, mappedValue;

    				// a. Let Pk be ToString(k).
    				//   This is implicit for LHS operands of the in operator
    				// b. Let kPresent be the result of calling the HasProperty internal
    				//    method of O with argument Pk.
    				//   This step can be combined with c
    				// c. If kPresent is true, then
    				if (k in O) {

    					// i. Let kValue be the result of calling the Get internal
    					//    method of O with argument Pk.
    					kValue = O[k];

    					// ii. Let mappedValue be the result of calling the Call internal
    					//     method of callback with T as the this value and argument
    					//     list containing kValue, k, and O.
    					mappedValue = callback.call(T, kValue, k, O);

    					// iii. Call the DefineOwnProperty internal method of A with arguments
    					// Pk, Property Descriptor
    					// { Value: mappedValue,
    					//   Writable: true,
    					//   Enumerable: true,
    					//   Configurable: true },
    					// and false.

    					// In browsers that support Object.defineProperty, use the following:
    					// Object.defineProperty(A, k, {
    					//   value: mappedValue,
    					//   writable: true,
    					//   enumerable: true,
    					//   configurable: true
    					// });

    					// For best browser support, use the following:
    					A[k] = mappedValue;
    				}
    				// d. Increase k by 1.
    				k++;
    			}

    			// 9. return A
    			return A;
    		},
    		isTrue: function(value) {
    			return value === 'true' || value === true || value === "1";
    		},
    		isFalse: function(value) {
    			return !value || value === 'false';
    		},
    		isDefined: function(value) {
    			return value !== undefined;
    		},
    		isNotDefined: function(value) {
    			return value === undefined || value === null;
    		},
    		isEnabledByDefault: function(value) {
    			return TRC.util.isDefined(value) ? TRC.util.isTrue(value) : true;
    		},
    		getPositiveNumber: function(stringValue, defaultValue) {
    			var number = Number(stringValue);
    			return number > 0 ? number : defaultValue;
    		},
    		isNumber: function(num) {
    			if (TRC.util.isType(num, 'string')) {
    				if (!num.trim()) return false;
    			} else if (!TRC.util.isType(num, 'number')) {
    				return false;
    			}

    			return (num - num + 1) >= 0 ;
    		},
    		parseTimeout: function (value, defaultValue) {
    			defaultValue = typeof defaultValue !== 'undefined' ? defaultValue : -1;
    			var hasValue = typeof value !== 'undefined';
    			return hasValue ? parseInt(value, 10) : defaultValue;
    		},

    		// This function allow you to add more items if needed.
    		splitUrlParts: (function() {
    			var linkElement = document.createElement("a");
    			return function (url) {
    				if (!url) {
    					return {};
    				}
    				linkElement.href = url;
    				return {
    					// hash: linkElement.hash,
    					// host: linkElement.host,
    					// hostname: linkElement.hostname,
    					// origin: linkElement.origin,
    					// pathname: linkElement.pathname,
    					// protocol: linkElement.protocol,
    					search: linkElement.search,
    				}
    			}
    		}()),
            hashString: function (str) {
                var hash = 0;
                if (str.length == 0) return hash;
                for (var i = 0; i < str.length; i++) {
                    var char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash;
            },
    		isPercentEnabled : (function (){
    				var flags = {};
    				if(window._trcIsUTactive) {
    					TRC._rolledFlagsByPercent = flags;
    				}
    				return function (flagMap, flagName) {
    					if(flags[flagName] === undefined || flags[flagName] === null){
    						var participationRoll = Math.random();
    						flags[flagName] = flagMap[flagName] === 'true' || participationRoll <= +(flagMap[flagName]);
    					}
    					return flags[flagName];
    				};
    		})(),
    		haveMutualKeys: function (obj1, obj2) {
    			if(!obj1 || !TRC.util.hasKeys(obj1) || !obj2 || !TRC.util.hasKeys(obj2)) {
    				return false;
    			}
    			var merged = TRC.util.merge({}, obj1, obj2);
    			return Object.keys(merged).length < Object.keys(obj1).length + Object.keys(obj2).length;
    		},
    		/**
    		 * a copy of T-Recs objectForEach, loops through an object's properties
    		 * @param data
    		 * @param callback
    		 */
    		objectForEach: function(data, callback) {
    			Object.keys(data).forEach(function(key) {
    				callback(key, data[key]);
    			});
    		},
    		/**
    		 * Checks if RBox is executed inside Google AMP
    		 * @param {object} env - The RBox environment
    		 * @returns {boolean}
    		 */
    		isAmp: function (env) {
    			return !!env.isAMP;
    		},
    		/**
    		 * Checks is RBox is executed by the mobile SDK
    		 * @param {object} env - The RBox environment
    		 * @returns {boolean}
    		 */
    		isMobileSDK: function (env) {
    			return !!(env.mobile && env.mobile.reportClick);
    		},
    		/**
    		 * Checks if RBox is executed inside a "sandbox"
    		 * that isolates it from the rest of the content
    		 * @param {object} env - The RBox environment
    		 * @returns {boolean}
    		 */
    		isRboxEncapsulated: function (env) {
    			return !!(this.isAmp(env) || this.isMobileSDK(env));
    		},
    		/**
    		 * Format string templates ({0} {1} {2}) through an array
    		 * @returns {string}
    		 * @param {string} message - string to modify
    		 * @param {any[]} args - items to use instead of curly templates
    		 */
    		formatString: function(message, args) {
    			var result;
    			if (!args || args.length === 0) {
    				result = message;
    			} else {
    				result = message.replace(/\{(\d+)\}/g, function (match, rest) {
    					var index = rest[0];
    					return typeof args[index] !== 'undefined' ? args[index] : match;
    				});
    			}
    			return result;
    		},
    		addSupportForGoogleFonts: function() {
    			var googleFontsArr = TRCImpl && TRCImpl.global['google-fonts'] || [];
    			googleFontsArr.forEach(function (fontName) {
    				var fontLinkEl = document.createElement('link');
    				fontLinkEl.setAttribute('rel', 'stylesheet');
    				fontLinkEl.setAttribute('type', 'text/css');
    				var fontAPILink = 'https://fonts.googleapis.com/css2?family=' + fontName + ':ital,wght@0,100;0,200;'
    					+ '0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;'
    					+ '1,900&display=swap';
    				fontLinkEl.setAttribute('href', fontAPILink);
    				document.head.appendChild(fontLinkEl);
    			});
    		},
    		getFeatureFlagData: function(featureFlag){
    			if(!win.TRCImpl || !win.TRCImpl.global){
    				return null;
    			}
    			return win.TRCImpl.global[featureFlag];
    		},
    		isMixpanelEventDisabled: function(eventName) {
    			var disabledMixPanelEvents = this.getFeatureFlagData('disabled-mixpanel-events');
    			if(!disabledMixPanelEvents){
    				return false;
    			}
    			disabledMixPanelEvents = disabledMixPanelEvents.map(function(eventName){
    				return eventName.toUpperCase();
    			});
    			if (disabledMixPanelEvents.indexOf(eventName.toUpperCase()) > -1) {
    				return true;
    			}
    			return false;
    		},
    		/**
    		 * Send sample supply feature event
    		 * @param {string}		type feature defined in pubs.proto
    		 * @param {string}		state feature defined in pubs.proto
    		 * @param {String}		(optional) message string value describe the event
    		 * @param {string}		(optional) value string value for extra info
    		 * @param {object}		(optional) postParams property list with additional parameters to send
    		 * @param {Boolean}		(optional) once optionally use log1 to send the event
    		 * @param {Function}	(optional) callback optionally trigger this callback after the event is received by the
    		 *     server
    		 * @param {Number}		(optional) timeout number milliseconds
    		 */
    		sendSupplyFeature: function (type, state, message, value,key,postParams, once, callback, timeout){
    			if(typeof type !== 'string' || typeof state !== 'string'){
    				return;
    			}
    			var requestData = {
    				event_type: type,
    				event_state: state,
    				event_value: typeof value === 'string' ? value : '',
    				event_msg: typeof message === 'string' ? message : '',
    				event_key: typeof key === 'string' ? key : ''
    			};
    			if (typeof win.TRCImpl.sendEvent === 'function') {
    				win.TRCImpl.sendEvent('supply-feature', {d: win.__trcJSONify(requestData)},postParams, once, callback, timeout);
    			}
    		},
    		generateUid: function(len) {
    			var result = '';
    			var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    			var charactersLength = characters.length;
    			for (var i = 0; i < len; i++) {
    				result += characters.charAt(Math.floor(Math.random() * charactersLength));
    			}
    			return result;
    		},
    		getCookieByName: function (name) {
    			var cookieName = name + "=";
    			var allCookies = "; " + document.cookie;
    			var cookies = allCookies.split(';');
    			for (var i = 0; i < cookies.length; i++) {
    				var cookie = cookies[i];
    				while (cookie.charAt(0) === ' ') {
    					cookie = cookie.substring(1, cookie.length);
    					if (cookie.indexOf(cookieName) === 0) {
    						return cookie.substring(cookieName.length, cookie.length);
    					}
    				}
    			}
    			return null;
    		}
    	};
    	return modObject;
    }(window, document));

    /*
     * Definition of global (window-scoped) utility functions
     * (everything here should be destroyed/moved to a proper name space)
     */


    // private name space is emulated by declaring names that start with __ (like in Python)

    /**
     * Helper method to duplicate objects
     * @param src original object from which to copy properties
     * @param dest target object into which to copy properties - use {} to init a new object
     * @return target object with added properties
     */
    window.__trcCopyProps  = function(src, dest, newProp) {
    	for (prop in src) {
    		dest[prop] = src[prop];
    	}
    	if(newProp){
    		for (var prop in newProp){
    			dest[prop] = newProp[prop];
    		}
    	}
    	return dest;
    };

    /* Logging and error reporting */

    /**
     * Create a readable error description from a browser-specific error object
     * @param error object returned by the browser
     * @return string with error description
     */
    window.__trcFromError = function(error) {
    	if (TRC.Browser.ie && error.message)
    		return error.message + "[" + error.number + ": " + error.name + "]";
    	if (error.message)
    		return error.message + (error.fileName ? error.fileName + ":" + error.lineNumber : "");
    	return error;
    };

    /**
     * Generate client side timestamp in the form HH:MM:SS.mmm - used for logging
     */
    window.__trcClientTimestamp = function() {
    	var ts = new Date();
    	var hours = ts.getHours();
    	var mins = ts.getMinutes();
    	var secs = ts.getSeconds() + ts.getMilliseconds()/1000;

    	return (hours < 10 ? '0' : '') + hours + ':' +
    	       (mins < 10 ? '0' : '')  + mins + ':' +
    	       (secs < 10 ? '0' : '')  + secs.toFixed(3);
    };

    /**
     * Log messages to the error console and to the server
     * @param level Logging level - lower is more serious
     * @param msg - Message to log
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcLog = function __trcLog(level, msg, error, serverLoggingPercentage, shouldUseBeacon) {

    	function shouldReportErrorStack(error) {
    		return error && error.stack
    			&& window.TRCImpl && TRC.util
    			&& TRC.util.isPercentEnabled(window.TRCImpl.global, 'rbox-error-stack-reporting-pct');
    	}

    	function shouldReportUrl() {
    		return window.TRCImpl && TRC.util && level === 0
    			&& TRC.util.isPercentEnabled(window.TRCImpl.global, 'rbox-error-fullUrl');
    	}

    	function getFullUrl(){
    		var urlMaxLength = TRCImpl && TRCImpl.global['rbox-err-url-max-length'] || 250;
    		var fullUrl = window.location.href.substr(0, urlMaxLength);

    		if(TRC.util.isAmp(TRC) && context && context.data){
    			fullUrl = context && context.data.url;
    		}
    		return fullUrl;
    	}

    	// check if we need to log messages to the server - if someone set the cookie or its a serious error
    	function shouldLogToServer(level, serverLoggingPercentage) {
    		return (Math.random() <= +serverLoggingPercentage)
    			&& (level <= window.trc_debug_level
    				// Check for Apple News MRAID document.cookie
    				|| (document.cookie && document.cookie.search('taboola-debug') > 0))
    	}

    	TRC.pConsole("page", TRC.modDebug.getType(level), msg, msg);
        if(level == "0"){
            TRC.pConsole("errors", TRC.modDebug.getType(level), msg, msg);
        }
    	// allow a pager to override the logging level by using the 'taboola-debug' parameter
    	if (window.trc_debug_level < level){
    		return;
    	}

    	//TODO : change console mechanism
    	if (typeof window.console == 'object'){
    		console.log(msg);
    	}

    	try {
    		if(isNaN(serverLoggingPercentage) || serverLoggingPercentage === null) {
    			serverLoggingPercentage = 1;
    		}

    		if (shouldLogToServer(level, serverLoggingPercentage)){
    			var extraLogParams = {
    				pct: serverLoggingPercentage
    			};
    			if(shouldReportErrorStack(error)) {
    				var stackMaxLength = TRCImpl && TRCImpl.global['rbox-err-stack-max-length'] || 250;
    				extraLogParams.errStack = error.stack.substr(0, stackMaxLength);
    			}

    			if(shouldReportUrl()){
    				extraLogParams.fullUrl = getFullUrl();
    			}

    			TRC.modDebug.logMessageToServer(level, msg, extraLogParams, shouldUseBeacon);
    		}
    	}
    	catch (e) {
    		// Will reach here if the sandbox blocking the usage of cookies. it mostly for MRAID ads.
    	}
    };

    /**
     * Log an error message to the server and to the error console
     * @param msg - Message to report
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcError = function(msg, error, serverLoggingPercentage) {
    	__trcLog(0, msg + (error ? ": " + __trcFromError(error) : ""), error, serverLoggingPercentage);
    	if (error && error.stack && (typeof window.console != 'undefined') && console.trace)
    		console.trace();
    };

    /**
     * Log a debug message to the error console
     * @param msg - Message to report
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcDebug = function(msg, error, serverLoggingPercentage) {
    	__trcLog(3, msg, error, serverLoggingPercentage);

    };

    /**
     * Log an informational message to the error console
     * @param msg - Message to report
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcInfo = function(msg, error, serverLoggingPercentage) {
    	if(TRC.util.isPercentEnabled(TRCImpl.global, 'trcinfo-sample-rate')) {
    		__trcLog(2, msg, error, serverLoggingPercentage);
    	}
    };


    /**
     * Log a warning message to the server and to the error console
     * @param msg - Message to report
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcWarn = function(msg, error, serverLoggingPercentage) {
    	__trcLog(1, msg + (error ? '(' + error + ')' : ''), error, serverLoggingPercentage);
    };

    /**
     * Log a warning message to the server using the Beacon API and to the error console
     * @param msg - Message to report
     * @param error (optional) - error object provided by the browser - set this to the exception if you caught one.
     * @param serverLoggingPercentage (optional) - a number between 0 and 1 representing the
     * 											percentage of times that this error should be reported to the server
     */
    window.__trcWarnUsingBeacon = function __trcWarnUsingBeacon(msg, error, serverLoggingPercentage) {
    	__trcLog(1, msg + (error ? '(' + error + ')' : ''), error, serverLoggingPercentage, true);
    };

    /**
     * Iterates thru a node descendants
     * @param node - item to iterate thru its childeren
     * @param func - a function to call against each node
     */
    window.__trcDOMWalker = function(node, func) {
        func(node);
        node = node.firstChild;
        while (node) {
            arguments.callee(node, func);
            node = node.nextSibling;
        }
    };

    /**
     * JSON namespaced local implementation
     * @param obj
     */
    window.__trcJSONify = function(obj){
      	return window.JSON.stringify(obj)
    };

    /**
     * JSON namespaced local implementation
     */
    window.__trcUnJSONify = function(json) {
    	try {
    		return typeof json === 'string' ? TRC.util.jsonParseWithNative(json) : json;
    	} catch (e) {
    		throw new Error('JSON parse update error - invalid input! ' + json);
    	}
    };

    // Next are some methods that, to the best of my knowledge, are not now defined in some
    // funky javascript library, but with all those 3rd party JavaScript APIs and new
    // browser extension, one can't be really sure of these things. So I'm playing it safe
    // for now with our local namespace, and I'll leave future me to consolidate any future
    // APIs that appear and we'd want to use but are not compatible with what I set here.

    // try to figure out the CSS property for some element
    if (typeof document.trcGetCurrentStyle == 'undefined') {
    	document.trcGetCurrentStyle = function(el,styleProp, pseudo) {
    		if (typeof el == 'string'){
                el = document.getElementById(el);
            }
            if (window.getComputedStyle) {
    			var computedStyle = window.getComputedStyle(el, pseudo);

    			if(computedStyle) {
                    return computedStyle.getPropertyValue(styleProp);
                }

                if(!pseudo) {
                	return el.style[styleProp];
    			}

                return null;
            } else {
                styleProp = styleProp.replace(/-(\w)/, function(s,a) { return a.toUpperCase(); });
                return el.currentStyle[styleProp];
            }
    		return null;
    	};
    }

    /**
     * __trcTrim
     * @param {String} str value
     *
     * delete leading and ending spaces on a string
     */
    window.__trcTrim = function(str){
    	return str.replace(/^\s+|\s+$/g,'');
    };

    /**
     * __trcGetElementsByClass
     * @param {String} className - name of class to search
     * @param {String} tag - optional tag name
     * @param {Element} node - optional node to search from, default: document
     * @returns {Array} of elements (or empty array)
     * @type Array
     */
    window.__trcGetElementsByClass = function(className, tag, node ) {
    	var result = [],
    		pattern = new RegExp("(^|\\s)" + className + "(\\s|$)"),
    		elements,
    		elementsLength,
    		i;

    	node = node || document;
    	tag = tag || '*';

    	elements = node.getElementsByTagName(tag);
    	elementsLength = elements.length;
    	for (i = 0; i < elementsLength; i++) {
    		if (!!pattern.test(elements[i].className)) {
    			result.push( elements[i]);
    		}
    	}
    	return result;
    };
    /** this will return the object as an array of the form [[key, value],[...],...]
     * @method __trcToArray
     * @param {Object} obj
     * @param {Array} arr
     */
    window.__trcToArray  = function(obj, arr){
        var i;
        for(i in obj){
            if(obj.hasOwnProperty(i)){
                arr.push([i, obj[i]]);
            }
        }
    };
    /** this is a wrapper for Object.create inorder to allow a polyfill for IE older than 9
     * @method __trcObjectCreate
     * @param {Object} prototype
     * taken from https://developer.mozilla.org
     */
    window.__trcObjectCreate = function(prototype) {
    	if (typeof Object.create == 'function') {
    		return Object.create(prototype);
    	}
    	else {
    		var Temp = function() {};
    		if(prototype !== Object(prototype) && prototype !== null) {
    			throw TypeError('Argument must be an object, or null');
    		}
    		Temp.prototype = prototype || {};
    		var result = new Temp();
    		Temp.prototype = null;
    		// to imitate the case of Object.create(null)
    		if(prototype === null) {
    			result.__proto__ = null;
    		}
    		return result;
    	}
    };
    // support delegating functions with pre-binding object context using a local closure
    if (!Function.prototype.trcBind) {
    	Function.prototype.trcBind = Function.prototype.bind;
    }
    /**
     * delay function excution :
     *  ....window.onresize = myFunction.trcThrottle(100);....
     *  @param {time} @type{Number}  -  miliseconds
     */
    if (typeof Function.prototype.trcThrottle == 'undefined') {
    	Function.prototype.trcThrottle = function(time) {
        	var timeout, fn = this;
        	return function() {
          		var args = arguments;
          		if (timeout){
          			clearTimeout(timeout);
          		}
          		timeout = setTimeout(function(){fn.apply(fn,args);}, time);
        	}
     	};
    }

    // Emulate HTML5's document.head
    if (typeof document.head == "undefined")
    	document.head = document.getElementsByTagName('head')[0];

    // stub for the google ad service
    TRC.GoogleAds = function(){
        if (typeof window.console == 'object'){
            console.log("TRC.GoogleAds is Deprecated");
        }
        return {
            draw :  function(){}
        }

    };
    /***
     * general math utilities
     */
    TRC.math = TRC.math ||  (function(win, doc) {
        /**
         * Decimal adjustment of a number.
         *
         * @param	{String}	type	The type of adjustment.
         * @param	{Number}	value	The number.
         * @param	{Integer}	exp		The exponent (the 10 logarithm of the adjustment base).
         * @returns	{Number}			The adjusted value.
         *
         * from https://developer.mozilla.org
         */
       function decimalAdjust(type, value, exp) {
            // If the exp is undefined or zero...
            if (typeof exp === 'undefined' || +exp === 0) {
                return Math[type](value);
            }
            value = +value;
            exp = +exp;
            // If the value is not a number or the exp is not an integer...
            if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
                return NaN;
            }
            // Shift
            value = value.toString().split('e');
            value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
            // Shift back
            value = value.toString().split('e');
            return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
       }


       return {
           /**
            * rounds a deicmal number to the nearest integer by a factor value
            * @param {number} num - decimal number
            * @param {number} factor - decimal number
            * @returns {number}
            */
           roundByDecimal : function roundByDecimal(num, factor){
               var frac = num / factor,
                   fixed0 = frac.toFixed(0),
                   remnant = frac - fixed0;
               return ( (fixed0 * factor) + (factor * Math.round(remnant)));
           },
           /**
            *
            * @param {number} value - decimal number
            * @param {number} exp - percision
            * @returns {Number}
            */
           round10 :  function(value, exp) {
               return decimalAdjust('round', value, exp);
           }
       }
    })(window, document);

    (() => {

        const CARD_ELEMENT_CLASS = 'trc_rbox_div',
            ITEM_CLASS = 'videoCube',
            ITEM_LINK_THUMBNAIL_CLASS = 'item-thumbnail-href',
            ITEM_LINK_LABEL_CLASS = 'item-label-href';

        class Heatmap {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.itemAppearanceTime = {};
            }

            static isEnabled(trcManager) {
                return TRC.util.isPercentEnabled(trcManager.global, 'enable-rbox-heatmap');
            }

            captureItemTime(itemId) {
                this.itemAppearanceTime[itemId] = Date.now();
            }

            captureAndSendClickData(clickEvent) {
                // if the click is not in a card, it should be discarded.
                // if the click is inside link, we take care of it in link redirection code
                if (!isInsideCard(clickEvent) || isInsideLink(clickEvent)) {
                    return;
                }
                const clickEventHeatmapData = Heatmap.collectClickHeatmapCardData(clickEvent);

                // collect additional data for click inside items
                if (isInsideItem(clickEvent)) {
                    clickEventHeatmapData['item-d'] = this.collectClickHeatmapItemData(clickEvent);
                }

                this.trcManager.sendEvent('heatmap', {d: JSON.stringify(clickEventHeatmapData)}, {});

                function isInsideLink(clickEvent) {
                    return TRC.dom.closest(clickEvent.target, `a.${ITEM_LINK_THUMBNAIL_CLASS}`) || TRC.dom.closest(clickEvent.target, `a.${ITEM_LINK_LABEL_CLASS}`);
                }

                function isInsideItem(clickEvent) {
                    return TRC.dom.closest(clickEvent.target, `.${ITEM_CLASS}`);
                }

                function isInsideCard(clickEvent) {
                    return TRC.dom.closest(clickEvent.target, `.${CARD_ELEMENT_CLASS}`);
                }
            }

            static collectEventTargetData(clickEvent, isCard) {
                const desiredTargetClass = isCard ? CARD_ELEMENT_CLASS : ITEM_CLASS;
                const isClickOnDesiredTarget = TRC.dom.containsClass(clickEvent.target, desiredTargetClass);
                const desiredTargetElement = isClickOnDesiredTarget ? clickEvent.target : TRC.dom.closest(clickEvent.target, `.${desiredTargetClass}`);
                const desiredTargetRects = desiredTargetElement.getClientRects()[0];
                const targetRects = isClickOnDesiredTarget ? {x: 0, y: 0} : clickEvent.target.getClientRects()[0];
                const [clickPointX, clickPointY] = Heatmap.getClickPoints(clickEvent, targetRects);
                const x = isClickOnDesiredTarget ? clickPointX
                    : Math.abs((targetRects.x || targetRects.left) - (desiredTargetRects.x || desiredTargetRects.left)) + clickPointX;
                const y = isClickOnDesiredTarget ? clickPointY
                    : Math.abs((targetRects.y || targetRects.top) - (desiredTargetRects.y || desiredTargetRects.top)) + clickPointY;
                return {
                    el: desiredTargetElement, x, y, h: desiredTargetRects.height, w: desiredTargetRects.width
                };
            }

            static collectClickHeatmapCardData(clickEvent) {
                const targetData = Heatmap.collectEventTargetData(clickEvent, true);
                return {
                    x: targetData.x,
                    y: targetData.y,
                    h: targetData.h,
                    w: targetData.w,
                    'c-time': Math.floor(clickEvent.timeStamp)
                };
            }

            collectClickHeatmapItemData(clickEvent) {
                const targetData = Heatmap.collectEventTargetData(clickEvent, false);
                const appearanceTime = this.itemAppearanceTime[targetData.el.video_data.id];
                const itemData = {
                    x: targetData.x,
                    y: targetData.y,
                    h: targetData.h,
                    w: targetData.w,
                    slot: targetData.el.video_data.itemIndex,
                    'ap-time': appearanceTime
                };
                return itemData;
            }

            static getClickPoints(clickEvent, targetRects) {
                if (isTouchEvent(clickEvent)) {
                    const targetRectsXY = {x: targetRects.x || targetRects.left, y: targetRects.y || targetRects.top};
                    return [clickEvent.touches[0].clientX - targetRectsXY.x, clickEvent.touches[0].clientY - targetRectsXY.y];
                }

                return [clickEvent.offsetX, clickEvent.offsetY];

                function isTouchEvent(clickEvent) {
                    return clickEvent.touches;
                }
            }

        }

        TRC.Heatmap = Heatmap;

    })();

    (() => {
        let rboxInViewObserver,
            rboxPercentInView = 0.1,
            minTreshold = 0.3,
            inViewReported = false;
        const boxes = {};
        const unitTypesList = ['4', '254'];
        const handleHighImpactPlacement = function ({
            mybox,
            containerElm
        }) {
            boxes[mybox.id] = mybox;
            const vTag = (mybox.trcResponse && mybox.trcResponse.vtag) ? mybox.trcResponse.vtag : false;
            const config = vTag.advancedVideoConfiguration ? vTag.advancedVideoConfiguration : false;
            if (!vTag || !checkIfHIP(vTag.unitType, config)) {
                return false;
            }
            if (config) {
                const inViewToReport = config['mid-article-hip-rbox-percent-inview-to-report'];
                const percentToDisplay = config['mid-article-hip-min-percent-to-display'];
                rboxPercentInView = inViewToReport ? Number(inViewToReport) : rboxPercentInView;
                minTreshold = percentToDisplay ? Number(percentToDisplay) : rboxPercentInView;
            }

            createObservers(mybox.id, containerElm);

            containerElm.classList.add('tbl-invisible');

            TRC.listen('noAdjacInFirstWF', event => {
                if (mybox.trcResponse.scac) {
                    TRC.trcHipCloseUnit = TRC.trcHipCloseUnit ? TRC.trcHipCloseUnit : {};
                    TRC.trcHipCloseUnit[event.data] = true;
                }
                TRCImpl.sendAbTestEvent('HipLostNoAdjacInFirstWF', 'HipLost');
                unHideRbox(event.data);
            });

        };

        const checkIfHIP = (unitType, config) => {
            if (config && config['mid-article-hip-opt-out'] === 'true') {
                return false;
            }
            return unitTypesList.indexOf(unitType.toString()) !== -1;
        };

        const createObservers = (rboxId, containerElm) => {
            createRboxInViewObserver(rboxId, containerElm);
            createHipRboxObserver(rboxId, containerElm);
        };

        const createRboxInViewObserver = (rboxId, containerElm) => {
            const thresholds = [];
            for (let i = rboxPercentInView * 10; i <= 10; i++) {
                const ratio = i / 100;
                thresholds.push(ratio);
            }

            const rboxInViewObserverParams = {
                targetElement: containerElm,
                threshold: thresholds,
                onEnter: reportRboxInViewPort.trcBind(undefined, rboxId)
            };

            rboxInViewObserver = TRC.intersections.observe(rboxInViewObserverParams);
        };

        const createHipRboxObserver = (rboxId, containerElm) => {
            const hipRboxObserverParams = {
                targetElement: containerElm,
                threshold: [minTreshold],
                onEnter: HandleRboxInViewPort.trcBind(undefined, rboxId),
                disableDuplicatePrevention: true
            };

            const hipRboxObserver = TRC.intersections.observe(hipRboxObserverParams);
            TRC.listen('adjacAdPlaying', unObserveRbox.trcBind(undefined, hipRboxObserver));
            TRC.listen('rBoxVisible', unObserveRbox.trcBind(undefined, hipRboxObserver));
        };

        const unHideRbox = rboxId => {
            const {container} = boxes[rboxId];
            container.classList.remove('tbl-invisible');
            TRC.dispatch('rBoxVisible', rboxId);
            TRC.trcHipContainersShowing = TRC.trcHipContainersShowing ? TRC.trcHipContainersShowing : {};
            TRC.trcHipContainersShowing[rboxId] = true;
        };

        const HandleRboxInViewPort = (rboxId, intersectionEvent) => {
            TRCImpl.sendAbTestEvent('HipLostRboxInViewPort', Math.floor(intersectionEvent.intersectionRatio * 100));
            unHideRbox(rboxId);
        };

        const reportRboxInViewPort = (rboxId, intersectionEvent) => {
            if (intersectionEvent.intersectionRatio > rboxPercentInView && !inViewReported) {
                inViewReported = true;
                TRCImpl.sendAbTestEvent('rboxViewPortIntersection', Math.floor(intersectionEvent.intersectionRatio * 100));
            } else if (intersectionEvent.intersectionRatio < rboxPercentInView && inViewReported) {
                TRCImpl.sendAbTestEvent('rboxOutOfViewPort', Math.floor(intersectionEvent.intersectionRatio * 100));
                unObserveRbox(rboxInViewObserver);
            }
        };

        const unObserveRbox = observer => {
            TRC.intersections.unobserve(observer);
        };

        TRC.HighImpactPlacement = {
            handleHighImpactPlacement
        };

        if (window._trcIsUTactive) {
            TRC.HighImpactPlacement.reportRboxInViewPort = reportRboxInViewPort;
            TRC.HighImpactPlacement.checkIfHIP = checkIfHIP;
        }

        TRC.listen('beforeBoxRender', handleHighImpactPlacement);

    })();

    (function() {
        var SCROLL_POS_LOCAL_STORAGE_KEY = 'trc_vp_els',
            maxEntries = 5;

        function HistoryManager(trcManager) {
            this.trcManager = trcManager;
            this.sessionStorage = TRC.pageManager.getLocalStorageImplementation('strict-w3c-storage', 'session');
            this.lastViewportElementData = this.getVPElementsHistory()[trcManager.getItemId()];

            trcManager.trcCache.enableCacheViaStorageFlag();
        }

        HistoryManager.prototype.trackElement = function(element) {
            TRC.dom.on(element, 'click', this.storeElementPosition.trcBind(this, element));
        };

        HistoryManager.prototype.scrollToElementIfWasLastInViewPort = function(element) {
            var vpElementsHistory,
                trcManager = this.trcManager;

            if(this.lastViewportElementData && element.id === this.lastViewportElementData.id) {
                vpElementsHistory = this.getVPElementsHistory();

                delete vpElementsHistory[this.trcManager.getItemId()];

                this.storeVPElementsHistory(vpElementsHistory);

                if ('scrollRestoration' in window.history) {
                    window.history.scrollRestoration = 'manual';
                }

                setTimeout(function() {
                    element.scrollIntoView(false);
                    
                    var abTestEventData = {
                        abTestsEventType: 'simple',
                        name: 'backToFeed_backToCard',
                        type: __trcJSONify({origViewId: element.placementData.cachedViewId, viewId: TRC.pageManager.getPageData(), placement: element.getAttribute('data-placement-name'), cardIndex: element.getAttribute('data-card-index')}),
                        eventTime: new Date().getTime()
                    };

                    trcManager.sendEvent("abtests",{'unescape-d' : encodeURIComponent(__trcJSONify(abTestEventData))}, null, false, null, null);


                }, 0);
            }
        };

        HistoryManager.prototype.storeElementPosition = function(element) {
            var vpElementsHistory = this.getVPElementsHistory();
                                                       
            vpElementsHistory[this.trcManager.getItemId()] = {
                id: element.id,
                s: new Date().getTime()
            };

            var abTestEventData = {
                abTestsEventType: 'simple',
                name: 'backToFeed_exitFromCard',
                type: __trcJSONify({viewId: TRC.pageManager.getPageData(), placement: element.getAttribute('data-placement-name'), cardIndex: element.getAttribute('data-card-index')}),
                eventTime: new Date().getTime()
            };

            this.trcManager.sendEvent("abtests",{'unescape-d' : encodeURIComponent(__trcJSONify(abTestEventData))}, null, false, null, null);


            this.storeVPElementsHistory(vpElementsHistory);

        };

        HistoryManager.prototype.storeVPElementsHistory = function(historyMap) {
            historyMap = this.removeEntriesToLimit(historyMap);

            this.sessionStorage.setValue(SCROLL_POS_LOCAL_STORAGE_KEY, __trcJSONify(historyMap));
        };

        HistoryManager.prototype.getVPElementsHistory = function() {
            var scrollPositionsStorageValue = this.sessionStorage.getValue(SCROLL_POS_LOCAL_STORAGE_KEY) || '{}';

            return TRC.util.jsonParseWithNative(scrollPositionsStorageValue);
        };

        HistoryManager.prototype.removeEntriesToLimit = function(historyMap) {
            var historyKeysByTimeStamp = {},
                timeStampsArr;

            if(TRC.util.keys(historyMap).length <= maxEntries) {
                return historyMap;
            }

            for(var key in historyMap) {
                if(historyMap.hasOwnProperty(key)) {
                    historyKeysByTimeStamp[historyMap[key].s] = key;
                }
            }

            timeStampsArr = TRC.util.keys(historyKeysByTimeStamp);
            timeStampsArr.sort();

            while(timeStampsArr.length > maxEntries) {
                timeStampsArr.shift();
            }

            for(var ts in historyKeysByTimeStamp) {
                if(historyKeysByTimeStamp.hasOwnProperty(ts)) {
                    if(timeStampsArr.indexOf(ts) === -1) {
                        delete historyMap[historyKeysByTimeStamp[ts]];
                    }
                }
            }

            return historyMap;
        };

        TRC.HistoryManager = HistoryManager;
    })();

    (({history}) => {
        function back() {
            history.back();
        }

        function forward() {
            history.forward();
        }

        function currentState() {
            return history.state;
        }

        function pushState(state) {
            history.pushState(state, document.title);
        }

        function replaceState(state) {
            history.replaceState(state, document.title);
        }

        function appendState(state) {
            let current = currentState();
            if (current == null) {
                current = {};
            }
            Object.assign(current, state);
            history.replaceState(current, document.title);
        }

        function isPageLoading() {
            return window.document.readyState !== 'complete';
        }

        function setManualPopState(callback, stateCheck, intervalTime) {
            const intervalId = TRC.Interval.set(() => {
                if (!isPageLoading()) {
                    TRC.Interval.clear(intervalId);
                }
                if (currentState() && stateCheck(currentState())) {
                    callback();
                    TRC.Interval.clear(intervalId);
                }
            }, intervalTime);
        }

        function onPopState(callback, options) {
            const popStateOptions = Object.assign({
                stateCheck: null,
                stateCheckIntervalTime: 200
            }, options || {});
            TRC.dom.on(window, 'popstate', callback);
            if (isPageLoading() && popStateOptions.stateCheck) {
                setManualPopState(callback, popStateOptions.stateCheck, popStateOptions.stateCheckIntervalTime);
            }
        }

        TRC.historyApi = {
            pushState,
            replaceState,
            appendState,
            back,
            forward,
            currentState,
            onPopState
        };
    })(window);

    (() => {
        const CLOUDINARY_IMAGE_PREFIX = 'https://images.taboola.com/taboola/image/fetch';
        TRC.imageUtils = {
            firstImageID: '',
            getImageUrlBasedOnCloudinaryApi(url, cropDetails, prefix = CLOUDINARY_IMAGE_PREFIX) {
                const encodeUrl = this.cloudinaryEncoding(url);
                return [prefix, cropDetails, encodeUrl].join('/');
            },
            cloudinaryEncoding(url) {
                if (url === null || typeof url === 'undefined') {
                    return '';
                }

                let start = void 0, // eslint-disable-line no-void
                    end = void 0, // eslint-disable-line no-void
                    utfURL = '',
                    n = 0;

                const string = `${url}`,
                    stringLength = string.length;

                start = end = 0;

                while (n < stringLength) {
                    // converting each character in URL to be below 256 bits
                    const c1 = string.charCodeAt(n);
                    let enc = null;
                    if (c1 < 128) {
                        end++;
                    } else if (c1 > 127 && c1 < 2048) {
                        enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128); // eslint-disable-line no-bitwise
                    } else {
                        enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128); // eslint-disable-line no-bitwise
                    }
                    if (enc !== null) {
                        if (end > start) {
                            utfURL += string.slice(start, end);
                        }
                        utfURL += enc;
                        start = end = n + 1;
                    }
                    n++;
                }
                if (end > start) {
                    utfURL += string.slice(start, stringLength);
                }
                return escape(utfURL);
            },
            markLoadPerformance(img) {
                // perf : image load time
                if (!TRC.performance) {
                    return;
                }
                const imgId = Date.now();
                if (!this.firstImageID) {
                    this.firstImageID = imgId;
                }
                TRC.performance.mark(`imgLoad${imgId}start`, null, '', imgId, 'imgLoadTime', TRC.PerfEvenType.START);
                if (imgId === this.firstImageID) {
                    TRC.performance.mark('firstImgLoadstart', null, '', 'firstImage', 'firstImgLoadTime', TRC.PerfEvenType.MARK);
                }
                TRC.dom.on(img, 'load', () => {
                    TRC.performance.mark(`imgLoad${imgId}stop`, null, '', imgId, 'imgLoadTime', TRC.PerfEvenType.STOP);
                    return true;
                });
            }
        }; 
    })();

    /** @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    (function(window, document) {
        "use strict";


    // Exits early if all IntersectionObserver and IntersectionObserverEntry
    // features are natively supported.
        if ('IntersectionObserver' in window &&
            'IntersectionObserverEntry' in window &&
            'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

            // Minimal polyfill for Edge 15's lack of `isIntersecting`
            // See: https://github.com/WICG/IntersectionObserver/issues/211
            if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
                Object.defineProperty(window.IntersectionObserverEntry.prototype,
                    'isIntersecting', {
                        get: function () {
                            return this.intersectionRatio > 0;
                        }
                    });
            }
            return;
        }


        /**
         * An IntersectionObserver registry. This registry exists to hold a strong
         * reference to IntersectionObserver instances currently observering a target
         * element. Without this registry, instances without another reference may be
         * garbage collected.
         */
        var registry = [];


        /**
         * Creates the global IntersectionObserverEntry constructor.
         * https://wicg.github.io/IntersectionObserver/#intersection-observer-entry
         * @param {Object} entry A dictionary of instance properties.
         * @constructor
         */
        function IntersectionObserverEntry(entry) {
            this.time = entry.time;
            this.target = entry.target;
            this.rootBounds = entry.rootBounds;
            this.boundingClientRect = entry.boundingClientRect;
            this.intersectionRect = entry.intersectionRect || getEmptyRect();
            this.isIntersecting = !!entry.intersectionRect;

            // Calculates the intersection ratio.
            var targetRect = this.boundingClientRect;
            var targetArea = targetRect.width * targetRect.height;
            var intersectionRect = this.intersectionRect;
            var intersectionArea = intersectionRect.width * intersectionRect.height;

            // Sets intersection ratio.
            if (targetArea) {
                this.intersectionRatio = intersectionArea / targetArea;
            } else {
                // If area is zero and is intersecting, sets to 1, otherwise to 0
                this.intersectionRatio = this.isIntersecting ? 1 : 0;
            }
        }


        /**
         * Creates the global IntersectionObserver constructor.
         * https://wicg.github.io/IntersectionObserver/#intersection-observer-interface
         * @param {Function} callback The function to be invoked after intersection
         *     changes have queued. The function is not invoked if the queue has
         *     been emptied by calling the `takeRecords` method.
         * @param {Object=} opt_options Optional configuration options.
         * @constructor
         */
        function IntersectionObserver(callback, opt_options) {

            var options = opt_options || {};

            if (typeof callback != 'function') {
                throw new Error('callback must be a function');
            }

            if (options.root && options.root.nodeType != 1) {
                throw new Error('root must be an Element');
            }

            // Binds and throttles `this._checkForIntersections`.
            this._checkForIntersections = throttle(
                this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

            // Private properties.
            this._callback = callback;
            this._observationTargets = [];
            this._queuedEntries = [];
            this._rootMarginValues = this._parseRootMargin(options.rootMargin);

            // Public properties.
            this.thresholds = this._initThresholds(options.threshold);
            this.root = options.root || null;
            this.rootMargin = this._rootMarginValues.map(function(margin) {
                return margin.value + margin.unit;
            }).join(' ');
        }


        /**
         * The minimum interval within which the document will be checked for
         * intersection changes.
         */
        IntersectionObserver.prototype.THROTTLE_TIMEOUT = 1000;


        /**
         * The frequency in which the polyfill polls for intersection changes.
         * this can be updated on a per instance basis and must be set prior to
         * calling `observe` on the first target.
         */
        IntersectionObserver.prototype.POLL_INTERVAL = null;


        /**
         * Starts observing a target element for intersection changes based on
         * the thresholds values.
         * @param {Element} target The DOM element to observe.
         */
        IntersectionObserver.prototype.observe = function(target) {
            // If the target is already being observed, do nothing.
            if (this._observationTargets.some(function(item) {
                    return item.element == target;
                })) {
                return;
            }

            if (!(target && target.nodeType == 1)) {
                throw new Error('target must be an Element');
            }

            this._registerInstance();
            this._observationTargets.push({element: target, entry: null});
            this._monitorIntersections();
        };


        /**
         * Stops observing a target element for intersection changes.
         * @param {Element} target The DOM element to observe.
         */
        IntersectionObserver.prototype.unobserve = function(target) {
            this._observationTargets =
                this._observationTargets.filter(function(item) {

                    return item.element != target;
                });
            if (!this._observationTargets.length) {
                this._unmonitorIntersections();
                this._unregisterInstance();
            }
        };


        /**
         * Stops observing all target elements for intersection changes.
         */
        IntersectionObserver.prototype.disconnect = function() {
            this._observationTargets = [];
            this._unmonitorIntersections();
            this._unregisterInstance();
        };


        /**
         * Returns any queue entries that have not yet been reported to the
         * callback and clears the queue. This can be used in conjunction with the
         * callback to obtain the absolute most up-to-date intersection information.
         * @return {Array} The currently queued entries.
         */
        IntersectionObserver.prototype.takeRecords = function() {
            var records = this._queuedEntries.slice();
            this._queuedEntries = [];
            return records;
        };


        /**
         * Accepts the threshold value from the user configuration object and
         * returns a sorted array of unique threshold values. If a value is not
         * between 0 and 1 and error is thrown.
         * @private
         * @param {Array|number=} opt_threshold An optional threshold value or
         *     a list of threshold values, defaulting to [0].
         * @return {Array} A sorted list of unique and valid threshold values.
         */
        IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
            var threshold = opt_threshold || [0];
            if (!Array.isArray(threshold)) threshold = [threshold];

            return threshold.sort().filter(function(t, i, a) {
                if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
                    throw new Error('threshold must be a number between 0 and 1 inclusively');
                }
                return t !== a[i - 1];
            });
        };


        /**
         * Accepts the rootMargin value from the user configuration object
         * and returns an array of the four margin values as an object containing
         * the value and unit properties. If any of the values are not properly
         * formatted or use a unit other than px or %, and error is thrown.
         * @private
         * @param {string=} opt_rootMargin An optional rootMargin value,
         *     defaulting to '0px'.
         * @return {Array<Object>} An array of margin objects with the keys
         *     value and unit.
         */
        IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
            var marginString = opt_rootMargin || '0px';
            var margins = marginString.split(/\s+/).map(function(margin) {
                var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
                if (!parts) {
                    throw new Error('rootMargin must be specified in pixels or percent');
                }
                return {value: parseFloat(parts[1]), unit: parts[2]};
            });

            // Handles shorthand.
            margins[1] = margins[1] || margins[0];
            margins[2] = margins[2] || margins[0];
            margins[3] = margins[3] || margins[1];

            return margins;
        };


        /**
         * Starts polling for intersection changes if the polling is not already
         * happening, and if the page's visibilty state is visible.
         * @private
         */
        IntersectionObserver.prototype._monitorIntersections = function() {
            if (!this._monitoringIntersections) {
                this._monitoringIntersections = true;

                this._checkForIntersections();

                // If a poll interval is set, use polling instead of listening to
                // resize and scroll events or DOM mutations.
                if (this.POLL_INTERVAL) {
                    this._monitoringInterval = setInterval(
                        this._checkForIntersections, this.POLL_INTERVAL);
                }
                else {
                    addEvent(window, 'resize', this._checkForIntersections, true);
                    addEvent(document, 'scroll', this._checkForIntersections, true);

                    if ('MutationObserver' in window) {
                        this._domObserver = new MutationObserver(this._checkForIntersections);
                        this._domObserver.observe(document, {
                            attributes: true,
                            childList: true,
                            characterData: true,
                            subtree: true
                        });
                    }
                }
            }
        };


        /**
         * Stops polling for intersection changes.
         * @private
         */
        IntersectionObserver.prototype._unmonitorIntersections = function() {
            if (this._monitoringIntersections) {
                this._monitoringIntersections = false;

                clearInterval(this._monitoringInterval);
                this._monitoringInterval = null;

                removeEvent(window, 'resize', this._checkForIntersections, true);
                removeEvent(document, 'scroll', this._checkForIntersections, true);

                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            }
        };


        /**
         * Scans each observation target for intersection changes and adds them
         * to the internal entries queue. If new entries are found, it
         * schedules the callback to be invoked.
         * @private
         */
        IntersectionObserver.prototype._checkForIntersections = function() {
            var rootIsInDom = this._rootIsInDom();
            var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

            this._observationTargets.forEach(function(item) {
                var target = item.element;
                var targetRect = getBoundingClientRect(target);
                var rootContainsTarget = this._rootContainsTarget(target);
                var oldEntry = item.entry;
                var intersectionRect = rootIsInDom && rootContainsTarget &&
                    this._computeTargetAndRootIntersection(target, rootRect);

                var newEntry = item.entry = new IntersectionObserverEntry({
                    time: now(),
                    target: target,
                    boundingClientRect: targetRect,
                    rootBounds: rootRect,
                    intersectionRect: intersectionRect
                });

                if (!oldEntry) {
                    this._queuedEntries.push(newEntry);
                } else if (rootIsInDom && rootContainsTarget) {
                    // If the new entry intersection ratio has crossed any of the
                    // thresholds, add a new entry.
                    if (this._hasCrossedThreshold(oldEntry, newEntry)) {
                        this._queuedEntries.push(newEntry);
                    }
                } else {
                    // If the root is not in the DOM or target is not contained within
                    // root but the previous entry for this target had an intersection,
                    // add a new record indicating removal.
                    if (oldEntry && oldEntry.isIntersecting) {
                        this._queuedEntries.push(newEntry);
                    }
                }
            }, this);

            if (this._queuedEntries.length) {
                this._callback(this.takeRecords(), this);
            }
        };


        /**
         * Accepts a target and root rect computes the intersection between then
         * following the algorithm in the spec.
         * TODO(philipwalton): at this time clip-path is not considered.
         * https://wicg.github.io/IntersectionObserver/#calculate-intersection-rect-algo
         * @param {Element} target The target DOM element
         * @param {Object} rootRect The bounding rect of the root after being
         *     expanded by the rootMargin value.
         * @return {?Object} The final intersection rect object or undefined if no
         *     intersection is found.
         * @private
         */
        IntersectionObserver.prototype._computeTargetAndRootIntersection =
            function(target, rootRect) {

                // If the element isn't displayed, an intersection can't happen.

                // TODO: this is a local change to a 3rd party repo - we need to update this polyfill from github
                //  after this PR is approved: https://github.com/w3c/IntersectionObserver/pull/369
                var targetComputedStyle = window.getComputedStyle(target);
                if (!targetComputedStyle || targetComputedStyle.display === 'none') return;

                var targetRect = getBoundingClientRect(target);
                var intersectionRect = targetRect;
                var parent = getParentNode(target);
                var atRoot = false;

                while (!atRoot) {
                    var parentRect = null;
                    var parentComputedStyle = parent.nodeType == 1 ?
                        window.getComputedStyle(parent) : {};

                    // If the parent isn't displayed, an intersection can't happen.

                    // TODO: this is a local change to a 3rd party repo - we need to update this polyfill from github
                    //  after this PR is approved: https://github.com/w3c/IntersectionObserver/pull/369
                    if (!parentComputedStyle || parentComputedStyle.display === 'none') return;

                    if (parent == this.root || parent == document) {
                        atRoot = true;
                        parentRect = rootRect;
                    } else {
                        // If the element has a non-visible overflow, and it's not the <body>
                        // or <html> element, update the intersection rect.
                        // Note: <body> and <html> cannot be clipped to a rect that's not also
                        // the document rect, so no need to compute a new intersection.
                        if (parent != document.body &&
                            parent != document.documentElement &&
                            parentComputedStyle.overflow != 'visible') {
                            parentRect = getBoundingClientRect(parent);
                        }
                    }

                    // If either of the above conditionals set a new parentRect,
                    // calculate new intersection data.
                    if (parentRect) {
                        intersectionRect = computeRectIntersection(parentRect, intersectionRect);

                        if (!intersectionRect) break;
                    }
                    parent = getParentNode(parent);
                }
                return intersectionRect;
            };


        /**
         * Returns the root rect after being expanded by the rootMargin value.
         * @return {Object} The expanded root rect.
         * @private
         */
        IntersectionObserver.prototype._getRootRect = function() {
            var rootRect;
            if (this.root) {
                rootRect = getBoundingClientRect(this.root);
            } else {
                // Use <html>/<body> instead of window since scroll bars affect size.
                var html = document.documentElement;
                var body = document.body;
                rootRect = {
                    top: 0,
                    left: 0,
                    right: html.clientWidth || body.clientWidth,
                    width: html.clientWidth || body.clientWidth,
                    bottom: html.clientHeight || body.clientHeight,
                    height: html.clientHeight || body.clientHeight
                };
            }
            return this._expandRectByRootMargin(rootRect);
        };


        /**
         * Accepts a rect and expands it by the rootMargin value.
         * @param {Object} rect The rect object to expand.
         * @return {Object} The expanded rect.
         * @private
         */
        IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
            var margins = this._rootMarginValues.map(function(margin, i) {
                return margin.unit == 'px' ? margin.value :
                    margin.value * (i % 2 ? rect.width : rect.height) / 100;
            });
            var newRect = {
                top: rect.top - margins[0],
                right: rect.right + margins[1],
                bottom: rect.bottom + margins[2],
                left: rect.left - margins[3]
            };
            newRect.width = newRect.right - newRect.left;
            newRect.height = newRect.bottom - newRect.top;

            return newRect;
        };


        /**
         * Accepts an old and new entry and returns true if at least one of the
         * threshold values has been crossed.
         * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
         *    particular target element or null if no previous entry exists.
         * @param {IntersectionObserverEntry} newEntry The current entry for a
         *    particular target element.
         * @return {boolean} Returns true if a any threshold has been crossed.
         * @private
         */
        IntersectionObserver.prototype._hasCrossedThreshold =
            function(oldEntry, newEntry) {

                // To make comparing easier, an entry that has a ratio of 0
                // but does not actually intersect is given a value of -1
                var oldRatio = oldEntry && oldEntry.isIntersecting ?
                    oldEntry.intersectionRatio || 0 : -1;
                var newRatio = newEntry.isIntersecting ?
                    newEntry.intersectionRatio || 0 : -1;

                // Ignore unchanged ratios
                if (oldRatio === newRatio) return;

                for (var i = 0; i < this.thresholds.length; i++) {
                    var threshold = this.thresholds[i];

                    // Return true if an entry matches a threshold or if the new ratio
                    // and the old ratio are on the opposite sides of a threshold.
                    if (threshold == oldRatio || threshold == newRatio ||
                        threshold < oldRatio !== threshold < newRatio) {
                        return true;
                    }
                }
            };


        /**
         * Returns whether or not the root element is an element and is in the DOM.
         * @return {boolean} True if the root element is an element and is in the DOM.
         * @private
         */
        IntersectionObserver.prototype._rootIsInDom = function() {
            return !this.root || containsDeep(document, this.root);
        };


        /**
         * Returns whether or not the target element is a child of root.
         * @param {Element} target The target element to check.
         * @return {boolean} True if the target element is a child of root.
         * @private
         */
        IntersectionObserver.prototype._rootContainsTarget = function(target) {
            return containsDeep(this.root || document, target);
        };


        /**
         * Adds the instance to the global IntersectionObserver registry if it isn't
         * already present.
         * @private
         */
        IntersectionObserver.prototype._registerInstance = function() {
            if (registry.indexOf(this) < 0) {
                registry.push(this);
            }
        };


        /**
         * Removes the instance from the global IntersectionObserver registry.
         * @private
         */
        IntersectionObserver.prototype._unregisterInstance = function() {
            var index = registry.indexOf(this);
            if (index != -1) registry.splice(index, 1);
        };


        /**
         * Returns the result of the performance.now() method or null in browsers
         * that don't support the API.
         * @return {number} The elapsed time since the page was requested.
         */
        function now() {
            return window.performance && performance.now && performance.now();
        }


        /**
         * Throttles a function and delays its executiong, so it's only called at most
         * once within a given time period.
         * @param {Function} fn The function to throttle.
         * @param {number} timeout The amount of time that must pass before the
         *     function can be called again.
         * @return {Function} The throttled function.
         */
        function throttle(fn, timeout) {
            var timer = null;
            return function () {
                if (!timer) {
                    timer = setTimeout(function() {
                        fn();
                        timer = null;
                    }, timeout);
                }
            };
        }


        /**
         * Adds an event handler to a DOM node ensuring cross-browser compatibility.
         * @param {Node} node The DOM node to add the event handler to.
         * @param {string} event The event name.
         * @param {Function} fn The event handler to add.
         * @param {boolean} opt_useCapture Optionally adds the even to the capture
         *     phase. Note: this only works in modern browsers.
         */
        function addEvent(node, event, fn, opt_useCapture) {
            if (typeof node.addEventListener == 'function') {
                node.addEventListener(event, fn, opt_useCapture || false);
            }
            else if (typeof node.attachEvent == 'function') {
                node.attachEvent('on' + event, fn);
            }
        }


        /**
         * Removes a previously added event handler from a DOM node.
         * @param {Node} node The DOM node to remove the event handler from.
         * @param {string} event The event name.
         * @param {Function} fn The event handler to remove.
         * @param {boolean} opt_useCapture If the event handler was added with this
         *     flag set to true, it should be set to true here in order to remove it.
         */
        function removeEvent(node, event, fn, opt_useCapture) {
            if (typeof node.removeEventListener == 'function') {
                node.removeEventListener(event, fn, opt_useCapture || false);
            }
            else if (typeof node.detatchEvent == 'function') {
                node.detatchEvent('on' + event, fn);
            }
        }


        /**
         * Returns the intersection between two rect objects.
         * @param {Object} rect1 The first rect.
         * @param {Object} rect2 The second rect.
         * @return {?Object} The intersection rect or undefined if no intersection
         *     is found.
         */
        function computeRectIntersection(rect1, rect2) {
            var top = Math.max(rect1.top, rect2.top);
            var bottom = Math.min(rect1.bottom, rect2.bottom);
            var left = Math.max(rect1.left, rect2.left);
            var right = Math.min(rect1.right, rect2.right);
            var width = right - left;
            var height = bottom - top;

            return (width >= 0 && height >= 0) && {
                top: top,
                bottom: bottom,
                left: left,
                right: right,
                width: width,
                height: height
            };
        }


        /**
         * Shims the native getBoundingClientRect for compatibility with older IE.
         * @param {Element} el The element whose bounding rect to get.
         * @return {Object} The (possibly shimmed) rect of the element.
         */
        function getBoundingClientRect(el) {
            var rect;

            try {
                rect = el.getBoundingClientRect();
            } catch (err) {
                // Ignore Windows 7 IE11 "Unspecified error"
                // https://github.com/WICG/IntersectionObserver/pull/205
            }

            if (!rect) return getEmptyRect();

            // Older IE
            if (!(rect.width && rect.height)) {
                rect = {
                    top: rect.top,
                    right: rect.right,
                    bottom: rect.bottom,
                    left: rect.left,
                    width: rect.right - rect.left,
                    height: rect.bottom - rect.top
                };
            }
            return rect;
        }


        /**
         * Returns an empty rect object. An empty rect is returned when an element
         * is not in the DOM.
         * @return {Object} The empty rect.
         */
        function getEmptyRect() {
            return {
                top: 0,
                bottom: 0,
                left: 0,
                right: 0,
                width: 0,
                height: 0
            };
        }

        /**
         * Checks to see if a parent element contains a child elemnt (including inside
         * shadow DOM).
         * @param {Node} parent The parent element.
         * @param {Node} child The child element.
         * @return {boolean} True if the parent node contains the child node.
         */
        function containsDeep(parent, child) {
            var node = child;
            while (node) {
                if (node == parent) return true;

                node = getParentNode(node);
            }
            return false;
        }


        /**
         * Gets the parent node of an element or its host element if the parent node
         * is a shadow root.
         * @param {Node} node The node whose parent to get.
         * @return {Node|null} The parent node or null if no parent exists.
         */
        function getParentNode(node) {
            var parent = node.parentNode;

            if (parent && parent.nodeType == 11 && parent.host) {
                // If the parent is a shadow root, return the host element.
                return parent.host;
            }
            return parent;
        }


    // Exposes the constructors globally.
        TRC.IntersectionObserver = IntersectionObserver;
        TRC.IntersectionObserverEntry = IntersectionObserverEntry;

    }(window, document));

    TRC.intersections = (function (win, doc) {
        var observebleCounter = 0,
            intersectionState = {},
            observers = {},
            TARGET_ATTRIB = 'observeId';

        function doNothing(){}

        var hasTbFrame = false;
        try {
            hasTbFrame = !!window.top._tbframe;
        }
        catch(e){
            // Keep no TbFrame
        }

        function fillNonDefaultThreshold(options, threshold) {
            if (!TRC.util.isArray(options.threshold)) {
                if (threshold.indexOf(options.threshold) === -1) {
                    threshold.push(options.threshold);
                }
            } else {
                for (var i = 0; i < options.threshold.length; i++) {
                    var currThreshold = options.threshold[i];
                    if (threshold.indexOf(currThreshold) === -1) {
                        threshold.push(options.threshold);
                    }
                }
            }
        }

        function overlayCheckAndUpdateState(currentState, visibilityState, currentIntersectionEvent, positions) {
            var elementAtCenterOfContainer,
                elementAtThresholdPointFromTop,
                elementAtTopOfContainer,
                elementAtBottomOfContainer,
                overLayOnContainerEdge;
            var currentDoc = doc;

            if(hasTbFrame && TRCImpl.global["enable-tbframe-visible-support"]){
                currentDoc = (currentIntersectionEvent.target && currentIntersectionEvent.target.ownerDocument) || document;
            }

            if (!currentState.disableCheckOverlay && visibilityState === TRC.intersections.visibilityState.IN_VIEW_PORT_VISIBLE) {
                elementAtCenterOfContainer = getElementPosition(currentDoc, positions.centerX, positions.centerY);

                if (!isNaN(currentState.exactVisibleThresholdFromTop)) {
                    elementAtThresholdPointFromTop = currentDoc.elementFromPoint(positions.centerX, currentIntersectionEvent.boundingClientRect.top + currentState.exactVisibleThresholdFromTop);
                }
                if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-full-overlay-check')) {
                    elementAtTopOfContainer = currentDoc.elementFromPoint(positions.centerX, positions.top);
                    elementAtBottomOfContainer = currentDoc.elementFromPoint(positions.centerX, positions.bottom);
                    overLayOnContainerEdge = !isElementInTargetArea(elementAtTopOfContainer, currentIntersectionEvent.target) && !isElementInTargetArea(elementAtBottomOfContainer, currentIntersectionEvent.target);
                }
                if ((!isElementInTargetArea(elementAtCenterOfContainer, currentIntersectionEvent.target) && !isElementInTargetArea(elementAtThresholdPointFromTop, currentIntersectionEvent.target)) || overLayOnContainerEdge) {
                    visibilityState = TRC.intersections.visibilityState.IN_VIEW_PORT_NOT_VISIBLE;
                    // check if 100% in viewport and with overlay starting polling on element
                    if (currentIntersectionEvent.intersectionRatio >= 1 && elementAtCenterOfContainer !== null){
                        TRC.intersections.observePolling(currentState);
                    }
                }
            }
            return visibilityState;
        }

        function isElementInTargetArea(element, target) {
            return element && (element === target
                || target.contains(element) || (('getAttribute' in element) && element.getAttribute('data-tbl-friendly-overlay')));
        }

        function isPointInViewport(x, y, intersectionRect, exactVisibleThresholdFromTop) {
            return (intersectionRect.height >= exactVisibleThresholdFromTop) || (x <= intersectionRect.right && y <= intersectionRect.bottom && y > 0);
        }

        // we know element is in view port and we know it was covered by overlay
        // get center point and check if its the element itself.
        function isElementCenterVisible(element){
            var elementAtCenterOfContainer = getElementInCenter(element);
            var isVisible = isElementInTargetArea(elementAtCenterOfContainer, element);
            return isVisible;
        }

        function getElementInCenter (element) {
            var elementRect = element.getBoundingClientRect();
            var __ret = getCenterPoint(elementRect);
            var targetElementCenterX = __ret.targetElementCenterX;
            var targetElementCenterY = __ret.targetElementCenterY;
            return doc.elementFromPoint(targetElementCenterX, targetElementCenterY);
        }

        function getCenterPoint(targetElementRect) {
            return getPointsOnElement(targetElementRect, ['mm']).mm
        }

        function getPointsOnElement(elementRect, pointsRequired) {
            var returnedPoints = {};
            pointsRequired.forEach(function (p) {
                returnedPoints[p] = getPointInElementByPosition(elementRect, p);
            });
            return returnedPoints;

            function getPointInElementByPosition(elementRects, pos) {
                switch (pos) {
                    case "lt" : return getPointsByOffset(elementRects, 0, 0);
                    case "mt" : return getPointsByOffset(elementRects, 0.5, 0);
                    case "rt" : return getPointsByOffset(elementRects, 1, 0);
                    case "lm" : return getPointsByOffset(elementRects, 0, 0.5);
                    case "mm" : return getPointsByOffset(elementRects, 0.5, 0.5);
                    case "rm" : return getPointsByOffset(elementRects, 1, 0.5);
                    case "lb" : return getPointsByOffset(elementRects, 0, 1);
                    case "mb" : return getPointsByOffset(elementRects, 0.5, 1);
                    case "rb" : return getPointsByOffset(elementRects, 1, 1);
                    default: __trcWarn('intersections.getPointInElementByPosition - pos parameter not recognized. pos is: ' + pos);
                }
            }

            function getPointsByOffset(elementRects, percentX, percentY) {
                return {
                    targetElementCenterX:elementRects.left + Math.round(
                        (elementRects.right - elementRects.left) * percentX
                    ),
                    targetElementCenterY:elementRects.top + Math.round(
                        (elementRects.bottom - elementRects.top) * percentY
                    )
                }
            }
        }

        function unObservePollingOnVisible(currentState, visibilityState) {
            if (visibilityState === TRC.intersections.visibilityState.IN_VIEW_PORT_VISIBLE) {
                TRC.intersections.unObservePolling(currentState);
            }
        }

        function callOnTriggerCallback(targetElement, currentState, visibilityState) {
            currentState.onTrigger(targetElement, currentState.observer, visibilityState, currentState.lastBoundingClientRect);
            unObservePollingOnVisible(visibilityState, currentState);
        }

        function clearVisibilityTimeout(targetElement) {
            TRC.Timeout.clear(targetElement.visibleTimeout);
            delete targetElement.visibleTimeout;
        }

        function checkVisibility(targetElement, currentState, visibilityState) {
            var shouldEnableOnlyFullVisibleEvent = TRC.util.isPercentEnabled(TRCImpl.global, 'enable-only-full-visible-event');
            var isFullyVisible = targetElement.visibilityState === TRC.intersections.visibilityState.IN_VIEW_PORT_VISIBLE;
            if (shouldEnableOnlyFullVisibleEvent && !isFullyVisible){
                return;
            }
            if(currentState.isEnter && targetElement.isVisible
               && (typeof currentState.visibleWidgetPredicate !== 'function' || currentState.visibleWidgetPredicate())) {

                delete targetElement.isVisible;
                targetElement.visibilityReported = true;

                callOnTriggerCallback(targetElement, currentState, visibilityState);
            }
        }

        function visibleTimerCallback(targetElement, currentState, visibilityState) {
            clearVisibilityTimeout(targetElement);

            if(targetElement.visibilityReported) {
                return;
            }

            checkVisibility(targetElement, currentState, visibilityState);
        }

        function setCallback(targetElement, currentState, visibilityState) {
            var visibilityCheckDelay = (TRCImpl && TRCImpl.global['visibility-intersection-api-delay']) || 1000,
                shouldEnableDelayedVisibility = (visibilityState === TRC.intersections.visibilityState.IN_VIEW_PORT_VISIBLE && !targetElement.visibleTimeout) || (TRC.intersections.forceEnableDelayedVisibilityState());
            if (currentState.enableDelayedVisibilityCheck) {
                if (shouldEnableDelayedVisibility) {
                    targetElement.isVisible = true;
                    // Assign to lastVisibleBoundingClientRect the observe callback object and relevant DOM elements:
                    targetElement.lastVisibleBoundingClientRect =  currentState.lastBoundingClientRect;
                    targetElement.lastVisibleBoundingClientRect.pageXOffset = currentState.geometryOffsets.pageXOffset;
                    targetElement.lastVisibleBoundingClientRect.pageYOffset = currentState.geometryOffsets.pageYOffset;
                    targetElement.visibleTimeout = TRC.Timeout.set(visibleTimerCallback.trcBind(this, targetElement, currentState, visibilityState), visibilityCheckDelay);
                }
            }
            else {
                callOnTriggerCallback(targetElement, currentState, visibilityState);
            }
        }

        function checkIntersectionAndUpdate(currentState, currentIntersectionEvent, options) {
              var targetElement = currentIntersectionEvent.target,
                  targetElementRect,
                  visibilityThresholdVal,
                  visibilityState;

            currentState.isEnter = currentIntersectionEvent.isIntersecting;
            currentState.isExit = !currentState.isEnter;
            currentState.intersection = currentIntersectionEvent.intersectionRatio;

            //callback
            if (currentState.isEnter) {
                currentState.onEnter(currentIntersectionEvent, targetElement, currentState.observer);
            } else if (currentState.isExit) {

                if (targetElement.visibleTimeout) {
                    clearVisibilityTimeout(targetElement);
                }
                targetElement.isVisible = false;

                currentState.onExit(currentIntersectionEvent, targetElement, currentState.observer);
                TRC.intersections.unObservePolling(currentState);
            }

            targetElementRect = currentIntersectionEvent.boundingClientRect;
            var __ret = getCenterPoint(targetElementRect);
            var positions = {
                centerX: __ret.targetElementCenterX,
                centerY: __ret.targetElementCenterY,
                top: targetElementRect.top,
                bottom: targetElementRect.top + targetElementRect.height
            };


            visibilityThresholdVal = (TRCImpl && TRCImpl.global['visibility-threshold-override']) || 0;

            if (currentIntersectionEvent.isIntersecting &&
                currentIntersectionEvent.intersectionRatio >= visibilityThresholdVal &&
                isPointInViewport(positions.centerX, positions.centerY, currentIntersectionEvent.intersectionRect,currentState.exactVisibleThresholdFromTop)) {
                targetElement.visibilityState = visibilityState = TRC.intersections.visibilityState.IN_VIEW_PORT_VISIBLE;
            } else if (currentIntersectionEvent.isIntersecting) {
                targetElement.visibilityState = visibilityState = TRC.intersections.visibilityState.IN_VIEW_PORT_NOT_VISIBLE;
            } else {
                targetElement.visibilityState = visibilityState = TRC.intersections.visibilityState.NOT_IN_VIEW_PORT;
            }

            // handle CheckOverlay
            visibilityState = overlayCheckAndUpdateState(currentState, visibilityState, currentIntersectionEvent, positions);

            // only for gradual rollout
            if(!TRC.util.isPercentEnabled(TRCImpl.global, 'disable-overlay-visibility-report-fix')){
                targetElement.visibilityState = visibilityState;
            }


            if (!options.disableDuplicatePrevention) {
                if ((!currentState.lastEventId) || (currentState.lastEventId !== visibilityState)) {
                    setCallback(targetElement, currentState, visibilityState);
                    currentState.lastEventId = visibilityState;
                }
            } else {
                setCallback(targetElement, currentState, visibilityState);
            }
            return visibilityState;
        }

        function getElementPosition(doc, x, y) {
            return doc.elementFromPoint(x - 1, y - 1) || doc.elementFromPoint(x + 1, y + 1);
        }

        var intersectionsApi = {
            getPointsOnElement: getPointsOnElement,
            TARGET_ATTRIB: TARGET_ATTRIB,
            visibilityState : {
                IN_VIEW_PORT_VISIBLE:1,
                IN_VIEW_PORT_NOT_VISIBLE:2,
                NOT_IN_VIEW_PORT:3
            },
            /***
             * @description
             * Observe intersection of elements with other element or viewport
             *
             * @param {Object}  options
             * @param {String}  options.rootSelector                The element that is used as the viewport for checking visibility of the target.
             *                                                       - Must the an ancestor of the target.
             *                                                       - Defaults to the browser's viewport if not specified or if null.
             * @param {String}  options.targetElement               Target element to watch
             * @param {Number}  options.threshold                   Number 1 < x < 0 how much of the object is in view port or array of values value will be added to basic [0,25,50,75,100]
             * @param {String}  options.rootMargin                  Margins for the root containers css margin syntax example : "20px 0 20px 0" will intersect 20px above and below view port
             * @param {Boolean} options.disableCheckOverlay         Check if middle point of target visible or hidden under another element
             * @param {Boolean} options.disableDuplicatePrevention  Prevent sequential event of same state
             * @param {Boolean} options.enableDelayedVisibility     Check call onTrigger callback with timer
             * @param {Boolean} options.visibleWidgetPredicate      Check if widget is visible
             * @param exactVisibleThresholdFromTop                  Check if widget is visible based on visible threshold from top
             * @param {function} options.onEnter                    Callback on enter
             * @param {function} options.onExit                     Callback on Exit
             * @param {function} options.onTrigger                  Callback on trigger of any threshold
             * @param {Object}  options.boundingClientRect          Client bounding rect object returned by IntersectionObserver.observe()
             */
            observe : function (options) {
                var target,
                    targetIdentifier,
                    targetAttribVal,
                    threshold = options.disableCheckOverlay ? [0, 0.5] : [0, 0.25, 0.5, 0.75, 1];

                function intersectionHandler(intersectionEvent) {
                    var stateIds;
                    //events are joined together
                    for (var i = 0; i < intersectionEvent.length; i++) {
                        var currentIntersectionEvent = intersectionEvent[i];
                        if(!currentIntersectionEvent.target.getAttribute(TARGET_ATTRIB) && TRC.util.isPercentEnabled(TRCImpl.global, 'intersection-should-not-throw-error-on-missing-attribute')) { // sorry for that, @eyal.z & @dedi.h requested it.
                            continue;
                        }
                        stateIds = currentIntersectionEvent.target.getAttribute(TARGET_ATTRIB).split(" ");

                        for (var j = 0; j < stateIds.length; j++) {
                            var stateKey = stateIds[j];
                            var currentState = intersectionState[stateKey];
                            currentState.lastBoundingClientRect = currentIntersectionEvent.boundingClientRect;
                            // Add DOM elements:
                            currentState.geometryOffsets = {
                                pageXOffset: window.pageXOffset,
                                pageYOffset: window.pageYOffset
                            };

                            if (currentState && currentState.observer.tblObserverKey === this.tblObserverKey) {
                                checkIntersectionAndUpdate(currentState, currentIntersectionEvent, options);
                            }
                        }
                    }
                }

                if (!options.targetElement || (options.threshold === null) || (!options.onEnter && !options.onExit && !options.onTrigger)){
                    __trcDebug('missing params for intersectionHandler');
                    return;
                }

                target = options.targetElement;
                targetIdentifier = 'tbl-observe-' + observebleCounter;

                targetAttribVal = target.getAttribute(TARGET_ATTRIB)
                    ? target.getAttribute(TARGET_ATTRIB) + ' ' +  targetIdentifier
                    : targetIdentifier;
                target.setAttribute(TARGET_ATTRIB, targetAttribVal);
                observebleCounter++;
                // add values that are not basic 0 25 50 75 100
                fillNonDefaultThreshold(options, threshold);

                //save state
                intersectionState[targetIdentifier] = {
                    targetSelector: targetIdentifier,
                    targetElement: target,
                    isEnter: null,
                    isExit: null,
                    intersection: null,
                    disableCheckOverlay: options.disableCheckOverlay,
                    disableDuplicatePrevention: options.disableDuplicatePrevention,
                    enableDelayedVisibilityCheck: options.enableDelayedVisibilityCheck,
                    visibleWidgetPredicate: options.visibleWidgetPredicate,
                    exactVisibleThresholdFromTop: options.exactVisibleThresholdFromTop,
                    threshold: options.threshold,
                    onExit: options.onExit || doNothing,
                    onEnter: options.onEnter || doNothing,
                    onTrigger: options.onTrigger || doNothing,
                    boundingClientRect: null
                };

                var params = {
                    root: options.rootSelector || null,
                    rootMargin: options.rootMargin || '0px',
                    threshold: options.threshold
                };

                //reuse observer with same params
                var observerKey = TRC.util.hashString(JSON.stringify(params)),
                    observer;

                if (observers[observerKey]){
                    observer = observers[observerKey];
                }
                else {
                    params.root = params.root && document.querySelector(params.root);
                    if(TRC.IntersectionObserver) {
                        observer = new TRC.IntersectionObserver(intersectionHandler.trcBind(params), params);
                    } else {
                        observer = new IntersectionObserver(intersectionHandler.trcBind(params), params);
                    }

                    if (!('MutationObserver' in window)) {
                        observer.POLL_INTERVAL = TRCImpl.global['intersections-polyfill-poll-interval'] || 500;
                    }

                    params.tblObserverKey = observer.tblObserverKey = observerKey;
                    observers[observerKey] = observer;
                }

                intersectionState[targetIdentifier].observer = observer;
                observer.observe(target);
                return targetIdentifier;
            },
            /***
             *
             * @param target
             * @param callback                      Returns event, observer, element, state
             * @param disableCheckOverlay           Check if middle point of target visible or hidden under onother element
             * @param disableDuplicatePrevention    Prevent duplicates of event with same state
             * @param enableDelayedVisibilityCheck  Call onTrigger callback with timer
             * @param visibleWidgetPredicate        Check if widget is visible
             * @param exactVisibleThresholdFromTop  Check if widget is visible based on visible threshold from top
             */
            isInViewPort : function (options) {
                var vThreshold = TRCImpl.global['visibility-threshold'] || options.disableCheckOverlay ? [0, 0.5] : [0, 0.25, 0.5, 0.75, 1];
                var params = {
                    rootSelector: options.rootSelector || null,
                    targetElement: options.targetElement,
                    threshold : vThreshold,
                    rootMargin: '0px',
                    disableCheckOverlay: options.disableCheckOverlay,
                    disableDuplicatePrevention: options.disableDuplicatePrevention,
                    enableDelayedVisibilityCheck: options.enableDelayedVisibilityCheck,
                    visibleWidgetPredicate: options.visibleWidgetPredicate,
                    exactVisibleThresholdFromTop: options.exactVisibleThresholdFromTop,
                    onTrigger: options.onTrigger,
                    onEnter: options.onEnter
                };
                return this.observe(params);
            },
            unobserve : function(targetId) {
                var target = intersectionState[targetId],
                    numOfObservers,
                    targetIdIndex;

                if (!target) {
                    __trcLog('missing target element for unobserve');
                    return;
                }

                target = intersectionState[targetId].targetElement;
                numOfObservers = target.getAttribute(TARGET_ATTRIB).split(' ');
                targetIdIndex = numOfObservers.indexOf(targetId);

                if(numOfObservers.length === 1) {
                    intersectionState[targetId].observer.unobserve(target);
                    target.removeAttribute(TARGET_ATTRIB);
                }

                //remove observer attribute from the dom
                if(targetIdIndex > -1 && numOfObservers.length > 1) {
                    numOfObservers.splice(targetIdIndex, 1);
                    target.setAttribute(TARGET_ATTRIB, numOfObservers.join(' '));
                }

                return delete intersectionState[targetId];
            },
            unobserveAll : function(observerList) {
                var observerArr = observerList.split(' ');

                for (var i = 0; i < observerArr.length; i++) {
                    this.unobserve(observerArr[i]);
                }
            },
            getIntersectionState : function() {
                return intersectionState;
            },
            observePolling: function (state) {
                var interval = 500;
                if (!this.observedElementsInPolling[state.targetSelector]) {
                    this.observedElementsInPolling[state.targetSelector] = {target: state.targetElement, state: state};
                    state.underPolling = true;
                    this.observedElementsInPollingCounter++;
                }
                if (this.observedElementsInPollingCounter > 0){
                    this.startPolling(interval);
                }
            },
            unObservePolling: function (state) {
                if (this.observedElementsInPolling[state.targetSelector]){
                    delete (this.observedElementsInPolling[state.targetSelector]);
                    this.observedElementsInPollingCounter--;
                    state.underPolling = false;
                }

                if (this.observedElementsInPollingCounter === 0){
                    this.stopPolling();
                }
            },
            stopPolling: function () {
                clearInterval(this.pollingInterval);
                this.pollingInterval = null;
            },
            startPolling: function (interval) {
                if (this.pollingInterval){
                    return;
                }
                this.pollingInterval = setInterval(function () {
                    var elementObj,
                        isVisible = false,
                        observedElementsIds,
                        observedElements;
                    var elementsArray = intersectionsApi.observedElementsInPolling;

                    for (var observedElementInPolling in elementsArray) {
                        if (elementsArray.hasOwnProperty(observedElementInPolling)) {
                            elementObj = elementsArray[observedElementInPolling];
                            isVisible = isElementCenterVisible(elementObj.target);
                            if (isVisible) {
                                if(!elementObj.target.getAttribute(intersectionsApi.TARGET_ATTRIB) && TRC.util.isPercentEnabled(TRCImpl.global, 'intersection-should-not-throw-error-on-missing-attribute')) { // sorry for that, @eyal.z & @dedi.h requested it.
                                    continue;
                                }
                                observedElementsIds = elementObj.target.getAttribute(intersectionsApi.TARGET_ATTRIB).split(" ");
                                observedElements = intersectionsApi.getIntersectionState();
                                for (var i = 0; i < observedElementsIds.length; i++) {
                                    var obserKey = observedElementsIds[i];
                                    setCallback(elementObj.target, observedElements[obserKey], intersectionsApi.visibilityState.IN_VIEW_PORT_VISIBLE);
                                }
                                intersectionsApi.unObservePolling(elementObj.state);
                            }
                        }
                    }
                }, interval);
            },
            observedElementsInPolling: {},
            observedElementsInPollingCounter: 0,
            forceEnableDelayedVisibilityState: function () {
                return false
            }
        };

        return intersectionsApi;

    })(window,document);

    (() => {
        const URL_PARAM = 'tbl_creative_preview';
        const ALL_SLOTS_OVERRIDE = 'tbl_should_override_all_slots';
        const REPEAT_OVERRIDE_ITEMS = 'tbl_should_repeat_override_items';
        const ADDITIONAL_PROPERTIES = 'additional-properties';
        const PROPERTIES_OVERRIDE = 'tbl_properties_override';
        const PLACEMENT_PROPERTIES = 'placement-properties';
        const ORIGINAL_ITEM_FALLBACK = 'original_item_fallback';
        const privateProps = {
            sentUsageLog: false,
            overriddenPlacements: {},
            encodeText: false
        };
        const defaultValues = {
            ALL_SLOTS_OVERRIDE: false,
            REPEAT_OVERRIDE_ITEMS: true
        };
        const performanceVideoConfig = {
            autoTriggerConfig: {
                hover: 'true',
                viewabilityConfig: {
                    percentage: '5',
                    time: '0'
                }
            },
            repeat: 'true',
            scriptUrlTemplate: '//15.taboola.com/tbp?oid=15&pubid=166277&tagid=948107&pstn=[pstn]&cb=[cb]&callback={CALLBACK_NAME}',
            unitBootSrc: '//vidstat.taboola.com/vpaid/units/{version}/creatives/creative_js.js'
        };
        const PVIDEO_VERSION_URL_PARAM = 'tbl_pvideo_version';
        const pVideoDefaultVersion = '27_6_17';

        const run = (rbox, response) => {
            if (!privateProps.isEnabled(rbox.global['enable-item-override'])) {
                return;
            }

            privateProps.encodeText = privateProps.encodeText || !!rbox.global['item-override-encode-fields'];

            const itemData = privateProps.getNewItemFromUrl();
            sendUsageLog(itemData);
            const [firstItem] = itemData;
            const vl = response && response.trc && response.trc.vl || [];
            if (itemData && firstItem && vl.length) {
                pVideoOverride(itemData, response);
                privateProps.handleOverrideItems(vl, itemData);
            }
        };

        privateProps.handleOverrideItems = (vl, itemData) => {
            let itemsForOverride;
            if (privateProps.getValueFromUrl(ALL_SLOTS_OVERRIDE, defaultValues.ALL_SLOTS_OVERRIDE)) {
                itemsForOverride = getAllItemsPerPlacement(vl, itemData);
            } else {
                itemsForOverride = getOneItemPerPlacement(vl, itemData[0].itemType);
            }

            privateProps.overrideItems(itemsForOverride, itemData);

            handlePlacementLevelOverride(vl, itemData);
        };

        const handlePlacementLevelOverride = (vl, itemData) => {
            if (itemData.length === 0) {
                return;
            }

            if (privateProps.getValueFromUrl(ALL_SLOTS_OVERRIDE, defaultValues.ALL_SLOTS_OVERRIDE)) {
                vl.forEach(placementData => {
                    addProperties(itemData[0], placementData, PLACEMENT_PROPERTIES);
                });
            } else {
                addProperties(itemData[0], vl[0], PLACEMENT_PROPERTIES);
            }
        };

        const getProperties = (newItem, properties) => {
            const newItemProps = newItem[properties];
            return newItemProps ? TRC.util.jsonParseSafe(newItemProps, properties) : {};
        };

        const addProperties = (newItem, item, properties) => {
            const props = getProperties(newItem, properties);
            if (!props) {
                return;
            }

            privateProps.replaceFields(item, props, Object.keys(props));
        };

        privateProps.overrideItems = (itemsToOverride, itemList) => {
            if (itemsToOverride.length > 0 && itemList) {
                itemsToOverride.forEach((item, index) => {
                    const itemListIndex = index % (itemList.length);
                    privateProps.overrideItem(itemsToOverride[index], itemList[itemListIndex]);
                });
            }
        };

        privateProps.overrideItem = (oldItem, newItem) => {
            privateProps.replaceFields(oldItem, newItem, ['thumbnail', 'title', 'description', 'branding-text', 'uploader', 'cropping']);
            addProperties(newItem, oldItem, ADDITIONAL_PROPERTIES);
            if (privateProps.getValueFromUrl(ORIGINAL_ITEM_FALLBACK)) {
                return;
            }

            oldItem.url = '#';
        };

        privateProps.replaceFields = (oldItem, newItem, fields) => {
            const isOriginalItemFallback = privateProps.getValueFromUrl(ORIGINAL_ITEM_FALLBACK);
            fields.forEach(field => {
                const oldFieldValue = oldItem[field];
                const isObject = typeof (newItem[field]) === 'object' && newItem[field] != null;
                oldItem[field] = isObject ? privateProps.replaceFields({}, newItem[field], Object.keys(newItem[field]))
                    : privateProps.replaceField(newItem[field], field);
                if (!isObject && isOriginalItemFallback) {
                    oldItem[field] = oldItem[field] || oldFieldValue;
                }
            });

            return oldItem;
        };

        privateProps.replaceField = (obj, field) => {
            let options,
                valueToReturn;

            if (field === 'thumbnail') {
                options = {ignoreAmpersand: true};
            }

            if (IsJsonString(obj)) {
                const parsedObj = JSON.parse(obj);
                valueToReturn = JSON.stringify(privateProps.replaceFields({}, parsedObj, Object.keys(parsedObj)));
            } else {
                valueToReturn = privateProps.replaceString(obj, options);
            }

            return valueToReturn;
        };

        privateProps.replaceString = (text, options) => ((privateProps.encodeText && typeof text === 'string') ? TRC.text.encodeHTML(text, options) : text);

        const IsJsonString = obj => {
            try {
                return typeof obj === 'string' && typeof JSON.parse(obj) === 'object';
            } catch (e) {
                return false;
            }
        };

        const sendUsageLog = itemData => {
            if (!privateProps.sentUsageLog) {
                const creativeIds = itemData ? itemData.map(item => item && item.creativeId || null) : null;
                TRC.RBoxUsage.logUsage('TRC.ItemOverride', {
                    extraData: {
                        creativeIds,
                        url: window.location.href
                    }
                });
                privateProps.sentUsageLog = true;
            }
        };

        privateProps.isEnabled = isFeatureFlagOn => (isFeatureFlagOn && privateProps.isItemOverrideUrlParam());

        privateProps.isItemOverrideUrlParam = () => location.search.indexOf(URL_PARAM) >= 0;

        const isItemOfType = (item, expectedItemType) => {
            if (item[expectedItemType]) {
                return true;
            }

            if (!item['is-syndicated'] && !item['is-in-network'] && !item['is-native']) {
                return expectedItemType === 'is-organic';
            }

            return false;
        };

        const getItemToOverrideByType = (placementItems, itemType) => {
            if (itemType) {
                for (let i = 0; i < placementItems.length; i++) {
                    if (isItemOfType(placementItems[i], itemType)) {
                        return placementItems[i];
                    }
                }
            } else {
                return placementItems[0];
            }
        };

        const getOneItemPerPlacement = (vl, ofType) => {
            const {overriddenPlacements = {}} = privateProps;
            const itemsToOverride = [];
            const propertiesOverrideObj = privateProps.getValueFromUrl(PROPERTIES_OVERRIDE);
            let itemToOverride;
            let placementName;

            vl.forEach(placementData => {
                placementName = placementData.uuip || placementData.uip;
                const {v} = placementData;
                if (v && placementName && !overriddenPlacements[placementName]) {
                    itemToOverride = getItemToOverrideByType(v, ofType);
                    if (itemToOverride) {
                        itemsToOverride.push(itemToOverride);
                        overriddenPlacements[placementName] = true;

                        if (propertiesOverrideObj) {
                            overwritePlacementProperties(placementData, propertiesOverrideObj);
                        }
                    }
                }
            });

            return itemsToOverride;
        };

        const getAllItemsPerPlacement = (vl, itemData) => {
            const shouldRepeatOverrideItems = privateProps.getValueFromUrl(REPEAT_OVERRIDE_ITEMS, defaultValues.REPEAT_OVERRIDE_ITEMS);
            const itemsToOverride = [];
            const propertiesOverrideObj = privateProps.getValueFromUrl(PROPERTIES_OVERRIDE);

            if (!shouldRepeatOverrideItems) {
                prepareVideoListNoRepeatOverrides(vl, itemData);
            }

            vl.forEach(placementData => {
                if (placementData.v) {
                    placementData.v.forEach(item => {
                        itemsToOverride.push(item);
                    });

                    if (propertiesOverrideObj) {
                        overwritePlacementProperties(placementData, propertiesOverrideObj);
                    }
                }
            });

            return itemsToOverride;
        };

        const prepareVideoListNoRepeatOverrides = (vl, itemData) => {
            let numOverridesRemaining = itemData.length;

            for (let i = 0; i < vl.length; i++) {
                const placementVideos = vl[i].v;
                if (!placementVideos) continue;

                if (placementVideos.length >= numOverridesRemaining) {
                    spliceVideoList(vl, i + 1, numOverridesRemaining);
                } else {
                    numOverridesRemaining -= placementVideos.length;

                    if (i === vl.length - 1 && numOverridesRemaining > 0) {
                        fillVideoList(placementVideos, numOverridesRemaining);
                    }
                }
            }

        };

        const spliceVideoList = (vl, vlSpliceIndex, vSpliceIndex) => {
            vl.splice(vlSpliceIndex);
            vl[vlSpliceIndex - 1].v.splice(vSpliceIndex);
        };

        const fillVideoList = (list, numItems) => {
            for (let j = 0; j < numItems; j++) {
                list.push(Object.assign({}, list[0]));
            }
        };

        privateProps.getValueFromUrl = (param, defaultValue) => {
            try {
                const valueJSON = TRC.URL.prototype.getParameter.call(window.location.search, param, decodeURIComponent);
                let value = JSON.parse(valueJSON);

                if (value === undefined || value === null && defaultValue) {
                    value = defaultValue;
                }

                return value;
            } catch (e) {
                __trcDebug(`invalid data in url param ${param}`);
                return null;
            }
        };


        privateProps.getNewItemFromUrl = () => {
            let newItemData = privateProps.getValueFromUrl(URL_PARAM);

            if (!Array.isArray(newItemData)) {
                newItemData = [newItemData];
            }

            return newItemData;
        };

        TRC.ItemOverride = {
            run
        };

        /* public methods for UT */
        if (window._trcIsUTactive) {
            TRC.ItemOverride.privateProps = privateProps;
        }

        const pVideoOverride = (itemData, response) => {
            const pVideoVersion = privateProps.getValueFromUrl(PVIDEO_VERSION_URL_PARAM, pVideoDefaultVersion);
            performanceVideoConfig.unitBootSrc = performanceVideoConfig.unitBootSrc.replace('{version}', pVideoVersion);
            for (let i = 0; i < itemData.length; i++) {
                if (itemData[i] && itemData[i][ADDITIONAL_PROPERTIES] && itemData[i][ADDITIONAL_PROPERTIES]['pvideo-url']) {
                    for (let i = 0; i < response.trc.vl.length; i++) {
                        response.trc.vl[i].pvc = performanceVideoConfig;
                    }
                    return;
                }
            }
        };

        const overwritePlacementProperties = function (placement, propertiesOverrideObj) {
            try {
                if (!placement || !propertiesOverrideObj) {
                    return;
                }

                const createPropertiesOverrideFromObj = propertiesObj => JSON.stringify(propertiesObj)
                    .replace(/(^\{)|(\}$)/g, '');

                let oldPropertiesOverride = {};
                if (placement.po) {
                    oldPropertiesOverride = JSON.parse(`{${placement.po}}`.replace(/'/g, `"`));
                }

                const mergedPropertiesOverride = TRC.util.merge({}, oldPropertiesOverride, propertiesOverrideObj);
                placement.po = createPropertiesOverrideFromObj(mergedPropertiesOverride);
            } catch (error) {
                // do nothing
            }
        };

    })();

    (function () {
        function ItemParser (video) {
            this._data = video;
        }

        ItemParser.prototype.getId = function () {
            return this._data.id;
        };

        ItemParser.prototype.getLinkTarget = function () {
            return this._data.linkTarget;
        };

        ItemParser.prototype.getUrl = function () {
            return this._data.url;
        };

        ItemParser.prototype.getTitle = function () {
            return this._data.title;
        };

        ItemParser.prototype.getType = function () {
            var item = this._data;

            if (item['is-syndicated'])
                return 'sponsored';

            if (item['is-in-network'])
                return 'exchange';

            if (item['is-native'])
                return 'native';

            return 'organic';
        };

        ItemParser.prototype.getSlot = function () {
            return this._data.itemIndex;
        };

        TRC.ItemParser = ItemParser;
    })();

    /**
     * Created by gabe.l on 3/22/19.
     * Modified version of trc-cache.js
     */
    (() => {
        class KeyValueCache {
            constructor(options, onlyClean = false) {
                this.onlyClean = onlyClean;
                this.pm = TRC.pageManager;
                this.storageType = options.storageType || 'session';
                this.localStorage = this.pm.getLocalStorageImplementation('strict-w3c-storage', this.storageType); // use true localstorage
                this.keyValueCache = null; // dummy storage
                this.cacheTtl = options.ttl || (1000 * 60 * 20); // TTL for an entry
                this.noTtl = options.noTtl || false;
                this.cacheName = options.cacheName || 'key_value_cache'; // name of the key for the entire trc cache in the local storage
                this.cacheUtils = new TRC.CacheUtils(this.localStorage, this.cacheName, this.cacheTtl);
                if (!localStorage) {
                    return {
                        isValidCache: false
                    };
                }
                this.isValidCache = true;
                this.init();
            }

            cacheData(key, value) {
                const cached = this.setCacheData(key, value);
                this.localStorage.setValue(this.cacheName, __trcJSONify(this.keyValueCache.getData()));
                return cached;
            }

            setCacheData(key, value) {
                const stamp = new Date().getTime();

                try {
                    this.keyValueCache.setValue(key, {value, s: stamp});
                    if (this.noTtl === false) {
                        this.setCacheClean(key);
                    }
                } catch (e) {
                    return false;
                }
                return true;
            }

            getCacheData(key) {
                const value = this.keyValueCache.getValue(key);
                if ((this.noTtl === true && value) || (value && !this.isOverTtl(this.keyValueCache.getValue(key).s))) {
                    return this.keyValueCache.getValue(key).value;
                }
                return null;
            }

            isOverTtl(stamp) {
                return this.cacheUtils.isOverTtl(stamp);
            }

            setCacheClean(key) {
                this.cacheUtils.setCacheClean(key, this.keyValueCache);
            }

            cleanCache(keys) {
                this.cacheUtils.cleanCache(keys, this.keyValueCache, this);
            }

            removeKey(key) {
                TRC.CacheUtils.removeKey(key, this.keyValueCache);
            }

            getKeyValueCache() {
                return this.cacheUtils.getCache(this.pm);
            }
            
            init() {
                if (this.onlyClean) {
                    this.localStorage.removeKey(this.cacheName);
                    return false;
                }
                this.keyValueCache = this.getKeyValueCache();
                const keys = TRC.util.keys(this.keyValueCache.getData());
                this.cleanCache(keys);
                return true;
            }
        }
        TRC.KeyValueCache = KeyValueCache;
    })(window, document);

    (() => {
        let isRunning = false;
        let cache = [];

        if (window._trcIsUTactive) {
            TRC.forceRAFtoRun = () => {
                isRunning = false;
            };
        }

        const LineClamp = TRC.LineClamp = {
            fixBoxOverflow(
                span,
                originalText,
                byWords,
                doTruncate,
                inlineDetailsList,
                parent,
                useNativeLineClamp,
                shouldUseSmartEllipsis
            ) {
                let lineClampUsed = false;

                if (span == null) {
                    return;
                }

                if (useNativeLineClamp) {
                    lineClampUsed = LineClamp.setupBoxLineClamp(span);
                    if (lineClampUsed) {
                        return;
                    }
                }

                if (shouldUseSmartEllipsis && !lineClampUsed) {
                    return __trcDebug('Skipping fixBoxOverflow due to feature flag.');
                }

                if (TRC.ellipsisPerf) { console.timeStamp('Taboola old ellipsis'); }

                if (span.clientHeight <= 0 || span.clientWidth <= 0) {
                    return;
                }

                let wasOverflow = false;

                // measure the line height for this element - this is used by thumbnail-under widgets
                // for setting the label-box-anchor's height
                span.parentNode.font = LineClamp.getFontSize(span);
                const store = span.innerHTML;
                span.innerText = '';
                const measure = LineClamp.add_span(null, 'H', span);
                const lineHeight = Math.max(measure.offsetHeight, measure.clientHeight);
                // do we need some extra padding to prevent cutting the bottom of the text?
                const extra = Math.max(0, span.scrollHeight - span.clientHeight);
                span.removeChild(measure);
                TRC.dom.setContentToElement(span, store);

                // If box should have additional inner elements, append them to the box.
                LineClamp.addInlineElementsForMeasure(span.inlineDetailsElements, span, true);
                // store the inline details HTML - should be re-appended after every measure and truncation
                span.inlineDetailsElementsHTML = span.innerHTML.replace(store, '');

                // make sure the original text is not space padded
                originalText = originalText.replace(/^\s+|\s+$/g, '');

                while ((span.clientHeight + extra + (lineHeight / 2)) < span.scrollHeight && originalText.length) {
                    wasOverflow = true;
                    originalText = LineClamp.truncateOverflowingText(span, originalText, byWords);

                    if (span.inlineDetailsElementsHTML) {
                        span.innerHTML += span.inlineDetailsElementsHTML;
                    }
                }

                /*
                 * Hide the original detail elements (these elements were already
                 * cloned and appended to the title)
                 */
                LineClamp.hideClonedElementsAfterMeasure(inlineDetailsList, parent);

                if (TRC.Browser.ie && !wasOverflow) {
                    span.style.height = 'auto';
                }
            },

            setupBoxLineClamp(span) {
                const lineHeight = parseInt(document.trcGetCurrentStyle(span, 'line-height'), 10),
                    height = parseInt(document.trcGetCurrentStyle(span, 'height'), 10),
                    numLines = lineHeight && height ? Math.round(height / lineHeight).toString() : null;

                // if we could not figure out how many lines are allowed, or the span text direction is RTL - do not perform line clamp
                if (!numLines) {
                    return false;
                }
                cache.push({domElm: span, numLine: numLines});

                /** For unit test */
                if (window._trcIsUTactive) {
                    TRC._lineClampCache = cache;
                }
                
                if (isRunning) {
                    return true;
                }
                
                requestAnimationFrame(() => {
                    cache.forEach(cacheObj => {
                        const span = cacheObj && cacheObj.domElm,
                            numLine = cacheObj && cacheObj.numLine;
                        
                        TRC.dom.addClass(span, 'trc_ellipsis');
                        
                        TRC.css.utils.setStyleProperty(span, '-webkit-line-clamp', numLine, false);

                        // measure the line height for this element - this is used by thumbnail-under widgets
                        // for setting the label-box-anchor's height
                        span.parentNode.font = LineClamp.getFontSize(span);
                    });
                    isRunning = false;
                    cache = [];
                });
                isRunning = true;

                return true;
            },

            getFontSize(obj) {
                let i = 0;
                let hasStr = false;
                let fontSize = document.trcGetCurrentStyle(obj, 'font-size');
                const substr = ['px', 'pt', 'em', 'ch'];
                while ((!hasStr) && (i < substr.length)) {
                    if (fontSize.indexOf(substr[i])) {
                        fontSize = parseInt(fontSize, 10);
                        /* eslint-disable operator-assignment */
                        switch (substr[i]) {
                            case 'px':
                                // do nothing - parseInt did the work
                                break;
                            case 'pt':
                                fontSize = (fontSize / 0.75);
                                break;
                            case 'em':
                            case 'ch':
                                fontSize = (fontSize * 10);
                                break;
                            default:
                                break;
                        }
                        hasStr = true;
                    }
                    i++;
                }
                return fontSize;
            },

            add_span(cssClass, content, parentElement) {
                /** @type Element */
                const span = document.createElement('span');
                if (cssClass != null) {
                    span.className = cssClass;
                }

                if (content != null) {
                    if (typeof content === 'object') {
                        span.appendChild(content);
                    } else {
                        TRC.dom.setContentToElement(span, content);
                    }
                }
                if (typeof parentElement !== 'undefined') {
                    parentElement.appendChild(span);
                }

                return span;
            },

            addInlineElementsForMeasure(inlineElements, parent, doClone) {
                let inlineElement,
                    inlineElementFound,
                    spacer;

                for (let i = 0; inlineElements && i < inlineElements.length; i++) {
                    /* eslint-disable no-loop-func,  */
                    inlineElement = inlineElements[i];
                    inlineElementFound = LineClamp.findElement(e => {
                        const nodeVal = e.className.search(inlineElement) >= 0 && e.parentNode === parent;
                        return nodeVal;
                    }, parent);

                    if (!inlineElementFound && inlineElement) {
                        // Add space before element
                        spacer = document.createElement('span');
                        spacer.className = 'trc_inline_detail_spacer';
                        spacer.innerHTML = ' ';
                        parent.appendChild(spacer);

                        // append the inline element
                        parent.appendChild(doClone ? inlineElement.cloneNode(true) : inlineElement);
                    }
                }
            },

            findElement(predicate, parent, tag, dflt) {
                if (typeof parent === 'undefined') {
                    parent = document;
                }
                if (typeof tag === 'undefined') {
                    tag = '*';
                }
                const elms = parent.getElementsByTagName(tag);
                for (let i = 0; i < elms.length; i++) {
                    if (predicate(elms[i])) {
                        return elms[i];
                    }
                }
                return dflt;
            },

            truncateOverflowingText(span, text, byWords) {
                text = byWords && text.search(/\s/) >= 0 
                    ? text.replace(/\s+\S+$/, '')
                    : text.substr(0, text.length - 1);

                /* eslint-disable camelcase */
                const bde_el = span.getElementsByTagName('bde'); // check if we have an embedded BiDi element
                let spanContent;
                if (span.inlineDetailsElementsHTML && bde_el.length) {
                    // remove the inline elements from to allow correct truncation of title.
                    // needed only when bde is used, otherwise these elements will be removed from the span anyway
                    // in the next lines because the innerHTML of the span is being reset
                    spanContent = span.innerHTML.replace(span.inlineDetailsElementsHTML, '');
                    TRC.dom.setContentToElement(span, spanContent);
                }

                // remove old ellipsis if found
                if (span.getElementsByTagName('span').length > 0) {
                    span.removeChild(span.getElementsByTagName('span')[0]);
                }

                const contentElement = (bde_el.length > 0) ? bde_el[0] : span;
                TRC.dom.setContentToElement(contentElement, text);
                LineClamp.add_span(null, LineClamp.createEllipsis(), span);

                return text;
            },

            hideClonedElementsAfterMeasure(originalElements, parent) {
                let elementClassName,
                    element;

                for (let i = 0; originalElements && i < originalElements.length; i++) {
                    elementClassName = originalElements[i];
                    element = LineClamp.findElement(e => {
                        const nodeVal = e.className.search(elementClassName) >= 0 && e.parentNode === parent;
                        return nodeVal;
                    }, parent, 'span');

                    if (element) {
                        element.style.display = 'none';
                    }

                }
            },

            createEllipsis() {
                return document.createTextNode('\u2026');
            }
        };
    })();

    (function(win,doc){
    	var validValues = {
    			source: '|v|h|c|t|s|p|o|z|video|home|category|text|search|photo|other|content_hub',  //valid source values
    			target: '|v|p|t|m|video|photo|text|mix|'
    		},
    		_source = 'v',
    			
    		normalizeParam = function(param, context){
    			param = param.toLowerCase();
    			if (validValues[context].indexOf('|' + param + '|') !== -1) {
    				if(param === 'content_hub') {
    					return 'z';
    				}
    				return param.substr(0, 1);
    			}
    			__trcError('illegal parameter "' + param + '" was passed to trc_ListOriginBuilder method: "set' +
    					context.substr(0, 1).toUpperCase() +
    					context.substr(1) +
    					'" \nUsing "video" instead');
    			return 'v';
    		};
    			
    	/**
    	 * ListOriginBuilder implements the rules of building a list origin
    	 * expression (like 't2v', 'p2v' etc.)
    	 * 
    	 * Note: the actual data is "static", so all instances provide the same data and affect each other
    	 */
    	var ListOriginBuilder = TRC.ListOriginBuilder = function(source, target) {
    			this.setSource(source || _source);
    		this.setTarget(target || 'v');
    	};
    	
    	ListOriginBuilder.prototype.setSource = function(value) {
    		_source = normalizeParam(value, 'source');
    	};

    	ListOriginBuilder.prototype.getSource = function() {
    		return _source;
    	};

    	ListOriginBuilder.prototype.setTarget = function(value) {
    		this.target = normalizeParam(value, 'target');
    	};

    	ListOriginBuilder.prototype.getTarget = function() {
    		return this.target;
    	};

    	ListOriginBuilder.prototype.toString = function() {
    		return (_source + '2' + this.target).replace(/v2v/, 'blended');
    	};

    	ListOriginBuilder.prototype.isHomePage = function() {
    		return _source === 'h';
    	};

    })(window,document);

    (() => {

        const internalCounter = {};

        class MetricsManager {

            static metricIncrement(metricType) {
                internalCounter[metricType] = internalCounter[metricType] || 0;
                internalCounter[metricType]++;
            }

            static getMetricValue(metricType) {
                return internalCounter[metricType] || 0;
            }

            static isMetricsEnabled(trcManager, trc) {
                return trc.util.isPercentEnabled(trcManager.global, 'rbox-metrics-enabled')
                       && trcManager.global['bulk-metrics-events-strategy']
                       && trcManager.global['rbox-post-events-as-ajax'];
            }


            static sendMetricsEvent(trc, trcManager, data, callback, sendBeacon) {
                try {
                    // sendBeacon indicates alos that this is top priority metric.
                    if (!sendBeacon && !MetricsManager.isMetricsEnabled(trcManager, trc)) {
                        return;
                    }
                    const metricsData = MetricsManager.formatMetricsData(trc, data);
                    trcManager.sendEvent('metrics', metricsData, null, false, callback, null, sendBeacon);

                } catch (e) {
                    __trcError('Failed to send Metrics event', e);
                }
            }

            static formatMetricsData(trc, data) {
                return {
                    dimensions: JSON.stringify({
                        publisher: trc.publisherId,
                        'integration-type': getIntegrationType(trc)
                    }),
                    type: data.type,
                    metricName: data.name,
                    value: data.value
                };

                function getIntegrationType(trc) {
                    return (isSDK(trc) && 'SDK')
                            || (isAMP(trc) && 'AMP')
                            || 'normal';

                    function isSDK(trc) {
                        return !!(trc.mobile && trc.mobile.reportClick);
                    }

                    function isAMP(trc) {
                        return trc.isAMP;
                    }
                }

            }
        }

        if (window._trcIsUTactive) {
            MetricsManager.setMetricValue = function (metricType, val) {
                internalCounter[metricType] = val;
            };
        }

        TRC.MetricsManager = MetricsManager;

    })();

    (() => {
        const projects = [];
        let mixPanelInstance;

        class Mixpanel {
            static loadMixpanelScript(projectId, onSuccess, onFail) {
                const mx = TRC.Mixpanel;
                try {
                    if (mixPanelInstance || mx.requested) {
                        if (mixPanelInstance && !projects[projectId]) {
                            mx.initMixpanelProject(projectId);
                        }
                        return;
                    }

                    mx.requested = true;

                    mx.mixpanelScript();
                    mx.initMixpanelProject(projectId);
                    mx.onMixpanelLoad(onSuccess);
                } catch (ex) {
                    mx.onMixpanelError(ex, onFail);
                }
            }

            static mixpanelScript() {
                /* eslint-disable */
                (function(f,b){if(!b.__SV){var e,g,i,h;mixPanelInstance=b;b._i=[];b.init=function(e,f,c){
                    function g(a,d){var b=d.split(".");2==b.length&&(a=a[b[0]],d=b[1]);a[d]=function(){a.push([d].concat(Array.prototype.slice.call(arguments,0)));};}var a=b;"undefined"!==typeof c?a=b[c]=[]:c="mixpanel";a.people=a.people||[];a.toString=function(a){var d="mixpanel";"mixpanel"!==c&&(d+="."+c);a||(d+=" (stub)");return d};a.people.toString=function(){return a.toString(1)+".people (stub)"};i="disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking start_batch_senders people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove".split(" ");
                    for(h=0;h<i.length;h++)g(a,i[h]);var j="set set_once union unset remove delete".split(" ");a.get_group=function(){function b(c){d[c]=function(){call2_args=arguments;call2=[c].concat(Array.prototype.slice.call(call2_args,0));a.push([e,call2]);};}for(var d={},e=["get_group"].concat(Array.prototype.slice.call(arguments,0)),c=0;c<j.length;c++)b(j[c]);return d};b._i.push([e,f,c]);};b.__SV=1.2;e=f.createElement("script");e.type="text/javascript";e.async=!0;e.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL? MIXPANEL_CUSTOM_LIB_URL:"file:"===f.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";g=f.getElementsByTagName("script")[0];g.parentNode.insertBefore(e,g);}})(document,mixPanelInstance||[]);
                /* eslint-enable */
            }

            static initMixpanelProject(projectId) {
                projects.push(projectId);
                mixPanelInstance.init(projectId, {batch_requests: true});
            }

            static isMixPanelLoaded() {
                return !!mixPanelInstance;
            }

            static onMixpanelLoad(onSuccess) {
                TRC.dispatch('mixpanelScriptSucceeded');
                onSuccess && onSuccess();
            }

            static onMixpanelError(ex, onFail) {
                __trcError('Failed to load mixpanel script', ex);
                TRC.Mixpanel.mixpanelScriptFailed = true;
                TRC.dispatch('mixpanelScriptFailed');
                onFail && onFail();
            }

            static sendMixpanelEvent(eventName, eventProps = {}, mixpanelProps) {
                if (TRC.util.isMixpanelEventDisabled(eventName)) {
                    return;
                }
                // eslint-disable-next-line no-undef
                if (!mixPanelInstance) {
                    __trcWarn(`No Mixpanel instance - ${eventName}`);
                    return;
                }

                const {publisherId, pageManager} = TRC;
                const {sessionId, formattedTRCRequest, experimentsData} = TRCImpl;
                const MIXPANEL_PROPS = mixpanelProps || {
                    pubId: publisherId,
                    sessionId,
                    taboolaUserId: pageManager && pageManager.getUserId(),
                    pageViewId: pageManager && pageManager.getPageData(),
                    pageType: formattedTRCRequest && formattedTRCRequest.it,
                    experimentsData
                };
                const props = TRC.util.merge({}, eventProps, MIXPANEL_PROPS);

                // eslint-disable-next-line no-undef
                mixPanelInstance.identify(MIXPANEL_PROPS.taboolaUserId);
                mixPanelInstance.people.set({'Taboola User ID': MIXPANEL_PROPS.taboolaUserId});
                mixPanelInstance.track(eventName, props);
            }
        }

        TRC.Mixpanel = Mixpanel;

        /* public methods for unitests */
        if (window._trcIsUTactive) {
            TRC.Mixpanel.getInstance = () => mixPanelInstance;
            TRC.Mixpanel.setInstance = val => mixPanelInstance = val;
            TRC.Mixpanel.clearInstance = () => mixPanelInstance = undefined;
        }
    })(window);

    /* EXAMPLE DATA FOR "widgetsArr"
    {
        orientation: 'H',
        gap: '1em', // Gap between child elements (from all sides)
        children: [{
                name: "thumbnails-feed",
                flexSize: 7,
            },
            {
                flexSize: 3,
                orientation: 'V',
                gap: '1em',
                children: [
                    { name: "thumbnails-feed" },
                    { name: "thumbnails-feed" }
                ]
            }
        ]
    }
    */

    (function () {
        TRC.multiWidget = {
            /**
             * initialize multi-widget flow
             * @param { Object }
             * @return { Object } DOM node
             */
            init({
                originalContainer, multiWidget, widgetOptions, initRBox, trcManager
            }) {
                const containerElm = originalContainer;
                this.trcManager = trcManager;
                const isRTL = this.trcManager.direction === 'rtl';
                const multiWidgetArr = [multiWidget];

                if (!originalContainer.parentNode) {
                    return null;
                }
                
                widgetOptions.multiWidgetRecItems = [].slice.call(widgetOptions.response.trc['video-list'].video);
                
                /* For cases there is no items - dont display the widget (like normal widget behavior) */
                if (!widgetOptions.multiWidgetRecItems.length && this.trcManager.global['mw-display-none-on-no-items-to-render']) {
                    originalContainer.style.display = 'none';
                }
                
                TRC.multiWidget.recursiveBuild.call(this, {
                    widgetsArr: multiWidgetArr,
                    containerElm,
                    depth: 0,
                    parentLayout: multiWidgetArr,
                    widgetOptions,
                    initRBox,
                    isRTL
                });

                containerElm.className += ' trc_multi_widget';
                
                return containerElm;
            },

            /**
             * Given a an Array of nested widgets ' layout and a container DOM element, builds nested DOM structure
             * @param { Object }
             */
            recursiveBuild({
                widgetsArr,
                containerElm,
                depth,
                parentLayout,
                widgetOptions,
                initRBox,
                isRTL
            }) {
                parentLayout.isRTL = isRTL;

                widgetsArr.forEach(widgetLayoutConf => {
                    const widgetLayoutData = __trcCopyProps(widgetLayoutConf, {});

                    // if this container is just a wrapper for other widgets
                    if (widgetLayoutData.children) {
                        if (!widgetLayoutData.children.length) {
                            return;
                        }
                        const wrapperElm = TRC.multiWidget.createWrapper(widgetLayoutData);
                        containerElm.appendChild(wrapperElm);
                        containerElm = wrapperElm;

                        TRC.multiWidget.addMargin(containerElm.previousSibling, parentLayout);

                        // go deeper
                        TRC.multiWidget.recursiveBuild.call(this, {
                            widgetsArr: widgetLayoutData.children,
                            depth: depth + 1,
                            parentLayout: widgetLayoutData,
                            containerElm,
                            widgetOptions,
                            initRBox,
                            isRTL
                        });
                    } else {
                        const widgetElm = TRC.multiWidget.createWidget.call(this, {
                            layout: widgetLayoutData,
                            widgetOptions,
                            initRBox,
                            isRTL
                        });

                        containerElm.appendChild(widgetElm);

                        TRC.multiWidget.addMargin(widgetElm.previousSibling, parentLayout);
                    }

                    // wrapper / widget flex-item styles
                    if (widgetLayoutData.flexSize) {
                        widgetLayoutData.container.style.msFlex = widgetLayoutData.container.style.flex = widgetLayoutData.flexSize;
                        widgetLayoutData.container.style.overflow = 'hidden';
                    }
                });
            },

            addMargin(elm, {
                gap,
                orientation,
                isRTL
            }) {
                if (!elm || !gap) return;

                const marginDirection = isRTL ? 'Left' : 'Right';
                const marginPropName = `margin${orientation === 'V' ? 'Bottom' : marginDirection}`;
                elm.style[marginPropName] = gap;
            },

            /**
             * Creates a wrapper element for any part of the multi-widget tree which has multiple children
             * @return {Object} - DOM node
             * @param layout
             */
            createWrapper(layout) {
                const newElm = document.createElement('div');

                // flex wrapper styles
                newElm.className += ' trc_multi_widget_container';

                // set flex container styles
                if (layout.orientation === 'V') {
                    newElm.style.msFlexDirection = newElm.style.flexDirection = 'column';
                }

                layout.container = newElm;

                return newElm;
            },

            /**
             * create a super - widget item(single widget)
             * @param { Object }
             */
            createWidget({
                layout,
                widgetOptions,
                initRBox
            }) {
                // create an RBox host node
                layout.container = document.createElement('div');

                const {container, name} = layout;

                this.ensureValidContainer(container);

                // if the widget has a name, include it as a node attribute to easily debug the correct widgets rendering order
                if (name) {
                    container.setAttribute('widget-name', name);
                }

                widgetOptions.mode_name = widgetOptions.mode = widgetOptions.response.trc['video-list']['base-mode'] = layout.name;
                widgetOptions.multiWidgetModeLevelData = TRC.multiWidget.formatMultiWidgetPO(layout);
                // start the RBox creation flow
                layout.RBox = initRBox.call(this, container, widgetOptions);

                return container;
            },

            formatMultiWidgetPO(layout) {
                if (layout.po) {
                    const newLayout = __trcCopyProps(layout, {});
                    newLayout['properties-override'] = TRC.util.jsonParseCustomNative(`{${layout.po}}`);
                    return newLayout;
                }
                return layout;
            }
        };
    }());

    /* External code loading methods */
    TRC.net =(function(win,doc){
    	var filesAdded = {}, // registry of files that where requested to be loaded
    		logs = [],

    		modObject = {
    			/**
    			 * Load an external JS or CSS file into the browser
    			 * @param fileName URL to load the file from
    			 * @param fileType type of file to load 'js' or 'css'
    			 * @param oCallback callback method to invoke when the file is ready;
    			 * @type Element
    			 * @return reference to the &lt;script&gt; or &lt;style&gt; element that contains the content of the file
    			 */
    			loadScript : function(fileName, fileType, oCallback, defer, async) {
    				var firstScriptElement = doc.getElementsByTagName('script')[0],
    					fileref = null;

    				if (fileType == "js") { // if filename is a external JavaScript file
    					fileref = doc.createElement('script');
    					fileref.type = 'text/javascript';
    					fileref.src = TRC.shiftDomain(fileName);
    					fileref.charset = "UTF-8";
    					if (!!defer) {
                            fileref.setAttribute('defer', 'defer');
                        } else if (!!async){
                            fileref.setAttribute('async', 'async');
                        }
    				} else if (fileType == "css") { // if filename is an external CSS file
    					fileref = doc.createElement("link");
    					fileref.rel = "stylesheet";
    					fileref.type = "text/css";
    					fileref.href = fileName;
    				} else
    					throw new Error("External reference loaded must be of type 'js' or 'css'!");

    				if (typeof oCallback == 'function') { // honor onload handlers
    					fileref.addEventListener('load', oCallback, false);
    					fileref.addEventListener('error', oCallback, false);
    				}

    				// Since we are not sure if we have a head elemnet, if it is closed already and safe for appending,
    				// the most safe thing to do is to insert the new script/link element before the first script
    				// element in this document
    				firstScriptElement.parentNode.insertBefore(fileref, firstScriptElement);

    				return fileref;
    			},
    			fireSimpleHttpRequest : function(src) {
    				    var img = new Image();
    				    img.src = src;
    					logs.push(img);
    			},
    			fireBeaconHttpRequest : function(src) {
    				win.navigator && navigator.sendBeacon && navigator.sendBeacon(src);
    			}
    		};

    	return modObject;

    })(window,document);

    (() => {

        const paramNames = {
                timeStamp: 'tim=',
                type: 'type=',
                message: 'msg=',
                debugLevel: 'llvl=',
                id: 'id='
            },
            protocol = TRC.PROTOCOL,
            formatUrlParams = function (urlParams) {
                const formattedParams = [];

                Object.keys(urlParams).forEach(key => {
                    formattedParams.push(`${encodeURIComponent(key)}=${encodeURIComponent(urlParams[key])}`);
                });
                return formattedParams.join('&');
            };

        let logCounter = 0;
        
        function isNewLoggingMechansimOn() {
            return window.TRCImpl && TRC.util.isPercentEnabled(window.TRCImpl.global, 'new-logging-mechanism-on');
        }

        function logMsgToServer(src, shouldUseBeacon) {
            if (shouldUseBeacon) {
                TRC.net.fireBeaconHttpRequest(src);
            } else {
                TRC.net.fireSimpleHttpRequest(src);
            }
        }

        function logMsg(host, level, msg, timestamp, pubId, extraUrlParams, shouldUseBeacon) {
            if (isNewLoggingMechansimOn() && window.SubtleCrypto) {
                return TRC.cryptoKeysManager.getPageViewUniqueID().then(uuid => {
                    this.logMsgToServer(`${protocol}//${host}/${pubId}/log/2/debug?${getLogParams(level, msg, timestamp, extraUrlParams, uuid)}`, shouldUseBeacon);
                }).catch(() => {
                    this.logMsgToServer(`${protocol}//${host}/${pubId}/log/2/debug?${getLogParams(level, msg, timestamp, extraUrlParams)}`, shouldUseBeacon);
                });
            }
            this.logMsgToServer(`${protocol}//${host}/${pubId}/log/2/debug?${getLogParams(level, msg, timestamp, extraUrlParams)}`);
        }

        function getLogParams(level, msg, timeStamp, extraUrlParams, uuid) {

            const loaderType = window.TRCImpl && window.TRCImpl.getSystemFlag('loaderType');

            return `${paramNames.timeStamp + encodeURIComponent(timeStamp)}&${paramNames.type}${encodeURIComponent(TRC.modDebug.getType(level))}&${ 
            paramNames.message}${encodeURIComponent(msg) 
        }${(window.trc_debug_level > 1) ? (`&${paramNames.debugLevel}${window.trc_debug_level}`) : '' 
        }&${paramNames.id}${Math.floor(Math.random() * 10000)}${(window.TRC.version) ? `&cv=${window.TRC.version}` : ''}${loaderType ? `&lt=${loaderType}` : '' 
        }${isNewLoggingMechansimOn() && window.SubtleCrypto && uuid
            ? `&uuid=${uuid
            }&dcc=${++logCounter}`
            : '' 
        }${extraUrlParams ? `&${formatUrlParams(extraUrlParams)}` : ''}`;
        }

        TRC.newDebugLogger = {
            logMsg,
            logMsgToServer
        };


        if (window._trcIsUTactive) {
            TRC.newDebugLogger.getLogParams = getLogParams;
            TRC.newDebugLogger.resetCounter = function () {
                logCounter = 0;
            };
        }

    })();

    (() => {
        const PREFIX = 'ack';
        TRC.pageLevelFeaturesManager = {
            features: {
                'explore-more': {
                    responseKey: 'exm',
                    enableInIframe: true, // for now we enable explore more in iframe and disable it using global configuration for publishers
                    functionCall: (response, key) => {
                        TRC.pageLevelFeaturesManager.getFeatureOnFeedLevel(response, key);
                    }
                },
                'virtual-placement': {
                    responseKey: 'vpl',
                    enableInIframe: true,
                    functionCall: (response, key) => {
                        TRC.pageLevelFeaturesManager.getFeatureOnPageLevel(response, key);
                    }
                },
                vignette: {
                    responseKey: 'vig',
                    enableInIframe: true,
                    functionCall: (response, key) => {
                        TRC.pageLevelFeaturesManager.getFeatureOnProdsLevel(response, key);
                    }
                }
            },
            pageLevelFeatures: {},
            disableFeatureOnIframe() {
                const {pageLevelFeatures} = TRC.pageLevelFeaturesManager;
                const isWithinIframe = window.self !== window.top;
                if (isWithinIframe) {
                    const featureNames = Object.keys(this.features);
                    for (let i = 0; i < featureNames.length; i++) {
                        const featureName = featureNames[i];
                        const {responseKey} = this.features[featureName];
                        const enableFeatureInIframeFlag = TRCImpl.global[`enable-${responseKey}-inside-iframe`];
                        let {enableInIframe} = this.features[featureName];

                        /* if the global flag exist it's override the default value */
                        if (enableFeatureInIframeFlag !== undefined) {
                            enableInIframe = enableFeatureInIframeFlag;
                        }
                        /* update trc that this feature to not render (do not to response it) because it's disabled */
                        if (enableInIframe === false) {
                            const plfKey = this.getPlfKey(responseKey);
                            pageLevelFeatures[plfKey] = true;
                        }
                    }
                }
            },
            getFeature(response) {

                Object.keys(this.features).forEach(featureName => {
                    const feature = this.features[featureName],
                        key = feature.responseKey,
                        isFeatureEnabled = this.pageLevelFeatures[key];

                    if (!isFeatureEnabled) {
                        try {
                            feature.functionCall(response, key);
                        } catch (e) {
                            __trcError('Error in functionCall in pageLevelFeaturesManager', e);
                        }
                    }
                });
            },

            /**
             * Get Feature on feed element (trc.f): setting this.pageLevelFeatures at featureKey location
             * @param response
             * @param featureKey - at define in response
             * @returns {boolean}
             */
            getFeatureOnFeedLevel(response, featureKey) {
                const feeds = response.trc.f,
                    feedsPlacements = feeds && Object.keys(feeds);

                if (feedsPlacements) {
                    for (let i = 0; i < feedsPlacements.length; i++) {
                        const feedsPlacement = feeds[feedsPlacements[i]];
                        const isFeatureExcitingInThisPlacement = feedsPlacement[featureKey];
                        if (isFeatureExcitingInThisPlacement) {
                            const plfKey = this.getPlfKey(featureKey);
                            return this.pageLevelFeatures[plfKey] = true;
                        }
                    }
                }
            },

            /**
             * Get Feature on page level (trc): setting this.pageLevelFeatures at featureKey location
             * @param response
             * @param featureKey
             * @returns {boolean}
             */
            getFeatureOnPageLevel(response, featureKey) {
                if (response.trc && response.trc[featureKey]) {
                    const plfKey = this.getPlfKey(featureKey);
                    return this.pageLevelFeatures[plfKey] = true;
                }
            },

            /**
             * Get the key as TRC need it
             * @param featureKey
             * @returns {string}
             */
            getPlfKey(featureKey) {
                return `${PREFIX}_${featureKey}`;
            },

            getFeatureOnProdsLevel(response, featureKey) {
                if (response.trc && response.trc.prods && response.trc.prods[featureKey]) {
                    const plfKey = this.getPlfKey(featureKey);
                    this.pageLevelFeatures[plfKey] = true;
                }
            }
        };
    })();

    (() => {

        let _referrer = null;

        class PageReferrer {
            static init(globalFlags) {
                PageReferrer.setReferrer(globalFlags);
                if (globalFlags['keep-referrer-in-session'] && !TRC.dom.isInIframe()) {
                    TRC.pageManager.sessionStorageSetValue('tbl-session-referrer', location.href);
                }
            }

            static updateReferrer(newReferrer) {
                _referrer = newReferrer;
            }

            static getReferrer() {
                return _referrer;
            }

            static setReferrer(globalFlags) {
                _referrer = _referrer
                            || getReferrerFromLinks()
                            || getReferrerFromDocument()
                            || getReferrerFromSessionData(globalFlags)
                            || '';


                function getReferrerFromLinks() {
                    const links = document.head.getElementsByTagName('link');
                    for (let i = 0; i < links.length; i++) {
                        if (links[i].rel === 'referrer') {
                            return links[i].href;
                        }
                    }
                }

                function getReferrerFromDocument() {
                    let currentReferrer = '';
                    try {
                        currentReferrer = (top.window.TRC && top.window.TRC.hasFeedView) ? decodeURI(document.referrer)
                            : decodeURI(top.window.document.referrer);

                        return ((currentReferrer && !/https?:\/\/(\w+)\.taboola(syndication)?\.com/.test(currentReferrer))
                            ? currentReferrer.substr(0, 400)
                            : currentReferrer.split('?')[0]);
                    } catch (e) {
                        __trcDebug('TRC.Manager.getReferrer : rendering in cross domain iframe');
                    }
                }

                function getReferrerFromSessionData(globalFlags) {
                    if (globalFlags['keep-referrer-in-session']) {
                        const referrerFromSessionStorage = TRC.pageManager.sessionStorageGetValue('tbl-session-referrer');
                        if (referrerFromSessionStorage && location.hostname === new TRC.URL(referrerFromSessionStorage).host) {
                            return referrerFromSessionStorage;
                        }
                    }
                }
            }
        }

        TRC.PageReferrer = PageReferrer;

    })();

    /*
     * Page information detection and storage API
     *
     * Loaded independently by the R-Player in addition to being included in the standard R-Box implementation file
     */
    (function(win,doc){

    	// make sure our name space is defined, even when being loaded by the R-Player directly (with no R-Box loader)
    	win.TRC = win.TRC || {};

    	var instance,
            forceTrcCache = false,
            TABOOLA_GLOBAL_KEY = 'taboola global',
        	TEST_COOKIE_NAME = 'trctestcookie';

    	/**
    	  * A storage implementation that uses the local document's domain cookies (instead of our own cookies, we're
    	  * funny that way ;-) ).
    	  */
    	function DomainCookieStorage() {
    		var myCookieName = 'trc_cookie_storage',
    		    myLocalCache = {},
    	     	dmCookies = document.cookie.split(/;\s+/);

    		for ( var i = 0; i < dmCookies.length; i++) {
    			var kv = TRC.text.lsplit(dmCookies[i],'=', 2);
    			var key = unescape(kv[0]), val = unescape(kv[1]);
    			if (key == myCookieName) {
    				var values = val.split("|");
    				for (var k = 0; k < values.length; k++) {
    					var kv = values[k].split('=');
    					myLocalCache[unescape(kv[0])] = unescape(kv[1]);
    				}
    				break;
    			}
    		}

    		this.save = function () {
    			var list = new Array(),
    				sign,
    				expires;
    			for (var p in myLocalCache) {
    				if (myLocalCache.hasOwnProperty(p) && myLocalCache[p] != null) {
    					list[list.length] = escape(p) + "=" + escape(myLocalCache[p]);
    				}
    			}
    			sign = list.length > 0 ? 1 : -1;
    			expires = new Date(new Date().getTime() + (sign * 365 * 86400000));
    			// Check if cookie needs to be stored in subdomain or the main domain
    			var domain = this.getDomain();
    			if (typeof document.cookie !== "undefined") {
    				document.cookie = myCookieName + "=" + escape(list.join("|")) + ';domain=' + domain + ';path=/;expires=' + expires.toUTCString();
    			}
    		};

    		this.getDomain = function () {
    			// if feature enabled then we store at top level domain
    			return (TRCImpl.global['store-first-party-cookie-in-subdomain'] === true || TRCImpl.global['store-first-party-cookie-in-subdomain'] === 'true')
    				? PageManager.getPageSubDomain() : '';
    		};

    		this.getValue = function (key) {
    			return myLocalCache.hasOwnProperty(key) ? myLocalCache[key] : null;
    		};
    		this.setValue = function (key, value) {
    			myLocalCache[key] = value;
    			this.save();
    		};
    		this.removeKey = function (key) {
    			delete myLocalCache[key];
    			this.save();
    		};
    		this.delete = function() {
    			myLocalCache = {};
    			this.save();
    		};
    		return this;
    	}

    	/**
    	  * A dummy storage that implements getValue() and setValue() as no-ops
    	  */
    	function DummyStorage(data) {
    		var localStorage = data || {};
    		this.getValue = function(key) {
    			return localStorage[key] ? localStorage[key] : null;
    		};
    		this.setValue = function(key, value) {
    			localStorage[key] = value;
    		};
    		this.removeKey = function (key ) {
    			delete localStorage[key];
    		};
            this.getData = function(){
                return localStorage;
            };
    		this.delete = function() {
    			localStorage = {};
    		};
    		return this;
    	}

    	/**
    	  * A storage implementation that uses W3 WebStorage implementation, without Internet Explorer extensions, but
    	  * accounting for them.
    	  */
    	function W3Storage(type) {
    		this.getValue = function(key) {
    			return win[type + 'Storage'].getItem(key);
    		};
    		this.setValue = function(key, value) {
    			try {
    				win[type + 'Storage'].setItem(key, value);
    			} catch (e) {
    				// ignore setValue errors in underlying data structure as there
    				// is no way to report them
    			}
    		};
    		this.removeKey = function (key ) {
    			try {
    				win[type + 'Storage'].removeItem(key);
    			} catch (e) {
    				// ignore setValue errors in underlying data structure as there
    				// is no way to report them
    			}
    		};
    		return this;
    	}

    	/**
    	 * get local/session storage if available
    	 * @param {String} type - storage type ("local" or "session")
    	 * @returns {W3Storage|null}
    	 */
    	function getStorage(type){
    		try {
    			if(TRC.useStorageDetection) {
    				var storage = win[type + "Storage"],
    					stamp = (new Date()).getTime() + "",
    					key = "_taboolaStorageDetection";
    				storage.setItem(key, stamp);
    				if(storage.getItem(key) === stamp ){
    					storage.removeItem(key);
    					if(storage){
    						return new W3Storage(type);
    					}
    				}
    			}
    		} catch (e) {
    			return null;
    		}
    	}

    	/* Page Manager implementation */
    	var PageManager = function() {
    		this.publisher_id = null;
    		this.item_id = null;
    		this.page_id = null;
    		this.state = {};
    		this.stateStack = [];

    		this.getPageSubDomain = function () {
    			return this.getPageDomainFromHostName(doc.location.hostname);
    		};

    		this.getPageDomainFromHostName = function (hostname) {
    			var domain = "";
    			try {
    				var domainLabels = hostname.split('.').reverse();
    				domain = "." + domainLabels[1] + '.' + domainLabels[0];
    				if (domainLabels.length >= 3) {
    					if (domainLabels[1].match(/^(com|edu|gov|net|mil|org|nom|co|name|info|biz)$/i)) {
    						domain = "." + domainLabels[2] + '.' + domainLabels[1] + '.' + domainLabels[0];
    					}
    				}
    			} catch (err) {
    				// do nothing. the default behaviour will take care of it
    			}
    			return domain;
    		};

    		/**
    		 * Instatiate the local storage implemenation
    		 */
    		this.getLocalStorageImplementation = function (localStorageUsage, type) {
    			// privateStorageImpl allready exists
    			if (this.state.privateStorageImpl != null && localStorageUsage != 'strict-w3c-storage')
    				return this.state.privateStorageImpl;
    			var conf = win.TRCImpl ? win.TRCImpl.global : {};
    			localStorageUsage = localStorageUsage || (conf['local-storage-usage'] ? conf['local-storage-usage'] : 'prefer-w3c-storage');

    			switch (localStorageUsage) {
                case 'strict-w3c-storage': //return localStorage or nothing(null)
                       if (type === 'session'){
                           return getStorage('session');
                       } else {
                           return getStorage('local'); // localStroage is the default
                       }

    			case 'prefer-w3c-storage':
                        var localStorage = getStorage('local');
                        if(localStorage){
                           return this.state.privateStorageImpl = localStorage;
                        }
    			case 'prefer-cookies':
    				try {
    					if (this.canWriteCookies()) {
    						return this.state.privateStorageImpl = new DomainCookieStorage();
                        }
    				} catch (e) {
    					// ignore failures to init DomainCookie storage and let fall back handle it
    				}
    			default:
    				return this.state.privateStorageImpl = new DummyStorage();
    			}

    		};

            this.getFirstPartyCookie = function () {

                if (this.state.firstPartyCookie) {
        		    return this.state.firstPartyCookie;
    		    }

    		    var localStorageImpl = this.getLocalStorageImplementation();
    		    if (localStorageImpl instanceof DomainCookieStorage ||
                    localStorageImpl instanceof DummyStorage) {
                    return this.state.firstPartyCookie = localStorageImpl;
    			}

    			try {
                    if (this.canWriteCookies()) {
                        return this.state.firstPartyCookie = new DomainCookieStorage();
    				}
    			} catch (e) {
    				// ignore failures to init DomainCookie storage and let fall back handle it
    			}

    			return this.state.firstPartyCookie = new DummyStorage();
            };

            this.canWriteCookies = function () {
    			var conf = win.TRCImpl ? win.TRCImpl.global : {},
    				isCookieWriteSuccess;
    			if (conf['use-trctestcookie']) {
    				document.cookie = TEST_COOKIE_NAME + '=ok';
    				isCookieWriteSuccess = document.cookie.indexOf(TEST_COOKIE_NAME) !== -1;
    				document.cookie = TEST_COOKIE_NAME + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    				return isCookieWriteSuccess;
    			} else {
    				return win.navigator.cookieEnabled;
    			}
            };

            this.getDummyStorage = function(data){
                return new DummyStorage(data);
            };

    		this.trcParseParams = function(queryString) {
    			if (!queryString || owner.item_id)
    				return;
    			var parts = queryString.split("&");
    			for ( var i = 0; i < parts.length; i++) {
    				var kv = TRC.text.lsplit(parts[i],'=', 2);
    				switch (unescape(kv[0])) {
    					case 'item_id':
    						owner.item_id = unescape(kv[1]);
    						break;
    					case 'publisher_id':
    						owner.publisher_id = unescape(kv[1]);
    						break;
    				}
    			}

    		};

    		this.trcGetPublisherParams = function() {
    			var scripts = document.getElementsByTagName('script');
    			for ( var i = 0; i < scripts.length; i++) {
    				var key = scripts[i].src.split('taboola(syndication)?.com/libtrc/')[1];
    				if (key) {
    					if (scripts[i].src.search(/taboola(syndication)?.com.*page_management/) >= 0) {
    						key = key.split('?')[0];
    						var subparts = key.split('/');
    						owner.page_id = subparts[0];
    						if (subparts.length > 2)
    							owner.page_id += '/' + subparts[1];
    						owner.trcParseParams(scripts[i].src.split('?')[1]);
    					}
    				}
    			}
    		};

    		/**
    		 * Calculate the current page ID
    		 * On AMP pages with split feed, this returns the viewID of the first loaded iframe
    		 */
    		this.getPageData = function() {
    			var topWindow = this.getTopMostWindow();

    			//try to write the view id variable on window top, so that all RBoxes will have the same
    			//view ID, even when rendered inside an iframe. This is expected to fail in cross domain iframes, so we fallback
    			//to the iframe's own window object.

    		    if (!topWindow.taboola_view_id){
    				topWindow.taboola_view_id = (new Date).getTime();
    			}

    			if (TRC.isAMPSplitFeed && typeof TRC.syncViewID !== 'undefined' && TRC.syncViewID !== '') {
    				return TRC.syncViewID;
    			}

    			return topWindow.taboola_view_id;
    		};

    		/**
    		 * Implement TRC Client Session Persistency PRD 4.3.A.i
    		 */
    		this.storeValue = function(key, value) {
                this.storePublisherValue(TABOOLA_GLOBAL_KEY, key, value);
    		};


    		/**
    		 * Implement TRC Client Session Persistency PRD 4.3.A.i
    		 */
    		this.removeKey = function(key) {
                this.removePublisherKey(TABOOLA_GLOBAL_KEY, key);
            };

    		/**
    		 * Implement TRC Client Session Persistency PRD 4.3.A.iii
    		 */
    		this.getValue = function(key) {
                return this.getPublisherValue(TABOOLA_GLOBAL_KEY, key);
            };

    		/**
    		 * Implement TRC Client Session Persistency PRD 4.3.A.ii
    		 */
    		this.storePublisherValue = function(publisher, key, value) {
                var keyWithPublisher;
                if (this.isNotAllowedToWriteValue(key, value)) {
    				return;
                }
                keyWithPublisher = this.buildKeyWithPublisher(publisher, key);
    			this.getLocalStorageImplementation().setValue(keyWithPublisher, value);
    			this.addKeyToStoredKeysList(keyWithPublisher);
    		};

            this.isNotAllowedToWriteValue = function (key, value) {
                return value == null || value == undefined || (TRC.doNotTrack && !this.isAllowedKeyWhenDoNotTrack(key));
            };

            this.buildKeyWithPublisher = function (publisher, key) {
                return publisher + ':' + key;
            };

    		/**
    		 * Implement TRC Client Session Persistency PRD 4.3.A.iv
    		 */
    		this.getPublisherValue = function(publisher, key) {
    			if (TRC.doNotTrack && !this.isAllowedKeyWhenDoNotTrack(key)){
    				return null;
    			}
                return this.getLocalStorageImplementation().getValue(this.buildKeyWithPublisher(publisher, key));
    		};

    		this.removePublisherKey = function(publisher, key) {
                return this.getLocalStorageImplementation().removeKey(this.buildKeyWithPublisher(publisher, key));
    		};

    		this.removeAllKeys = function(){
    			var storedKeysList = this.getStoredKeysList(),
    				updatedStoredKeysList = [],
    				currentKey;

    			for(var i = 0 ; i < storedKeysList.length ; i++){
    				currentKey = storedKeysList[i];
    				if (!this.isAllowedKeyWhenDoNotTrack(currentKey)){
    					this.getLocalStorageImplementation().removeKey(currentKey);
    				}
    				else {
    					updatedStoredKeysList.push(currentKey);
    				}
    			}

    			this.setStoredKeysList(updatedStoredKeysList);
    		};

    		this.addKeyToStoredKeysList = function(keyWithPublisher){
    			var storedKeysList = this.getStoredKeysList();

    			if (storedKeysList.indexOf(keyWithPublisher) === -1){
    				storedKeysList.push(keyWithPublisher);
    				this.setStoredKeysList(storedKeysList);
    			}
    		};

    		this.getStoredKeysList = function(){
                var storedKeysListAsStr = this.getLocalStorageImplementation().getValue(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'local-storage-keys')), storedKeysList;
    			try{
    				storedKeysList = TRC.util.jsonParseWithNative(storedKeysListAsStr) || [];
    			} catch(e){
    				storedKeysList = [];
    				__trcError('Could not parse local storage keys', e);
    			}

    			return storedKeysList;
    		};

    		this.setStoredKeysList = function(storedKeysList){
    			var storedKeysListStr;
    			try{
    				storedKeysListStr = __trcJSONify(storedKeysList);
                    this.getLocalStorageImplementation().setValue(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'local-storage-keys'), storedKeysListStr);
    			} catch(e){
    				__trcError('Could not stringify local storage keys', e);
    				return;
    			}
    		};

    		this.isAllowedKeyWhenDoNotTrack = function(key){
    			var conf = win.TRCImpl ? (win.TRCImpl.global || {}) : {},
    				allowedKeys = conf['dnt-allowed-keys'] || ['session-id'],
    				keyWithoutPublisher;

    			if (key === null || key === undefined){
    				return false;
    			}
    			keyWithoutPublisher = key.split(':')[1] || key;

    			return allowedKeys.indexOf(keyWithoutPublisher) !== -1;
    		};

            this.removeUserId = function () {
                TRC.pageManager.removeKey('user-id');//Don't remove this line. We want to make sure to remove user-id. it's for cases where we stored it before we implemented removeAllKeys for DNT.
                if (TRCImpl.global['store-userid-first-party-cookie']) {
                    this.getFirstPartyCookie().removeKey(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'user-id'));
                }
            };

            this.storeUserId = function (userId, consentRequiredAndMissing) {
            	if (this.isNotAllowedToWriteValue('user-id', userId)) {
                    return;
                }

    			if (consentRequiredAndMissing) {
    				this.getFirstPartyCookie().delete();
    			} else {
    				this.storePublisherValue(TABOOLA_GLOBAL_KEY, 'user-id', userId);
    				if (TRCImpl.global['store-userid-first-party-cookie']) {
    					if (this.getFirstPartyCookie() !== this.getLocalStorageImplementation()) {
    						this.getFirstPartyCookie().setValue(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'user-id'), userId);
    					}
    				}
    			}
    		};

            this.getUserId = function () {
    			return TRC.user_id || TRC.pageManager.getValue('user-id');
    		};

    		this.storeSessionId = function (sessionId, consentRequiredAndMissing) {
    			if (this.isNotAllowedToWriteValue('session-id', sessionId)) {
    				return;
    			}

    			if (consentRequiredAndMissing) {
    				this.getFirstPartyCookie().delete();
    			} else if (TRCImpl.global['store-sessiondata-first-party-cookie'] == true) {
    				if (this.getFirstPartyCookie() !== this.getLocalStorageImplementation()) {
    					this.getFirstPartyCookie().setValue(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'session-data'), sessionId);
    				}
    			}
    		};

    		this.getUserIdFirstPartyCookie = function () {
    			return this.getFirstPartyCookie().getValue(this.buildKeyWithPublisher(TABOOLA_GLOBAL_KEY, 'user-id'));
    		};

    		this.getUserIdFromReferrer = function () {
    			var referrer = this.getReferrer();
    			return (referrer && referrer.indexOf("taboola") > -1) ? TRC.URL.prototype.getParameter.call(referrer,"ui") : null;
    		};

    		/**
    		 * Tries to get the top most window object safely. If the RBox is inside an IFrame, returns the top window,
    		 * unless it fails due to cross domain restrictions and then the IFrame's own window object is returned.
    		 * @returns {*}
    		 */
    		this.getTopMostWindow = function() {
    			var topWindow;

    			try {
    				topWindow = win.top;
    				topWindow.TRC = topWindow.TRC || {};

    				//Cross domain iframe - we failed to read the TRC parameter, so fallback to the iframe's own Window.object.
    				//This is required because Safari fails silently when trying to write on window.top on cross domain iframe
    				if(!topWindow.TRC) {
    					topWindow = win;
    				}

                    /**
    				 * The following check if especially for Edge browser. It tries to access public object on window.top. As opposed to
    				 * window.top.TRC which we created and can access on Edge, window.location is not accessible in some iframes, cuasing an exception
    				 * to be thrown later. We would like to avoid this exception, so we fallback to the current window in such cases.
    				 *
    				 * For more details see: https://jira.taboola.com/browse/DEV-43088
    				 *
    				 * The feature flag check that surrounds the code is just for safety measures and can be removed
    				 * after July 2019
                     */
    				if(!TRCImpl || !TRCImpl.global || !TRCImpl.global['disable-strict-top-window-check']) {
    					var topLocation = topWindow.location;
    				}
    			} catch(e) {
    				topWindow = win;
    			}

    			return topWindow;
    		};

    		this.additionalDispatchParams = function() {
    			if (this.state.moreDispatchParams == null) {
    				this.state.moreDispatchParams = this.getCurrentURL().filtered;
    			}
    			var overrideDispatchParams = (win.TRCImpl && win.TRCImpl.trcForce) ? win.TRCImpl.trcForce : undefined;
    			var emptyDispatchParams = this.state.moreDispatchParams.length === 0;
    			if (emptyDispatchParams && !overrideDispatchParams) {
    				return '';
    			}
    			var dispatchParams = this.mergeDispatchValues(overrideDispatchParams);
    			return '&' + dispatchParams.join('&');
    		};

    		this.mergeDispatchValues = function(overrideDispatchParams) {
    			if (!overrideDispatchParams){
    				return this.state.moreDispatchParams;
    			}
    			var parameterPairs = TRC.util.merge({}, overrideDispatchParams);

    			if (this.state.moreDispatchParams.length > 0){
    				this.state.moreDispatchParams.forEach(function (param) {
    					var keyValueQueryParam = param.split("=");
    					parameterPairs[keyValueQueryParam[0]] = keyValueQueryParam[1];
    				});
    			}

    			return Object.keys(parameterPairs).map(function (paramKey) {
    				return paramKey + '=' + parameterPairs[paramKey];
    			});
    		};

            this.getForceTrcCache = function(){
                return forceTrcCache;
            };
    		this.getCurrentURL = function() {
    			var currentUrl = (TRC.isAMP && win.context && win.context.canonicalUrl) || win.location.href;
    			var url = new TRC.URL( currentUrl ),
    			    search = [], filtered = [];
    			var populateParamArrays = function (shouldAddSearch){
    				return function(n) {
    					if (!n) return;
    					if (n.search('trc_') == 0 || n == 'taboola-debug'){
    						forceTrcCache = new Boolean(n.match(/trc_cache/)).valueOf();
    						filtered.push(n);
    					}
    					else if(shouldAddSearch) {
    						search.push(n);
    					}
    				}
    			};

    			if(win.context && win.context.location){
    				win.context.location.search.replace(/^\?/, '').split(/&/).forEach(populateParamArrays(false));
    			}
    			url.search.replace(/^\?/, '').split(/&/).forEach(populateParamArrays(true));

    			url.search = search.length > 0 ? '?' + search.join('&') : '';
    			var out = new String(url.toString());
    			out.filtered = filtered;
    			return out;
    		};

    		this.sessionStorageGetValue = function(key){
    			var storage = this.getLocalStorageImplementation('strict-w3c-storage', 'session');
    			return (storage && storage.getValue(key)) || null;
    		};

    		this.sessionStorageIsSupported = function () {
    			if (this.state.sessionStorageImpl !== undefined) {
    				return !!this.state.sessionStorageImpl;
    			}
    			this.state.sessionStorageImpl = this.getLocalStorageImplementation('strict-w3c-storage', 'session');
    			return !!this.state.sessionStorageImpl;
    		};

    		this.sessionStorageSetValue = function(key, value){
    			var storage = this.getLocalStorageImplementation('strict-w3c-storage', 'session');
    			if(storage) {
    				storage.setValue(key, value);
    			}
    		};

    		this.sessionStorageRemoveKey = function(key){
    			var storage = this.getLocalStorageImplementation('strict-w3c-storage', 'session');
    			if(storage) {
    				storage.removeKey(key);
    			}
    		};

    		this.initState = function() {
    			if (typeof this.state == 'undefined')
    				this.state = {};
    			this.state.privateStorageImpl = null;
    			this.state.sessionStorageImpl = undefined;
    			this.state.m_publisherDomains = { host : [], path : [], query : [] };
    			this.state.moreDispatchParams = null;
    		};

    		this.getReferrer = function() {
    			return TRC.PageReferrer.getReferrer();
    		};

    		this.updateReferrer = function(newReferrer) {
    			TRC.PageReferrer.updateReferrer(newReferrer);
    		};

    		this.initReferrer = function(globalFlags) {
    			TRC.PageReferrer.init(globalFlags);
    		};

    		this.pushState = function() {
    			this.stateStack.push(this.state);
    			delete this.state;
    			this.initState();
    		};

    		this.popState = function() {
    			if (this.stateStack.length > 0)
    				this.state = this.stateStack.pop();
    		};

    		/* Collection all query string parameters that being with 'trc_' and send
    		 * them to the dispatcher
    		 */
    		this.initState();

    		return this;
    	};

    	/**
    	 * Calculate the current page ID
    	 *
    	 * @return String with page ID if it can be calculated, null otherwise
    	 */
    	PageManager.getPageData = function() {
    	    return instance.getPageData();
    	    /*
    		var args = Array.prototype.slice.call(arguments);
    		return instance.getPageData.apply(null, args);
    		*/
    	};

    	/**
    	 * Store a global value into the current local storage database. Note: that this is normally implemented in such a
    	 * way so that two websites with different host names have different databases Note: the valye stored must be a
    	 * string as underlying implementations are not guranteed to support javascript data types.
    	 *
    	 * @param key
    	 *            Key name under which to store the value
    	 * @param value
    	 *            Value to store
    	 */
    	PageManager.storeValue = function(key, value) {
    		return instance.storeValue(key, value);
    	};

    	/**
    	 * Store a value that is specific for the current publisher, into the current local storage database. Note: the
    	 * valye stored must be a string as underlying implementations are not guranteed to support javascript data types.
    	 *
    	 * @param publisher
    	 *            Publisher id to store this value under
    	 * @param key
    	 *            Key name under which to store the value
    	 * @param value
    	 *            Value to store.
    	 */
    	PageManager.storePublisherValue = function(publisher, key, value) {
    		return instance.storePublisherValue(publisher, key, value);
    	};

    	/**
    	 * Retrieves a global value from the current local storage database. Note: that this is normally implemented in such
    	 * a way so that two websites with different host names have different databases
    	 *
    	 * @param key
    	 *            Key name under which the requested value is stored
    	 * @return String with the value or null if the key specified has no value associted.
    	 */
    	PageManager.getValue = function(key) {
    		return instance.getValue(key);
    	};

    	/**
    	 * Retrieves a value that is specific for the current publisher, from the current local storage database.
    	 *
    	 * @param publisher
    	 *            Publisher id for which to retrieve the value
    	 * @param key
    	 *            Key name under which the requested value is stored
    	 * @return String with the value or null if the key specified has no value associted.
    	 */
    	PageManager.getPublisherValue = function(publisher, key) {
    		return instance.getPublisherValue(publisher, key);
    	};

    	/**
    	 * Check if additional query string parameters are needed for the TRC dispatch
    	 * request for recommendations, and return a string of such additional parameters.
    	 * These parameters normally do not include any parameters required by the TRC
    	 * client-server protocol and that are already provided for by the client.
    	 *
    	 * Please note that the returned screen does not include a query string delimiter
    	 * prefix ("?" or "&"), though it does include any internal delimiters if required.
    	 * So, for example, it may return "key=value" or "key=value&key2=value2".
    	 *
    	 * @returns String with additional query string parameters
    	 */
    	PageManager.additionalDispatchParams = function() {
    		return instance.additionalDispatchParams();
    	};

    	/**
    	 * Get the current window URL, formatted without any additional "Taboola specific"
    	 * parameters.
    	 * @returns a valid URL
    	 */
    	PageManager.getCurrentURL = function () {
    		return instance.getCurrentURL();
    	};

    	PageManager.getPageSubDomain = function () {
    		return instance.getPageSubDomain();
    	};
    	/**
    	 * Push the current PageManager state of the page manager to a stack and reset the state.
    	 * This does not recalculate the page id, ATM.
    	 */
    	PageManager.pushState = function () {
    		return instance.pushState();
    	};

    	/**
    	 * Pop a state from the current state stack and set it as the current PageManager state.
    	 * If there is no state in the stack, then this is a no op - it will not affect the
    	 * current state.
    	 */
    	PageManager.popState = function() {
    		return instance.popState();
    	};

    	// initialize the singleton and register it in the global name space (so that R-Box and R-Player can share the same instance)
    	TRC.pageManager = instance = TRC.pageManager || new PageManager();

    	// register the global name PageManager so the R-Player can interoperate
    	win.PageManager = win.PageManager || PageManager;

    })(window,document);

    (() => {
        const visibleLevel = {
            item: 'i',
            placement: 'p'
        };
        class PlacementEventPostData {
            constructor() {
                this.postData = {};
            }
            
            setFullItemList(val) {
                if (typeof val === 'object') {
                    this.postData.fil = __trcJSONify(val);
                } else if (typeof val === 'string') {
                    this.postData.fil = val;
                }
            }

            // Page Geometry [Screen]:
            setScreenHeight(val) {
                this.postData.sh = val;
            }

            setScreenWidth(val) {
                this.postData.sw = val;
            }

            setScreenDensity(val) {
                this.postData.sde = val;
            }

            // Page Geometry [Browser/Viewport]:
            setBrowserWidth(val) {
                this.postData.bw = val;
            }

            setBrowserHeight(val) {
                this.postData.bh = val;
            }

            // Page Geometry [Document]:
            setDocumentWidth(val) {
                this.postData.dw = val;
            }

            setDocumentHeight(val) {
                this.postData.dh = val;
            }

            // Page Geometry [Article]:
            setArticlePos(val) {
                this.postData.bad = val;
            }

            // Page Geometry [Container]:
            setContainerPos(val) {
                this.postData.cd = val;
            }

            setContainerWidth(val) {
                this.postData.mw = val;
            }

            setVisibleLevel(isItemLevel) {
                this.postData.vl = isItemLevel ? visibleLevel.item : visibleLevel.placement;
            }

            setFirstVisibleEvent(val) {
                this.postData.fve = val;
            }

            setNewVisibleSent() {
                this.postData.nwv = true;
            }

            getAll() {
                return this.postData;
            }

            getSpecificItemsPostData(itemIdsArr) {
                try {
                    let {fil} = this.postData;
                    if (typeof fil === 'string') {
                        fil = __trcUnJSONify(fil);
                    }
                    if (fil) {
                        fil = fil.filter(element => element && itemIdsArr.indexOf(element.tii) > -1);
                    }
                    const itemPostData = new TRC.PlacementEventPostData();
                    itemPostData.setFullItemList(fil);
                    return itemPostData;
                } catch (e) {
                    __trcWarn('getSpecificItemsPostData error ', e);
                    return this;
                }
            }
        }
        
        TRC.PlacementEventPostData = PlacementEventPostData;
    })();

    /**
     * popupLink.es6.js
     * Component for creating "<a/>" element that trigger popup on desktop
     * and open a new tab on mobile
     */
    ((win, doc, trc) => {
        // public interface

        const init = (container, options) => {
            const {style = '', location = 'beforeend'} = options;
            style && TRC.dom.injectStyle(style);

            container.insertAdjacentHTML(location, createMarkup(options));
            onclick(getElementLink(location, container));
        };

        const createMarkup = options => {
            const {
                markup = '', href = '#', enableScrolling = 'no', classList = '', children = '', inlineStyle = '', wrapper
            } = options;

            let linkElement = `<a tblenablesscrolling="${enableScrolling}" href="${href}" 
                               class="${classList}" style="${inlineStyle}" rel="nofollow" target="_blank"
                               >${markup}${children}</a>`;

            if (wrapper) {
                linkElement = `<${wrapper.type} class="${wrapper.className}">${linkElement}</${wrapper.type}>`;
            }

            return linkElement;
        };

        const onclick = element => {
            if (!TRC.Device.isTouchDevice && !TRC.dom.isInIframe() && !TRCImpl.global['ccpa-new-tab']) {
                TRC.dom.on(element, 'click', event => TRC.aboutUs.open(event) || false);
            }
            if (TRC.dom.containsClass(element, 'link-ccpa')) {
                TRC.dom.on(element, 'click', () => TRC.ccpa.sendCcpaEvent('taboola', 'CLICKED'));
            }
        };

        const getElementLink = (location, container) => {
            switch (location) {
                case 'beforebegin': return container.previousElementSibling;
                case 'afterbegin': return container.firstElementChild;
                case 'beforeend': return container.lastElementChild;
                case 'afterend': return container.nextElementSibling;
                default: return container.firstElementChild;
            }
        };

        trc.PopupLink = {
            create: init
        };

    })(window, document, TRC);

    (function(win,doc){
    	
    	/**
    	 * Manages the post-render queue
    	 * @class PostRenderQueue
    	 */
    	var PostRenderQueue = TRC.PostRenderQueue = function() {
    		this.backend = [];
    		return this;
    	};
    	
    	PostRenderQueue.prototype.pushBack = function(name, func) {
    		__trcDebug('postRenderQueue.pushBack(' + name + ')');
    		this.backend.push({'name':name, 'func':func});
    	};
    	
    	PostRenderQueue.prototype.pushFront = function(name, func) {
    		__trcDebug('postRenderQueue.pushFront(' + name + ')');
    		this.backend.unshift({'name':name, 'func':func});
    	};
    	
    	PostRenderQueue.prototype.popFront = function() {
    		if (this.backend.length == 0) {
    			return null;
    		}
    		var front = this.backend.shift();
    		if (typeof front == 'function') {
    			// It's only a function - create a full object with dummy name for backward compatibility
    			return {'name':'unknown', 'func':front};
    		}
    		
    		// It's a full object - we assume it have a name and func defined
    		return front;
    	};

    })(window,document);

    /* Created by Effie.n on 6/24/15.
    *  integrated by Yoni.f on 6/29/15
    *
    *  Read More - shorting articles
    */

    ((win, doc) => {
        const ARTICLE_MAIN_CLASS = 'tbl-forkorts-article',
            ARTICLE_CLASSES = ` ${ARTICLE_MAIN_CLASS} ${ARTICLE_MAIN_CLASS}-active`,
            BUTTON_ID = `tbl-read-more-box-btn`,
            ARROW_SVG_CLASS = 'tbl-read-more-button-arrow',
            DEFAULT_CAPTION = 'Read%20More',
            BELOW_VP_RENDERING_MARGIN = 400;

        TRC._translationQueue = TRC._translationQueue || [];
        TRC._translationQueue.push({
            'read-more': {DEFAULT_CAPTION}
        });


        /**
         * sets an returns the configuration object for read more extracted
         * form different configuration possibilities
         * @param pageConfig
         * @param modeConfig
         * @returns {{
         *  caption: (*|HTMLTableCaptionElement|caption|F.caption||boolean),
         *  boxSelector: string, threshold: (*|number),
         *  backgroundColor: (*|CSSStyleDeclaration.backgroundColor|string|TRC.SliderManager.backgroundColor|string),
         *  minimizedSize: (*|number)
         *  }}
         */
        function getConfig(pageConfig, modeConfig) {

            const caption = TRC.translationManager.getLabel({feature: 'read-more', label: 'DEFAULT_CAPTION'}) || DEFAULT_CAPTION;
            return {
                caption: (pageConfig && pageConfig.caption) || (modeConfig && modeConfig.caption) || caption && decodeURIComponent(caption),
                boxSelector: (pageConfig && pageConfig.boxSelector) || (modeConfig && modeConfig.boxSelector) || null,
                threshold: (pageConfig && pageConfig.threshold) || (modeConfig && modeConfig.threshold) || 1100,
                backgroundColor: (pageConfig && pageConfig.backgroundColor) || (modeConfig && modeConfig.backgroundColor) || '#fff',
                minimizedSize: (pageConfig && pageConfig.minimizedSize) || (modeConfig && modeConfig.minimizedSize) || 800,
                scrollSize: (pageConfig && pageConfig.scrollSize) || (modeConfig && modeConfig.scrollSize) || 800,
                buttonTop: (pageConfig && pageConfig.buttonTop) || (modeConfig && modeConfig.buttonTop) || 48,
                buttonBottom: (pageConfig && pageConfig.buttonBottom) || (modeConfig && modeConfig.buttonBottom) || 28,
                divTop: (pageConfig && pageConfig.divTop) || (modeConfig && modeConfig.divTop) || 75,
                gradient: (pageConfig && pageConfig.gradient) || (modeConfig && modeConfig.gradient) || 40,
                cutoffType: (pageConfig && pageConfig.cutoffType) || (modeConfig && modeConfig.cutoffType) || 'ARTICLE',
                anchorSelector: (pageConfig && pageConfig.anchorSelector) || (modeConfig && modeConfig.anchorSelector) || null,
                lengthFromAnchorElementType: (pageConfig && pageConfig.lengthFromAnchorElementType) || (modeConfig && modeConfig.lengthFromAnchorElementType) || 'BELOW',
                lengthFromAnchorElement: (pageConfig && pageConfig.lengthFromAnchorElement) || (modeConfig && modeConfig.lengthFromAnchorElement) || 30
            };
        }

        /**
         * returns related css text
         * @param options
         * @returns {string}
         */
        // eslint-disable-next-line no-unused-vars
        function createStyleSheet(options) {
            return `.${ARTICLE_MAIN_CLASS} { max-height: inherit; } .${ARTICLE_MAIN_CLASS}.tbl-forkorts-article-active { max-height: calc(${options.minimizedSize}px - 35px); overflow: hidden; position: relative; }.tbl-read-more-box { position: absolute; z-index: 4; left: 0; right: 0; /* there's a small line between the start of the feed/widget aand you can see the content there. so i placed the gradient 2px lower. */ bottom: -2px; display: none; text-align: center; padding: ${options.divTop}px 12px calc(50px - 35px); background: linear-gradient(to bottom, rgba(255, 255, 255, 0.05) 10%, ${options.backgroundColor} 60%, ${options.backgroundColor} 100%); } .tbl-read-more-box .tbl-read-more-btn { background: #F7F7F7; border: 1px solid #bebebe; border-radius: 24px; color: #5C5C5C; width: 130px; margin: -6px 0 40px 0; padding: 8px 20px 8px 25px; height: 30px; line-height: 14px; font-size: 14px; font-weight: 500; text-align: center; } .tbl-read-more-box .tbl-read-more-btn.tbl-rtl-read-more-btn { padding: 8px 25px 8px 20px; } .tbl-read-more-box .tbl-read-more-btn.tbl-rtl-read-more-btn .tbl-read-more-button-arrow { margin: 0 6px 0 0; } .tbl-read-more-box .tbl-read-more-btn .tbl-read-more-button-arrow { width: 8px; height: 8px; margin: 0 0 0 6px; } .tbl-read-more-box .tbl-read-more-btn:hover { cursor: pointer; text-decoration: none; background: #ececec; color: #5C5C5C; }.${ARTICLE_MAIN_CLASS}-active .tbl-read-more-box { display: block; }`;
        }

        /**
         *
         * @returns {Number|number}
         */
        function getPageScrollAmount() {
            return win.pageYOffset || doc.documentElement.scrollTop || doc.body.scrollTop;
        }

        /**
         * click handler for read more button
         * @param event
         */
        function handleClick(event) {
            const articleContent = doc.querySelector(`.${ARTICLE_MAIN_CLASS}`);

            event.preventDefault();
            event.stopPropagation();
            articleContent.classList.remove(`${ARTICLE_MAIN_CLASS}-active`);
            articleContent.style.maxHeight = '';
            TRC.readMoreVisible = false;
            sendReadMoreEvent.call(this, 'clicked', 'true', null);
            TRC.EventsAPI.readmore('click', this.response && this.response.trc);
            TRC.dispatch('readMoreClicked');
        }

        /**
         * generate read more box and button inside
         * @param options
         * @param id
         * @returns {HTMLElement}
         */
        function getReadMoreBox(options, id) {
            const div = doc.createElement('div');
            div.className = `tbl-read-more-box`;
            div.innerHTML = `<a 
                            id="${BUTTON_ID}_${id}" 
                            class="tbl-read-more-btn ${TRCImpl.direction === 'rtl' ? 'tbl-rtl-read-more-btn' : ''}"
                            href="#" 
                        > 
                            ${options.caption}
                            ${getArrowSvgTemplate()}
                        </a>`;
            return div;
        }
        /**
         * returns template string svg that will display next to the button caption
         * @returns {string}
         */
        function getArrowSvgTemplate() {
            return `
            <svg class='${ARROW_SVG_CLASS}' viewBox="0 0 8 6" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path 
                    d="M6.85381 0.203525L3.99181 3.06553L1.12981 0.203525C1.00407 0.0820867 0.835672 0.0148905 0.660874 0.0164095C0.486076 0.0179284 0.318868 0.088041 0.195262 0.211646C0.0716568 0.335252 0.00154415 0.50246 2.52017e-05 0.677258C-0.00149374 0.852056 0.0657025 1.02046 0.187141 1.14619L3.52047 4.47953C3.64549 4.60451 3.81503 4.67472 3.99181 4.67472C4.16858 4.67472 4.33812 4.60451 4.46314 4.47953L7.79647 1.14619C7.86015 1.08469 7.91094 1.01113 7.94588 0.929795C7.98081 0.848459 7.99921 0.760979 7.99997 0.67246C8.00074 0.58394 7.98388 0.496154 7.95036 0.414223C7.91683 0.332292 7.86733 0.257857 7.80474 0.195262C7.74214 0.132667 7.66771 0.083165 7.58578 0.0496444C7.50385 0.0161238 7.41606 -0.00074404 7.32754 2.51711e-05C7.23902 0.000794382 7.15154 0.0191852 7.0702 0.0541246C6.98887 0.0890639 6.91531 0.139852 6.85381 0.203525Z"
                    fill="#BCBCBC"
                />
            </svg>
        `;
        }

        /**
         * change the window and document context for the feature
         * @param pageConfig
         * @param modeConfig
         */
        function setContext(pageConfig, modeConfig) {
            const context = pageConfig.context || modeConfig.context;
            if (context === 'parent') {
                win = win.parent;
                doc = win.parent.document;
            }
            if (context === 'top') {
                win = win.top;
                doc = win.top.document;
            }
        }
        /**
         * creates a stylesheet from css text
         * @param cssText - string - the content of the new stylesheet
         * @param id - for the new created stylesheet
         */
        function injectStyleSheet(cssText, id) {
            const styleNodeId = id || 'kortWidgetCssStyle';
            let node = doc.querySelector(`#${styleNodeId}`);

            // remove previous node (in cases we load more than once)
            if (node) {
                node.parentNode.removeChild(node);
            }

            node = doc.createElement('div');

            // make sure we have something printable in the div
            // or IE will refuse to load the style ( '&shy;' is soft hyphen which is considered by IE
            // as content but does not produce any visual output)
            node.id = styleNodeId;
            node.innerHTML = `&shy;<style>${cssText}</style>`;
            doc.documentElement.appendChild(node);
        }

        function getLengthFromAnchorElement(options, articleContent, readMoreBox) {
            let readMorePosition,
                anchorElement;
            if (options.cutoffType === 'PAGE_ELEMENT') {
                anchorElement = doc.querySelector(options.anchorSelector);

                if (anchorElement) {
                    const anchorElementRect = anchorElement.getBoundingClientRect();
                    const articleRect = articleContent.getBoundingClientRect();

                    if (options.lengthFromAnchorElementType === 'ABOVE') {
                        readMorePosition = anchorElementRect.top - articleRect.top - options.lengthFromAnchorElement;
                    } else {
                        readMorePosition = anchorElementRect.bottom - articleRect.top + options.lengthFromAnchorElement;
                        readMorePosition += readMoreBox.getBoundingClientRect().height;
                    }
                }
            }

            return readMorePosition;
        }

        function sendReadMoreEvent(state, value, message) {
            if (TRC.util.isPercentEnabled(TRCImpl.global, 'read-more-events-enabled')) {
                const requestData = {
                    event_type: 'read_more', event_state: state, event_value: value, event_msg: message
                };
                this.sendEvent('supply-feature', {d: JSON.stringify(requestData)}, null);
            }
        }


        function findScrollOffsetToRender(rbox, options, article) {
            function getTrcContainer(container) {
                while (container.className.indexOf('trc_related_container') === -1
                       || container.parentNode.className.indexOf('trc_related_container') > -1) {
                    container = container.parentNode;
                }
                return container;
            }

            const feedContainer = getTrcContainer(rbox.container);
            const currentScroll = getPageScrollAmount();
            const articleTop = article.getBoundingClientRect().top + currentScroll;
            // render read more normally
            if (currentScroll < options.scrollSize) {
                return {
                    scrollHeight: currentScroll,
                    renderHeight: options.minimizedSize + articleTop,
                    articleRenderOffset: options.minimizedSize
                };
            }
            const viewPortHeight = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            const feedTopFromVP = feedContainer.getBoundingClientRect().top;
            const distanceViewPortBottomToFeed = feedTopFromVP - viewPortHeight;
            // do not render read more
            if (distanceViewPortBottomToFeed < (BELOW_VP_RENDERING_MARGIN * 2)) {
                return null;
            }
            // render read more at this location
            const viewPortBottom = currentScroll + viewPortHeight;
            const result = {
                scrollHeight: currentScroll,
                renderHeight: viewPortBottom + BELOW_VP_RENDERING_MARGIN,
                articleRenderOffset: (viewPortBottom + BELOW_VP_RENDERING_MARGIN) - articleTop
            };
            return result;
        }


        /**
         * init method for the feature
         * @param rbox
         */
        function init(rbox) {
            const readMoreRendered = tryRenderReadMore(rbox);
            if (!readMoreRendered) {
                TRC.EventsAPI.readmore('none', rbox.response && rbox.response.trc);
            }

            function tryRenderReadMore(rbox) {
                try {
                    const sendEvent = sendReadMoreEvent.trcBind(rbox);
                    (TRC.tlf && console.time('init Read More'));
                    sendEvent('Available', true, null);
                    const options = getConfig(rbox.readMorePageConfig, rbox.readMoreConfig);

                    setContext(rbox.readMorePageConfig, rbox.readMoreConfig);

                    // window.matchMedia identifies modern browsers
                    if (!win.matchMedia) {
                        sendEvent('Rendered', false, 'match media is not supported');
                        return false;
                    }
                    if (!options.boxSelector) {
                        sendEvent('Rendered', false, 'no box selector defined');
                        return false;
                    }
                    const articleContent = doc.querySelector(options.boxSelector);
                    if (!articleContent) {
                        sendEvent('Rendered', false, 'box content not detected');
                        return false;
                    }
                    if (doc.querySelector(`.${ARTICLE_MAIN_CLASS}`) === articleContent) {
                        sendEvent('Rendered', false, 'box content already in use');
                        return false;
                    }

                    let RenderingData = !(getPageScrollAmount() >= options.scrollSize);
                    if (TRCImpl.global['read-more-scroll-fast-enabled']) {
                        RenderingData = findScrollOffsetToRender(rbox, options, articleContent);

                        if (RenderingData && options.minimizedSize < RenderingData.articleRenderOffset) {
                            options.minimizedSize = RenderingData.articleRenderOffset;
                        }
                    }
                    if (!RenderingData || articleContent.offsetHeight < options.threshold) {
                        sendEvent('Rendered', false, 'dimensions exception');
                        return false;
                    }
                    articleContent.className += ARTICLE_CLASSES;
                    injectStyleSheet(createStyleSheet(options));
                    const readMoreBox = getReadMoreBox(options, rbox.id);
                    articleContent.appendChild(readMoreBox);
                    const lengthFromAnchorElement = getLengthFromAnchorElement(options, articleContent, readMoreBox);
                    if (lengthFromAnchorElement) {
                        articleContent.style.maxHeight = `${lengthFromAnchorElement}px`;
                    }
                    // send CLS report to check if rendering read-more even if user scrolling fast down is affecting CLS
                    TRC.CLSReporter.addCLSEventFilter({prefixMessage: 'Send CLS report from Read-More'});

                    TRC.readMoreVisible = true;
                    TRC.dispatch('readMoreRendered');
                    TRC.EventsAPI.readmore('render', rbox.response && rbox.response.trc);
                    if (TRCImpl.global['read-more-scroll-fast-enabled']) {
                        TRCImpl.sendAbTestEvent('rendered', {
                            renderingHeight: RenderingData.renderHeight,
                            scrollHeight: RenderingData.scrollHeight
                        });
                    }
                    doc.querySelector(`#${BUTTON_ID}_${rbox.id}`).addEventListener('click', handleClick.trcBind(rbox), false);
                    sendEvent('Rendered', true, null);
                    const observerOptions = {
                        targetElement: readMoreBox,
                        onEnter: () => {
                            sendEvent('Visible', true, null);
                            TRC.intersections.unobserve(readmoreObserverId);
                        }
                    };
                    const readmoreObserverId = TRC.intersections.observe(observerOptions);

                    (TRC.tlf && console.timeEnd('init Read More'));
                    return true;
                } catch (e) {
                    __trcError('Error read more init', e);
                    return false;
                }
            }
        }
        TRC.setReadMore = init;
    })(window, document);

    const CLASSES = {
        SLIDER: 'tbl-reco-reel-slider',
        SLIDER_CLOSE: 'tbl-reco-reel-slider-close',
        SLIDER_CLOSE_HOVER: 'tbl-close-hover',
        SLIDER_MOBILE: 'tbl-slider-mobile',
        SLIDER_DESKTOP: 'tbl-slider-desktop',
        SLIDER_OVERLAY: 'tbl-slider-overlay',
        SLIDER_CONTROLLERS: 'tbl-slider-controllers',
        SHOW_SLIDER_OVERLAY: 'tbl-slider-show',
        SLIDER_CONTROL: 'tbl-slider-control',
        SLIDER_PLAY: 'tbl-slider-play',
        SLIDER_NAVIGATION: 'tbl-slider-navigation',
        SLIDER_CLOSE_BUTTON: 'tbl-slider-close',
        SLIDER_ARROW: 'tbl-slider-arrow-btn',
        SLIDER_CLOSE_BTN: 'tbl-slider-close-btn',
        PAUSE: 'tbl-slider-pause',
        HIDDEN: 'tbl-hidden',
        TEXT_CONTAINER: 'tbl-text-container',
        MIN_DESIGN_WRAPPER: 'tbl-reco-reel-min-design',
        START_CTA_ANIMATION: 'tbl-start-cta'
    };

    const ATTRIBUTES = {
        FRIENDLY_OVERLAY: 'data-tbl-friendly-overlay'
    };

    const DIRECTIONS = {
        BOTTOM: 'bottom',
        LEFT: 'left'
    };

    const POSITIONS = {
        ABOVE_RECOREEL: 'above',
        BELOW_RECOREEL: 'below'
    };

    const ANIMATION_STATUS = {
        PAUSED: 'paused',
        RUNNING: 'running'
    };

    const PLATFORMS = {
        DESKTOP: 'desktop',
        MOBILE: 'mobile'
    };

    const SELECTORS = {
        TITLE_BACKGROUND: '.tbl-text-under-title-background'
    };

    const CONTROL_BUTTON_TYPES = {
        BACK: 'back',
        PLAY: 'play',
        PAUSE: 'pause',
        FORWARD: 'forward',
        CLOSE: 'close',
        NAVIGATE: 'navigate',
        MUTE: 'mute'
    };

    const ADD = 'addClass';
    const REMOVE = 'removeClass';

    const TICK_CYCLE = 150;

    const CONTROLLERS_FADE_DURATION = 2000;

    const CLIENT_PROPERTIES = {
        ENABLE_SLIDER: 'recommendationReel-enable-slider',
        NAVIGATION_TEXT: 'recommendationReel-slider-navigation-text',
        BELOW_ONLY: 'recommendationReel-slider-below-only',
        BELOW_FIRST_ITEM_ONLY: 'recommendationReel-slide-below-first-item-only',
        START_FROM_SLIDER: 'recommendationReel-slider-start-from-slider',
        SLIDER_POSITION: 'recommendationReel-slider-position',
        TEXT_UNDER_SLIDER_IN_ONLY: 'recommendationReel-slider-text-under-slide-in-only',
        DISCLOSURE_LINK_TEXT: 'disclosure-link-text-sponsored',
        IS_VIDEO_REEL: 'recommendationReel-is-videoreel',
        AUTO_PAUSE: 'recommendationReel-auto-pause',
        IS_MINUTELY_DESIGN: 'recommendationReel-is-min-adx',
        CTA_TEXT: 'recommendationReel-min-adx-cta-text',
        VERTICAL_LINE_COLOR: 'recommendationReel-min-adx-line-color',
        PROGRESS_BAR_COLOR: 'recommendationReel-min-adx-progress-color',
        REEL_INTERVAL: 'recommendationReel-interval'
    };

    const DEFAULT_REEL_INTERVAL = 7;

    const EVENT_TYPES = {
        RECO_REEL_SLIDER: 'RECO_REEL_SLIDER',
        CONFIGURATION: 'CONFIGURED',
        VISIBLE: 'VISIBLE',
        INTERACTION: 'INTERACTION',
        AVAILABLE: 'AVAILABLE',
        DEFAULT: 'default - detach both ways'
    };

    const EVENT_VALUES = {
        EVENT_VALUES_LIST: ['belowOnly', 'belowOnlyFirstSlider', 'shouldStartFromSlider']
    };

    const CONTROL_BUTTONS$1 = {
        [CONTROL_BUTTON_TYPES.BACK]: `<svg width="39" height="38" viewBox="0 0 39 38" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g filter="url(#filter0_d)">
                            <rect x="11" y="12.137" width="3.27471" height="14.1904" fill="white"/>
                            <path d="M27.1615 11.0844C27.0293 11.0181 26.8811 10.99 26.7338 11.0032C26.5865 11.0164 26.4457 11.0704 26.3274 11.1592L16.7761 18.3226C16.6773 18.3967 16.5971 18.4929 16.5418 18.6034C16.4865 18.7139 16.4578 18.8358 16.4578 18.9593C16.4578 19.0829 16.4865 19.2048 16.5418 19.3153C16.5971 19.4258 16.6773 19.522 16.7761 19.5961L26.3274 26.7595C26.4651 26.8629 26.6327 26.9187 26.8049 26.9187C26.9287 26.9182 27.0507 26.8894 27.1615 26.8343C27.2936 26.7682 27.4046 26.6666 27.4822 26.5409C27.5598 26.4152 27.6009 26.2705 27.6009 26.1228V11.7959C27.6009 11.6482 27.5598 11.5035 27.4822 11.3778C27.4046 11.2521 27.2936 11.1505 27.1615 11.0844Z" fill="white"/>
                            </g>
                            <defs>
                            <filter id="filter0_d" x="0" y="0" width="38.6009" height="37.9187" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                            <feOffset/>
                            <feGaussianBlur stdDeviation="5.5"/>
                            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.64 0"/>
                            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                            <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                            </filter>
                            </defs>
                            </svg>`,

        [CONTROL_BUTTON_TYPES.PLAY]: `<svg width="35" height="38" viewBox="0 0 35 38" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g filter="url(#filter1_d)">
                            <path d="M11.4787 11.0844C11.6228 11.0181 11.7841 10.99 11.9446 11.0032C12.1052 11.0164 12.2585 11.0704 12.3874 11.1592L22.7932 18.3226C22.9009 18.3967 22.9883 18.4929 23.0485 18.6034C23.1087 18.7139 23.14 18.8358 23.14 18.9593C23.14 19.0829 23.1087 19.2048 23.0485 19.3153C22.9883 19.4258 22.9009 19.522 22.7932 19.5961L12.3874 26.7595C12.2373 26.8629 12.0548 26.9187 11.8672 26.9187C11.7323 26.9182 11.5994 26.8894 11.4787 26.8343C11.3348 26.7682 11.2139 26.6666 11.1293 26.5409C11.0448 26.4152 11 26.2705 11 26.1228V11.7959C11 11.6482 11.0448 11.5035 11.1293 11.3778C11.2139 11.2521 11.3348 11.1505 11.4787 11.0844Z" fill="white"/>
                            </g>
                            <defs>
                            <filter id="filter1_d" x="0" y="0" width="34.14" height="37.9187" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                            <feOffset/>
                            <feGaussianBlur stdDeviation="5.5"/>
                            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.64 0"/>
                            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                            <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                            </filter>
                            </defs>
                            </svg>`,

        [CONTROL_BUTTON_TYPES.PAUSE]: `<svg width="33" height="38" viewBox="0 0 33 38" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g filter="url(#filter2_d)">
                            <rect x="11" y="11.0455" width="3.82049" height="15.8278" fill="white"/>
                            <rect x="18.0952" y="11.0455" width="3.82049" height="15.8278" fill="white"/>
                            </g>
                            <defs>
                            <filter id="filter2_d" x="0" y="0.0454712" width="32.9157" height="37.8278" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                            <feOffset/>
                            <feGaussianBlur stdDeviation="5.5"/>
                            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.64 0"/>
                            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                            <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                            </filter>
                            </defs>
                            </svg>`,

        [CONTROL_BUTTON_TYPES.FORWARD]: `<svg width="39" height="38" viewBox="0 0 39 38" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <g filter="url(#filter3_d)">
                            <rect width="3.27471" height="14.1904" transform="matrix(-1 0 0 1 28.0001 12.137)" fill="white"/>
                            <path d="M11.8385 11.0844C11.9708 11.0181 12.1189 10.99 12.2663 11.0032C12.4136 11.0164 12.5543 11.0704 12.6727 11.1592L22.2239 18.3226C22.3228 18.3967 22.403 18.4929 22.4583 18.6034C22.5135 18.7139 22.5423 18.8358 22.5423 18.9593C22.5423 19.0829 22.5135 19.2048 22.4583 19.3153C22.403 19.4258 22.3228 19.522 22.2239 19.5961L12.6727 26.7595C12.5349 26.8629 12.3673 26.9187 12.1951 26.9187C12.0714 26.9182 11.9494 26.8894 11.8385 26.8343C11.7065 26.7682 11.5955 26.6666 11.5179 26.5409C11.4403 26.4152 11.3992 26.2705 11.3992 26.1228V11.7959C11.3992 11.6482 11.4403 11.5035 11.5179 11.3778C11.5955 11.2521 11.7065 11.1505 11.8385 11.0844Z" fill="white"/>
                            </g>
                            <defs>
                            <filter id="filter3_d" x="0.39917" y="0" width="38.6009" height="37.9187" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
                            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
                            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
                            <feOffset/>
                            <feGaussianBlur stdDeviation="5.5"/>
                            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.64 0"/>
                            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
                            <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
                            </filter>
                            </defs>
                            </svg>`,

        [CONTROL_BUTTON_TYPES.MUTE]: `<svg height="100%" width="100%" viewBox="0 0 33 33">
                        <path d="m 21.48,17.98 c 0,-1.77 -1.02,-3.29 -2.5,-4.03 v 2.21 l 2.45,2.45 c .03,-0.2 .05,-0.41 .05,-0.63 z m 2.5,0 c 0,.94 -0.2,1.82 -0.54,2.64 l 1.51,1.51 c .66,-1.24 1.03,-2.65 1.03,-4.15 0,-4.28 -2.99,-7.86 -7,-8.76 v 2.05 c 2.89,.86 5,3.54 5,6.71 z M 9.25,8.98 l -1.27,1.26 4.72,4.73 H 7.98 v 6 H 11.98 l 5,5 v -6.73 l 4.25,4.25 c -0.67,.52 -1.42,.93 -2.25,1.18 v 2.06 c 1.38,-0.31 2.63,-0.95 3.69,-1.81 l 2.04,2.05 1.27,-1.27 -9,-9 -7.72,-7.72 z m 7.72,.99 -2.09,2.08 2.09,2.09 V 9.98 z" fill="white">
                        </path>
                        </svg>`
    };

    class SliderEventManager {

        static handleSliderEvents(eventType, action, context) {
            if (!eventType) return;
            const {handleSliderConfigEvent, sliderSendEvent, sliderEventTimer} = SliderEventManager;

            switch (eventType) {
                case EVENT_TYPES.CONFIGURATION:
                    handleSliderConfigEvent(action);
                    break;
                case EVENT_TYPES.INTERACTION:
                    sliderSendEvent(eventType, action);
                    break;
                case EVENT_TYPES.AVAILABLE:
                    sliderEventTimer(eventType, context);
                    break;
                case EVENT_TYPES.VISIBLE:
                    if (context && !context.sliderFirstVisible) {
                        sliderEventTimer(eventType, context);
                        context.sliderFirstVisible = true;
                    } else {
                        sliderSendEvent(eventType);
                    }
                    break;
                default:
                    break;
            }
        }

        static handleSliderConfigEvent(options) {
            if (!options) return;
            const sliderConfigurationsArr = [];

            EVENT_VALUES.EVENT_VALUES_LIST.forEach(val => {
                if (TRC.util.isTrue(options[val])) {
                    sliderConfigurationsArr.push(val);
                }
            });
            const sliderConfigState = sliderConfigurationsArr.length < 1 ? EVENT_TYPES.DEFAULT : sliderConfigurationsArr;

            SliderEventManager.sliderSendEvent(EVENT_TYPES.CONFIGURATION, sliderConfigState);
        }

        static sliderEventTimer(eventType, context) {
            if (!eventType) return;

            const sliderTimeCalc = performance.now() - context.sliderEventTimer;
            SliderEventManager.sliderSendEvent(eventType, sliderTimeCalc);
        }

        static sliderSendEvent(eventState, eventValue) {
            const requestData = {
                event_type: EVENT_TYPES.RECO_REEL_SLIDER,
                event_state: eventState,
                event_value: Array.isArray(eventValue) ? eventValue.join(',') : eventValue
            };

            TRCImpl.sendEvent('supply-feature', {d: JSON.stringify(requestData)}, null);
        }
    }

    var SliderEventManager$1 = {
        handleSliderEvents: SliderEventManager.handleSliderEvents
    };

    class RecommendationReelSlider {
        constructor(rbox) {
            this.rbox = rbox;
            this.trcManager = rbox.trc;
            this.modeName = rbox.options.mode_name;
            this.numberOfInstances = 0;
            this.IntersectionObserver = TRC.IntersectionObserver || window.IntersectionObserver;
            this.options = this.getOptions();
            !RecommendationReelSlider.isStyleInjected && RecommendationReelSlider.injectStyle();
            SliderEventManager$1.handleSliderEvents(EVENT_TYPES.CONFIGURATION, this.options);
        }

        static getInstance(context) {
            return RecommendationReelSlider.instance = new RecommendationReelSlider(context.rbox);
        }

        getOptions() {
            return {
                onlyNewRecoReel: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.TEXT_UNDER_SLIDER_IN_ONLY, this.rbox.propertiesOverride),
                belowOnly: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.BELOW_ONLY, this.rbox.propertiesOverride),
                belowOnlyFirstSlider: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.BELOW_FIRST_ITEM_ONLY, this.rbox.propertiesOverride),
                shouldStartFromSlider: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.START_FROM_SLIDER, this.rbox.propertiesOverride),
                position: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.SLIDER_POSITION, this.rbox.propertiesOverride),
                navigationText: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.NAVIGATION_TEXT, this.rbox.propertiesOverride),
                text: this.trcManager.getProperty(this.modeName, CLIENT_PROPERTIES.DISCLOSURE_LINK_TEXT, this.rbox.propertiesOverride)
            };
        }

        static injectStyle() {
            TRC.dom.injectStyle(`.tbl-reco-reel-slider { animation: tbl-slideInRight 0.5s forwards; position: fixed !important; width: 100% !important; max-width: 200px; margin-top: 0 !important; top: 50%; right: 0; } @media (min-width: 1024px) { .tbl-reco-reel-slider { max-width: 400px; } } .tbl-reco-reel-slider.tbl-slider-left { animation: tbl-slideInLeft 0.5s forwards; right: unset; left: 0; } .tbl-reco-reel-slider.tbl-slider-bottom { top: unset; bottom: 0; } .tbl-reco-reel-slider.tbl-reco-reel-slider-close { animation: tbl-slideOutRight 0.5s forwards; } .tbl-reco-reel-slider.tbl-reco-reel-slider-close.tbl-slider-left { animation: tbl-slideOutLeft 0.5s forwards; } .tbl-reco-reel-slider .tbl-story-progressBar-overflow-wrp { height: 30% !important; } .tbl-reco-reel-slider .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp { height: 100% !important; } .tbl-reco-reel-slider .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar { height: 50% !important; } .tbl-reco-reel-slider .item-label-href { bottom: 0; top: unset; height: auto; left: 3% !important; position: absolute; } .tbl-reco-reel-slider .item-label-href > * { top: unset !important; } .tbl-reco-reel-slider .item-label-href .tbl-text-under-title-background-wrapper { width: 100% !important; height: 100% !important; bottom: 0; display: block; } @media (min-width: 1024px) { .tbl-reco-reel-slider .item-label-href .tbl-text-under-title-background-wrapper { font-size: 15px; } } .tbl-reco-reel-slider .item-label-href .tbl-text-under-title-background-wrapper .tbl-text-under-title-background { display: block; width: 100%; height: 100%; } .tbl-reco-reel-slider .item-label-href .tbl-ui-line-wrapper { height: 100% !important; } .tbl-reco-reel-slider .item-label-href .tbl-ui-line-wrapper .tbl-ui-line { display: block; width: 100%; } .tbl-reco-reel-slider .item-label-href .video-label-box.trc-main-label { position: static !important; } @media (min-width: 1024px) { .tbl-reco-reel-slider .item-label-href .video-label-box.trc-main-label { padding: 5px 0; } } .tbl-reco-reel-slider .thumbBlock_holder { height: 100%; } .tbl-reco-reel-slider .tbl-text-under-title-background.label-show .tbl-text-container { background: #EBEBEB; color: #9E9E9E; font-size: 12px; font-weight: 600; position: absolute; z-index: 333; right: 0; top: -20px; padding: 0 10px; display: block !important; } @media (min-width: 1024px) { .tbl-reco-reel-slider .tbl-text-under-title-background.label-show .tbl-text-container { font-size: 15px; } } .tbl-reco-reel-slider .video-label-box .video-title { overflow: revert; margin: 3px 5px !important; -webkit-line-clamp: 2 !important; font-size: 12px; line-height: 15px; } @media (min-width: 1024px) { .tbl-reco-reel-slider .video-label-box .video-title { font-size: 15px; margin: 0 6px !important; line-height: 16px; } } .tbl-reco-reel-slider .video-label-box .branding { display: none !important; } .tbl-reco-reel-slider .thumbBlock .thumbnail-emblem.top-left { width: 20px; height: 20px; top: 12%; left: 5%; } @media (min-width: 1024px) { .tbl-reco-reel-slider .thumbBlock .thumbnail-emblem.top-left { width: 45px; height: 45px; top: 8%; left: 4%; } } .tbl-reco-reel-slider .tbl-slider-arrow-btn { position: absolute; top: calc(50% - 15px); width: 40px; height: 40px; z-index: 2; display: flex; align-items: center; padding: 0 5px; justify-content: flex-end; } @media (min-width: 1024px) { .tbl-reco-reel-slider .tbl-slider-arrow-btn { top: calc(50% - 10px); justify-content: center; padding: 0; } } .tbl-reco-reel-slider .tbl-slider-arrow-btn.tbl-arrow-right { right: 0; } .tbl-reco-reel-slider .tbl-slider-arrow-btn.tbl-arrow-left { -webkit-transform: scaleX(-1); -moz-transform: scaleX(-1); -ms-transform: scaleX(-1); -o-transform: scaleX(-1); transform: scaleX(-1); } .tbl-reco-reel-slider .tbl-slider-arrow-btn svg { filter: drop-shadow(0px 0px 2px #00000066); }.tbl-slider-close-btn { position: fixed; z-index: 333; right: 0; display: flex; justify-content: center; align-items: center; width: 22px; height: 22px; background-color: #C7C7C7; } @media (min-width: 1024px) { .tbl-slider-close-btn { width: 25px; height: 25px; } }.tbl-text-under-title-background .tbl-text-container { display: none; }@keyframes tbl-slideInRight { 0% { transform: translateX(100%); } 100% { transform: translateX(0); } }@keyframes tbl-slideOutRight { 0% { transform: translateX(0); } 100% { transform: translateX(100%); } }@keyframes tbl-slideInLeft { 0% { transform: translateX(-100%); } 100% { transform: translateX(0); } }@keyframes tbl-slideOutLeft { 0% { transform: translateX(0); } 100% { transform: translateX(-100%); } }`);
            RecommendationReelSlider.isStyleInjected = true;
        }

        createSlider(context) {
            try {
                const {isTextUnderSlideIn: isNewRecoreel} = context;
                const {setSliderContainer, isInViewport} = RecommendationReelSlider;
                // filters old recoreels in case of restriction from options
                if (this.options.onlyNewRecoReel && !isNewRecoreel) {
                    return;
                }
                this.numberOfInstances++;
                context.firstSlider = this.numberOfInstances === 1;
                context.sliderEventTimer = performance.now();
                const cardHeight = context.calcCardHeight();
                setSliderContainer(context);
                this.arrows = isNewRecoreel && RecommendationReelSlider.createArrowBtns(context);
                this.closeBtn = this.createCloseBtn(context);
                this.supportMultipleSliders(context, cardHeight);
                isInViewport(context.sliderContainer) || this.startFromSlider(context, cardHeight);
                this.initRecoreelObserver(context, cardHeight);
                this.handleSponsoredItems(context);
                SliderEventManager$1.handleSliderEvents(EVENT_TYPES.AVAILABLE, null, context);
            } catch (e) {
                __trcError(`Failed to create recommendation reel slider - ${e.message}`);
            }
        }

        handleSponsoredItems(context) {
            context.items.forEach(item => {
                if (!(item && item.video_data && item.video_data['is-syndicated'])) return;

                const videoTitleContainer = item.querySelector(SELECTORS.TITLE_BACKGROUND);
                this.textContainer = TRC.dom.createHTMLElement('span', {
                    className: CLASSES.TEXT_CONTAINER,
                    innerText: this.options.text
                });
                this.setTextContainerBackground(item, videoTitleContainer);
                videoTitleContainer.insertAdjacentElement('afterbegin', this.textContainer);

            });
        }

        setTextContainerBackground(item, videoTitleContainer) {
            const itemTitleBackgroundColor = getComputedStyle(videoTitleContainer).backgroundColor;
            if (!itemTitleBackgroundColor) return;

            this.textContainer.style.backgroundColor = itemTitleBackgroundColor;
        }

        static setSliderContainer(context) {
            context.sliderContainer = context.isTextUnderSlideIn ? context.internalc.parentNode : context.container;
        }

        supportMultipleSliders(context, cardHeight) {
            this.numberOfInstances === 2 && this.addMultipleSlidersSupport();
            RecommendationReelSlider.listenToSliderStop(context, cardHeight);
        }

        addMultipleSlidersSupport() {
            const oldSliderEnd = RecommendationReelSlider.onSliderEnd;
            RecommendationReelSlider.onSliderEnd = (context, cardHeight) => {
                if (!context.sliderActive) {
                    cardHeight.itemHeight = TRC.RecommendationReel.getOuter('height', cardHeight.item);
                    TRC.dispatch('tbl-recommendation-reel-slider-stop');
                    return;
                }
                oldSliderEnd.call(this, context, cardHeight);
                TRC.dispatch('tbl-recommendation-reel-slider-stop');
            };
        }

        startFromSlider(context, cardHeight) {
            if (!this.options.shouldStartFromSlider || this.numberOfInstances !== 1) {
                return;
            }
            const imageLoadedListener = TRC.listen('item-image-loaded', e => {
                if (this.rbox.boxes && this.rbox.boxes.length && this.rbox.boxes[0] === e.container) {
                    TRC.dom.removeClass(context.mainContainer, 'tbl-invisible');
                    this.onSliderStart(context, cardHeight);
                    imageLoadedListener.remove();
                }
            });
        }

        static isInViewport(el) {
            const rect = el.getBoundingClientRect();
            return (
                rect.top >= 0
                && rect.left >= 0
                && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
                && rect.right <= (window.innerWidth || document.documentElement.clientWidth)
            );
        }

        static listenToSliderStop(context, cardHeight) {
            TRC.listen('tbl-recommendation-reel-slider-stop', () => {
                if (context.sliderActive) {
                    RecommendationReelSlider.onSliderEnd(context, cardHeight);
                }
            });
        }

        initRecoreelObserver(context, cardHeight) {
            const animationEndEvent = TRC.dom.detectAnimationEvent(context.sliderContainer, 'end') || 'animationend';
            TRC.dom.on(context.sliderContainer, animationEndEvent, () => this.onSliderAnimationEnd(context, cardHeight));

            const {mainContainer} = context;
            const options = {
                root: null,
                rootMargin: '0px',
                threshold: [0.5]
            };
            context.sliderObserver = new this.IntersectionObserver(([entry]) => {
                const {ABOVE_RECOREEL, BELOW_RECOREEL} = POSITIONS;
                const intersectionPosition = entry.intersectionRect.y ? ABOVE_RECOREEL : BELOW_RECOREEL;
                const shouldPreventSliderAboveItem = ((this.options.belowOnlyFirstSlider && context.firstSlider) || this.options.belowOnly);
                // it means that the reco-reel is not visible on viewport
                if (entry.intersectionRatio === 0) {
                    return;
                }
                if (intersectionPosition === ABOVE_RECOREEL && shouldPreventSliderAboveItem) {
                    return;
                }
                if (entry.isIntersecting) {
                    return this.onSliderEnd(context, cardHeight);
                }
                this.onSliderStart(context, cardHeight, entry);
            }, options);
            context.sliderObserver.observe(mainContainer);
        }

        static setContainerStaticHeight(context, cardHeight, entry) {
            const height = entry && entry.boundingClientRect && entry.boundingClientRect.height;
            context.mainContainer.style.height = `${height || cardHeight.itemHeight}px`;
        }

        static removeContainerStaticHeight(context) {
            context.mainContainer.style.removeProperty('height');
        }

        fastScrollSupport(context) {
            RecommendationReelSlider.preventSliderClose(context);
            TRC.dom.removeClass(context.sliderContainer, CLASSES.SLIDER_CLOSE);
            this.toggleSliderArrows('removeClass');
            RecommendationReelSlider.toggleElementVisible('removeClass', this.closeBtn);
            RecommendationReelSlider.toggleElementVisible('addClass', context.controls);
            context.sliderActive = true;
        }

        static preventSliderClose(context) {
            clearTimeout(context.isCloseAnimationRunning);
            context.isCloseAnimationRunning = null;
        }

        onSliderStart(context, cardHeight, entry) {
            const {setContainerStaticHeight, reCalculateSliderSize} = RecommendationReelSlider;

            if (context.isCloseAnimationRunning) {
                return this.fastScrollSupport(context);
            }
            setContainerStaticHeight(context, cardHeight, entry);
            this.setSliderFixedPosition(context.sliderContainer, ADD);
            TRC.dom.addClass(context.sliderContainer, CLASSES.SLIDER);
            reCalculateSliderSize(context, cardHeight);
            this.toggleSliderArrows('removeClass');
            this.setCloseBtnBottomSpace(context);
            RecommendationReelSlider.toggleElementVisible('removeClass', this.closeBtn);
            RecommendationReelSlider.toggleElementVisible('addClass', context.controls);
            TRC.dispatch('tbl-recommendation-reel-slider-open');
            context.sliderActive = true;
            SliderEventManager$1.handleSliderEvents(EVENT_TYPES.VISIBLE, null, context);
        }

        setSliderFixedPosition(container, type) {
            const {position} = this.options;
            position.split(' ').forEach(direction => {
                switch (direction) {
                    case DIRECTIONS.LEFT:
                    case DIRECTIONS.BOTTOM:
                        TRC.dom[type](container, `tbl-slider-${direction}`);
                        break;
                    default:
                        break;
                }
            });
        }

        onSliderAnimationEnd(context, cardHeight) {
            if (!context.isCloseAnimationRunning) {
                return;
            }

            const {reCalculateSliderSize, removeContainerStaticHeight} = RecommendationReelSlider;

            TRC.dom.addClass(context.sliderContainer, CLASSES.HIDDEN);
            // taking care of cls issues by waiting next tick
            setTimeout(() => {
                if (context.isCloseAnimationRunning === null) {
                    return TRC.dom.removeClass(context.sliderContainer, CLASSES.HIDDEN);
                }
                TRC.dom.removeClass(context.sliderContainer, CLASSES.SLIDER);
                TRC.dom.removeClass(context.sliderContainer, CLASSES.SLIDER_CLOSE);
                this.setSliderFixedPosition(context.sliderContainer, REMOVE);
                TRC.dom.removeClass(context.sliderContainer, CLASSES.HIDDEN);
                reCalculateSliderSize(context, cardHeight);
                removeContainerStaticHeight(context);
                context.isCloseAnimationRunning = null;
                TRC.dispatch('tbl-recommendation-reel-slider-close');
            }, TICK_CYCLE);
        }

        onSliderEnd(context) {
            if (!context.sliderActive) {
                return;
            }
            TRC.dom.addClass(context.sliderContainer, CLASSES.SLIDER_CLOSE);
            this.toggleSliderArrows('addClass');
            RecommendationReelSlider.toggleElementVisible('addClass', this.closeBtn);
            RecommendationReelSlider.toggleElementVisible('removeClass', context.controls);
            context.isCloseAnimationRunning = true;
            context.sliderActive = false;
        }

        static reCalculateSliderSize(context, cardHeight) {
            context.recalculateWidgetSize(cardHeight);
            context.isTextUnderSlideIn && context.calcLabelBoxSizes();
        }

        // slider arrows region

        static createArrowBtns(context) {
            if (context.isWithVideoLayout) {
                return [];
            }
            return ['left', 'right'].map(position => {
                const arrow = document.createElement('div');
                arrow.className = `${CLASSES.SLIDER_ARROW} tbl-arrow-${position}`;
                arrow.insertAdjacentHTML('beforeend', RecommendationReelSlider.addASvgArrow());
                TRC.dom.on(arrow, 'click', context.slideCard.trcBind(context));
                context.internalc && context.internalc.parentNode && context.internalc.parentNode.appendChild(arrow);
                return arrow;
            });
        }

        static addASvgArrow() {
            return `<svg width="10px" height="20px" viewBox="0 0 17 29" version="1.1" xmlns="http://www.w3.org/2000/svg">
                       <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                           <g id="Desktop-4-cards" transform="translate(-1073.000000, -436.000000)" fill="#FFFDFD" fill-rule="nonzero">
                               <g id="Group" transform="translate(1081.500000, 450.500000) scale(-1, 1) translate(-1081.500000, -450.500000) translate(1073.000000, 436.000000)">
                                   <polygon id="Rectangle-5" transform="translate(8.294336, 8.495231) rotate(45.000000) translate(-8.294336, -8.495231) " points="7.05498966 -1.37457069 9.68971053 -1.39537442 9.53368258 18.3650322 6.8989617 18.3858359"></polygon>
                                   <polygon id="Rectangle-5" transform="translate(8.294336, 20.257858) scale(1, -1) rotate(45.000000) translate(-8.294336, -20.257858) " points="7.05498966 10.3880565 9.68971053 10.3672528 9.53368258 30.1276594 6.8989617 30.1484631"></polygon>
                               </g>\n'
                           </g>\n'
                       </g>\n'
                   </svg>`;
        }

        toggleSliderArrows(action) {
            const {HIDDEN} = CLASSES;
            this.arrows.forEach(arrow => {
                TRC.dom[action](arrow, HIDDEN);
            });
        }

        // region end

        createCloseBtn(context) {
            const closeBtn = document.createElement('div');
            TRC.dom.addClass(closeBtn, `${CLASSES.SLIDER_CLOSE_BTN} ${CLASSES.HIDDEN}`);
            closeBtn.insertAdjacentHTML('beforeend', RecommendationReelSlider.addCloseBtnSVG());
            TRC.dom.on(closeBtn, 'click', () => {
                this.onSliderEnd.trcBind(this, context)();
                context.sliderObserver.unobserve(context.mainContainer);
            });
            context.container && context.container.appendChild(closeBtn);
            return closeBtn;
        }

        setCloseBtnBottomSpace() {
            this.closeBtn.style.bottom = `${this.rbox.internalContainer && this.rbox.internalContainer.clientHeight}px`;
        }

        static addCloseBtnSVG() {
            const size = 10;
            return `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 0 0 0L${size} ${size}" stroke="#ffffff" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M${size} 0 ${size} 0L0 ${size}" stroke="#ffffff" stroke-width="2" stroke-miterlimit="10" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`;
        }

        static toggleElementVisible(action, element) {
            const {HIDDEN} = CLASSES;
            TRC.dom[action](element, HIDDEN);
        }
    }

    /**
     * Options:
     * text: string - text to display
     * clickCB: function - handler for click event
     * duration: number - duration of animation in seconds
     */
    class ReelCTA {
        constructor(options) {
            this.wrap = createCtaElement(options.text, options.clickCB);
            !ReelCTA.injected && ReelCTA.injectStyle(options.duration);
        }

        // eslint-disable-next-line no-unused-vars
        static injectStyle(ctaAnimDuration) {
            TRC.dom.injectStyle(`.tbl-rr-cta { text-align: right; margin-bottom: 10px; } .tbl-rr-cta-text { line-height: 27px; font-family: Arial, serif; font-size: 14px; } .tbl-rr-cta-inner { display: inline-block; padding: 2px 15px; border-radius: 6px; border: 1px solid #E4E4E4; background-color: #E4E4E4; position: relative; overflow: hidden; z-index: 2; -webkit-animation-play-state: inherit; -moz-animation-play-state: inherit; -ms-animation-play-state: inherit; -o-animation-play-state: inherit; animation-play-state: inherit; } .tbl-rr-cta-inner:hover { cursor: pointer; } .tbl-rr-cta-inner::before { content: ""; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background-color: #CBCBCB; z-index: -1; -webkit-animation-play-state: inherit; -moz-animation-play-state: inherit; -ms-animation-play-state: inherit; -o-animation-play-state: inherit; animation-play-state: inherit; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } .tbl-rr-cta.tbl-start-cta .tbl-rr-cta-inner::before { -webkit-animation: ${ctaAnimDuration}s linear 0s 1 normal tbl-rr-fillBackground; -moz-animation: ${ctaAnimDuration}s linear 0s 1 normal tbl-rr-fillBackground; -ms-animation: ${ctaAnimDuration}s linear 0s 1 normal tbl-rr-fillBackground; -o-animation: ${ctaAnimDuration}s linear 0s 1 normal tbl-rr-fillBackground; animation: ${ctaAnimDuration}s linear 0s 1 normal tbl-rr-fillBackground; }@keyframes tbl-rr-fillBackground { 0% { left: -100%; } 100% { left: 0; } }`);
            ReelCTA.injected = true;
        }

        /**
         * Forces reel to start/restart animation
         */
        start() {
            this.wrap.classList.remove(CLASSES.START_CTA_ANIMATION);
            setTimeout(() => {
                requestAnimationFrame(() => {
                    this.wrap.classList.add(CLASSES.START_CTA_ANIMATION);
                });
            }, 10);
        }

        /**
         * Toggles CTA animation
         * @param state
         */
        setState(state) {
            if (state === CONTROL_BUTTON_TYPES.PLAY) {
                this.wrap.classList.add(CLASSES.START_CTA_ANIMATION);
                this.wrap.style.webkitAnimationPlayState = ANIMATION_STATUS.RUNNING;
                this.wrap.style.animationPlayState = ANIMATION_STATUS.RUNNING;
                return;
            }
            this.wrap.style.webkitAnimationPlayState = ANIMATION_STATUS.PAUSED;
            this.wrap.style.animationPlayState = ANIMATION_STATUS.PAUSED;
        }
    }

    function createCtaElement(text, onClickHandler) {
        const ctaWrapper = document.createElement('div');
        ctaWrapper.className = 'tbl-rr-cta';
        const ctaInnerWrapper = document.createElement('div');
        ctaInnerWrapper.className = 'tbl-rr-cta-inner';
        const ctaText = document.createElement('span');
        ctaText.className = 'tbl-rr-cta-text';
        ctaText.textContent = TRC.text.htmlUnescape(text);
        ctaInnerWrapper.appendChild(ctaText);
        ctaWrapper.appendChild(ctaInnerWrapper);
        onClickHandler && ctaWrapper.addEventListener('click', onClickHandler);
        return ctaWrapper;
    }

    var components_es6 = {
        ReelCTA
    };

    const defaultVideoAttributes = ['loop', 'muted', 'playsinline'];
    const EVENT_ID = 'recommendation-video-reel';
    const VIDEO_URL_ATTRIBUTE = 'ovideo-url';
    const VIDEO_REEL_ITEM = 'tbl-vrl-item';
    const VIDEO_REEL_IDENTIFIER = 'tbl-vrl';
    const DEFAULT_ANIMATION_DURATION = 1000;
    const CONTROL_BUTTONS = [
        CONTROL_BUTTON_TYPES.PLAY,
        CONTROL_BUTTON_TYPES.PAUSE,
        CONTROL_BUTTON_TYPES.MUTE,
        CONTROL_BUTTON_TYPES.BACK,
        CONTROL_BUTTON_TYPES.FORWARD
    ];

    class VideoReel {
        constructor(rbox) {
            this.rbox = rbox;
            this.videoElements = {};
            this.videoLoaders = [];
            this.itemTypes = [];
            this.isReadyToPlay = false;
            this.placementData = rbox.recommendationList;
            this.setupVideoElements();
            this.setVideoDesign();
            VideoReel.injectStyles();
            this.startLoading();
        }

        registerItemType(itemData) {
            const placementItemType = getPlacementItemType(itemData);
            this.itemTypes.push(placementItemType);
        }

        setupVideoElements() {
            const placementList = Array.prototype.slice.call(this.rbox.boxes);
            placementList.forEach((box, index) => {
                const itemData = this.placementData[index] || {};
                const videoUrl = itemData[VIDEO_URL_ATTRIBUTE];
                this.registerItemType(itemData);
                if (!videoUrl) {
                    return;
                }
                const videoLocation = box.querySelector('.thumbBlock_holder');
                TRC.dom.addClass(videoLocation, `${VIDEO_REEL_IDENTIFIER} ${VIDEO_REEL_ITEM}`);
                const loadVideoElement = () => {
                    const videoWrapper = this._createVideoElement(videoUrl, index);
                    videoLocation.appendChild(videoWrapper);
                };
                this.videoLoaders.push(loadVideoElement);
            });
        }

        startLoading() {
            const isFirstItemVideo = this.itemTypes[0] === 'VOC';
            if (isFirstItemVideo) {
                this.loadFirstVideo();
                return;
            }
            this.showUnit();
        }
        
        setAsReady() {
            this.isReadyToPlay = true;
        }

        loadNextClips() {
            if (this.videoLoaders.length > 0) {
                const videoLoader = this.videoLoaders.shift();
                videoLoader();
            }
        }

        showUnit() {
            this.loadNextClips();
            this.setAsReady();
            this.startReelAnimation();
        }

        loadFirstVideo() {
            const videoLoader = this.videoLoaders.shift();
            videoLoader();
            this.firstVideoTimeout = setTimeout(this.showUnit.bind(this), 5000);
        }

        reportFullCycle() {
            if (!this.fullCycleIsReported) {
                this.fullCycleIsReported = true;
                this.sendAbTestEvent('fullCycle');
            }
        }

        _createVideoElement(videoUrl, locationIndex) {
            const videoWrapper = _createWrapper();
            const videoElement = _createVideoTag(videoUrl);
            defaultVideoAttributes.forEach(attribute => {
                videoElement.setAttribute(attribute, '');
            });
            this.videoElements[locationIndex] = videoElement;
            videoElement.addEventListener('error', e => {
                const message = videoElement.error ? (videoElement.error.message || videoElement.error.code) : e.message;
                this.handleVideoError(locationIndex, message, videoWrapper);
            }, {once: true});
            videoElement.addEventListener('canplaythrough', () => {
                videoWrapper.appendChild(videoElement);
                videoElement.classList.add('tbl-vid-active');
                this.onReadyToPlay(locationIndex);
            }, {once: true});
            return videoWrapper;
        }

        handleVideoError(locationIndex, message, videoWrapper) {
            TRC.dom.removeClass(videoWrapper.parentNode, VIDEO_REEL_ITEM);
            delete this.videoElements[locationIndex];
            const failedItemId = this.placementData[locationIndex].id;
            __trcError(`#${locationIndex} VOC error: ${message}:${failedItemId}`);
            const isFirstVideo = locationIndex === 0;
            if (isFirstVideo) {
                clearTimeout(this.firstVideoTimeout);
                this.showUnit();
                return;
            }
            this.loadNextClips();
        }

        start(startReelCB, visibleIndex) {
            this.startReelCB = startReelCB;
            if (this.isReadyToPlay) {
                this.startReelAnimation();
            }
            const currentVideo = this.videoElements[visibleIndex];
            if (!currentVideo) {
                return;
            }
            try {
                currentVideo.play();
            } catch (e) {
                __trcWarn('error auto-playing first video: ', e);
            }
        }

        handleNextVideo(finishedVideoIndex, nextShowPosition) {
            const finishedVideo = this.videoElements[finishedVideoIndex];
            if (finishedVideo) {
                const resetVideo = () => {
                    try {
                        finishedVideo.pause();
                        finishedVideo.currentTime = 0;
                    } catch (e) {
                        __trcWarn('error pausing finished video: ', e);
                    }
                };
                setTimeout(resetVideo, DEFAULT_ANIMATION_DURATION);
            }
            updateItemIndicator(this.itemIndicator, nextShowPosition + 1);
            this.ctaButton && this.ctaButton.start();
            const nextVideo = this.videoElements[nextShowPosition];
            if (!nextVideo) {
                return;
            }
            try {
                nextVideo.play();
            } catch (e) {
                __trcWarn('error playing next video: ', e);
            }
        }

        toggleMiddleControl(currentIndex, type) {
            const currentVideo = this.videoElements[currentIndex];
            if (!currentVideo) {
                return;
            }
            this.ctaButton && this.ctaButton.setState(type);

            try {
                if (type === CONTROL_BUTTON_TYPES.PLAY) {
                    currentVideo.play();
                } else if (type === CONTROL_BUTTON_TYPES.PAUSE) {
                    currentVideo.pause();
                }
            } catch (e) {
                __trcWarn(`error toggle ${type} video `, e);
            }
            this.sendAbTestEvent(type);
        }

        startReelAnimation() {
            if (!this.startReelCB) {
                return;
            }
            // fixes the flickering of the first video/last videoCube
            const firstVideoCube = this.rbox.boxes[0];
            firstVideoCube.style.zIndex = 1;
            this.startReelCB();
            this.startReelCB = undefined;
            setTimeout(() => {
                this.ctaButton && this.ctaButton.setState(CONTROL_BUTTON_TYPES.PLAY);
                setTimeout(() => {
                    firstVideoCube.style.zIndex = null;
                }, 100);
            }, 0);
        }

        reportVisible(itemPosition, eventData) {
            const visibleItemType = this.itemTypes[itemPosition];
            this.sendAbTestEvent(`${eventData}_${visibleItemType}`);
        }

        onReadyToPlay(videoIndex) {
            this.sendAbTestEvent(`#${videoIndex} VOC readyToPlay`);
            const isFirstVideo = videoIndex === 0;
            if (isFirstVideo) {
                clearTimeout(this.firstVideoTimeout);
                this.showUnit();
                return;
            }
            this.loadNextClips();
        }

        getProgressBarStyle(amountOfItems) {
            const defaultStyle = `width: ${(100 / amountOfItems)}%`;
            if (this.layout.adx) {
                return defaultStyle;
            }
            return defaultStyle;
        }

        getDesignTypeClass() {
            return this.layout.class;
        }

        setLayoutOptions(options) {
            this.layout = options;
        }

        isWithVideoLayout() {
            return !!this.layout;
        }

        setAdxVideoDesign() {
            const verticalLineColor = getModeProperty(this.rbox, CLIENT_PROPERTIES.VERTICAL_LINE_COLOR),
                progressBarColor = getModeProperty(this.rbox, CLIENT_PROPERTIES.PROGRESS_BAR_COLOR);
            injectMinutelyAdxCompliantStyles(verticalLineColor, progressBarColor);
            TRC.dom.injectStyle('@import url(//fonts.googleapis.com/css?family=Roboto+Condensed);');
            this.setLayoutOptions({
                class: CLASSES.MIN_DESIGN_WRAPPER,
                controlButtons: CONTROL_BUTTONS,
                adx: true
            });
        }

        setVideoDesign() {
            const isMinAdxUnit = getModeProperty(this.rbox, CLIENT_PROPERTIES.IS_MINUTELY_DESIGN);
            if (isMinAdxUnit) {
                this.setAdxVideoDesign();
            }
        }

        getControlButtons() {
            return this.layout.controlButtons;
        }

        static initiate(rbox) {
            const isVideoReelType = TRC.util.isTrue(getModeProperty(rbox, CLIENT_PROPERTIES.IS_VIDEO_REEL));
            if (isVideoReelType) {
                return new VideoReel(rbox);
            }
            return undefined;
        }

        static injectStyles() {
            if (VideoReel.cssLoaded) {
                return;
            }
            TRC.dom.injectStyle(`.tbl-vrl-item .thumbBlock { background-image: unset !important; }.tbl-vrl-item .tbl-vrl-video-wrapper { height: 100%; width: 100%; background-color: transparent; background-size: auto; text-align: center; overflow: hidden; display: block; position: absolute; top: 0; z-index: 9999; } .tbl-vrl-item .tbl-vrl-video-wrapper video { width: 100%; height: 100%; object-fit: contain; object-position: 50% 50%; -o-object-fit: contain; -o-object-position: 50% 50%; display: none; } .tbl-vrl-item .tbl-vrl-video-wrapper video.tbl-vid-active { display: block; }`);
            VideoReel.cssLoaded = true;
        }

        addCta(mainContainer) {
            const button = this.ctaButton = _addCtaButton(this.rbox);
            if (!button) {
                return;
            }
            const reportAndNavigate = () => {
                const currentVisibleItem = mainContainer.querySelector('.videoCube.tbl-show-item .item-label-href');
                if (currentVisibleItem) {
                    this.sendAbTestEvent('ctaClick');
                    currentVisibleItem.click();
                }
            };
            button.wrap.addEventListener('click', reportAndNavigate);
            mainContainer.insertAdjacentElement('afterbegin', button.wrap);
        }

        createAdditionalLayout(controlPanel, mainContainer) {
            this.addCta(mainContainer);
            this.addItemIndicator(controlPanel);
        }

        addItemIndicator(controlPanel) {
            const totalCount = this.rbox.recommendationList.length;
            this.itemIndicator = addCurrentItemIndicator(controlPanel, totalCount);
        }

        sendAbTestEvent(eventData) {
            const requestData = {
                abTestsEventType: 'simple',
                name: EVENT_ID,
                type: eventData,
                eventTime: new Date().getTime()
            };
            this._sendEvent('abtests', requestData);
        }

        _sendEvent(eventName, eventData) {
            const eventParams = {
                d: JSON.stringify(eventData),
                ri: this.rbox.reqId
            };

            this.rbox.trc.sendEvent(eventName, eventParams, {});
        }
    }

    function _addCtaButton(rbox) {
        const options = getCtaOptions(rbox);
        if (!options.text) {
            return;
        }
        return new ReelCTA(options);
    }

    function getCtaOptions(rbox) {
        const text = getModeProperty(rbox, CLIENT_PROPERTIES.CTA_TEXT);
        if (!text) {
            return {};
        }
        const interval = getModeProperty(rbox, CLIENT_PROPERTIES.REEL_INTERVAL),
            duration = (interval ? +interval : DEFAULT_REEL_INTERVAL) + 0.9;
        return {
            text,
            duration
        };
    }

    // eslint-disable-next-line no-unused-vars
    function injectMinutelyAdxCompliantStyles(verticalLineColor, progressBarColor) {
        TRC.dom.injectStyle(`div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-rr-item-indicator { float: right; color: white; line-height: 40px; font-family: Arial, serif; margin-right: 10px; }div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-rr-current-indicator { font-weight: bold; }div.tbl-reco-reel.tbl-reco-reel-min-design ._cm-native-ad-bottom { background-color: #0000005c; }div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-reco-reel-progressBar-overflow-wrp { width: 100%; bottom: 40px; top: unset; height: 5px !important; } div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { margin: 0; top: 0; height: 5px; } div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner { background-color: ${progressBarColor}; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { padding: 0; height: 5px; background: transparent; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .tbl-recommendation-reel .item-label-href .tbl-text-under-title-background { top: 0; height: 100%; width: 100%; display: block; -webkit-transition: all .3s; -moz-transition: all .3s; -ms-transition: all .3s; -o-transition: all .3s; transition: all .3s; position: relative; background: -webkit-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); background: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(1, 0, 0, 0.8))); background: -o-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); pointer-events: none; opacity: 0; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .tbl-recommendation-reel .item-label-href .tbl-text-under-title-background.label-show { opacity: 1; pointer-events: all; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .item-label-href .video-label-box { margin-left: 10px; padding-left: 10px; width: 90%; position: relative; top: 0; } div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .item-label-href .video-label-box .video-title { margin: 10px 0 7px 7px; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper { left: 15px; height: 100%; top: 0; } div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .tbl-ui-line { background: ${verticalLineColor}; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper { top: 0; width: 100%; height: calc(100% + 15px); left: 0; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer a.item-label-href { position: absolute; bottom: 55px; left: 0; width: 100%; } div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer a.item-label-href span { color: white; background: transparent; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock_placeholder { background-color: black; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .videoCube .item-label-href .video-label-box .video-description { left: 0; opacity: 0; -webkit-transition: all .3s; -moz-transition: all .3s; -ms-transition: all .3s; -o-transition: all .3s; transition: all .3s; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .videoCube .item-label-href .video-label-box .branding { left: 0; opacity: 0; -webkit-transition: all .3s; -moz-transition: all .3s; -ms-transition: all .3s; -o-transition: all .3s; transition: all .3s; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .videoCube .item-label-href .video-label-box .video-description.label-show { opacity: 1; }div.tbl-reco-reel.tbl-reco-reel-min-design .trc_rbox_outer .videoCube .item-label-href .video-label-box .branding.label-show { opacity: 1; }div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-text-under-controls { display: block !important; position: absolute; bottom: 0; height: 40px; width: 100%; z-index: 9; background: black; right: 0; } div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-text-under-controls .tbl-play, div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-text-under-controls .tbl-pause { margin-left: 10px; }div.tbl-reco-reel.tbl-reco-reel-min-design .tbl-recommendation-reel .tbl-text-under-branding-background { background: transparent; }div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { padding: 0; height: 5px; background: transparent; }div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { margin: 0; top: 0; height: 5px; }div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .trc_rbox_outer .item-label-href { left: 0; width: 100%; } div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .video-label-box, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .trc_rbox_outer .item-label-href .video-label-box { margin-left: 10px; padding-left: 10px; width: 90%; position: relative; top: 0; } div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper { top: 0; } div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, div.tbl-reco-reel.tbl-reco-reel-min-design.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper { top: 0; }`);
        /* eslint-enable */
    }

    function updateItemIndicator(indicator, newIndex) {
        if (indicator) {
            indicator.textContent = newIndex;
        }
    }

    function addCurrentItemIndicator(controlPanel, totalCount) {
        const indexIndicatorWrap = document.createElement('div');
        indexIndicatorWrap.className = 'tbl-rr-item-indicator';
        const currentIndicator = document.createElement('span');
        currentIndicator.className = 'tbl-rr-current-indicator';
        currentIndicator.textContent = '1';
        const totalCountIndicator = document.createElement('span');
        totalCountIndicator.textContent = ` / ${totalCount}`;
        indexIndicatorWrap.appendChild(currentIndicator);
        indexIndicatorWrap.appendChild(totalCountIndicator);
        controlPanel.appendChild(indexIndicatorWrap);

        return currentIndicator;
    }

    function getModeProperty(rbox, propertyName) {
        return rbox.trc.getProperty(rbox.mode_name, propertyName, rbox.propertiesOverride);
    }


    function _createVideoTag(rawUrl) {
        const video = document.createElement('video');
        const urlData = TRC.URL.prototype.switchProtocol.call(rawUrl, TRC.PROTOCOL);
        const [videoUrl] = urlData.split('!-#');
        video.setAttribute('preload', 'auto');
        video.setAttribute('src', `${videoUrl}`);
        video.muted = true; // without this line there is no autoplay
        return video;
    }

    function getPlacementItemType(itemData) {
        if (itemData[VIDEO_URL_ATTRIBUTE]) {
            return 'VOC';
        } if (itemData['is-syndicated']) {
            return 'SC';
        } if (itemData['is-native']) {
            return 'NT';
        } if (itemData['is-in-network']) {
            return 'AE';
        } if (itemData['is-dc']) {
            return 'TN';
        }
        return 'OC';
    }

    function _createWrapper() {
        const wrapper = document.createElement('div');
        wrapper.className = 'tbl-vrl-video-wrapper';
        return wrapper;
    }

    (function () {
        const CSS_CLASSES = {
                // BACKWARDS COMPATIBLE CLASSES
                // TODO: remove story-widget classes post migration of client properties
                RECO_REEL: 'tbl-reco-reel story-widget',
                PROGRESS_BAR: 'tbl-reco-reel-progressBar tbl-story-progressBar',
                PROGRESS_BAR_WRAPPER: 'tbl-reco-reel-progressBar-wrp tbl-story-progressBar-wrp',
                PROGRESS_BAR_WRAPPER_TEXT_OVER: 'tbl-reco-reel-progressBar-wrp-text-over tbl-story-progressBar-wrp-text-over',
                PROGRESS_BAR_OVERFLOW_WRAPPER: 'tbl-reco-reel-progressBar-overflow-wrp tbl-story-progressBar-overflow-wrp',
                TOUCH_DEVICE: 'tbl-reco-reel-touch-device tbl-story-touch-device',
                DESKTOP: 'tbl-reco-reel-desktop tbl-story-desktop',
                TEXT_OVER: 'tbl-reco-reel-text-over story-widget-text-over',
                TEXT_UNDER_SLIDE_IN: 'tbl-reco-reel-text-under-slide-in story-widget-text-under-slide-in',
                TEXT_UNDER_RTL: 'tbl-reco-reel-text-under-rtl story-widget-text-under-rtl',
                // -------------------------------------------------------------------------
                SHOW_ITEM: 'tbl-show-item',
                NEXT_ITEM: 'tbl-next-item',
                REMOVE_LEFT: 'tbl-remove-item',
                REMOVE_RIGHT: 'tbl-remove-item-to-right',
                IMAGE_HOLDER: 'thumbBlock_holder',
                ZOOM_IN: TRC.Browser.ie ? '' : 'tbl-zoom-in-item', // NO ZOOM FOR IE!
                PROGRESS_RUNNER: 'tbl-progress-runner',
                PROGRESS_ANIM: 'tbl-progress-anim',
                PREVENT_CLICK: 'tbl-prevent-click-progressBar',
                ARROW_BUTTON: 'tbl-arrow-btn',
                CLICKABLE_AREA: 'tbl-clickable-area-btn',
                TEXT_UNDER_CONTROLS: 'tbl-text-under-controls',
                HIDDEN: 'tbl-hidden',
                LABEL_SHOW: 'label-show',
                ANIMATION_ZOOM_IN: 'tbl-animation-zoom-In',
                EXPAND: 'tbl-expand-container'
            },
            CSS_ANIMATION = {
                SLIDE_OUT_LEFT: 'tbl-animation-slide-out-left',
                SLIDE_OUT_RIGHT: 'tbl-animation-slide-out-right',
                PROGRESS_BAR_ANIMATION: 'tbl-animation-progress-bar'
            },
            LABELS_CSS = {
                LABELS: '.item-label-href',
                LABELS_BOX: '.item-label-href .video-label-box',
                LABELS_BRANDING: '.item-label-href .branding',
                LABELS_GRADIENT_CONTAINER: 'tbl-text-over-container',
                LABELS_GRADIENT_OVERLAY: 'tbl-text-over',
                LABELS_ALIGN: 'tbl-text-over-align',
                LABELS_ALIGN_LEFT: 'tbl-text-over-labels-left',
                LABELS_ALIGN_RIGHT: 'tbl-text-over-labels-right',
                VIDEO_TITLE: 'video-title'
            },
            SLIDE_EVENTS = [CSS_ANIMATION.SLIDE_OUT_LEFT, CSS_ANIMATION.SLIDE_OUT_RIGHT],
            ARROW_SIZE = 56,
            CLICKED_AREA_SIZE = 0.15, // 15% percent of the card width
            PROGRESS_BAR_HEIGHT = 100,
            LABELS_ANIMATION_TIMEOUT = 300,
            MINIMUM_IMG_HEIGHT_FOR_CNTRLS = 270,
            DEFAULT_LABEL_TOP_DESKTOP = -38, // must be same as labels box, ui line & title background "top" property.
            DEFAULT_LABEL_TOP_MOBILE = -35, // same but for mobile
            DEFAULT_CONTROL_HEIGHT = 40;

        const CONTROL_BUTTON_ORDER = [CONTROL_BUTTON_TYPES.BACK, CONTROL_BUTTON_TYPES.PLAY, CONTROL_BUTTON_TYPES.PAUSE, CONTROL_BUTTON_TYPES.FORWARD];

        const CONTROL_BUTTON_ANIMATION_STATUSES_MAP = {
            play: ANIMATION_STATUS.RUNNING,
            pause: ANIMATION_STATUS.PAUSED
        };

        class RecommendationReel {
            constructor(rbox) {
                this.props = RecommendationReel.GetRecommendationReelProps(rbox);
                this.active = false;
                this.finishFirstCycle = false;
                this.browserWidth = TRC.dom.getWindowWidth() || RecommendationReel.getDefaultWidthByDevice();
                this.internalc = rbox.internalContainer;
                this.mainContainer = rbox.container;
                this.rboxContainer = this.mainContainer.firstElementChild;
                this.rbox = rbox;
                this.setNumOfItems(rbox.responsiveRules);
                this.items = Array.prototype.slice.call(rbox.boxes, 0, this.amountOfItems);
                this.intervalLength = this.props.recoReelInterval; // sec
                this.debugWidget = window.location.search.indexOf('tbl-debug=true') !== -1;
                this.isTouchDevice = TRC.Device.isTouchDevice;
                this.deviceType = this.isTouchDevice ? CSS_CLASSES.TOUCH_DEVICE : CSS_CLASSES.DESKTOP;
                this.calcImageHeight();
                this.thumbnailPosition = rbox.getThumbnailPosition();
                this.isTextOver = this.thumbnailPosition === 'under';
                this.direction = RecommendationReel.getDirection(rbox);
                this.isTextUnderSlideIn = RecommendationReel.checkIsTextUnderSlideIn(rbox) && !this.isTextOver;
                this.enableSlider = this.getBooleanProperty(CLIENT_PROPERTIES.ENABLE_SLIDER);
                this.waitForVideoDemand = RecommendationReel.checkIfNeedToWaitForVideoDemand(rbox);
                this.initiateVideoReel();

                if (this.enableSlider) {
                    this.recommendationReelSlider = RecommendationReelSlider.getInstance(this);
                }

                this.isWithLabelAnimation = this.isTextUnderSlideIn && !this.isWithVideoLayout;

                this.state = {
                    previousItem: null,
                    showItem: this.items[0],
                    showNextItem: this.items[1],
                    activePB: null,
                    previousPosition: null,
                    currentPosition: 0
                };
                this.instanceType = this.getInstanceType();
                // loaded only once for all recommendation reels -> common css
                !RecommendationReel.cssLoaded && RecommendationReel.setDefaultCss();

                const listener = TRC.listen('trcContentReady', e => {
                    /* we need to wait for Taboola to completely loaded for getting the height and width after all been rendered */
                    if (e.container !== this.mainContainer) {
                        return;
                    }

                    this.initContainer(listener);
                });
            }

            initiateVideoReel() {
                this.videoReel = VideoReel.initiate(this.rbox);
                if (!this.videoReel || this.isTextOver) {
                    return;
                }
                this.isWithVideoLayout = this.videoReel.isWithVideoLayout();
                if (this.isWithVideoLayout) {
                    this.isTextUnderSlideIn = true;
                }
            }

            static getDefaultWidthByDevice() { // according to breakpoints mixings
                if ((window.taboolaMobile && window.taboolaBridge) || TRC.dom.isSmartPhone()) {
                    return 360;
                }
                if (TRC.dom.isTablet()) {
                    return 768;
                }
                if (TRC.dom.isDesktop()) {
                    return 1280;
                }
                return 360;
            }

            static shouldInitRecommendationReel(context) {
                return TRC.util.isTrue(RecommendationReel.getProperty(context, 'recommendationReel', 'storyWidget'));
            }

            static GetRecommendationReelProps(context) {
                return {
                    recoReelInterval: RecommendationReel.getProperty(context, 'interval', 'storyWidget-story-interval')
                                      || DEFAULT_REEL_INTERVAL
                };
            }

            static checkIsTextUnderSlideIn(context) {
                return TRC.util.isTrue(RecommendationReel.getProperty(context, 'enable-text-under-slide-in', 'storyWidget-recommendation-reel-enable-text-under-slide-in'));
            }

            static checkIfNeedToWaitForVideoDemand(context) {
                return TRC.util.isTrue(RecommendationReel.getProperty(context, 'wait-for-video-demand', 'recommendationReel-wait-for-video-demand'));
            }

            static getProperty(context, cpName, legacyCpName) {
                return context.trc.getProperty(context.mode_name, cpName, context.propertiesOverride)
                   || context.trc.getProperty(context.mode_name, legacyCpName, context.propertiesOverride);
            }

            /**
             * Update Recommendation Reel Cards with Text Over
             * @param {object} rboxManager
             * @param {object} videoBoxContainer
             */
            static setTextOverForRecommendationReel(rboxManager, videoBoxContainer) {
                const textOverOverlay = document.createElement('span');
                const direction = this.getDirection(rboxManager);
                TRC.dom.addClass(textOverOverlay, LABELS_CSS.LABELS_GRADIENT_OVERLAY);
                videoBoxContainer.link.appendChild(textOverOverlay);
                TRC.dom.addClass(videoBoxContainer.link, LABELS_CSS.LABELS_GRADIENT_CONTAINER);
                this.alignLabelsBox(videoBoxContainer, direction);
                this.addArrowIcon(videoBoxContainer.link, direction);
            }

            getBooleanProperty(property) {
                return TRC.util.isTrue(this.rbox.trc.getProperty(this.rbox.mode_name, property, this.rbox.propertiesOverride));
            }

            calcImageHeight() {
                // height of first thumbnail is enough
                this.imageHeight = RecommendationReel.getOuter('height', this.items[0].querySelector(`.${CSS_CLASSES.IMAGE_HOLDER}`));
                // width of first thumbnail is enough
                this.imageWidth = RecommendationReel.getOuter('width', this.items[0].querySelector(`.${CSS_CLASSES.IMAGE_HOLDER}`));
            }

            initContainer(listener) {
                try {
                    listener.remove();
                    const recoReelTypeClass = this.getRecoReelTypeContainerClass();
                    setTimeout(() => {
                        this.container = this.mainContainer.querySelector('.trc_rbox_container');
                        TRC.dom.addClass(this.container,
                            `${CSS_CLASSES.RECO_REEL} ${recoReelTypeClass} ${this.deviceType}`);
                        TRC.dom.addClass(this.internalc, 'tbl-recommendation-reel');

                        this.init();
                        if (this.waitForVideoDemand) {
                            this.toggleContainerExpandClass('addClass');
                            this.waitForVideoDemandReady();
                        }
                    }, 0);
                } catch (ex) {
                    __trcError('error on reco reel initialisation', ex);
                }

            }

            init() {
                if (this.isTextUnderSlideIn) {
                    this.addLabelsBoxAnimatedElements();
                    this.calcLabelBoxSizes();
                }
                this.calcImageHeight();
                /* also need to wait for next clock cycle for getting the updated and real sizes of cards */
                this.buildRecommendationReel();
                this.setDynamicCss();
                TRC.dispatch('widgetHeightReady');

                /* resize Feed to match final height of cards in Reco Reel if in AMP */
                this.resizeIfAMPFeed();
                if (this.enableSlider) {
                    this.recommendationReelSlider.createSlider(this);
                }

                const options = this.getIntersectionOptions();
                TRC.intersections.observe(options);
            }

            waitForVideoDemandReady() {
                this.toggleWidgetFooterVisibility('hide');
                TRC.listen('showVideoRecoReel', () => {
                    this.waitForVideoDemand = false;
                    this.startTheReel();
                    setTimeout(() => {
                        this.toggleWidgetFooterVisibility('show');
                        this.toggleContainerExpandClass('removeClass');
                    }, 500);
                });
            }

            toggleWidgetFooterVisibility(action) {
                this.widgetFooter = this.widgetFooter || this.mainContainer.querySelector('.trc-widget-footer');
                if (this.widgetFooter) {
                    const actionType = action === 'hide' ? 'addClass' : 'removeClass';
                    TRC.dom[actionType](this.widgetFooter, `${CSS_CLASSES.HIDDEN}`);
                }
            }

            toggleContainerExpandClass(action) {
                if (this.mainContainer) {
                    TRC.dom[action](this.mainContainer, `${CSS_CLASSES.EXPAND}`);

                }
            }

            getIntersectionOptions() {
                const isAutoPauseEnabled = this.getBooleanProperty(CLIENT_PROPERTIES.AUTO_PAUSE);
                const options = {
                    targetElement: this.internalc,
                    onEnter: isAutoPauseEnabled ? this.togglePlayState.bind(this) : this.startTheReel.bind(this),
                    onExit: isAutoPauseEnabled ? this.togglePauseState.bind(this) : this.stopTheReel.bind(this)
                };
                if (isAutoPauseEnabled) {
                    options.threshold = [0.5];
                }
                return options;
            }

            resizeIfAMPFeed() {
                try {
                    if (TRC && TRC.isAMP && TRC.amp && typeof TRC.amp.sendAMPFeedResize === 'function') {
                        if (this.rbox && this.rbox.isFeedCard) {
                            TRC.amp.sendAMPFeedResize();
                        }
                    }
                } catch (ex) {
                    __trcWarn('error in resize amp feed', ex);
                }
            }

            /**
             * first build of the the widget and append it to the dom
             * this widget based on 1 row and minimum 4 columns
             * @returns  {void / boolean}
             */
            buildRecommendationReel() {
                this.rbox.trc.sendAbTestEvent(this.instanceType, 'available');
                this.listenToAnimationEvents();

                this.arrows = [];
                this.clickedAreas = [];
                this.progressBar = this.createProgressBar();
                this.internalc.parentNode.appendChild(this.progressBar);
                this.allowRecalculateSize = true;

                if (this.deviceType === CSS_CLASSES.DESKTOP) {
                    this.arrows = [];
                    if (!this.isTextUnderSlideIn) {
                        this.arrows = this.createArrowBtns();
                        TRC.dom.on(this.internalc, 'mouseover', this.playStateAnimation.trcBind(this, 'paused'));
                        TRC.dom.on(this.internalc, 'mouseleave', this.playStateAnimation.trcBind(this, 'running'));
                    }
                } else {
                    this.clickedAreas = this.createMobileClickedArea();
                    const PreventClickOnProgressBars = document.createElement('div');
                    PreventClickOnProgressBars.className = CSS_CLASSES.PREVENT_CLICK;
                    this.progressBar.appendChild(PreventClickOnProgressBars);
                }

                const cardHeight = this.calcCardHeight();
                this.createLayout(cardHeight);

                /* update cardHeight, arrows and progressBar position on resize
                   main motivation for landscape / portrait changes on mobile  */
                TRC.dom.on(window, 'resize', TRC.util.debounce(() => {
                    this.recalculateWidgetSize(cardHeight);
                    if (this.isTextUnderSlideIn) this.calcLabelBoxSizes();
                }, 100, false, this));
            }

            _createTextUnderLayout(cardHeight) {
                this.createControls();
                this.responsiveAlignmentTextUnder(cardHeight);
            }

            createLayout(cardHeight) {
                if (this.isWithVideoLayout) {
                    this._createTextUnderLayout(cardHeight);
                    this.videoReel.createAdditionalLayout(this.controls, this.mainContainer);
                    return;
                }
                if (this.isTextUnderSlideIn) {
                    this._createTextUnderLayout(cardHeight);
                } else {
                    this.responsiveAlignment(cardHeight);
                }
            }

            recalculateWidgetSize(cardHeight) {
                cardHeight.item.style.removeProperty('top');
                cardHeight.itemHeight = RecommendationReel.getOuter('height', cardHeight.item);
                !this.isTextUnderSlideIn ? this.responsiveAlignment(cardHeight) : this.responsiveAlignmentTextUnder(cardHeight);
            }

            static getConsts() {
                return {
                    CSS_CLASSES,
                    CSS_ANIMATION,
                    SLIDE_EVENTS,
                    ARROW_SIZE,
                    PROGRESS_BAR_HEIGHT
                };
            }

            setNumOfItems(responsiveRules) {
                const items = this.rbox.boxes.length;
                this.amountOfItems = items; // case there's no responsive rules take the number of items
                if (responsiveRules) {
                    responsiveRules.forEach(rule => {
                        const isTheRightResponsiveRule = rule.min < this.browserWidth && (this.browserWidth < rule.max || rule.max === undefined);
                        const itemsByResponsive = rule.rows * rule.cells;
                        const isResponsiveRuleNotBiggerItemsAmount = itemsByResponsive <= items;

                        if (isTheRightResponsiveRule) {
                            this.amountOfItems = isResponsiveRuleNotBiggerItemsAmount ? itemsByResponsive : items;
                        }
                    });
                }
            }

            getRecoReelTypeContainerClass() {
                let containerClass = '';
                if (this.isTextUnderSlideIn) {
                    containerClass = CSS_CLASSES.TEXT_UNDER_SLIDE_IN;
                    if (this.direction === 'rtl') {
                        containerClass += ` ${CSS_CLASSES.TEXT_UNDER_RTL}`;
                    }
                    if (this.isWithVideoLayout) {
                        containerClass += ` ${this.videoReel.getDesignTypeClass()}`;
                    }
                } else if (this.isTextOver) {
                    containerClass = CSS_CLASSES.TEXT_OVER;
                }
                return containerClass;
            }

            static setDefaultCss() {
                RecommendationReel.cssLoaded = true;
                TRC.dom.injectStyle(`div.tbl-reco-reel, div.story-widget { position: relative; /*DEFAULTS */ /*EVENTS*/ /*PROGRESS BAR */ /*ARROWS */ } div.tbl-reco-reel .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow { position: absolute; } div.tbl-reco-reel .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align { width: 91%; } div.tbl-reco-reel .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-right, div.story-widget .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-right { right: 0; left: auto; } div.tbl-reco-reel .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-left, div.story-widget .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-left { left: 0; right: auto; } div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { position: absolute; width: 100%; font-size: 0; background: -webkit-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: -webkit-gradient(linear, left top, left bottom, from(rgba(1, 0, 0, 0.8)), to(rgba(0, 0, 0, 0))); background: -o-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: linear-gradient(to bottom, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); } div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { top: 5px; height: 2px; } div.tbl-reco-reel.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.tbl-reco-reel.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.tbl-reco-reel.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.story-widget.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.story-widget.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, div.story-widget.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar { pointer-events: auto; } div.tbl-reco-reel.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.tbl-reco-reel.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align { bottom: 0; } div.tbl-reco-reel.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.tbl-reco-reel.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow { bottom: 10px; } div.tbl-reco-reel.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.tbl-reco-reel.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right { right: 3%; } div.tbl-reco-reel.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.tbl-reco-reel.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left { left: 3%; } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp, div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-story-progressBar-wrp, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-story-progressBar-wrp, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp { opacity: 0; transform: translateY(100px); } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp-text-over, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-story-progressBar-wrp-text-over, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over { opacity: 1; transform: none; } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align { bottom: 15px; } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow { bottom: 20px; } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-right { right: 4%; } div.tbl-reco-reel:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.tbl-reco-reel:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget:not(.tbl-reco-reel-text-under-slide-in).tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget:not(.story-widget-text-under-slide-in).tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-left { left: 4%; } div.tbl-reco-reel .trc_rbox_outer, div.story-widget .trc_rbox_outer { margin: 0; } div.tbl-reco-reel .trc_rbox_outer .trc_rbox_div, div.story-widget .trc_rbox_outer .trc_rbox_div { overflow: hidden; } div.tbl-reco-reel .trc_rbox_outer .videoCube, div.story-widget .trc_rbox_outer .videoCube { position: absolute; width: 100%; margin: 0; bottom: 0; } div.tbl-reco-reel .trc_rbox_outer .videoCube .thumbBlock_holder, div.story-widget .trc_rbox_outer .videoCube .thumbBlock_holder { overflow: hidden; z-index: -1; } div.tbl-reco-reel .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock_placeholder, div.story-widget .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock_placeholder { background-color: #aeaeae; position: absolute; top: 0; left: 0; width: 100%; height: 100%; } div.tbl-reco-reel .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock_placeholder svg, div.story-widget .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock_placeholder svg { width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); } div.tbl-reco-reel .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock, div.story-widget .trc_rbox_outer .videoCube .thumbBlock_holder .thumbBlock { -webkit-transform: scale(1.00); -moz-transform: scale(1.00); -ms-transform: scale(1.00); -o-transform: scale(1.00); transform: scale(1.00); } div.tbl-reco-reel .trc_rbox_outer .videoCube .video-label-box, div.story-widget .trc_rbox_outer .videoCube .video-label-box { z-index: -1; opacity: 0; } div.tbl-reco-reel .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container, div.story-widget .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container { z-index: -1; opacity: 0; } div.tbl-reco-reel .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container .video-label-box, div.story-widget .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container .video-label-box { z-index: auto; opacity: 1; } div.tbl-reco-reel .videoCube.tbl-show-item, div.story-widget .videoCube.tbl-show-item { z-index: 1; } div.tbl-reco-reel .videoCube.tbl-show-item .thumbBlock_holder, div.story-widget .videoCube.tbl-show-item .thumbBlock_holder { z-index: 1; } div.tbl-reco-reel .videoCube.tbl-show-item .video-label-box, div.story-widget .videoCube.tbl-show-item .video-label-box { z-index: 1; -webkit-animation: tbl-animation-fade-in 1s; -moz-animation: tbl-animation-fade-in 1s; -ms-animation: tbl-animation-fade-in 1s; -o-animation: tbl-animation-fade-in 1s; animation: tbl-animation-fade-in 1s; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel .videoCube.tbl-show-item .item-label-href.tbl-text-over-container, div.story-widget .videoCube.tbl-show-item .item-label-href.tbl-text-over-container { z-index: 1; -webkit-animation: tbl-animation-fade-in 1s; -moz-animation: tbl-animation-fade-in 1s; -ms-animation: tbl-animation-fade-in 1s; -o-animation: tbl-animation-fade-in 1s; animation: tbl-animation-fade-in 1s; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel .videoCube.tbl-show-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget .videoCube.tbl-show-item .item-label-href.tbl-text-over-container .video-label-box { animation: none; z-index: auto; } div.tbl-reco-reel .videoCube.tbl-show-item .tbl-labels-arrow-right, div.story-widget .videoCube.tbl-show-item .tbl-labels-arrow-right { z-index: 1; -webkit-animation: tbl-animation-fade-in 1s; -moz-animation: tbl-animation-fade-in 1s; -ms-animation: tbl-animation-fade-in 1s; -o-animation: tbl-animation-fade-in 1s; animation: tbl-animation-fade-in 1s; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel .videoCube.tbl-show-item .tbl-labels-arrow-left, div.story-widget .videoCube.tbl-show-item .tbl-labels-arrow-left { z-index: 1; -webkit-animation: tbl-animation-fade-in 1s; -moz-animation: tbl-animation-fade-in 1s; -ms-animation: tbl-animation-fade-in 1s; -o-animation: tbl-animation-fade-in 1s; animation: tbl-animation-fade-in 1s; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel .videoCube.tbl-remove-item .thumbBlock_holder, div.story-widget .videoCube.tbl-remove-item .thumbBlock_holder { -webkit-animation: tbl-animation-slide-out-left 0.75s; -moz-animation: tbl-animation-slide-out-left 0.75s; -ms-animation: tbl-animation-slide-out-left 0.75s; -o-animation: tbl-animation-slide-out-left 0.75s; animation: tbl-animation-slide-out-left 0.75s; } div.tbl-reco-reel .videoCube.tbl-remove-item .video-label-box, div.story-widget .videoCube.tbl-remove-item .video-label-box { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container, div.story-widget .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container .video-label-box { animation: none; } div.tbl-reco-reel .videoCube.tbl-remove-item .tbl-labels-arrow-right, div.story-widget .videoCube.tbl-remove-item .tbl-labels-arrow-right { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item .tbl-labels-arrow-left, div.story-widget .videoCube.tbl-remove-item .tbl-labels-arrow-left { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item-to-right .thumbBlock_holder, div.story-widget .videoCube.tbl-remove-item-to-right .thumbBlock_holder { -webkit-animation: tbl-animation-slide-out-right 0.75s; animation: tbl-animation-slide-out-right 0.75s; } div.tbl-reco-reel .videoCube.tbl-remove-item-to-right .video-label-box, div.story-widget .videoCube.tbl-remove-item-to-right .video-label-box { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container, div.story-widget .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container .video-label-box, div.story-widget .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container .video-label-box { animation: none; } div.tbl-reco-reel .videoCube.tbl-next-item .video-label-box, div.story-widget .videoCube.tbl-next-item .video-label-box { opacity: 0; } div.tbl-reco-reel .videoCube.tbl-next-item .item-label-href.tbl-text-over-container, div.story-widget .videoCube.tbl-next-item .item-label-href.tbl-text-over-container { opacity: 0; } div.tbl-reco-reel .videoCube.tbl-next-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget .videoCube.tbl-next-item .item-label-href.tbl-text-over-container .video-label-box { opacity: 0; } div.tbl-reco-reel .videoCube.tbl-next-item .thumbBlock_holder, div.story-widget .videoCube.tbl-next-item .thumbBlock_holder { z-index: 0; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp, div.story-widget .tbl-story-progressBar-overflow-wrp, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp { z-index: 9; position: absolute; pointer-events: none; overflow: hidden; width: 100%; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { direction: ltr; width: 100%; box-sizing: border-box; position: absolute; padding: 0 4%; background: -webkit-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); background: -webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0)), to(rgba(1, 0, 0, 0.8))); background: -o-linear-gradient(top, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(1, 0, 0, 0.8) 100%); opacity: 1; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { position: relative; top: 85px; display: inline-block; vertical-align: top; /* set bars to the absolute top container when using inline block */ width: 23%; height: 3px; background-color: rgba(255, 255, 255, 0.4); margin: 0 1%; overflow: hidden; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar span.tbl-progress-runner, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar span.tbl-progress-runner { width: 100%; height: 100%; position: absolute; left: 0; overflow: hidden; display: block; background-color: #fcfcfc; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar .tbl-progress-anim, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar .tbl-progress-anim { -webkit-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.story-widget .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.story-widget .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over { padding: 0 3%; background: none; } div.tbl-reco-reel .tbl-arrow-btn, div.story-widget .tbl-arrow-btn { position: absolute; background-color: rgba(0, 0, 0, 0.419608); z-index: 2; font-size: 40px; text-align: center; color: #ffffff; cursor: pointer; line-height: 0; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none; -webkit-transition: transform 1s; -moz-transition: transform 1s; -ms-transition: transform 1s; -o-transition: transform 1s; transition: transform 1s; display: none; } div.tbl-reco-reel .tbl-arrow-btn svg, div.story-widget .tbl-arrow-btn svg { transform: translateY(50%); margin: auto; } div.tbl-reco-reel .tbl-arrow-btn.tbl-arrow-left, div.story-widget .tbl-arrow-btn.tbl-arrow-left { -webkit-transform: scaleX(-1); -moz-transform: scaleX(-1); -ms-transform: scaleX(-1); -o-transform: scaleX(-1); transform: scaleX(-1); } div.tbl-reco-reel .tbl-clickable-area-btn, div.story-widget .tbl-clickable-area-btn { position: absolute; z-index: 2; } div.tbl-reco-reel .tbl-clickable-area-btn.tbl-clickable-area-back, div.story-widget .tbl-clickable-area-btn.tbl-clickable-area-back { left: 0; } div.tbl-reco-reel .tbl-clickable-area-btn.tbl-clickable-area-forward, div.story-widget .tbl-clickable-area-btn.tbl-clickable-area-forward { right: 0; }.trc_related_container.tbl-expand-container { position: absolute; left: 0; top: 0; width: 100%; opacity: 0; }@-webkit-keyframes tbl-animation-slide-out-left { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(-100%); -moz-transform: translateX(-100%); -ms-transform: translateX(-100%); -o-transform: translateX(-100%); transform: translateX(-100%); } }@keyframes tbl-animation-slide-out-left { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(-100%); -moz-transform: translateX(-100%); -ms-transform: translateX(-100%); -o-transform: translateX(-100%); transform: translateX(-100%); } }@-webkit-keyframes tbl-animation-slide-out-right { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(100%); -moz-transform: translateX(100%); -ms-transform: translateX(100%); -o-transform: translateX(100%); transform: translateX(100%); } }@keyframes tbl-animation-slide-out-right { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(100%); -moz-transform: translateX(100%); -ms-transform: translateX(100%); -o-transform: translateX(100%); transform: translateX(100%); } }@-webkit-keyframes tbl-animation-fade-in { 0% { opacity: 0; } 100% { opacity: 1; } }@keyframes tbl-animation-fade-in { 0% { opacity: 0; } 100% { opacity: 1; } }@-webkit-keyframes tbl-animation-fade-out { 0% { opacity: 1; } 100% { opacity: 0; } }@keyframes tbl-animation-fade-out { 0% { opacity: 1; } 100% { opacity: 0; } }@-webkit-keyframes tbl-animation-zoom-In { 0% { -webkit-transform: scale(1.00); -moz-transform: scale(1.00); -ms-transform: scale(1.00); -o-transform: scale(1.00); transform: scale(1.00); } 100% { -webkit-transform: scale(1.1); -moz-transform: scale(1.1); -ms-transform: scale(1.1); -o-transform: scale(1.1); transform: scale(1.1); } }@keyframes tbl-animation-zoom-In { 0% { -webkit-transform: scale(1.00); -moz-transform: scale(1.00); -ms-transform: scale(1.00); -o-transform: scale(1.00); transform: scale(1.00); } 100% { -webkit-transform: scale(1.1); -moz-transform: scale(1.1); -ms-transform: scale(1.1); -o-transform: scale(1.1); transform: scale(1.1); } }@-webkit-keyframes tbl-animation-progress-bar { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(100%); -moz-transform: translateX(100%); -ms-transform: translateX(100%); -o-transform: translateX(100%); transform: translateX(100%); } }@keyframes tbl-animation-progress-bar { 0% { -webkit-transform: translateX(0); -moz-transform: translateX(0); -ms-transform: translateX(0); -o-transform: translateX(0); transform: translateX(0); } 100% { -webkit-transform: translateX(100%); -moz-transform: translateX(100%); -ms-transform: translateX(100%); -o-transform: translateX(100%); transform: translateX(100%); } }`);
                TRC.dom.injectStyle(`div.tbl-reco-reel.tbl-reco-reel-text-over, div.story-widget.story-widget-text-over { position: relative; /*DEFAULTS */ /*EVENTS*/ /*PROGRESS BAR */ } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget.story-widget-text-over .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow { position: absolute; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.story-widget-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align { width: 91%; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-right, div.story-widget.story-widget-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-right { right: 0; left: auto; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-left, div.story-widget.story-widget-text-over .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-labels-left { left: 0; right: auto; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { background: -webkit-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: -webkit-gradient(linear, left top, left bottom, from(rgba(1, 0, 0, 0.8)), to(rgba(0, 0, 0, 0))); background: -o-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: linear-gradient(to bottom, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.story-widget-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .video-label-box.tbl-text-over-align { bottom: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget.story-widget-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow { bottom: 10px; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.story-widget-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-right { right: 3%; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.story-widget-text-over.tbl-story-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.story-widget-text-over.tbl-reco-reel-touch-device .videoCube.thumbnail_under .tbl-text-over-container .tbl-labels-arrow-left { left: 3%; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop:hover .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-desktop:hover .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp { opacity: 0; transform: translateY(100px); } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop:hover .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget.story-widget-text-over.tbl-story-desktop:hover .tbl-story-progressBar-wrp-text-over, div.story-widget.story-widget-text-over.tbl-story-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop:hover .tbl-story-progressBar-wrp-text-over, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop:hover .tbl-reco-reel-progressBar-wrp-text-over { opacity: 1; transform: none; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.story-widget-text-over.tbl-story-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop .tbl-text-over-container .video-label-box.tbl-text-over-align { bottom: 15px; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow, div.story-widget.story-widget-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow { bottom: 20px; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.story-widget-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-right, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-right { right: 4%; } div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.tbl-reco-reel.tbl-reco-reel-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.story-widget-text-over.tbl-story-desktop .tbl-text-over-container .tbl-labels-arrow-left, div.story-widget.story-widget-text-over.tbl-reco-reel-desktop .tbl-text-over-container .tbl-labels-arrow-left { left: 4%; } div.tbl-reco-reel.tbl-reco-reel-text-over .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container, div.story-widget.story-widget-text-over .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container { z-index: -1; opacity: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container .video-label-box, div.story-widget.story-widget-text-over .trc_rbox_outer .videoCube .item-label-href.tbl-text-over-container .video-label-box { opacity: 1; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-show-item .item-label-href.tbl-text-over-container, div.story-widget.story-widget-text-over .videoCube.tbl-show-item .item-label-href.tbl-text-over-container { z-index: 1; -webkit-animation: tbl-animation-fade-in 1s; -moz-animation: tbl-animation-fade-in 1s; -ms-animation: tbl-animation-fade-in 1s; -o-animation: tbl-animation-fade-in 1s; animation: tbl-animation-fade-in 1s; -webkit-animation-fill-mode: forwards; -moz-animation-fill-mode: forwards; -ms-animation-fill-mode: forwards; -o-animation-fill-mode: forwards; animation-fill-mode: forwards; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-show-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget.story-widget-text-over .videoCube.tbl-show-item .item-label-href.tbl-text-over-container .video-label-box { animation: none; z-index: auto; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container, div.story-widget.story-widget-text-over .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget.story-widget-text-over .videoCube.tbl-remove-item .item-label-href.tbl-text-over-container .video-label-box { animation: none; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container, div.story-widget.story-widget-text-over .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container { -webkit-animation: tbl-animation-fade-out 1s; -moz-animation: tbl-animation-fade-out 1s; -ms-animation: tbl-animation-fade-out 1s; -o-animation: tbl-animation-fade-out 1s; animation: tbl-animation-fade-out 1s; opacity: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container .video-label-box, div.story-widget.story-widget-text-over .videoCube.tbl-remove-item-to-right .item-label-href.tbl-text-over-container .video-label-box { animation: none; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-next-item .item-label-href.tbl-text-over-container, div.story-widget.story-widget-text-over .videoCube.tbl-next-item .item-label-href.tbl-text-over-container { opacity: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over .videoCube.tbl-next-item .item-label-href.tbl-text-over-container .video-label-box, div.story-widget.story-widget-text-over .videoCube.tbl-next-item .item-label-href.tbl-text-over-container .video-label-box { opacity: 0; } div.tbl-reco-reel.tbl-reco-reel-text-over .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.tbl-reco-reel.tbl-reco-reel-text-over .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget.story-widget-text-over .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.story-widget.story-widget-text-over .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over, div.story-widget.story-widget-text-over .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp-text-over, div.story-widget.story-widget-text-over .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp-text-over { padding: 0 3%; background: none; }`);
                TRC.dom.injectStyle(`.tbl-reco-reel-text-under-slide-in .tbl-ui-line, .story-widget-text-under-slide-in .tbl-ui-line { background-color: #333333; }.tbl-reco-reel-text-under-slide-in .tbl-text-under-title-background, .story-widget-text-under-slide-in .tbl-text-under-title-background { background-color: #EBEBEB; }.tbl-reco-reel.tbl-reco-reel-text-under-slide-in, .story-widget.story-widget-text-under-slide-in { /*Here added weak selectors for css client properties to be able to override SW styles*/ /* Device specifics */ /*DEFAULTS */ /*PROGRESS BAR */ /* Control buttons */ } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .video-label-box, .story-widget.story-widget-text-under-slide-in .video-label-box { margin: 0; max-height: initial; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .video-title, .story-widget.story-widget-text-under-slide-in .video-title { max-height: initial; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .branding, .story-widget.story-widget-text-under-slide-in .branding { display: inline-block; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href { left: 10px; width: 90%; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .video-label-box, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .video-label-box, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .video-label-box, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .video-label-box, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper { top: -35px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .video-label-box .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .video-label-box .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .video-title, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .video-title, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .video-title, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .video-title, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .video-title { margin: 10px 0 10px 7px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-story-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-touch-device .trc_rbox_outer .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { top: 7px; height: 2px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer { /*EVENTS*/ } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href { position: absolute; left: 20px; width: 90%; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box { position: absolute; top: -38px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding { z-index: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title { position: relative; margin: 10px 0 10px 7px; left: 5px; opacity: 0; transition: opacity .3s; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title.label-show, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-title.label-show { opacity: 1; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background { position: absolute; display: inline; top: 0; left: -5px; width: 122%; height: 100%; z-index: -1; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding.tbl-branding-on-top, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding.tbl-branding-on-top { top: -2px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding { margin: 0 0 0 12px; position: relative; left: -110%; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding.label-show, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .video-label-box .branding.label-show { left: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper { position: absolute; top: -38px; left: 0; display: block; overflow: hidden; width: 5px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .tbl-ui-line, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .tbl-ui-line { position: absolute; top: 0; left: 0; right: 0; bottom: 100%; transition: bottom .3s; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .tbl-ui-line.label-show, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper .tbl-ui-line.label-show { bottom: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper { position: absolute; top: -38px; left: 5px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .tbl-text-under-title-background, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .tbl-text-under-title-background { position: absolute; top: 0; height: 100%; width: 0; transition: width .3s; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .tbl-text-under-title-background.label-show, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper .tbl-text-under-title-background.label-show { width: 100%; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item { z-index: 1; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .thumbBlock_holder, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .thumbBlock_holder { z-index: 1; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .video-description, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .branding, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .video-description, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-show-item .item-label-href .video-label-box .branding { z-index: 2; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-remove-item .thumbBlock_holder, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-remove-item .thumbBlock_holder { -webkit-animation: tbl-animation-slide-out-left 0.75s; -moz-animation: tbl-animation-slide-out-left 0.75s; -ms-animation: tbl-animation-slide-out-left 0.75s; -o-animation: tbl-animation-slide-out-left 0.75s; animation: tbl-animation-slide-out-left 0.75s; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .trc_rbox_outer .videoCube.tbl-next-item .thumbBlock_holder, .story-widget.story-widget-text-under-slide-in .trc_rbox_outer .videoCube.tbl-next-item .thumbBlock_holder { z-index: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp { top: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { background: -webkit-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: -webkit-gradient(linear, left top, left bottom, from(rgba(1, 0, 0, 0.8)), to(rgba(0, 0, 0, 0))); background: -o-linear-gradient(top, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); background: linear-gradient(to bottom, rgba(1, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%); } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-reco-reel-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-story-progressBar, .story-widget.story-widget-text-under-slide-in .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-reco-reel-progressBar { top: 10px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-text-under-controls, .story-widget.story-widget-text-under-slide-in .tbl-text-under-controls { position: absolute; right: 10px; z-index: 2; direction: ltr; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-text-under-controls span, .story-widget.story-widget-text-under-slide-in .tbl-text-under-controls span { cursor: pointer; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in .tbl-text-under-controls span svg, .story-widget.story-widget-text-under-slide-in .tbl-text-under-controls span svg { width: 33px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href { left: auto; right: 20px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-title, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-title, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-title { margin: 10px 7px 10px 0; left: auto; right: 5px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding { position: relative; margin: 0 12px 0 0; left: auto; right: -110%; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding .tbl-text-under-branding-background { left: auto; right: -5px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding.label-show, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding.label-show, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding.label-show, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .video-description.label-show, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .video-label-box .branding.label-show { left: auto; right: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .tbl-ui-line-wrapper { left: auto; right: 0; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .trc_rbox_outer .item-label-href .tbl-text-under-title-background-wrapper { left: auto; right: 5px; } .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.tbl-reco-reel-text-under-rtl .tbl-text-under-controls, .tbl-reco-reel.tbl-reco-reel-text-under-slide-in.story-widget-text-under-rtl .tbl-text-under-controls, .story-widget.story-widget-text-under-slide-in.tbl-reco-reel-text-under-rtl .tbl-text-under-controls, .story-widget.story-widget-text-under-slide-in.story-widget-text-under-rtl .tbl-text-under-controls { right: auto; left: 10px; }`);
            }

            setDynamicCss() {

                /* eslint-disable no-unused-vars */
                const interval = `${this.intervalLength}s`,
                    // for ensure zoom animation will be longer then the interval add 0.5 sec
                    zoomTime = `${+this.intervalLength + 0.5}s`,
                    arrowSize = `${ARROW_SIZE}`,
                    modeName = this.rbox.mode_name,
                    progressBarHeight = this.isTouchDevice ? Math.round(this.imageHeight * 0.3)
                                                             || PROGRESS_BAR_HEIGHT : PROGRESS_BAR_HEIGHT,
                    progressBarPreventClickHeight = this.isTouchDevice ? Math.round(this.imageHeight * 0.15) : 0,
                    progressBarPosition = this.imageHeight - PROGRESS_BAR_HEIGHT;

                /* eslint-enable */

                // eslint-disable-next-line no-unused-vars
                TRC.dom.injectStyle(`.tbl-reco-reel.tbl-story-touch-device .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .tbl-reco-reel.tbl-story-touch-device .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .tbl-reco-reel.tbl-reco-reel-touch-device .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .tbl-reco-reel.tbl-reco-reel-touch-device .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .story-widget.tbl-story-touch-device .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .story-widget.tbl-story-touch-device .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .story-widget.tbl-reco-reel-touch-device .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-prevent-click-progressBar, .story-widget.tbl-reco-reel-touch-device .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-prevent-click-progressBar { height: ${progressBarPreventClickHeight}px; }.tbl-reco-reel .${modeName}, .story-widget .${modeName} { /*EVENTS*/ } .tbl-reco-reel .${modeName} .videoCube.tbl-show-item.tbl-zoom-in-item .thumbBlock_holder .thumbBlock, .story-widget .${modeName} .videoCube.tbl-show-item.tbl-zoom-in-item .thumbBlock_holder .thumbBlock { -webkit-animation: tbl-animation-zoom-In ${zoomTime} ease-in; -moz-animation: tbl-animation-zoom-In ${zoomTime} ease-in; -ms-animation: tbl-animation-zoom-In ${zoomTime} ease-in; -o-animation: tbl-animation-zoom-In ${zoomTime} ease-in; animation: tbl-animation-zoom-In ${zoomTime} ease-in; } .tbl-reco-reel .${modeName} .tbl-story-progressBar-overflow-wrp, .tbl-reco-reel .${modeName} .tbl-reco-reel-progressBar-overflow-wrp, .story-widget .${modeName} .tbl-story-progressBar-overflow-wrp, .story-widget .${modeName} .tbl-reco-reel-progressBar-overflow-wrp { height: ${progressBarHeight}px; } .tbl-reco-reel .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .tbl-reco-reel .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .tbl-reco-reel .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .tbl-reco-reel .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .story-widget .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .story-widget .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp, .story-widget .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp, .story-widget .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp { height: ${progressBarHeight}px; -webkit--webkit-transition: all 1s; -moz--webkit-transition: all 1s; -ms--webkit-transition: all 1s; -o--webkit-transition: all 1s; -webkit-transition: all 1s; } .tbl-reco-reel .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-progress-anim, .tbl-reco-reel .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-progress-anim, .tbl-reco-reel .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-progress-anim, .tbl-reco-reel .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-progress-anim, .story-widget .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-progress-anim, .story-widget .${modeName} .tbl-story-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-progress-anim, .story-widget .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-story-progressBar-wrp .tbl-progress-anim, .story-widget .${modeName} .tbl-reco-reel-progressBar-overflow-wrp .tbl-reco-reel-progressBar-wrp .tbl-progress-anim { -webkit-animation: tbl-animation-progress-bar ${interval} linear; -moz-animation: tbl-animation-progress-bar ${interval} linear; -ms-animation: tbl-animation-progress-bar ${interval} linear; -o-animation: tbl-animation-progress-bar ${interval} linear; animation: tbl-animation-progress-bar ${interval} linear; } .tbl-reco-reel .${modeName} .tbl-arrow-btn, .story-widget .${modeName} .tbl-arrow-btn { height: ${arrowSize}px; width: ${arrowSize}px; display: block; } .tbl-reco-reel .${modeName} .tbl-clickable-area-btn, .story-widget .${modeName} .tbl-clickable-area-btn { top: ${progressBarPreventClickHeight}px; width: ${arrowSize}px; height: ${this.imageHeight - progressBarPreventClickHeight}px; } .tbl-reco-reel .${modeName} .tbl-arrow-btn.tbl-arrow-left, .story-widget .${modeName} .tbl-arrow-btn.tbl-arrow-left { left: ${-1*arrowSize}px; } .tbl-reco-reel .${modeName} .tbl-arrow-btn.tbl-arrow-right, .story-widget .${modeName} .tbl-arrow-btn.tbl-arrow-right { right: ${-1*arrowSize}px; }.tbl-reco-reel.tbl-story-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-left, .tbl-reco-reel.tbl-reco-reel-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-left, .story-widget.tbl-story-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-left, .story-widget.tbl-reco-reel-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-left { -webkit-transform: scaleX(-1) translateX(${-1*arrowSize}px); -moz-transform: scaleX(-1) translateX(${-1*arrowSize}px); -ms-transform: scaleX(-1) translateX(${-1*arrowSize}px); -o-transform: scaleX(-1) translateX(${-1*arrowSize}px); transform: scaleX(-1) translateX(${-1*arrowSize}px); }.tbl-reco-reel.tbl-story-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-right, .tbl-reco-reel.tbl-reco-reel-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-right, .story-widget.tbl-story-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-right, .story-widget.tbl-reco-reel-desktop .${modeName}:hover .tbl-arrow-btn.tbl-arrow-right { -webkit-transform: translateX(${-1*arrowSize}px); -moz-transform: translateX(${-1*arrowSize}px); -ms-transform: translateX(${-1*arrowSize}px); -o-transform: translateX(${-1*arrowSize}px); transform: translateX(${-1*arrowSize}px); }`);
            }

            listenToAnimationEvents() {
                const animationEndEvent = TRC.dom.detectAnimationEvent(this.container, 'end') || 'animationend',
                    animationStartEvent = TRC.dom.detectAnimationEvent(this.container, 'start') || 'animationstart';

                TRC.dom.on(this.container, animationStartEvent, event => this.animationStartHandler(event));
                TRC.dom.on(this.container, animationEndEvent, event => this.animationEndHandler(event));
            }

            /**
             * Helper method to calculate the height or width of the widget including margin and border
             * @param prop width or height
             * @param {HTMLElement} element element to calc the height (if element not defined then stop and return )
             * @returns {number | void} calculated height
             */
            static getOuter(prop, element) {
                return element && element.getBoundingClientRect()[prop];
            }

            /**
             * create SVG element clicked arrow and append to the element parameter
             * @returns string
             */
            static addASvgArrow() {
                return `<svg width="17px" height="29px" viewBox="0 0 17 29" version="1.1" xmlns="http://www.w3.org/2000/svg">
                       <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                           <g id="Desktop-4-cards" transform="translate(-1073.000000, -436.000000)" fill="#FFFDFD" fill-rule="nonzero">
                               <g id="Group" transform="translate(1081.500000, 450.500000) scale(-1, 1) translate(-1081.500000, -450.500000) translate(1073.000000, 436.000000)">
                                   <polygon id="Rectangle-5" transform="translate(8.294336, 8.495231) rotate(45.000000) translate(-8.294336, -8.495231) " points="7.05498966 -1.37457069 9.68971053 -1.39537442 9.53368258 18.3650322 6.8989617 18.3858359"></polygon>
                                   <polygon id="Rectangle-5" transform="translate(8.294336, 20.257858) scale(1, -1) rotate(45.000000) translate(-8.294336, -20.257858) " points="7.05498966 10.3880565 9.68971053 10.3672528 9.53368258 30.1276594 6.8989617 30.1484631"></polygon>
                               </g>\n'
                           </g>\n'
                       </g>\n'
                   </svg>`;
            }

            /**
             * create SVG element clicked arrow and append to the element parameter
             * @returns string
             */
            static addASvgPlaceHolder() {
                return `<svg version="1.1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"
                    viewBox="0 0 100 100" enable-background="new 0 0 100 100" xml:space="preserve">
                     <rect fill="none" stroke="#fff" stroke-width="4" x="25" y="25" width="50" height="50">
                    <animateTransform
                       attributeName="transform"
                       dur="0.5s"
                       from="0 50 50"
                       to="180 50 50"
                       type="rotate"
                       id="strokeBox"
                       attributeType="XML"
                       begin="rectBox.end"/>
                    </rect>
                     <rect x="27" y="27" fill="#fff" width="46" height="50">
                    <animate
                       attributeName="height"
                       dur="1.3s"
                       attributeType="XML"
                       from="50" 
                       to="0"
                       id="rectBox" 
                       fill="freeze"
                       begin="0s;strokeBox.end"/>
                    </rect>
                  </svg>`;
            }

            static addArrowIcon(linkContainer, direction) {
                let svg;

                if (direction === 'ltr') {
                    svg = `<div class="tbl-labels-arrow tbl-labels-arrow-right">
                          <?xml version="1.0" encoding="UTF-8"?>
                          <svg width="23px" height="23px" viewBox="0 0 23 23" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>Group 3</title>
                          <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round">
                          <g id="Mobile-SC-CTA" transform="translate(-320.000000, -479.000000)" stroke="#FFFFFF">
                          <g id="Group-3" transform="translate(321.000000, 480.000000)">
                          <polyline id="Path" points="8.2173913 5.47826087 13.6956522 10.0434783 8.2173913 14.6086957"></polyline>
                          <circle id="Oval" cx="10.5" cy="10.5" r="10.5"></circle>
                          </g>
                          </g>
                          </g>
                          </svg>
                        </div>`;
                } else {
                    svg = `<div class="tbl-labels-arrow tbl-labels-arrow-left">
                    <?xml version="1.0" encoding="UTF-8" standalone="no"?>\n
                    <svg width="23px" height="23px"
                         viewBox="0 0 23 23"
                         version="1.1"
                         xmlns="http://www.w3.org/2000/svg"
                         xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title id="title37">Group 3</title>
                      <desc id="desc39">Created with Sketch.</desc>
                      <g transform="rotate(180,11.5,11.5)"
                         stroke-linejoin="round"
                         stroke-linecap="round"
                         fill-rule="evenodd"
                         fill="none"
                         stroke-width="1"
                         stroke="none"
                         id="Page-1">
                        <g stroke="#ffffff" transform="translate(-320,-479)" id="Mobile-SC-CTA">
                          <g transform="translate(321,480)" id="Group-3">
                            <polyline points="8.2173913 5.47826087 13.6956522 10.0434783 8.2173913 14.6086957" id="Path" />
                            <circle r="10.5" cy="10.5" cx="10.5" id="Oval" />
                          </g>
                        </g>
                      </g>
                    </svg>
                    </div>`;
                }

                linkContainer.insertAdjacentHTML('beforeend', svg);
            }

            /**
             * Create text under control elements
             */
            createControls() {
                this.controls = document.createElement('div');
                TRC.dom.addClass(this.controls, CSS_CLASSES.TEXT_UNDER_CONTROLS);

                // create control buttons in order
                const buttonTypes = this.isWithVideoLayout ? this.videoReel.getControlButtons() : CONTROL_BUTTON_ORDER;
                buttonTypes.forEach(type => this[`${type}Button`] = this.createControlButton(type));

                this.internalc.parentNode.insertAdjacentElement('beforeend', this.controls);
            }

            createControlButton(buttonType) {
                const button = document.createElement('span');
                if (buttonType === CONTROL_BUTTON_TYPES.PLAY) {
                    TRC.dom.addClass(button, CSS_CLASSES.HIDDEN);
                }
                TRC.dom.addClass(button, `tbl-${buttonType}`);
                button.innerHTML = CONTROL_BUTTONS$1[buttonType];
                const onClick = this.generateControlButtonOnClick(buttonType);
                TRC.dom.on(button, 'click', onClick);
                this.controls.insertAdjacentElement('beforeend', button);
                return button;
            }

            generateControlButtonOnClick(buttonType) {
                switch (buttonType) {
                    case CONTROL_BUTTON_TYPES.BACK:
                    case CONTROL_BUTTON_TYPES.FORWARD:
                        return TRC.util.debounce((() => {
                            if (this.animationInProgress) {
                                return;
                            }
                            this.toggleMiddleControlButton(CONTROL_BUTTON_TYPES.PLAY);
                            this.slideCard(buttonType === CONTROL_BUTTON_TYPES.BACK ? 'right' : 'left', true);
                        }), LABELS_ANIMATION_TIMEOUT, true, this);
                    case CONTROL_BUTTON_TYPES.PAUSE:
                    case CONTROL_BUTTON_TYPES.PLAY:
                        return this.toggleMiddleControlButton.trcBind(this, buttonType);
                    default:
                        break;
                }
            }

            toggleMiddleControlButton(middleButtonType) {
                if (this.animationInProgress) {
                    return;
                }
                if (this.videoReel) {
                    this.videoReel.toggleMiddleControl(this.state.currentPosition, middleButtonType);
                }
                // NOTE: To see where this.playButton and this.pauseButton are initialized, look at createControls
                this.playStateAnimation(CONTROL_BUTTON_ANIMATION_STATUSES_MAP[middleButtonType]);
                switch (middleButtonType) {
                    case CONTROL_BUTTON_TYPES.PLAY:
                        TRC.dom.addClass(this.playButton, CSS_CLASSES.HIDDEN);
                        TRC.dom.removeClass(this.pauseButton, CSS_CLASSES.HIDDEN);
                        break;
                    case CONTROL_BUTTON_TYPES.PAUSE:
                        TRC.dom.addClass(this.pauseButton, CSS_CLASSES.HIDDEN);
                        TRC.dom.removeClass(this.playButton, CSS_CLASSES.HIDDEN);
                        break;
                    default:
                        break;
                }
            }

            /**
             * Define publisher text direction
             * @param rboxManager
             */
            static getDirection(rboxManager) {
                const directionProp = rboxManager.trc.getProperty(rboxManager.mode_name, 'direction', rboxManager.propertiesOverride);
                return TRC.direction || directionProp || 'ltr';
            }

            /**
             * Align labels box by the publisher text direction
             * @param videoBoxContainer
             * @param direction
             */
            static alignLabelsBox(videoBoxContainer, direction) {
                const alignClass = direction === 'rtl' ? LABELS_CSS.LABELS_ALIGN_RIGHT : LABELS_CSS.LABELS_ALIGN_LEFT;
                TRC.dom.addClass(videoBoxContainer.labelsBox, LABELS_CSS.LABELS_ALIGN);
                TRC.dom.addClass(videoBoxContainer.labelsBox, alignClass);
            }

            /**
             * Events handler method for swipe events on mobile catch events : swipe down / up / left / right / tap
             * and trigger the arrow click function with the relevant direction
             * @param {HTMLElement} gestureZone element add event listener :  touchstart , touchend
             * @returns {void}
             */
            listenToSwipeEvents(gestureZone) {
                const touchCoordinates = {
                    start: {screenX: 0, screenY: 0},
                    end: {screenX: 0, screenY: 0}
                };

                TRC.dom.on(gestureZone, 'touchstart', event => {
                    touchCoordinates.start = {
                        screenX: event.changedTouches[0].screenX,
                        screenY: event.changedTouches[0].screenY
                    };
                });

                TRC.dom.on(gestureZone, 'touchend', event => {
                    touchCoordinates.end = {
                        screenX: event.changedTouches[0].screenX,
                        screenY: event.changedTouches[0].screenY
                    };
                    this.handleGesture(gestureZone, touchCoordinates);
                });
            }

            handleGesture(gestureZone, touchCoordinates) {
                const {start, end} = touchCoordinates;
                const ClientRect = gestureZone.getBoundingClientRect(),
                    {width, height} = ClientRect,
                    ratioHorizontal = (end.screenX - start.screenX) / width,
                    ratioVertical = (end.screenY - start.screenY) / height,
                    touchOnScreenWidth = 0.25; // percent

                if (ratioHorizontal > ratioVertical && ratioHorizontal > touchOnScreenWidth) {
                    return this.slideCard('right', true);
                }

                if (ratioHorizontal < ratioVertical && ratioHorizontal < -touchOnScreenWidth) {
                    return this.slideCard('left', true);
                }
            }

            calcCardHeight() {
                let maxHeight = {itemHeight: 0, item: null};
                this.items.forEach((item, index) => {
                    if (index === 0) {
                        maxHeight.item = item;
                    }
                    const thumbBlockHolder = item.querySelector('.thumbBlock_holder');
                    thumbBlockHolder && thumbBlockHolder.insertAdjacentHTML('afterbegin',
                        `<div class="thumbBlock_placeholder">${RecommendationReel.addASvgPlaceHolder()}</div>`);

                    /* set card size by is bigger height item */
                    const itemHeight = RecommendationReel.getOuter('height', item);
                    item.style.top = 0;

                    if (itemHeight > maxHeight.itemHeight) {
                        maxHeight = {itemHeight, item};
                    }

                    if (this.isTouchDevice) {
                        this.listenToSwipeEvents(item.querySelector(`.${CSS_CLASSES.IMAGE_HOLDER}`));
                    }
                });

                return maxHeight;
            }

            responsiveAlignment(maxHeight) {
                const {progressBar, arrows, clickedAreas} = this;
                maxHeight.item.style.top = 0;
                this.calcImageHeight();
                if (maxHeight.itemHeight > 0) {
                    this.internalc.style.height = `${maxHeight.itemHeight}px`;
                }

                const firstItem = this.items[0];
                let preThumbHeight = 0;
                if (firstItem && firstItem.pre_detail_order && firstItem.pre_detail_order.length > 0) {
                    preThumbHeight += RecommendationReel.getOuter('height', firstItem.preLabelsBox);
                }

                const progressBarPosition = `${this.imageHeight - PROGRESS_BAR_HEIGHT + preThumbHeight}px`;
                progressBar.firstChild.style.top = 0;
                progressBar.style.top = this.isTouchDevice ? `${preThumbHeight}px` : progressBarPosition;

                arrows.forEach(arrow => {
                    arrow.style.top = `${(this.imageHeight + preThumbHeight) / 2 - ARROW_SIZE / 2}px`;
                });

                clickedAreas.forEach(clickedArea => {
                    clickedArea.style.width = `${this.imageWidth * CLICKED_AREA_SIZE}px`;
                });
            }

            /**
             * Recalculate elements dimensions on resize
             */
            responsiveAlignmentTextUnder(maxHeight) {
                const {controls, clickedAreas} = this;
                maxHeight.item.style.top = 0;
                this.calcImageHeight();

                let labelBoxHeightAdjust = 0;
                this.items.forEach(item => {
                    const curLabelsBoxHeight = RecommendationReel.getOuter('height', item.querySelector('.video-label-box'));
                    if (labelBoxHeightAdjust < curLabelsBoxHeight) {
                        labelBoxHeightAdjust = curLabelsBoxHeight;
                    }
                });

                if (maxHeight.itemHeight > 0) {
                    if (this.isWithVideoLayout) {
                        this.internalc.style.height = `${maxHeight.itemHeight + DEFAULT_CONTROL_HEIGHT}px`;
                    } else {
                        this.internalc.style.height = `${maxHeight.itemHeight + labelBoxHeightAdjust + DEFAULT_LABEL_TOP_MOBILE}px`;
                    }
                }

                let deviceOffest = 0.25;
                const intImgHeight = parseInt(this.imageHeight, 10);
                if (intImgHeight <= MINIMUM_IMG_HEIGHT_FOR_CNTRLS) {
                    deviceOffest = 0.37;
                    !TRC.dom.containsClass(this.container, 'tbl-reco-reel-touch-device')
                    && TRC.dom.addClass(this.container, 'tbl-reco-reel-touch-device');
                    TRC.dom.removeClass(this.container, 'tbl-reco-reel-desktop');
                } else {
                    !TRC.dom.containsClass(this.container, 'tbl-reco-reel-desktop')
                    && TRC.dom.addClass(this.container, 'tbl-reco-reel-desktop');
                    TRC.dom.removeClass(this.container, 'tbl-reco-reel-touch-device');
                }
                if (!this.isWithVideoLayout) {
                    controls.style.top = `${intImgHeight - intImgHeight * deviceOffest}px`;
                }

                if (this.isTouchDevice) {
                    clickedAreas.forEach(clickedArea => {
                        clickedArea.style.width = `${this.imageWidth * CLICKED_AREA_SIZE}px`;
                    });
                }
            }

            /**
             * Calculate labels box top offset when title is not first element
             */
            static calcLabelsTopByDetailsOrder(item) {
                const labelsBox = item.querySelector(LABELS_CSS.LABELS_BOX);
                const isDesktop = TRC.dom.isDesktop();
                let offset = isDesktop ? DEFAULT_LABEL_TOP_DESKTOP : DEFAULT_LABEL_TOP_MOBILE;

                const labelsBoxChildren = labelsBox.children;
                for (let i = 0; i < labelsBoxChildren.length; i++) {
                    const label = labelsBoxChildren[i];
                    if (TRC.dom.containsClass(label, LABELS_CSS.VIDEO_TITLE)) {
                        break;
                    }
                    const labelHeight = getComputedStyle(label).height;
                    const labelHeightInt = parseInt(labelHeight, 10);

                    if (labelHeightInt > 0) {
                        offset -= labelHeightInt;
                    } else {
                        label.style.display = 'none';
                    }

                }
                if ((isDesktop && offset !== DEFAULT_LABEL_TOP_DESKTOP)
                    || (!isDesktop && offset !== DEFAULT_LABEL_TOP_MOBILE)) {
                    return offset;
                }
                return '';
            }

            /**
             * Insert branding background, use client property to update background color
             */
            static insertBrandingBackground(item) {
                const branding = item.querySelector(LABELS_CSS.LABELS_BRANDING);
                TRC.dom.addClass(branding, 'tbl-branding-on-top');
                const brandingBackground = `<span class="tbl-text-under-branding-background"></span>`;
                branding.insertAdjacentHTML('beforeend', brandingBackground);
            }

            /**
             * Insert animated background and border line for title
             * and branding background if in case it's above the title
             */
            addLabelsBoxAnimatedElements() {
                this.items.forEach(item => {
                    const href = item.querySelector(LABELS_CSS.LABELS);
                    const labelsTop = RecommendationReel.calcLabelsTopByDetailsOrder(item);
                    if (labelsTop) {
                        const labelsBox = item.querySelector(LABELS_CSS.LABELS_BOX);
                        labelsBox.style.top = `${labelsTop}px`;
                        RecommendationReel.insertBrandingBackground(item);
                    }
                    const animatedElements = ` <span class="tbl-text-under-title-background-wrapper">
                                             <span class="tbl-text-under-title-background"></span></span>
                                             <span class="tbl-ui-line-wrapper">
                                             <span class="tbl-ui-line"></span></span>
                                            `;
                    href.insertAdjacentHTML('afterbegin', animatedElements);
                });
            }

            /**
             * stop animation on hover or touch start
             * @param {String} status start or stop the animation based on : 'paused' , 'running' those values;
             * @returns  void
             */
            playStateAnimation(status) {
                const {activePB, showItem} = this.state,
                    item = showItem.querySelector('.thumbBlock'),
                    currentBar = activePB.firstChild;

                if (currentBar) {
                    currentBar.style.webkitAnimationPlayState = status;
                    currentBar.style.animationPlayState = status;
                }
                if (item) {
                    item.style.webkitAnimationPlayState = status;
                    item.style.animationPlayState = status;
                }
            }

            createProgressBar() {
                const progressBarWrp = document.createElement('div');
                progressBarWrp.className = CSS_CLASSES.PROGRESS_BAR_OVERFLOW_WRAPPER;
                const progressBar = document.createElement('div');
                progressBar.className = CSS_CLASSES.PROGRESS_BAR_WRAPPER;
                if (this.thumbnailPosition === 'under') {
                    TRC.dom.addClass(progressBar, CSS_CLASSES.PROGRESS_BAR_WRAPPER_TEXT_OVER);
                }

                progressBar.insertAdjacentHTML('afterbegin', this.createProgressUnits());
                this.progressBars = Array.prototype.slice.call(progressBar.childNodes);

                // eslint-disable-next-line prefer-destructuring
                this.state.activePB = this.progressBars[0];
                progressBarWrp.appendChild(progressBar);
                return progressBarWrp;
            }

            /**
             * create HTML element progress bar unit and append to progress bar wrapper
             * @returns  string
             */
            createProgressUnits() {
                let bars = '';
                const progressBarStyle = this.isWithVideoLayout
                    ? this.videoReel.getProgressBarStyle(this.amountOfItems)
                    : `width: ${(100 / this.amountOfItems) - 2}%`;
                for (let index = 0; this.amountOfItems > index; index++) {
                    bars += `<div class="${CSS_CLASSES.PROGRESS_BAR}" style="${progressBarStyle}" data-progress-bar-index="${index}"><span class="${CSS_CLASSES.PROGRESS_RUNNER}"></span></div>`;
                }
                return `${bars}`;
            }

            /**
             * create arrows elements for sliding
             * @returns {array}
             */
            createArrowBtns() {
                return ['left', 'right'].map(position => {
                    const arrow = document.createElement('div');
                    arrow.className = `${CSS_CLASSES.ARROW_BUTTON} tbl-arrow-${position}`;
                    arrow.insertAdjacentHTML('beforeend', RecommendationReel.addASvgArrow());
                    TRC.dom.on(arrow, 'click', this.slideCard.trcBind(this));
                    this.internalc.parentNode.appendChild(arrow);
                    return arrow;
                });
            }

            createMobileClickedArea() {
                if (this.isWithVideoLayout) {
                    return [];
                }
                return [CONTROL_BUTTON_TYPES.BACK, CONTROL_BUTTON_TYPES.FORWARD].map(position => {
                    const clickableArea = document.createElement('div');
                    clickableArea.style.height = `${this.calcImageHeight()}px`;
                    const onClick = !this.isTextUnderSlideIn ? this.slideCard.trcBind(this) : this.generateControlButtonOnClick(position);
                    clickableArea.className = `${CSS_CLASSES.CLICKABLE_AREA} tbl-clickable-area-${position}`;
                    TRC.dom.on(clickableArea, 'click', onClick);
                    this.internalc.parentNode.appendChild(clickableArea);
                    return clickableArea;
                });
            }

            togglePlayState() {
                if (this.container) {
                    this.toggleMiddleControlButton(CONTROL_BUTTON_TYPES.PLAY);
                    return;
                }
                this.startTheReel();
            }

            /**
             * observer callback function for "onEnter"
             * wait for widget to build if necessary or restart the widget based on current state
             */
            startTheReel() {
                if (this.waitForVideoDemand) {
                    return;
                }
                if (this.isImageHeightChanged() && this.allowRecalculateSize) {
                    this.allowRecalculateSize = false;
                    const cardHeight = this.calcCardHeight();
                    this.recalculateWidgetSize(cardHeight);
                }
                this.active = true;
                if (this.videoReel) {
                    this.videoReel.start(this.restartAnimation.bind(this), this.state.currentPosition);
                } else {
                    this.restartAnimation();
                }
            }

            getInstanceType() {
                if (this.videoReel) {
                    return 'recommendation-video-reel';
                }
                return 'recommendation-reel';
            }

            isImageHeightChanged() {
                const {imageHeight} = this;
                this.calcImageHeight();
                return imageHeight !== this.imageHeight;
            }

            togglePauseState() {
                if (this.container) {
                    this.toggleMiddleControlButton(CONTROL_BUTTON_TYPES.PAUSE);
                    return;
                }
                this.stopTheReel();
            }

            /**
             * observer callback function for "onEXit"
             * stop the reel animation and clear al css class from dom for next restarting the widget
             */
            stopTheReel() {
                this.active = false;
                if (this.videoReel) {
                    this.videoReel.toggleMiddleControl(this.state.currentPosition, 'pause');
                }
            }

            /**
             * start the animation based on current state
             */
            restartAnimation() {
                setTimeout(() => {
                    this.isTextUnderSlideIn && this.calcLabelBoxSizes();
                    this.updateItem();
                    this.updateCarouselIteration('left');
                });
            }

            /**
             * event method for click on controls or swipe based device and move to next item
             * @param {event | String} event fired on controls clicked or direction (left| right) on swipe
             * @param {boolean } swipeEvent is swiped true or false
             * @returns boolean
             */
            slideCard(event, swipeEvent) {
                if (this.disableClickEvents) {
                    return false;
                }

                const direction = RecommendationReel.resolveAnimationDirection(event, swipeEvent);
                const {showItem} = this.state;

                TRCImpl.sendAbTestEvent(this.instanceType, `click_${direction === 'left' ? 'right' : 'left'}`); // change from slide direction to click location
                if (this.isWithLabelAnimation) {
                    this.hideAnimatedLabelBox(showItem, this.updateIteration.trcBind(this, direction));
                } else {
                    this.updateIteration(direction);
                }
                return true;
            }

            static resolveAnimationDirection(event, swipeEvent) {
                let direction;
                if (swipeEvent) {
                    /* mobile state -> swipe event */
                    direction = event;
                } else if (TRC.dom.containsClass(event.currentTarget, CSS_CLASSES.ARROW_BUTTON)
                           || TRC.dom.containsClass(event.currentTarget, CLASSES.SLIDER_ARROW)) {
                    direction = TRC.dom.containsClass(event.currentTarget, 'tbl-arrow-left') ? 'right' : 'left';
                } else if (TRC.dom.containsClass(event.currentTarget, CSS_CLASSES.CLICKABLE_AREA)) {
                    direction = TRC.dom.containsClass(event.currentTarget, 'tbl-clickable-area-back') ? 'right' : 'left';
                } else {
                    direction = 'left';
                }
                return direction; // return the slide direction
            }

            /**
             * get the item position to show and the next one after him
             * @param slideDirection
             * @returns {object}
             */
            updateIteration(slideDirection) {
                slideDirection = slideDirection || 'left';
                this.debugWidget && this.debugSlider();

                let step = 1;
                const {showNextItem, currentPosition} = this.state;

                if (slideDirection === 'right') {
                    TRC.dom.removeClass(showNextItem, CSS_CLASSES.NEXT_ITEM);

                    let nextItemIndex;
                    if (!currentPosition) {
                        step = this.amountOfItems - 1;
                        nextItemIndex = step;
                    } else {
                        step = -1;
                        nextItemIndex = currentPosition - 1;
                    }

                    TRC.dom.addClass(this.items[nextItemIndex], CSS_CLASSES.NEXT_ITEM);
                }
                const showPosition = +currentPosition + step === this.amountOfItems ? 0 : currentPosition + step;
                this.setState({
                    showPosition,
                    nextShowPosition: Number(showPosition + 1) === this.amountOfItems ? 0 : showPosition + 1
                });
                this.updateCarouselIteration(slideDirection);
                if (this.videoReel) {
                    this.videoReel.handleNextVideo(this.state.previousPosition, this.state.currentPosition);
                }
            }

            /**
             * send RvAvailable event if the item is "rv" and we haven't sent "rv" available event for this item already
             * @param {number} position
             */
            sendRvAvailableIfNeeded(position) {
                try {
                    const currentRecommendationData = this.rbox.recommendationList[position];
                    if (!this.shouldSendRvAvailable(currentRecommendationData)) {
                        return;
                    }
                    TRC.dispatch(`required-viewability-available::${currentRecommendationData['item-id']}`);
                    currentRecommendationData.rvAvailableSent = true;
                } catch (e) {
                    __trcWarn('error while sending rv available for reco reel: ', e);
                }
            }

            /**
             * check if we need send rvAvailable for reco reel
             * @param {object} currentRecommendationData is the item data
             * @returns boolean
             */
            shouldSendRvAvailable(currentRecommendationData) {
                return this.rbox.trc.global['rv-available-for-reco-reel'] && currentRecommendationData.rv && !currentRecommendationData.rvAvailableSent;
            }

            /**
             * set RecommendationReel state for new lifeCycle
             * @param {object} targets  the next position that the widget show
             * @returns {object} the updated RecommendationReel state
             */
            setState({showPosition, nextShowPosition}) {
                const showItem = this.items[showPosition],
                    showNextItem = this.items[nextShowPosition],
                    showProgressBar = this.progressBars[showPosition];

                return (this.state = {
                    previousItem: this.state.showItem,
                    showItem,
                    showNextItem,
                    activePB: showProgressBar,
                    previousPosition: this.state.currentPosition,
                    currentPosition: showPosition
                });
            }

            isFirstIteration() {
                return this.state.previousPosition === null;
            }

            /**
             * update the progress bar state : active , not active , animated
             * @param {String} [direction] css class tbl-remove-item , tbl-remove-item-to-right
             * trigger animation event for slide out left or right
             * @returns void
             */
            updateCarouselIteration(direction) {
                if (!this.active) {
                    return;
                }

                const {REMOVE_LEFT, REMOVE_RIGHT} = CSS_CLASSES;
                const slideClassName = direction === 'left' ? REMOVE_LEFT : REMOVE_RIGHT;
                const {previousPosition} = this.state;

                (!this.isFirstIteration()) && this.slideAnimation(slideClassName); // no need to slide on first init
                this.updateProgressBar();

                if (this.progressBars.length - 1 === previousPosition) { // finished full cycle
                    this.finishFirstCycle = true;
                    this.videoReel && this.videoReel.reportFullCycle();
                }
            }

            debugSlider() { // window.trc_debug_level
                const debug = {};
                const itemClass = ['SHOW_ITEM', 'NEXT_ITEM', 'REMOVE_LEFT', 'REMOVE_RIGHT', 'ZOOM_IN'];
                this.items.forEach((item, index) => {
                    debug[`item_${index}`] = {};
                    Object.keys(CSS_CLASSES).forEach(key => {
                        if (itemClass.indexOf(key) !== -1) {
                            debug[`item_${index}`][key] = TRC.dom.containsClass(CSS_CLASSES[key]) ? 'X' : null;
                        }
                    });
                });
                console.log(`%c card ${this.container.dataset.cardIndex}`,
                    `background: #5${this.container.dataset.cardIndex * 10}; color: white`);
                console.table(debug);
            }

            slideAnimation(slideOutDirection = CSS_CLASSES.REMOVE_LEFT) {
                const currentIndex = this.state.previousPosition,
                    removeItemEl = this.items[currentIndex];

                TRC.dom.addClass(removeItemEl, slideOutDirection);
            }

            updateProgressBar() {
                const {activePB, currentPosition, previousPosition} = this.state;
                if (!this.isFirstIteration()) {
                    TRC.dom.removeClass(this.progressBars[previousPosition].firstChild, CSS_CLASSES.PROGRESS_ANIM);
                }
                TRC.dom.addClass(activePB.firstChild, CSS_CLASSES.PROGRESS_ANIM);

                this.progressBars.forEach((bar, index) => {
                    // fill other bars if needed
                    bar.firstChild.style.left = currentPosition > index ? '0' : '-100%';
                });
            }

            /**
             * update the item to be shown , to be next to shown or to be hide based on the state manager
             * @returns void
             */
            updateItem() {

                const {
                    showItem, showNextItem, currentPosition
                } = this.state;

                /* 1. clear the old shown item */
                this.clearThePreviousItem();

                /* 1.1 sometime if the widget outside the viewport the classname not cleared this is a hot fix   */
                if (document.querySelector(`.${CSS_CLASSES.SHOW_ITEM}`)) {
                    this.clearAll();
                }
                /* 2. now set the new show item */
                TRC.dom.addClass(showItem, `${CSS_CLASSES.SHOW_ITEM} ${CSS_CLASSES.ZOOM_IN}`);
                TRC.dom.removeClass(showItem, CSS_CLASSES.NEXT_ITEM);

                /* 3. and finally set the next show item */
                TRC.dom.addClass(showNextItem, CSS_CLASSES.NEXT_ITEM);

                /* 4. that's it now it's time to check if we finish full cycle */
                if (!this.finishFirstCycle) {
                    const eventData = `Visible_${currentPosition + 1}`;
                    // fire event only for finished first cycle (moving from last item to first item)
                    if (this.videoReel) {
                        this.videoReel.reportVisible(currentPosition, eventData);
                    } else {
                        TRCImpl.sendAbTestEvent(this.instanceType, eventData);
                    }
                    this.sendRvAvailableIfNeeded(currentPosition);
                }
            }

            clearThePreviousItem() {
                const {previousItem} = this.state;
                if (previousItem) {
                    RecommendationReel.clearClassNames(previousItem);
                    return true;
                }
                return false;
            }

            clearAll() {
                this.items.forEach(item => {
                    RecommendationReel.clearClassNames(item);
                    return true;
                });
            }

            static clearClassNames(item) {
                TRC.dom.removeClass(item, CSS_CLASSES.SHOW_ITEM);
                TRC.dom.removeClass(item, CSS_CLASSES.REMOVE_LEFT);
                TRC.dom.removeClass(item, CSS_CLASSES.REMOVE_RIGHT);
                CSS_CLASSES.ZOOM_IN && TRC.dom.removeClass(item, CSS_CLASSES.ZOOM_IN);
            }

            /**
             * Calculate dimensions of title background and left border line
             */
            calcLabelBoxSizes() {
                if (this.isWithVideoLayout) {
                    return;
                }
                requestAnimationFrame(() => {
                    this.items.forEach(item => {
                        const title = item.querySelector('.item-label-href .video-title');
                        const line = item.querySelector('.item-label-href .tbl-ui-line-wrapper');
                        const background = item.querySelector('.item-label-href .tbl-text-under-title-background-wrapper');
                        const titleComputed = getComputedStyle(title);
                        // 20 is 10px margin to align video-title on background.
                        // Binded to fixed margin in .video-title/margin: 10px 0 10px 7px;
                        item.titleElemsAndSizes = {
                            line,
                            background,
                            titleHeight: `${parseInt(titleComputed.height, 10) + 20}px`,
                            titleWidth: `${parseInt(titleComputed.width, 10) + 20}px`
                        };
                    });

                    this.items.forEach(item => {
                        const {
                            line,
                            background,
                            titleHeight,
                            titleWidth
                        } = item.titleElemsAndSizes;

                        if (line) line.style.height = titleHeight;
                        if (background) {
                            background.style.height = titleHeight;
                            background.style.width = titleWidth;
                        }
                    });
                });
            }

            /**
             * Get elements from labels container for updating animation
             */
            static getLabelBoxElements(item) {
                return {
                    href: item.querySelector('.item-label-href'),
                    title: item.querySelector('.item-label-href .video-title'),
                    background: item.querySelector('.item-label-href .tbl-text-under-title-background'),
                    branding: item.querySelector('.item-label-href .branding'),
                    description: item.querySelector('.item-label-href .video-description'),
                    line: item.querySelector('.item-label-href .tbl-ui-line')
                };
            }

            /**
             * Aniamte labels of showItem
             */
            showAnimatedLabelBox(item) {
                const itemLabelBoxElements = RecommendationReel.getLabelBoxElements(item);
                Object.keys(itemLabelBoxElements).forEach(key => {
                    TRC.dom.removeClass(itemLabelBoxElements[key], CSS_CLASSES.LABEL_SHOW);
                });
                if (itemLabelBoxElements.href) itemLabelBoxElements.href.style.zIndex = '2'; 
                TRC.dom.addClass(itemLabelBoxElements.line, CSS_CLASSES.LABEL_SHOW);
                setTimeout(() => {
                    TRC.dom.addClass(itemLabelBoxElements.background, CSS_CLASSES.LABEL_SHOW);
                    TRC.dom.addClass(itemLabelBoxElements.branding, CSS_CLASSES.LABEL_SHOW);
                    TRC.dom.addClass(itemLabelBoxElements.description, CSS_CLASSES.LABEL_SHOW);
                    setTimeout(() => {
                        TRC.dom.addClass(itemLabelBoxElements.title, CSS_CLASSES.LABEL_SHOW);
                        this.animationInProgress = false;
                    }, LABELS_ANIMATION_TIMEOUT);
                }, LABELS_ANIMATION_TIMEOUT);
            }

            /**
             * Hide previous and show next item
             */
            hideAnimatedLabelBox(item, nextCallback) {
                if (this.animationInProgress) {
                    return;
                }
                this.animationInProgress = true;
                const itemLabelBoxElements = RecommendationReel.getLabelBoxElements(item);
                TRC.dom.removeClass(itemLabelBoxElements.title, CSS_CLASSES.LABEL_SHOW);
                setTimeout(() => {
                    TRC.dom.removeClass(itemLabelBoxElements.background, CSS_CLASSES.LABEL_SHOW);
                    TRC.dom.removeClass(itemLabelBoxElements.branding, CSS_CLASSES.LABEL_SHOW);
                    TRC.dom.removeClass(itemLabelBoxElements.description, CSS_CLASSES.LABEL_SHOW);
                    setTimeout(() => {
                        TRC.dom.removeClass(itemLabelBoxElements.line, CSS_CLASSES.LABEL_SHOW);
                        setTimeout(() => {
                            if (itemLabelBoxElements.href) itemLabelBoxElements.href.style.zIndex = '-1';
                            nextCallback();
                        }, LABELS_ANIMATION_TIMEOUT);
                    }, LABELS_ANIMATION_TIMEOUT);
                }, LABELS_ANIMATION_TIMEOUT);
            }

            /**
             * on animation start update the state and trigger next cycle
             * @param {object} event - when slide animation start disable click events
             * @returns void
             */
            animationStartHandler(event) {
                if (this.isWithLabelAnimation) {
                    const {showItem} = this.state;
                    if (event.animationName === CSS_ANIMATION.PROGRESS_BAR_ANIMATION) {
                        this.showAnimatedLabelBox(showItem);
                    }
                }

                if (SLIDE_EVENTS.indexOf(event.animationName) !== -1) {
                    this.disableClickEvents = true;
                }
            }

            /**
             * on animation end update the state and trigger next cycle
             * @param {object} event - every time progress bar end trigger new iteration
             * @returns void
             */
            animationEndHandler(event) {

                if (event.animationName === CSS_ANIMATION.PROGRESS_BAR_ANIMATION) {
                    this.disableClickEvents = false;

                    if (this.isWithLabelAnimation) {
                        const {showItem} = this.state;
                        this.hideAnimatedLabelBox(showItem, this.updateIteration.trcBind(this));
                    } else {
                        this.updateIteration();
                    }
                }

                if (SLIDE_EVENTS.indexOf(event.animationName) !== -1) {

                    this.disableClickEvents = false;
                    this.updateItem();
                }
            }

            static setRVAvailableListener(trcbox, item, postData, utmParams, itemId) {
                const rvAvailableParams = {rvpm: 0};
                TRC.util.merge(rvAvailableParams, utmParams);
                const itemObserver = TRC.listen(`required-viewability-available::${itemId}`, function () {
                    this.sendRequiredViewabilityAvailableEvent(rvAvailableParams, postData, itemId);
                    item.rvAvailableRecoReelObserver.remove();
                }.trcBind(trcbox));
                item.rvAvailableRecoReelObserver = itemObserver;
            }

            static isPlacementRecoReel(placementData, trcManager) {
                return trcManager.global['force-set-reco-reel-container-value']
                       && placementData.uip
                       && placementData.uip === trcManager.global['force-set-reco-reel-container-value'];
            }

            static setContainerForRRPlacement(placementData, preloadRequest, feedsData) {
                if (!feedsData || !(typeof feedsData === 'object')
                    || !preloadRequest || !placementData || !placementData.cs) {
                    __trcWarn(`tried to set placement for Reco reel and failed. placementData: ${placementData},
                            preloadRequest:${preloadRequest}, feedsData: ${feedsData}.`);
                    return;
                }
                const feedName = Object.keys(feedsData)[0];
                const requestPlacement = preloadRequest[feedName];
                const toSet = placementData.cs[0];
                if (toSet && requestPlacement && requestPlacement.container) {
                    toSet.container = `#${requestPlacement.container.id}`;
                }
            }
        }

        TRC.RecommendationReel = RecommendationReel;
    }());

    var recommendationReel_es6 = TRC.RecommendationReel;

    (() => {

        const EXPLORE_MORE = 'Feed - Explore More';
        const RENDER_API_EVENT = 'api::render';
        const DEFAULT_MIN_RENDER_CARDS = 5;
        const DEFAULT_MAX_BATCH = 1;
        const ROOT_MARGIN = '2500px';
        const ObserverParams = {
            threshold: 0,
            disableCheckOverlay: true,
            root: null
        };

        /**
        * set all render type configurations and initiate 'RenderResponseInstance' for each trc response
        */
        class RenderControl {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.cardsCounters = {};
                this.lazyBatches = {};
                this.init();
            }
            
            init() {
                this.isLazyRenderEnabled = typeof this.isLazyRenderEnabled === 'boolean' ? this.isLazyRenderEnabled : this.checkLazyRenderEnabled();
                if (this.isLazyRenderEnabled) {
                    this.setLazyConfig();
                }
            }

            /**
             * check if lazy render is enabled global level
             * @returns {boolean|boolean}
             */
            checkLazyRenderEnabled() {
                const {global, yieldingEnabled, framework} = this.trcManager,
                    lazyRenderEnabled = !!(global && global['lazy-render-enable']),
                    yieldDisabled = !yieldingEnabled,
                    notAmpOrSDK = !framework, // disable in AMP and mobile SDK
                    notInIframe = !TRC.dom.isInIframe(true); // this my risk the viewability of the entire feed or widget
                return lazyRenderEnabled && yieldDisabled && notAmpOrSDK && notInIframe;
            }

            /**
             * set global lazy render configurations
             */
            setLazyConfig() {
                const lazyGlobalConfig = this.trcManager.global['lazy-render'] || {};
                /*
                excPlc - placement names to exclude from lazy rendering
                sbKill (split batch)- disabled split batch on trc
                dispatchPlacements - placement names that trigger rendering per event (e.g. stories)
                raKill (render api)- disable lazy rendering if publisher has registerd for render events (a.k.a api::render)
                 */
                const {
                    excPlc,
                    sbKill,
                    dispatchPlacements,
                    raKill
                } = lazyGlobalConfig;

                this.lazyConfig = {
                    excludePlacements: getExcludePlacements(excPlc),
                    sbKill: TRC.util.isTrue(sbKill),
                    dispatchPlacements: RenderControl.getDispatchPlacements(dispatchPlacements),
                    raKill: TRC.util.isTrue(raKill)
                };
                if (this.lazyConfig.sbKill) {
                    TRC.pageLevelFeaturesManager.pageLevelFeatures.sb_kill = true; // this will kill the "split-batch" feature on the server side
                }
                this.placementsConfigs = {};
                __trcCopyProps(RenderControl.proxyPlacementLevelConfigs(lazyGlobalConfig), this.lazyConfig);

                function getExcludePlacements(excPlc) {
                    if (!excPlc || !TRC.util.isArray(excPlc)) {
                        return [EXPLORE_MORE];
                    }
                    return (excPlc.indexOf(EXPLORE_MORE)) > -1 ? excPlc : excPlc.concat([EXPLORE_MORE]);
                }
            }

            /**
             * returns a config property if found in the placement level
             * otherwise return from the default configuration
             * @param configProp
             * @param placementData
             * @returns {*}
             */
            getPlacementConfig(configProp, placementData) {
                const {unifiedPlacement} = placementData;
                if (this.isFppEnabled(unifiedPlacement)) {
                    return this.placementsConfigs[unifiedPlacement][configProp] || this.lazyConfig[configProp];
                }
                return this.lazyConfig[configProp];
            }

            /**
             * set fpp placement level configs
             * @param lzrFppConfig
             */
            setPlacementsConfig(lzrFppConfig) {
                if (lzrFppConfig) {
                    Object.keys(lzrFppConfig).forEach(placementName => {
                        this.placementsConfigs[placementName] = RenderControl.proxyPlacementLevelConfigs(lzrFppConfig[placementName]);
                    });
                }
            }

            /**
             * proxy the placement level configs to their true js types
             * @param configObject -
             * @returns {{minCards: (number), maxBatch: (number), enable: boolean, fullLazyBatch: boolean, rootMargin: (*)}}
             */
            static proxyPlacementLevelConfigs(configObject) {
                const {
                    enable,
                    rootMargin,
                    minCards,
                    maxBatch,
                    fullLazyBatch,
                    dispatchEnabled
                } = configObject;

                return {
                    enable: TRC.util.isTrue(enable),
                    minCards: TRC.util.isNumber(minCards)
                        ? parseInt(minCards, 10) : DEFAULT_MIN_RENDER_CARDS, // number of cards to render the none lazy way
                    maxBatch: TRC.util.isNumber(maxBatch)
                        ? parseInt(maxBatch, 10) : DEFAULT_MAX_BATCH, // max number of batch to lazy render
                    rootMargin: typeof rootMargin === 'string' && rootMargin.indexOf('px') > 1 ? rootMargin : ROOT_MARGIN,
                    // render all the lazy card at once(first lazy card approximation) or per card approximation to the view port
                    fullLazyBatch: TRC.util.isTrue(fullLazyBatch),
                    dispatchEnabled: TRC.util.isTrue(dispatchEnabled)
                };
            }

            static getDispatchPlacements(dispatchPlacements) {
                if (Array.isArray(dispatchPlacements)) {
                    return dispatchPlacements;
                } if (typeof dispatchPlacements === 'string') {
                    return __trcUnJSONify(dispatchPlacements);
                }
                return [];
            }

            /**
            * return true if the placement response has video configured
            * @param placementData
            * @returns {boolean}
            */
            static hasVideo(placementData) {
                if (placementData.trcResponse && placementData.trcResponse.vtag) {
                    return true;
                }
            }


            /**
            *
            * @param placementData
            * @param batchIndex
            * @returns {boolean}
            */
            isLazyBatch(batchIndex, placementData) {
                return !!(this.getPlacementConfig('maxBatch', placementData) >= batchIndex || placementData.isCache);
            }

            /**
            *  update card counters -
            * @param response
            */
            addResponse(response) {
                const placements = response.trc.vl;
                this.onePlacementRendered = false;
                if (response.trc.f) {
                    this.updateCardsCounters(placements);
                } else {
                    this.onePlacementRendered = true;
                }
            }

            /**
            * update the number of cards per feed - standard widgets will updated as a placement with one card
            * @param placements
            */
            updateCardsCounters(placements) {
                placements.forEach(placement => {
                    if (placement.fb) {
                        const {uuip: unifiedPlacement, fb: batchIndex} = placement;
                        this.cardsCounters[unifiedPlacement] = this.cardsCounters[unifiedPlacement] || {};
                        this.cardsCounters[unifiedPlacement][batchIndex] = this.cardsCounters[unifiedPlacement][batchIndex]
                            ? ++this.cardsCounters[unifiedPlacement][batchIndex] : 1;
                    }
                });
            }

            /**
            * render placement
            * @param placementData
            */
            placementRender(placementData) {
                if (typeof placementData.container !== 'undefined' || placementData.addWidget) {
                    // initiate RBox drawing
                    if (this.trcManager.yieldingEnabled) {
                        this.yieldRenderer(placementData);
                    } else if (this.isLazyRenderEnabled && this.isLazyPlacement(placementData)) {
                        this.lazyRenderer(placementData);
                    } else {
                        this.standardRenderer(placementData);
                    }
                }
            }

            /**
            * calculates & returns batch threshold for next batch call
            * @param scrollEngine
            * @param threshold
            * @returns {number}
            */
            getBatchThreshold(scrollEngine, threshold) {
                const {uiBatchNumberCounter, parentPlacementData} = scrollEngine;
                if (this.isValidLazyPlacement(parentPlacementData) && this.isLazyBatch(uiBatchNumberCounter, parentPlacementData)) {
                    // we set a threshold for each card - we divide the standard threshold by the number of cards to render and get the card threshold.
                    const cardsInBatch = this.getNumberOfCards(parentPlacementData.unifiedPlacement, uiBatchNumberCounter);
                    const minCards = this.getPlacementConfig('minCards', parentPlacementData);
                    return (cardsInBatch && cardsInBatch > minCards)
                        ? Math.floor((threshold * minCards) / cardsInBatch) : threshold;
                }
                return threshold;
            }

            /**
            * returns number of in each feed batch
            * @param unifiedPlacement
            * @param batchIndex
            * @returns {number}
            */
            getNumberOfCards(unifiedPlacement, batchIndex) {
                try {
                    return this.cardsCounters[unifiedPlacement][batchIndex];
                } catch (e) {
                    __trcError(`failed to get number of cards for lazy rendering :- ${unifiedPlacement} | ${batchIndex}`);
                    return 0;
                }
            }

            /**
            * return ture if the placement is valid for lazy rendering
            * @param placementData
            * @returns {boolean}
            */
            isValidLazyPlacement(placementData) {
                const {unifiedPlacement, placement} = placementData;
                const placementName = unifiedPlacement || placement;

                // verify if there is an explicitly enable/disable of the placement in FPP
                if (RenderControl.hasVideo(placementData)) {
                    return false;
                }

                if (placementData.isStories) {
                    const storiesInstance = this.trcManager.storiesManager.stories[placementData.parentStories.unifiedPlacementName];
                    if (storiesInstance.isFirstCardRendered) {
                        storiesInstance.isFirstCardRendered = true;
                        return false;
                    }
                }

                if (placementData.isHp4u) {
                    return false;
                }

                if (placementData.isDynamicLinks) {
                    return false;
                }

                if (this.isFppEnabled(placementName)) {
                    return true;
                }
                if (this.isFppDisabled(placementName) || !this.lazyConfig.enable) {
                    return false;
                }

                const isExcludePlacement = this.lazyConfig.excludePlacements.indexOf(placementName) > -1;
                const isNextUp = !!(placementData.trcResponse && placementData.trcResponse.nup);
                if (isNextUp) {
                    return false;
                }
                if (isExcludePlacement) {
                    return false;
                }
                return true;
            }

            /**
             * checks if the placement is enbaled via FPP config
             * @param placement
             * @returns {boolean}
             */
            isFppEnabled(placement) {
                const fppConfig = this.placementsConfigs[placement];
                return !!(fppConfig && TRC.util.isTrue(fppConfig.enable));
            }

            /**
             * checks if the placement is enbaled via FPP config
             * @param placement
             * @returns {boolean}
             */
            isFppDisabled(placement) {
                const fppConfig = this.placementsConfigs[placement];
                return !!(fppConfig && TRC.util.isFalse(fppConfig.enable));
            }

            /**
            * yield renderer flow
             * @param placementData
            */
            yieldRenderer(placementData) {
                this.trcManager.loadRBoxDrawQueue(placementData);
            }

            /**
            * standard rendering
            * @param placementData
            */
            standardRenderer(placementData) {
                this.onePlacementRendered = false;
                this.trcManager.internalDrawRBox(placementData);
            }

            /**
            * returns the root scrollable element set by the feed's infiniteScrollEngine
            * @param placementData
            * @returns {null|Element}
            */
            static getRootElement(placementData) {
                // some times the 'observerScrollElement' is set to the global 'window' (which is not an observerbale element) so we will fallback to null
                return placementData.parentFeed && placementData.parentFeed.infiniteScrollEngine.observerScrollElement.children
                    ? placementData.parentFeed.infiniteScrollEngine.observerScrollElement : null; // null = the view port
            }

            /**
            * lazy rendering
            * @param placementData
            */
            lazyRenderer(placementData) {
                const minCards = this.getPlacementConfig('minCards', placementData);
                const {unifiedPlacement} = placementData;

                if (typeof unifiedPlacement === 'undefined' || placementData.modeGroupOrder > minCards) {
                    const fullLazyBatch = this.getPlacementConfig('fullLazyBatch', placementData);
                    const {dispatchPlacements} = this.lazyConfig;

                    const dispatchEnabled = this.getPlacementConfig('dispatchEnabled', placementData) || dispatchPlacements.indexOf(unifiedPlacement) > -1;
                    if (dispatchEnabled) {
                        this.dispatchPlacements(placementData);
                    } else if (unifiedPlacement && fullLazyBatch && this.lazyBatches[unifiedPlacement]) {
                        this.pushLazyBatchPlacement(placementData); // other(not the first lazy render) placement in full lazy batch goes through here
                    } else {
                        this.setObserverParams(placementData); // first lazy placement in full lazy batch goes through here
                    }
                    if (this.trcManager.global['send-eager-available-for-lazy-placements']) {
                        TRC.availableEventCoordinator.get(this.trcManager).sendAvailableEventsForPlacement(placementData);
                    }
                } else {
                    this.standardRenderer(placementData);
                }
            }

            /**
            * this method force rendering placement by dispatch for using it just add dispatch with event name "render-placement"
            * and set in the configuration for the lazy rendering : dispatchPlacements: [placementName]
            * @param placementData
            *
            */
            dispatchPlacements(placementData) {
                this.pushLazyBatchPlacement(placementData);
                if (!this.listener) {
                    this.listener = TRC.listen('render-placement', data => {
                        this.lazyRenderBatch(data.placement, data.cb);
                    });
                }
            }

            /**
            * sets the IntersectionObserver on the fake container and the card container
            * @param placementData
            *
            */
            setObserverParams(placementData) {
                const obsConfig = this.getObserverConfig(placementData);
                const observer = TRC.IntersectionObserver
                    ? new TRC.IntersectionObserver(obsConfig.onEnter, obsConfig.observerParams)
                    : new IntersectionObserver(obsConfig.onEnter, obsConfig.observerParams);
                observer.observe(placementData.container);
            }

            /**
            * return true if the placement should be rendered in a lazy manner
            * @param placementData
            * @returns {boolean}
            */
            isLazyPlacement(placementData) {
                if (!this.onRenderApiKill() && !this.onePlacementRendered && placementData.container && this.isValidLazyPlacement(placementData)) {
                    if (placementData.trcResponse.fb) {
                        return this.isLazyBatch(placementData.trcResponse.fb, placementData);
                    }
                    return true;
                }
                return false;
            }

            /**
             * checks if publihser listens to "render" events
             * @returns {boolean}
             */
            onRenderApiKill() {
                return !!(this.lazyConfig.raKill && TRC.hasEvent(RENDER_API_EVENT));
            }

            /**
            * set and updates the lazy batch cards - the will be render at once when first lazy card in in thrdshold
            * @param placementData
            * @returns {string}
            */
            pushLazyBatchPlacement(placementData) {
                const lazyBatch = this.lazyBatches[placementData.unifiedPlacement];
                if (lazyBatch) {
                    this.lazyBatches[placementData.unifiedPlacement].push(placementData);
                } else {
                    this.lazyBatches[placementData.unifiedPlacement] = [placementData];
                }
            }

            /**
             * render all lazy cards in batch
             * @param unifiedPlacement
             * @param dispatchCallback
             */
            lazyRenderBatch(unifiedPlacement, dispatchCallback) {
                const lazyBatch = this.lazyBatches[unifiedPlacement];
                if (lazyBatch) {
                    lazyBatch.forEach(placementData => this.standardRenderer(placementData));
                    delete this.lazyBatches[unifiedPlacement];
                }

                dispatchCallback && dispatchCallback();
            }

            /**
            * return observable config object
            * @param placementData
            * @returns {Object}
            */
            getObserverConfig(placementData) {
                let renderFunc;
                const observerParams = __trcCopyProps(ObserverParams, {});
                observerParams.root = RenderControl.getRootElement(placementData);
                observerParams.rootMargin = this.getPlacementConfig('rootMargin', placementData);

                if (this.getPlacementConfig('fullLazyBatch', placementData)) {
                    this.pushLazyBatchPlacement(placementData);
                    renderFunc = this.lazyRenderBatch.trcBind(this, placementData.unifiedPlacement);
                } else {
                    renderFunc = this.trcManager.internalDrawRBox.trcBind(this.trcManager, placementData);
                }

                return {
                    targetElement: placementData.container,
                    observerParams,
                    onEnter: (entries, obsObject) => {
                        if (entries[0].isIntersecting) {
                            renderFunc();
                            obsObject.unobserve(placementData.container);
                        }
                    }
                };
            }
        }
        TRC.RenderControl = RenderControl;
    })();

    // Real Time User Sync
    (() => {

        const RTUS_ID_STORAGE_KEY = 'tbl_rtus_id',
            CMP_CCPA_API_VERSION = 1,
            CMP_GDPR_API_VERSION = 2,
            TABOOLA_VENDOR_ID = 42,
            CRITEO_VENDOR_ID = 91,
            RTUS_MAIN_EVENT_NAME_FOR_MONITORING = 'RealTimeUserSyncMain',
            RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING = 'RealTimeUserSyncCallback';

        class Rtus {

            constructor(trc) {
                this.trc = trc;
                this.localStorage = trc.pageManager.getLocalStorageImplementation();
            }

            applyRtus() {
                if (this.trc.ccpaPs) { // Check if CCPA applies using push message from publisher
                    this._log('ccpaPushTriggerRtus');
                    this._validateCcpaConsentAndCallRtusWithCcpaParams(this.trc.ccpaPs);
                } else if (typeof window.__uspapi === 'function') { // Check if CCPA applies using API
                    this._applyRtusWithCcpa();
                } else if (typeof window.__tcfapi === 'function') { // Check if GDPR applies using CMP V2
                    this._applyRtusWithGdpr();
                } else if (typeof window.__cmp === 'function') { // Check if GDPR applies using CMP V1
                    // CMP V1 is not supported
                    this._log('gdprV1');
                } else {
                    this._log('default');
                    this._triggerRtusCall('');
                }
            }

            _applyRtusWithCcpa() {
                window.__uspapi('getUSPData', CMP_CCPA_API_VERSION, (uspData, success) => {
                    try {
                        if (success) {
                            this._log('ccpaApiTriggerRtus');
                            this._validateCcpaConsentAndCallRtusWithCcpaParams(uspData.uspString);
                        } else {
                            this._log('ccpaApiFail');
                        }
                    } catch (e) {
                        this._log('ccpaApiError');
                    }
                });
            }

            _validateCcpaConsentAndCallRtusWithCcpaParams(privacyString) {
                if (privacyString.charAt(2) === 'Y') { // If the user opted-out of the sale. More data can be found here: https://github.com/InteractiveAdvertisingBureau/USPrivacy/blob/master/CCPA/US%20Privacy%20String.md
                    return;
                }
                const consentUrlParams = `&us_privacy=${privacyString}&gdpr=0&gdpr_consent=&gdpr_pd=`;
                this._triggerRtusCall(consentUrlParams);
            }

            _applyRtusWithGdpr() {
                window.__tcfapi('getTCData', CMP_GDPR_API_VERSION, (tcData, success) => { // tcData structure can be found here: https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20CMP%20API%20v2.md#tcdata
                    try {
                        if (success) {
                            if (TRC.Rtus.shouldCallRtusWithGdprParams(tcData)) {
                                this._log('gdprV2triggerRtus');
                                this._callRtusWithGdprParams(tcData);
                            } else {
                                this._log('gdprV2notTriggerRtus');
                            }
                        } else {
                            this._log('gdprV2fail');
                        }
                    } catch (e) {
                        this._log('gdprV2error');
                    }
                }, [TABOOLA_VENDOR_ID, CRITEO_VENDOR_ID]);
            }

            static shouldCallRtusWithGdprParams(tcData) {
                return TRC.Rtus.isGdprNotApplies(tcData) || TRC.Rtus.hasConsent(tcData);
            }

            static isGdprNotApplies(tcData) {
                return !tcData.gdprApplies;
            }

            static hasConsent(tcData) {
                const {consents} = tcData.vendor || {};
                return consents[TABOOLA_VENDOR_ID] && consents[CRITEO_VENDOR_ID];
            }

            _callRtusWithGdprParams(tcData) {
                const gdprUrlParams = `&us_privacy=&gdpr=${tcData.gdprApplies ? 1 : 0}&gdpr_consent=${tcData.tcString}&gdpr_pd=0`;
                this._triggerRtusCall(gdprUrlParams);
            }

            _triggerRtusCall(consentUrlParams) {
                const handlerName = 'getRTUS';
                const url = `//gum.criteo.com/sync?c=72&r=2&j=TRC.${handlerName}${consentUrlParams}`;
                this._setRtusCallback(handlerName); // This callback will be triggered upon RTUS response
                (this.trc.performance && this.trc.performance.mark(`${RTUS_MAIN_EVENT_NAME_FOR_MONITORING}Start`, null, RTUS_MAIN_EVENT_NAME_FOR_MONITORING, 0, RTUS_MAIN_EVENT_NAME_FOR_MONITORING, this.trc.PerfEvenType.START));
                (this.trc.performance && this.trc.performance.mark(`${RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING}Start`, null, RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING, 0, RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING, this.trc.PerfEvenType.START));
                try {
                    this.trc.net.loadScript(url, 'js', null, null, true);
                    this.trc.pConsole('page', 'info', 'injected RTUS service');
                } catch (e) {
                    __trcWarn('Error during RTUS loading asset file: ', e);
                }
                try {
                    this.trc.rtbRealTimeUserId = this.localStorage.getValue(RTUS_ID_STORAGE_KEY);
                } catch (e) {
                    __trcWarn('Error during fetching RTUI from local storage: ', e);
                }
            }

            _setRtusCallback(handlerName) {
                this.trc[handlerName] = rtusResponse => {
                    try {
                        (this.trc.performance && this.trc.performance.mark(`${RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING}Stop`, null, RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING, 0, RTUS_CALLBACK_EVENT_NAME_FOR_MONITORING, this.trc.PerfEvenType.STOP));
                        const {status, userid} = rtusResponse || {};
                        if (status === 'OK') {
                            // Store rtus response if the user is known
                            this.trc.rtbRealTimeUserId = userid;
                            this.localStorage.setValue(RTUS_ID_STORAGE_KEY, userid);
                        } else {
                            // If the user is unknown or opt-out, the previously stored value is invalid
                            this.trc.rtbRealTimeUserId = null;
                            this.localStorage.removeKey(RTUS_ID_STORAGE_KEY);
                        }
                    } catch (e) {
                        __trcWarn('Error during RTUS callback: ', e);
                    }
                };
            }

            _log(positionVal) {
                if (TRCImpl && TRCImpl.global && !TRCImpl.global['allow-rtus-usage-logging']) {
                    return;
                }
                this.trc.RBoxUsage.logUsage('rtus', {file: 'rtus.js', method: 'injectRtus', position: positionVal});
            }
        }

        TRC.Rtus = Rtus;
    })();

    (() => {
        TRC.ScriptRenderer = {
            render(scriptData, placementData) {
                if (!scriptData || !scriptData.js) {
                    __trcError('could not find script to render');
                    return;
                }
                scriptData.normalizedTag = TRC.text.htmlUnescape(scriptData.js);
                this.renderInIframe(this.createIframe(placementData.container), scriptData);
            },
            
            createIframe(container) {
                if (!container) {
                    __trcError('could not find container to create Iframe within');
                    return;
                }
                const frame = document.createElement('iframe');
                frame.style.border = frame.frameBorder = frame.border = '0';
                frame.style.display = 'block';
                frame.scrolling = 'no';
                container.appendChild(frame);
                return frame;
            },
            
            renderInIframe(iframe, scriptData) {
                if (!iframe) {
                    __trcError('could not find iframe to render within');
                    return;
                }
                let frameDoc = iframe.contentWindow || iframe.contentDocument;

                if (frameDoc.document) {
                    frameDoc = frameDoc.document;
                }

                this.setOuterIframeStyle(iframe, scriptData);
                this.runTagInIframe(frameDoc, scriptData.normalizedTag);
                this.resetStyleInIframe(frameDoc);
            },

            setOuterIframeStyle(frame, scriptData) {
                frame.style.width = scriptData.w || '0px';
                frame.style.height = scriptData.h || '0px';
            },

            runTagInIframe(frameDoc, normalizedTag) {
                if (typeof normalizedTag === 'undefined' || normalizedTag === null) {
                    __trcError('could not find normalizedTag to render');
                    return;
                }

                frameDoc.open();
                frameDoc.write(normalizedTag);
                frameDoc.close();
            },

            resetStyleInIframe(frameDoc) {
                const css = frameDoc.createElement('style'),
                    styles = 'body { margin: 0px }';
                css.type = 'text/css';

                if (css.styleSheet) {
                    css.styleSheet.cssText = styles;
                } else {
                    css.appendChild(frameDoc.createTextNode(styles));
                }
                frameDoc.getElementsByTagName('head')[0].appendChild(css);
            }
        };
    })();

    (function (win, doc) {
        TRC.SpotlightLoader = {
            load: function(response) {
                if (!this.shouldLoad(response)) {
                    return;
                }
                if (this.loadedScript) {
                    TRC.dispatch('trc_afterRboxDraw');
                } else {
                    __trcDebug("Detected Spotlight Administrator(" + response.trc['pi'] + ")");
                    TRC.backstageDomainPrefix = response.trc['bdp'];
                    TRC.backstageDomainSuffix = response.trc['bds'];
                    this.loadedScript = TRC.URL.prototype.switchProtocol.call(TRC.getBackstageUrl() +  "resources/js/1.1.0/spotlight.js", TRC.PROTOCOL);
                    TRC.Manager.prototype.loadExternal(this.loadedScript, 'js');
                }
            },
            /**
             * Check if Spotlight should be loaded - conditions are:
             * 1. browser supports document.querySelectorAll (IE9 and above)
             * 2. Not a touch device
             * 3. TRC response allowed Spotlight
             *
             * @param response
             * @returns {*|boolean}
             */
            shouldLoad: function(response) {
                return !!doc.querySelectorAll && !TRC.Device.isTouchDevice &&
                    !!response && !!response.trc && '1' == response.trc['sl'];
            },

            registerOnMainContainer: function(publisherContainer, response) {
                if (publisherContainer && this.shouldLoad(response)) {
                    publisherContainer.setAttribute('data-spotlight-publisher-id', response.trc['pi']);
                }
            }
        };
    }(window, document));

    (() => {
        class StoriesBase {
            constructor(uniqueId, name) {
                this._createInstanceList(uniqueId, name);
            }

            _createInstanceList(uniqueId, name) {
                if (!TRC[name]) {
                    __trcError(`${name} does not exist under TRC`, null);
                }
                if (TRC[name].instances) {
                    if (TRC[name].instances[uniqueId]) {
                        throw new Error('instance already exists under this uniqueid');
                    }
                    TRC[name].instances[uniqueId] = this;
                    return;
                }

                const getInstance = function (uniqueId) {
                    if (!TRC[this].instances) {
                        return null;
                    }
                    return TRC[this].instances[uniqueId];
                };
                TRC[name].instances = {};
                TRC[name].getInstance = getInstance.bind(name);
                TRC[name].instances[uniqueId] = this;
            }
        }

        TRC.StoriesBase = StoriesBase;
    })();

    TRC.listen('stories-initiation', (() => {
        const CLASSES = {
            CAROUSEL_ANIMATION: 'bouncing-animation',
            CAROUSEL_CONTAINER: 'tbl-stories-carousel-container',
            CAROUSEL_TOPICS_WRAPPER: 'tbl-stories-topics-wrapper',
            CAROUSEL_TOPIC_CONTAINER: 'tbl-stories-topics-container',
            CAROUSEL_TOPIC_IMAGE_WRAPPER: 'tbl-stories-topic-image-wrapper',
            CAROUSEL_TOPIC_TITLE: 'tbl-stories-topic-title',
            CAROUSEL_TOPIC_IMAGE: 'tbl-stories-topic-image',
            CAROUSEL_TOPIC_CLICK_LOADING: 'tbl-stories-topic-loading',
            CAROUSEL_ONBOARDING: 'tbl-stories-onboarding',
            CAROUSEL_ONBOARDING_STATIC: 'tbl-stories-onboarding-static',
            CAROUSEL_READY: 'tbl-stories-carousel-ready'
        };

        const VIDEO_EVENTS = {
            CATEGORIES_DISPLAYED: 'categoriesDisplayed'
        };

        const DEFAULT_TOPIC_BORDER = {
            cs: '#4472c4',
            ce: '#00b5d9'
        };

        const EVENTS = {
            TOPIC_CLICKED: 'topic-click'
        };

        const DEFAULTS = {
            LONG_VISIBLE_TIMEOUT: 3000,
            ON_BOARDING_TEXT: 'New! Click to view visual Stories',
            ON_BOARDING_COLOR: '#2676F7',
            ON_BOARDING_FIRST_WORDS: 1
        };

        class StoriesCarousel extends TRC.StoriesBase {
            constructor(unifiedPlacementName, container) {
                super(unifiedPlacementName, 'StoriesCarousel');
                try {
                    this.unifiedPlacementName = unifiedPlacementName;
                    this.eventsManager = TRC.StoriesEventsManager.getInstance(unifiedPlacementName);
                    this.options = this.getCarouselOptions();

                    this.injectCarouselStyle();
                    this.createCarouselLayout();
                    this.setStickyStories(container);
                    this.eventsManager.observeCarousel(this);
                } catch (ex) {
                    this.eventsManager.onError(`StoriesCarousel instance`, ex);
                }
            }

            injectCarouselStyle() {
                /* eslint-disable no-unused-vars */
                const {onBoardingColor, extendedStyle} = this.options;
                /* eslint-enable */
                TRC.dom.injectStyle(`.tbl-stories-carousel-container { box-sizing: initial; float: initial; padding: initial; width: initial; vertical-align: initial; border: initial; }.tbl-stories-carousel-container .tbl-stories-topic-image { top: 0; left: 0; bottom: 0; right: 0; }.bouncing-animation > li { transform: translateY(-100%); -webkit-animation: bouncingDown 1s ease-in-out 1s forwards; -moz-animation: bouncingDown 1s ease-in-out 1s forwards; -ms-animation: bouncingDown 1s ease-in-out 1s forwards; -o-animation: bouncingDown 1s ease-in-out 1s forwards; animation: bouncingDown 1s ease-in-out 1s forwards; }.bouncing-animation > li:nth-child(1) { -webkit-animation: bouncingDown 1s ease-in-out 0.1s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.1s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.1s forwards; -o-animation: bouncingDown 1s ease-in-out 0.1s forwards; animation: bouncingDown 1s ease-in-out 0.1s forwards; }.bouncing-animation > li:nth-child(2) { -webkit-animation: bouncingDown 1s ease-in-out 0.2s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.2s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.2s forwards; -o-animation: bouncingDown 1s ease-in-out 0.2s forwards; animation: bouncingDown 1s ease-in-out 0.2s forwards; }.bouncing-animation > li:nth-child(3) { -webkit-animation: bouncingDown 1s ease-in-out 0.3s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.3s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.3s forwards; -o-animation: bouncingDown 1s ease-in-out 0.3s forwards; animation: bouncingDown 1s ease-in-out 0.3s forwards; }.bouncing-animation > li:nth-child(4) { -webkit-animation: bouncingDown 1s ease-in-out 0.4s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.4s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.4s forwards; -o-animation: bouncingDown 1s ease-in-out 0.4s forwards; animation: bouncingDown 1s ease-in-out 0.4s forwards; }.bouncing-animation > li:nth-child(5) { -webkit-animation: bouncingDown 1s ease-in-out 0.5s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.5s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.5s forwards; -o-animation: bouncingDown 1s ease-in-out 0.5s forwards; animation: bouncingDown 1s ease-in-out 0.5s forwards; }.bouncing-animation > li:nth-child(6) { -webkit-animation: bouncingDown 1s ease-in-out 0.6s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.6s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.6s forwards; -o-animation: bouncingDown 1s ease-in-out 0.6s forwards; animation: bouncingDown 1s ease-in-out 0.6s forwards; }.bouncing-animation > li:nth-child(7) { -webkit-animation: bouncingDown 1s ease-in-out 0.7s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.7s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.7s forwards; -o-animation: bouncingDown 1s ease-in-out 0.7s forwards; animation: bouncingDown 1s ease-in-out 0.7s forwards; }.bouncing-animation > li:nth-child(8) { -webkit-animation: bouncingDown 1s ease-in-out 0.8s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.8s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.8s forwards; -o-animation: bouncingDown 1s ease-in-out 0.8s forwards; animation: bouncingDown 1s ease-in-out 0.8s forwards; }.bouncing-animation > li:nth-child(9) { -webkit-animation: bouncingDown 1s ease-in-out 0.9s forwards; -moz-animation: bouncingDown 1s ease-in-out 0.9s forwards; -ms-animation: bouncingDown 1s ease-in-out 0.9s forwards; -o-animation: bouncingDown 1s ease-in-out 0.9s forwards; animation: bouncingDown 1s ease-in-out 0.9s forwards; }.bouncing-animation > li:nth-child(10) { -webkit-animation: bouncingDown 1s ease-in-out 1s forwards; -moz-animation: bouncingDown 1s ease-in-out 1s forwards; -ms-animation: bouncingDown 1s ease-in-out 1s forwards; -o-animation: bouncingDown 1s ease-in-out 1s forwards; animation: bouncingDown 1s ease-in-out 1s forwards; }.tbl-stories-carousel-container { position: relative; overflow: hidden; } .tbl-stories-carousel-container .tbl-stories-topics-wrapper { overflow-y: hidden; overflow-x: scroll; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; -webkit-box-pack: justify; -webkit-justify-content: space-between; -ms-flex-pack: justify; justify-content: space-between; margin: 0; padding: 0 5px; z-index: 0; } .tbl-stories-carousel-container .tbl-stories-topics-wrapper::-webkit-scrollbar { display: none; } .tbl-stories-carousel-container .tbl-stories-topics-container { list-style: none; text-align: center; -webkit-flex-shrink: 0; -ms-flex-negative: 0; flex-shrink: 0; width: 72px; position: relative; } .tbl-stories-carousel-container .tbl-stories-topic-image-wrapper { height: 64px; width: 64px; position: relative; left: 0; top: 0; border-radius: 32px; margin: 0 4px; z-index: 0; } .tbl-stories-carousel-container .tbl-stories-topic-image-wrapper svg { vertical-align: inherit; fill: transparent; } .tbl-stories-carousel-container .tbl-stories-topic-title { position: relative; bottom: 0; left: 0; width: 100%; font-size: 12px; font-weight: normal; font-style: normal; display: block; padding: 4px 0 0; word-break: break-word; word-wrap: break-word; } .tbl-stories-carousel-container .tbl-stories-topic-loading svg { animation: tbl-stories-rotate 2s infinite linear; -webkit-animation: tbl-stories-rotate 2s infinite linear; } .tbl-stories-carousel-container .tbl-stories-topic-loading .tbl-stories-topic-image { filter: grayscale(100%); } .tbl-stories-carousel-container .tbl-stories-onboarding { position: absolute; opacity: 0; background-color: ${onBoardingColor}; color: #fcfcfc; padding: 0 15px; z-index: 1; right: 0; -webkit-transform: translateX(-100vh); -ms-transform: translateX(-100vh); transform: translateX(-100vh); border-radius: 16px 0 0 16px; font-size: 12px; height: 30px; line-height: 30px; top: 0; } .tbl-stories-carousel-container .tbl-stories-onboarding-static { position: relative; font-size: 14px; color: initial; padding: 5px 15px; z-index: 1; line-height: initial; overflow-y: hidden; } .tbl-stories-carousel-container .tbl-stories-topic-image { width: 60px; height: 60px; border: 2px solid #fcfcfc; position: absolute; border-radius: 50%; z-index: 1; opacity: 0; transition: opacity 1s ease-in, filter 1s ease-in; box-sizing: border-box; margin: auto; overflow: auto; } .tbl-stories-carousel-container.tbl-stories-carousel-ready .tbl-stories-topic-image { opacity: 1; } .tbl-stories-carousel-container.tbl-stories-carousel-ready .tbl-stories-onboarding { -webkit-animation: tbl-stories-onboarding-fade 6s linear; animation: tbl-stories-onboarding-fade 6s linear; -webkit-animation-delay: 2s; animation-delay: 2s; }@-webkit-keyframes tbl-stories-rotate { from { -webkit-transform: rotate(-360deg); transform: rotate(-360deg); } to { -webkit-transform: rotate(360deg); transform: rotate(360deg); } }@keyframes tbl-stories-rotate { from { -webkit-transform: rotate(-360deg); transform: rotate(-360deg); } to { -webkit-transform: rotate(360deg); transform: rotate(360deg); } }@-webkit-keyframes tbl-stories-onboarding-fade { 0%, 100% { -webkit-transform: translate(0, -10px); transform: translate(0, -10px); opacity: 0; } 10%, 90% { -webkit-transform: translate(0, -10px); transform: translate(0, -10px); opacity: 0.8; } }@keyframes tbl-stories-onboarding-fade { 0%, 100% { -webkit-transform: translate(0, -10px); transform: translate(0, -10px); opacity: 0; } 10%, 90% { -webkit-transform: translate(0, -10px); transform: translate(0, -10px); opacity: 0.8; } }@-webkit-keyframes bouncingDown { 0% { -webkit-transform: translateY(-100%); } 50% { -webkit-transform: translateY(10px); } 100% { -webkit-transform: translateY(0); } }@keyframes bouncingDown { 0% { transform: translateY(-100%); } 50% { transform: translateY(10px); } 100% { transform: translateY(0); } }`);
                if (extendedStyle) {
                    TRC.dom.injectStyle(extendedStyle);
                }
            }

            carouselReady() {
                requestAnimationFrame(() => {
                    TRC.dom.addClass(this.carouselContainer, CLASSES.CAROUSEL_READY);
                    TRC.dom.addClass(this.topicsList, CLASSES.CAROUSEL_ANIMATION);
                });
            }

            getCarouselOptions() {
                const {options} = this.eventsManager;
                let {cc: carouselConfig} = options.storiesUi;

                if (!carouselConfig) {
                    carouselConfig = {};
                }

                // if you think about refactoring this to => {ob: onboardingConfig = {}}
                // than know that it's not supported at the moment this row as been written
                let {ob: onboardingConfig} = carouselConfig;

                if (!onboardingConfig) {
                    onboardingConfig = {};
                }

                return {
                    extendedStyle: carouselConfig.style || '',
                    topicBorderColor: carouselConfig.tc || DEFAULT_TOPIC_BORDER,
                    onBoardingEnableTooltip: !!onboardingConfig.obet || false,
                    onBoardingColor: onboardingConfig.obc || DEFAULTS.ON_BOARDING_COLOR,
                    onBoardingText: onboardingConfig.obtxt || DEFAULTS.ON_BOARDING_TEXT,
                    onBoardingFirstWordsNum: onboardingConfig.obfwn ? parseInt(onboardingConfig.obfwn, 10) : DEFAULTS.ON_BOARDING_FIRST_WORDS,
                    useCloudinaryCroppingForThumbs: carouselConfig.clcrt !== undefined ? TRC.util.isTrue(carouselConfig.clcrt) : true,
                    visibleDuration: carouselConfig.vsd ? parseInt(carouselConfig.vsd, 10) : DEFAULTS.LONG_VISIBLE_TIMEOUT,
                    stickyStories: carouselConfig.stcy,
                    randomTopicImage: carouselConfig.rndTpcImage || ''
                };
            }

            createCarouselLayout() {
                this.carouselContainer = TRC.dom.createHTMLElement('nav', {
                    className: CLASSES.CAROUSEL_CONTAINER
                });

                this.topicsList = TRC.dom.createHTMLElement('ul', {
                    className: CLASSES.CAROUSEL_TOPICS_WRAPPER
                });

                this.carouselContainer.insertAdjacentHTML('afterbegin', this.getOnBoarding());
                this.carouselContainer.appendChild(this.topicsList);
            }

            addTopic(topic) {
                this.topicsList.insertAdjacentElement('beforeend', this.getTopicElement(topic));
            }

            getTopicElement({
                id, imageUrl, title, slotPosition
            }) {
                const topic = TRC.dom.createHTMLElement('li', {
                    className: CLASSES.CAROUSEL_TOPIC_CONTAINER,
                    topicName: title,
                    topicPosition: slotPosition,
                    topicId: id
                });

                const imageLayout = `<div class="${CLASSES.CAROUSEL_TOPIC_IMAGE_WRAPPER}">
                            <img alt="${id}" class="${CLASSES.CAROUSEL_TOPIC_IMAGE}" src="${imageUrl}" onerror="this.style.display='none'">
                            ${this.getBorderTopic()}
                           </div>`;

                const titleLayout = `<label class="${CLASSES.CAROUSEL_TOPIC_TITLE}">${title}</label>`;

                topic.insertAdjacentHTML('afterbegin', `${imageLayout}${titleLayout}`);
                TRC.CustomModulesManager.runHook('stories-topic-rendered', null, this, id, topic, title);
                TRC.dom.on(topic, 'click', this.carouselTopicClickHandler.trcBind(this, id));
                this.eventsManager.observeCarouselTopic(topic);
                return topic;
            }

            carouselTopicClickHandler(topicId, e) {
                const storiesContext = TRC.Stories.getInstance(this.unifiedPlacementName);
                const topic = storiesContext.topics[topicId];
                const {videoTag} = storiesContext.options;

                StoriesCarousel.clickOnCarouselTopicLoadingIndication(e.currentTarget);

                if (TRC.StoriesVerticalUi) {
                    storiesContext.renderVerticalUiPlacements(topic);
                } else {
                    TRC.listen('vertical-ui-loaded', storiesContext.renderVerticalUiPlacements.trcBind(storiesContext, topic));
                }
                const topicName = topic.title;
                const topicPosition = topic.slotPosition;
                this.eventsManager.sendEvent(EVENTS.TOPIC_CLICKED, {
                    ab: [topicName, topicPosition],
                    mxp: {topicName, topicPosition}
                });

                // creates video html tags with content
                if (videoTag && TRC.StoriesVideoManager) {
                    TRC.dispatch(VIDEO_EVENTS.CATEGORIES_DISPLAYED);
                }
            }

            /**
             * Triggered by Mobile Loader upon sdk click on Topic
             * @param topicId
             */
            carouselSDKTopicClickHandler(topicId) {
                const storiesContext = TRC.Stories.getInstance(this.unifiedPlacementName);
                const topic = storiesContext.topics[topicId];
                if (TRC.StoriesVerticalUi) {
                    storiesContext.renderVerticalUiPlacements(topic, true);
                } else {
                    TRC.listen('vertical-ui-loaded', storiesContext.renderVerticalUiPlacements.trcBind(storiesContext, topic));
                }
            }

            getBorderTopic() {
                const {topicBorderColor} = this.options;
                return `<svg height="64px" width="64px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xml:space="preserve">  
                            <linearGradient id="topic-background-grad" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:${topicBorderColor.cs};stop-opacity:1"></stop>
                                <stop offset="100%" style="stop-color:${topicBorderColor.ce};stop-opacity:1"></stop>
                            </linearGradient>
                            <circle cx="50" cy="50" r="50" fill="url(#topic-background-grad)"></circle>
                        </svg>`;
            }

            getImageURL(itemsList) {
                const {randomTopicImage} = this.options;
                const itemIndex = TRC.util.isTrue(randomTopicImage) ? Math.floor(Math.random() * itemsList.length) : 0;
                return itemsList.length > 0 ? itemsList[itemIndex].thumbnail : '';

            }

            getTopicImage(categoryImage, itemsList) {
                const cropDetails = 'g_auto,c_thumb,w_128,h_128,fl_advanced_resize,e_sharpen,q_auto:best,f_auto';
                const {useCloudinaryCroppingForThumbs} = this.options;
                let imageUrl = this.getImageURL(itemsList);

                if (categoryImage) {
                    imageUrl = categoryImage;
                }

                return useCloudinaryCroppingForThumbs ? TRC.imageUtils.getImageUrlBasedOnCloudinaryApi(imageUrl, cropDetails) : imageUrl;
            }

            static clickOnCarouselTopicLoadingIndication(topicEl) {
                TRC.dom.addClass(topicEl, CLASSES.CAROUSEL_TOPIC_CLICK_LOADING);
                TRC.Timeout.set(() => {
                    TRC.dom.removeClass(topicEl, CLASSES.CAROUSEL_TOPIC_CLICK_LOADING);
                }, 2000);
            }

            getOnBoarding() {
                const {
                    onBoardingText,
                    onBoardingFirstWordsNum,
                    onBoardingColor,
                    onBoardingEnableTooltip
                } = this.options;

                if (onBoardingEnableTooltip) {
                    return `<div class="${CLASSES.CAROUSEL_ONBOARDING}">${onBoardingText}</div>`;
                }

                const [firstWords, restOfOnBoardingText] = StoriesCarousel.getOnBoardingSliced(onBoardingText, onBoardingFirstWordsNum);
                return `<div class="${CLASSES.CAROUSEL_ONBOARDING_STATIC}">
                    <span class="tbl-stories-onboarding-static-first-words" style="color: ${onBoardingColor}">${firstWords}</span> ${restOfOnBoardingText}</div>`;
            }

            static getOnBoardingSliced(onBoardingText, firstWordsNum) {
                firstWordsNum = firstWordsNum < 0 ? 0 : firstWordsNum;
                const words = onBoardingText.split(' ');
                return [words.slice(0, firstWordsNum).join(' '), words.slice(firstWordsNum, words.length).join(' ')];
            }

            setStickyStories(container) {
                this.stickyStories = null;
                if (this.options.stickyStories) {
                    this.stickyStories = new TRC.StoriesSticky(container, this.options.stickyStories, this.unifiedPlacementName);
                }
            }
        }

        TRC.StoriesCarousel = StoriesCarousel;
    }));

    TRC.listen('stories-initiation', (() => {
        const EVENTS = {
            VISIBLE: 'visible',
            LONG_VISIBLE: 'long-visible',
            TOPIC_VISIBLE: 'topic-visible'
        };

        class StoriesEventsManager extends TRC.StoriesBase {
            constructor(options, unifiedPlacementName) {
                super(unifiedPlacementName, 'StoriesEventsManager');
                this.options = options;
                this.unifiedPlacementName = unifiedPlacementName;
            }

            sendLifeCycleEvents(eventName) {
                try {
                    const {responseEnd} = window.performance.timing;
                    const now = Date.now();
                    const timeFromLoad = now - responseEnd;
                    this.sendEvent(eventName, {ab: [timeFromLoad], mxp: {timeFromLoad}});
                } catch (ex) {
                    this.onError('sendLifeCycleEvents', ex);
                }
            }

            sendDefaultEvent(eventName, eventData, extraData = []) {
                const {topicName, topicPosition, itemPosition} = eventData;
                const mixPanelData = {};
                extraData.forEach((eData, index) => {
                    mixPanelData[`extraData_${++index}`] = eData;
                });
                mixPanelData.topicName = topicName;
                mixPanelData.topicPosition = topicPosition;
                mixPanelData.itemPosition = itemPosition;

                const values = {
                    ab: [topicName, topicPosition, itemPosition, ...extraData],
                    mxp: mixPanelData
                };
                this.sendEvent(eventName, values);
            }

            sendEvent(eventName, {ab: abEventData, mxp: mixPanelData}) {
                const eventNameWithPrefix = `stories-${eventName}`;
                StoriesEventsManager.sendAbEvent(eventNameWithPrefix, abEventData.join('_'));
                this.sendMixpanelEvent(eventNameWithPrefix, mixPanelData);
            }

            sendMixpanelEvent(eventNameWithPrefix, mixPanelData) {
                if (this.options.enableMixpanel) {
                    if (TRC.Mixpanel.isMixPanelLoaded()) {
                        TRC.Mixpanel.sendMixpanelEvent(eventNameWithPrefix, mixPanelData);
                    } else {
                        TRC.listen('mixpanelScriptSucceeded', () => {
                            TRC.Mixpanel.sendMixpanelEvent(eventNameWithPrefix, mixPanelData);
                        });
                    }
                }
            }

            static sendAbEvent(eventName, value) {
                TRCImpl.sendAbTestEvent(eventName, value);
            }

            onError(text, ex, errorCb = __trcWarn) {
                let mixPanelData = {};
                if (ex) {
                    mixPanelData = {
                        errorMsg: `${text} - error: ${ex.message}`,
                        errorStack: ex.stack
                    };

                } else {
                    mixPanelData.errorMsg = text;
                }

                this.sendMixpanelEvent('stories-error', mixPanelData);
                errorCb(`stories ${mixPanelData.errorMsg}`, ex);
            }

            observeCarousel({carouselContainer, options}) {
                const observerId = TRC.intersections.observe({
                    targetElement: carouselContainer,
                    onEnter: () => {
                        this.onCarouselVisible(observerId, options.visibleDuration);
                    },
                    onExit: () => {
                        TRC.Timeout.clear(this.visibleTimeoutId);
                    },
                    threshold: 0.5
                });
            }

            onCarouselVisible(observerId, visibleDuration) {
                const {options} = TRC.Stories.getInstance(this.unifiedPlacementName);
                this.sendLifeCycleEvents(EVENTS.VISIBLE);
                this.visibleTimeoutId = TRC.Timeout.set(() => {
                    TRC.intersections.unobserve(observerId);
                    TRC.Timeout.clear(this.visibleTimeoutId);
                    this.sendLifeCycleEvents(EVENTS.LONG_VISIBLE);
                    TRC.CustomModulesManager.runHook('stories-long-visible', null, this, options.storiesUi);
                }, visibleDuration);
            }

            observeCarouselTopic(topicElem) {
                let observerId;
                const options = {
                    targetElement: topicElem,
                    onEnter: ({target}) => {
                        TRC.intersections.unobserve(observerId);
                        const {topicName, topicPosition} = target;
                        this.sendEvent(EVENTS.TOPIC_VISIBLE, {
                            ab: [topicName, topicPosition],
                            mxp: {topicName, topicPosition}
                        });
                    },
                    threshold: 0.5
                };
                observerId = TRC.intersections.observe(options);
            }
        }

        TRC.StoriesEventsManager = StoriesEventsManager;
    }));

    TRC.listen('stories-initiation', (() => {
        class StoriesHistoryController extends TRC.StoriesBase {
            constructor(namespace, unifiedPlacementName) {
                super(unifiedPlacementName, 'StoriesHistoryController');
                this._historyApi = TRC.historyApi;
                this._inactiveKey = `${namespace}-open`;
                this._activeKey = `${namespace}-close`;
                this._applyOpen = [];
                this._applyClose = [];
                this._currentArgs = [];
                this._reason = 'History controller init';
                this._setupEventListeners();
            }

            onOpen(callback) {
                this._applyOpen.push(callback);
            }

            onClose(callback) {
                this._applyClose.push(callback);
            }

            _setupEventListeners() {
                this._historyApi.onPopState(() => {
                    if (this.isInactive()) {
                        this._close();
                    } else if (this.isActive()) {
                        this._open();
                    }
                }, {
                    stateCheck: state => state[this._inactiveKey]
                });
                if (this.isActive()) {
                    this.close();
                }
            }

            isActive() {
                const state = this._historyApi.currentState();

                return state && state[this._activeKey];
            }

            isInactive() {
                const state = this._historyApi.currentState();

                return state && state[this._inactiveKey];
            }

            _open() {
                this._applyOpen.forEach(cb => cb(...this._currentArgs));
            }

            open(...args) {
                this._currentArgs = args;
                this._open();
                if (!this.isActive()) {
                    this._historyApi.appendState({[this._inactiveKey]: true});
                    this._historyApi.pushState({[this._activeKey]: true});
                }
            }

            _close() {
                const reason = this._reason || 'Browser back';
                delete this._reason;
                this._applyClose.forEach(cb => cb(reason));
            }

            close(reason) {
                this._reason = reason;
                this._historyApi.back();
            }
        }

        TRC.StoriesHistoryController = StoriesHistoryController;
    }));

    (() => {
        const mandatoryDependencies = {
            'stories-transition-manager': true,
            'stories-vertical-ui': true
        };

        const MIXPANEL_PROJECT_ID = '017c7c2cd4672abad2a2cf4d9d7fbb13';

        class StoriesManager {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.stories = {};
                this.configs = {};
                if (!TRC.Stories) {
                    TRC.dispatch('stories-initiation');
                }
            }

            static lazyLoadStoriesModules() {
                if (!TRC.StoriesVerticalUi) {
                    TRC.ModuleLoader.load('stories-vertical-ui', TRC.StoriesVerticalUi, (() => {
                        TRC.dispatch('vertical-ui-loaded');
                    }));
                }
            }

            lazyLoadFailure(event, placements) {
                if (mandatoryDependencies[event.moduleFile]) {
                    placements.forEach(placementName => this.stories[placementName].collapseContainer());
                    __trcWarn(`failed to load ${event.moduleFile}, stories collapsed`);
                }
            }

            createNewStories({s: storiesResponse, cga: clientGenericResponse}, storiesPlacementsAmount) {
                try {
                    TRC.listen('module-loader-failure', event => this.lazyLoadFailure(event, Object.keys(storiesResponse)));
                    StoriesManager.lazyLoadStoriesModules();
                    Object.keys(storiesResponse)
                        .forEach(placementName => {
                            if (this.stories[placementName]) {
                                __trcWarn(`Stories already created for '${placementName}'`);
                                return;
                            }

                            const options = StoriesManager.getOptions(storiesResponse, clientGenericResponse, placementName, storiesPlacementsAmount);

                            if (options.enableMixpanel) {
                                TRC.Mixpanel.loadMixpanelScript(MIXPANEL_PROJECT_ID);
                            }
                            TRC.listen('vp-selector-not-found', () => this.stories.storiesContainerNotCreated = true);
                            TRC.VirtualPlacementsManager.handleVirtualPlacement(this.trcManager, placementName);

                            if (this.stories.storiesContainerNotCreated) {
                                return;
                            }

                            TRC.CustomModulesManager.runHook('stories-init', null, this);
                            this.stories[placementName] = new TRC.Stories(this.trcManager, placementName, options);
                        });
                } catch (ex) {
                    __trcWarn(`Stories - failed to create Stories Instance`, ex.message);
                }
            }

            handleStoryPlacement(currentPlacementResponseData, currentPlacementData) {
                if (this.stories.storiesContainerNotCreated) {
                    return;
                }

                currentPlacementData.isStories = true;
                currentPlacementData.parentStories = this.getRelevantStories(currentPlacementResponseData);
                currentPlacementData.parentStories.handlePlacement(currentPlacementData);
            }

            getRelevantStories(cardPlacementResponseData) {
                return this.stories[cardPlacementResponseData.stpl];
            }

            static getOptions(storiesResponse, cgaResponse, placementName, storiesPlacementsAmount) {
                const storiesUnitConfig = storiesResponse[placementName];
                const storiesExtendConfig = cgaResponse && cgaResponse.storiesExtendConfig && cgaResponse.storiesExtendConfig[placementName];
                const options = StoriesManager.parseStoriesOptionsFromResponse(storiesUnitConfig);

                StoriesManager.overrideOptionsConfiguration('cc', options, storiesExtendConfig);
                StoriesManager.overrideOptionsConfiguration('vui', options, storiesExtendConfig);

                options.storiesPlacementsAmount = storiesPlacementsAmount;
                return options;
            }

            static overrideOptionsConfiguration(prop, options, storiesExtendConfig) {
                if (storiesExtendConfig && storiesExtendConfig[prop] && options.storiesUi && options.storiesUi[prop]) {
                    options.storiesUi[prop] = TRC.util.merge(options.storiesUi[prop], storiesExtendConfig[prop]);
                }
            }

            static parseStoriesOptionsFromResponse({
                sti: storiesProductId,
                sui: storiesUi,
                fv: enableFeedView,
                st: injectScStrategy,
                vtag: videoTag,
                dm: enableMixpanel,
                dir: direction
            } = null) {
                return {
                    storiesProductId,
                    storiesUi: storiesUi || {},
                    enableFeedView: TRC.util.isTrue(enableFeedView),
                    injectScStrategy: injectScStrategy || 'static',
                    enableMixpanel: TRC.util.isTrue(enableMixpanel) || true,
                    videoTag,
                    direction
                };
            }

        }

        TRC.StoriesManager = StoriesManager;
    })();

    TRC.listen('stories-initiation', (() => {
        const CLASSES = {
            STICKY_ACTIVE: 'tbl-stories-sticky-active',
            STICKY_HIDDEN: 'tbl-stories-sticky-hidden',
            STICKY_SCROLL_UP: 'tbl-stories-sticky-scroll-direction-up',
            STICKY_SCROLL_DOWN: 'tbl-stories-sticky-scroll-direction-down',
            STICKY_STYLE_ID: 'tbl-sticky-style'
        };

        const STICKY_TOGGLE = {
            SHOW: 'SHOW',
            HIDE: 'HIDE'
        };

        const STICKY_SCROLL_DIRECTION = {
            UP: 'UP',
            DOWN: 'DOWN'
        };

        const STICKY_BACKGROUND_COLOR = '#fff';

        class StoriesSticky extends TRC.StoriesBase {
            constructor(container, options, unifiedPlacementName) {
                super(unifiedPlacementName, 'StoriesSticky');
                this.storiesContainer = container;
                this.eventsManager = TRC.StoriesEventsManager.getInstance(unifiedPlacementName);
                this.feedInViewPort = false;
                this.isStickyActive = false;
                this.options = this.getStickyOptions(options);

                if (!this.options.enabled) {
                    return;
                }

                StoriesSticky.injectStickyStyles(this.options);
                this.setStickyScrollListener();
                this.listenForFeedInViewPort();

                if (this.options.topScrollDownValue === undefined) {
                    this.setPublisherHeaderListener();
                }
            }

            setStickyScrollListener() {
                this.lastScrollTop = TRC.dom.getScrollTop(window);
                this.initialScroll = true;
                TRC.dom.on(window, 'scroll', this.onScroll.trcBind(this));
            }

            setPublisherHeaderListener() {
                try {
                    const resizeObserver = new ResizeObserver(entries => {
                        [].slice.call(entries).forEach(entry => {
                            const {height} = entry.contentRect;
                            this.options.topScrollDownValue = this.options.topScrollUpValue = `${height}px`;
                        });
                    });
                    resizeObserver.observe(this.publisherHeaderEl);
                } catch (ex) {
                    this.eventsManager.onError(`Error creating resizeObserver for sticky stories`, ex);
                }
            }

            listenForFeedInViewPort() {
                TRC.listen('feed-present-in-viewport', ({data}) => {
                    this.feedInViewPort = TRC.util.isTrue(data);
                });
            }

            // eslint-disable-next-line no-unused-vars
            static injectStickyStyles({stickyBackgroundColor, zIndex, topScrollDownValue}) {
                TRC.dom.injectStyle(`.tbl-stories-container { transition: transform 1s, top 0.5s; z-index: ${zIndex}; } .tbl-stories-container.tbl-stories-sticky-active { background: ${stickyBackgroundColor}; top: 0; position: sticky; border-bottom: 1px solid #ccc; } .tbl-stories-container.tbl-stories-sticky-hidden { top: -100%; }`);
            }

            getStickyOptions(options) {
                const {
                    e: enabled,
                    uthrsld: topScrollUpValue,
                    scrldwn: stickyScrollDownDepth,
                    isc: ignoreScrollChanges,
                    zi: zIndex,
                    bgc: stickyBackgroundColor,
                    off: disableStickyOffset
                } = options;

                const headerSelector = options.slctr || 'header';

                this.publisherHeaderEl = document.querySelector(headerSelector);

                if (!this.publisherHeaderEl) {
                    this.eventsManager.onError(`Sticky Stories header was not found on the page: ${headerSelector}`);
                }

                const topScrollDownValue = parseInt(options.thrsld || this.getHeaderComputedStyle('height'), 10);

                return {
                    enabled: enabled !== 'false' && !!this.publisherHeaderEl,
                    zIndex: this.getZIndex(zIndex),
                    stickyScrollDownDepth: stickyScrollDownDepth ? parseInt(stickyScrollDownDepth, 10) : 1000,
                    ignoreScrollChanges: ignoreScrollChanges ? parseInt(ignoreScrollChanges, 10) : 30,
                    stickyBackgroundColor: stickyBackgroundColor || STICKY_BACKGROUND_COLOR,
                    topScrollDownValue,
                    topScrollUpValue: topScrollUpValue ? parseInt(topScrollUpValue, 10) : topScrollDownValue,
                    disableStickyOffset
                };
            }

            getZIndex(zIndex) {
                if (!zIndex) {
                    // In case zIndexComp is 'auto'
                    zIndex = this.getHeaderComputedStyle('zIndex');
                    return TRC.util.isNumber(zIndex) ? parseInt(zIndex, 10) - 1 : zIndex;
                }

                return parseInt(zIndex, 10);
            }

            getHeaderComputedStyle(property) {
                if (!this.publisherHeaderEl) {
                    return;
                }

                if (!this._getComputedStyle) {
                    this._getComputedStyle = getComputedStyle(this.publisherHeaderEl);
                }

                return this._getComputedStyle[property];
            }

            onScroll() {
                requestAnimationFrame(() => {
                    this.toggleStoriesOnScroll();
                });
            }

            toggleStoriesOnScroll() {
                const scrollTop = TRC.dom.getScrollTop(window);

                if (this.shouldIgnoreScrollChanges(scrollTop)) {
                    return;
                }

                const direction = this.getStickyScrollDirection(scrollTop);
                const trigger = this.getTrigger(scrollTop, direction);
                const shouldToggleSticky = this.shouldToggleSticky(trigger);
                if (shouldToggleSticky) {
                    this.toggleStickyStories(trigger);
                }
                const shouldChangeTopPosition = this.shouldChangeTopPosition(shouldToggleSticky, direction);
                if (shouldChangeTopPosition) {
                    this.changeTopPosition(direction);
                }
                this.lastScrollTop = scrollTop <= 0 ? 0 : scrollTop; // For Mobile or negative scrolling
                this.direction = direction;
            }

            shouldIgnoreScrollChanges(scrollTop) {
                const scrollChange = Math.abs(this.lastScrollTop - scrollTop);
                return scrollChange < this.options.ignoreScrollChanges;
            }

            getStickyScrollDirection(curScrollTop) {
                return this.lastScrollTop > curScrollTop ? STICKY_SCROLL_DIRECTION.UP : STICKY_SCROLL_DIRECTION.DOWN;
            }

            getTrigger(scrollTop, direction) {
                const {
                    disableStickyOffset, topScrollDownValue, topScrollUpValue, stickyScrollDownDepth
                } = this.options;
                const inDisabledStickyArea = !!disableStickyOffset && (disableStickyOffset > scrollTop);

                this.storiesCarouselTopPosition = this.storiesContainer.getBoundingClientRect().top;
                const isCarouselInViewPort = this.storiesCarouselTopPosition > topScrollUpValue;

                if (inDisabledStickyArea || isCarouselInViewPort) {
                    return STICKY_TOGGLE.HIDE;
                }

                const thresholdAreaOnScrollDown = +topScrollDownValue + stickyScrollDownDepth;
                const isScrollDownOutThreshold = (scrollTop >= thresholdAreaOnScrollDown);

                if (direction === STICKY_SCROLL_DIRECTION.DOWN && isScrollDownOutThreshold) {
                    return STICKY_TOGGLE.HIDE;
                }

                return STICKY_TOGGLE.SHOW;
            }

            shouldToggleSticky(trigger) {
                if (this.initialScroll) {
                    this.initialScroll = false;
                    return false;
                }
                const isShowTrigger = trigger === STICKY_TOGGLE.SHOW;
                if (this.isStickyActive) {
                    return !isShowTrigger;
                }
                if (isShowTrigger) {
                    return !this.feedInViewPort;
                }
                return false;
            }

            toggleStickyStories(trigger) {
                if (trigger === STICKY_TOGGLE.HIDE) {
                    TRC.dom.addClass(this.storiesContainer, CLASSES.STICKY_HIDDEN);
                    TRC.dom.removeClass(this.storiesContainer, CLASSES.STICKY_ACTIVE);
                    this.storiesContainer.style.transform = '';
                }
                if (trigger === STICKY_TOGGLE.SHOW) {
                    TRC.dom.removeClass(this.storiesContainer, CLASSES.STICKY_HIDDEN);
                    TRC.dom.addClass(this.storiesContainer, CLASSES.STICKY_ACTIVE);
                }
                this.isStickyActive = !this.isStickyActive;
            }

            calcTranslateY(yPosition) {
                const TRANSFORM_REGEX = /(matrix(?:3d)*\((?:(?:-*\d+(?:\.\d+)*, ){13}|(?:-*\d+(?:\.\d+)*, ){5}))(-*\d+(?:\.\d+)*)((?:, -*\d+(?:\.\d+)*)*\))/;
                const transformMatrix = getComputedStyle(this.storiesContainer).transform;
                if (TRANSFORM_REGEX.test(transformMatrix)) {
                    return transformMatrix.replace(TRANSFORM_REGEX, `$1${yPosition}$3`);
                }
                return `translateY(${yPosition}px)`;
            }

            shouldChangeTopPosition(shouldToggleSticky, direction) {
                const {topScrollDownValue, topScrollUpValue} = this.options;
                const isDiffTopValue = topScrollDownValue !== topScrollUpValue;
                const isDiffDirection = this.direction !== direction;
                return this.isStickyActive ? shouldToggleSticky || isDiffTopValue && isDiffDirection : false;
            }

            changeTopPosition(direction) {
                const {topScrollUpValue, topScrollDownValue} = this.options;
                const isScrollingUp = direction === STICKY_SCROLL_DIRECTION.UP;
                if (isScrollingUp) {
                    this.storiesContainer.style.transform = this.calcTranslateY(topScrollUpValue);
                } else {
                    this.storiesContainer.style.transform = this.calcTranslateY(topScrollDownValue);
                }
            }
        }

        TRC.StoriesSticky = StoriesSticky;
    }));

    TRC.listen('stories-initiation', (() => {

        const CLASSES = {
            STORIES_CONTAINER: 'tbl-stories-container',
            PLACEMENTS_CONTAINER: 'tbl-stories-placements-container',
            CAROUSEL_CONTAINER: 'tbl-stories-carousel-container',
            STORIES_PLACEMENT: 'tbl-stories-placement',
            STORIES_RTL: 'tbl-stories-rtl'
        };

        const ATTRIBUTES = {
            MAIN_CONTAINER_ID: 'data-stories-main-container-id',
            STORY_INDEX: 'data-story-index',
            STORY_TOPIC_INDEX: 'data-story-topic-index',
            STORY_TOPIC: 'data-story-topic'
        };

        const EVENTS = {
            AVAILABLE: 'available',
            COLLAPSED: 'collapsed',
            COLLAPSED_TOPIC: 'collapsed-topic',
            VIDEO_PLAYING: 'video-playing',
            TOPIC_SWIPED: 'topic-swiped'
        };

        class Stories extends TRC.StoriesBase {
            constructor(trcManager, unifiedPlacementName, options) {
                super(unifiedPlacementName, 'Stories');
                this.trcManager = trcManager;
                this.storiesPlacements = {};
                this.topics = {};
                this.isFirstCardRendered = false;
                this.options = options;
                this.unifiedPlacementName = unifiedPlacementName;
                this.numPlacements = 0;
                this.numTopics = 0;
                this.placementData = trcManager.preloadRequest[unifiedPlacementName];
                this.container = this.placementData.container;
                this.parentContainerId = this.container.id;
                new TRC.StoriesHistoryController(`tbl-stories-${this.parentContainerId}`, unifiedPlacementName);
                this.topicMinAmount = 4;
                this.storiesHeight = trcManager.global['default-stories-height'];
                this.enableClsReducer = trcManager.global['enable-cls-reducer'] || false;
                this.eventsManager = new TRC.StoriesEventsManager(options, unifiedPlacementName);
                this.isRtl = this.options.direction || this.trcManager.direction === 'rtl';

                this.isVideoInitiated = false;
                this.placementData.isStories = true;

                if (!this.isLazyRenderEnabled()) {
                    const reason = `lazy render disabled: ${this.unifiedPlacementName}`;
                    this.eventsManager.sendEvent(EVENTS.COLLAPSED, {ab: [reason], mxp: {errorMsg: reason}});
                    this.collapseContainer();
                    __trcWarn(reason);
                    return;
                }

                TRC.listen('trcContentReady', e => this.initVideoTag(e));
                Stories.injectCss();
                this.createStoriesContainer();
                this.eventsManager.sendLifeCycleEvents(EVENTS.AVAILABLE);

                try {
                    new TRC.StoriesCarousel(unifiedPlacementName, this.container);
                } catch (ex) {
                    this.eventsManager.onError(`failed to create StoriesCarousel`, ex);
                    this.collapseContainer();
                }
            }

            isLazyRenderEnabled() {
                const {isLazyRenderEnabled, placementsConfigs} = this.trcManager.renderController;
                const unifiedPlacementNameWithActionPrefix = `Stories - ${this.unifiedPlacementName}`;
                const lazyRenderPlacementConfig = placementsConfigs ? placementsConfigs[unifiedPlacementNameWithActionPrefix] : {};
                return (isLazyRenderEnabled && (lazyRenderPlacementConfig && lazyRenderPlacementConfig.enable));
            }

            shouldLoadVideo(trcbox) {
                return this.options.videoTag && !this.isVideoInitiated && trcbox.isStories && trcbox.trc['mode-before-video-load'](trcbox);
            }

            initVideoTag({trcbox}) {
                if (this.shouldLoadVideo(trcbox)) {
                    const videoTagOptions = {
                        placement: trcbox.placement,
                        container: trcbox.container
                    };
                    this.isVideoInitiated = true;
                    this.videoTagLoader = new TRC.VideoTagLoader(trcbox.trc, this.options.videoTag, videoTagOptions, trcbox, trcbox.response.trc);
                    this.videoTagLoader.loadVideo();
                }
            }

            static createBlurImageBox(container) {
                const blurImageStoriesBox = document.createElement('div');
                container.appendChild(blurImageStoriesBox);
                container.blurImageStoriesBox = blurImageStoriesBox;
            }

            static injectCss() {
                TRC.dom.injectStyle(`.tbl-stories-container { width: 100vw; font-family: helvetica, arial, sans-serif; -webkit-overflow-scrolling: auto; padding: 0 0 5px; } .tbl-stories-container.tbl-stories-rtl { direction: rtl; } .tbl-stories-container .tbl-stories-placement { display: none; } .tbl-stories-container svg { /*override publisher css on svg tag*/ vertical-align: inherit; fill: transparent; }.tbl-feed-view-parent-wrapper body.tbl-stories-show { position: initial; overflow: initial; }`);
            }

            createStoriesContainer() {
                TRC.dom.addClass(this.container, CLASSES.STORIES_CONTAINER);
                this.isRtl && TRC.dom.addClass(this.container, CLASSES.STORIES_RTL);

                this.container.setAttribute(ATTRIBUTES.MAIN_CONTAINER_ID, this.unifiedPlacementName);

                this.placementsContainer = TRC.dom.createHTMLElement('section', {
                    className: CLASSES.PLACEMENTS_CONTAINER
                });
            }

            handlePlacement(placementData) {
                try {
                    if (this.storiesColapsed) {
                        return;
                    }

                    const {
                        placement: placementName,
                        trcResponse
                    } = placementData;

                    if (this.storiesPlacements[placementName]) {
                        this.eventsManager.onError(`placement already created for '${placementName}'`);
                        return;
                    }

                    const itemsAmount = placementData.trcResponse.v.length;
                    if (!itemsAmount) {
                        this.options.storiesPlacementsAmount--;
                        this.eventsManager.sendEvent(EVENTS.COLLAPSED_TOPIC, {
                            ab: [placementName, this.numPlacements + 1],
                            mxp: {topicName: placementName, topicPosition: this.numPlacements + 1}
                        });
                        this.isStoriesLastPlacement();
                        return;
                    }

                    const placementContainer = document.createElement('section');

                    placementData.container = placementContainer;
                    placementData.modeGroupOrder = ++this.numPlacements;
                    placementContainer.setAttribute(ATTRIBUTES.STORY_INDEX, this.numPlacements);
                    placementContainer.placementData = placementData;
                    placementContainer.id = `${this.parentContainerId}-pl${this.numPlacements}`;

                    TRC.dom.addClass(placementContainer, CLASSES.STORIES_PLACEMENT);

                    this.handleTopicRelatedPlacement(placementContainer, trcResponse, placementData);

                    this.placementsContainer.appendChild(placementContainer);

                    this.isStoriesLastPlacement();

                    this.storiesPlacements[placementName] = placementData;
                } catch (ex) {
                    this.eventsManager.onError(`failed to handlePlacement`, ex);
                    this.collapseContainer();
                }
            }

            collapseContainer() {
                this.storiesColapsed = true;
                TRC.dom.addClass(this.container, 'tbl-hidden');
            }

            isStoriesLastPlacement() {
                if (this.options.storiesPlacementsAmount === this.numPlacements) {

                    if (this.numTopics < this.topicMinAmount) {
                        __trcWarn(`Stories Collapsed - Topics Rendered: ${this.numTopics}`);
                        const reason = `topics length is : ${this.numTopics}`;
                        this.eventsManager.sendEvent(EVENTS.COLLAPSED, {ab: [reason], mxp: {errorMsg: reason}});
                        this.collapseContainer();
                        return;
                    }

                    this.clsReducer(() => {
                        const storiesCarouselInstance = TRC.StoriesCarousel.getInstance(this.unifiedPlacementName);
                        const {carouselContainer} = storiesCarouselInstance;
                        this.container.appendChild(carouselContainer);
                        this.container.appendChild(this.placementsContainer);
                        storiesCarouselInstance.carouselReady();
                    });

                    TRC.EventsAPI.dispatchStoriesLoaded();
                }
            }

            clsReducer(cb) {
                const {virtualPlacementsMap} = this.trcManager.virtualPlacementsManager;
                if (this.enableClsReducer && virtualPlacementsMap[this.unifiedPlacementName]) {
                    window.scroll({top: (this.storiesHeight)});
                    TRC.Timeout.set(cb, 0);
                } else {
                    cb();
                }
            }

            renderVerticalUiPlacements(topic, isLazyRenderDisabled) {
                try {
                    let verticalUi = TRC.StoriesVerticalUi.getInstance && TRC.StoriesVerticalUi.getInstance(this.unifiedPlacementName);
                    if (!verticalUi) {
                        verticalUi = new TRC.StoriesVerticalUi(this.unifiedPlacementName);
                    }
                    if (isLazyRenderDisabled) {
                        verticalUi.handleVerticalUiLayout();
                    }
                    verticalUi.openVerticalUi(topic);
                } catch (ex) {
                    this.eventsManager.onError('renderVerticalUiPlacements', ex);
                }
            }

            handleTopicRelatedPlacement(placementContainer, trcResponse, placementData) {
                const {categoryId, categoryTitle, categoryImage} = Stories.getPlacementCategoryData(trcResponse);
                const storiesCarouselInstance = TRC.StoriesCarousel.getInstance(this.unifiedPlacementName);

                if (!categoryId) {
                    return; // if we don't have categoryId it's not a topic placement
                }

                this.loadFeedView(placementData);

                placementContainer.setAttribute(ATTRIBUTES.STORY_TOPIC, categoryId);
                placementContainer.setAttribute(ATTRIBUTES.STORY_TOPIC_INDEX, ++this.numTopics);
                const topicData = {
                    id: categoryId,
                    title: categoryTitle || categoryId,
                    imageUrl: storiesCarouselInstance.getTopicImage(categoryImage, trcResponse.v),
                    slotPosition: this.numPlacements,
                    placementContainer
                };

                this.topics[categoryId] = placementData.topicData = topicData;

                storiesCarouselInstance.addTopic(topicData);
            }

            static getPlacementCategoryData(trcResponse) {
                const {cid: categoryId, ct: categoryTitle, ciu: categoryImage} = trcResponse;
                return {categoryId, categoryTitle, categoryImage};
            }

            loadFeedView(placementData) {
                if (this.options.enableFeedView) {
                    new TRC.FeedViewWidgetLoaderManager(placementData);

                    const {fvConfig} = this.options.storiesUi.vui;
                    if (fvConfig) {
                        placementData.feedViewConfig = fvConfig;
                    }
                }
            }
        }

        TRC.Stories = Stories;
    }));

    class ClassTreeFactory {
        constructor(settings = {}) {
            this.Class = this.constructor;
            this.settings = settings;
            this.settings.classTreeArr = this.settings.classTreeArr || [];
        }

        sub(label) {
            const settings = JSON.parse(JSON.stringify(this.settings));
            settings.classTreeArr.push(label);
            return new this.Class(settings);
        }

        mixin(...mixins) {
            const CombinedMixingClass = mixins.reduceRight((base, fn) => fn(base), this.Class);
            return new CombinedMixingClass(this.settings);
        }
    }

    const MetricReporterMixin = Class => class extends (Class) {
        constructor(settings = {}) {
            super(settings);
            this.settings.classTreeArr = this.settings.classTreeArr || [];
            this.id = this.settings.classTreeArr.slice(-1)[0] || '';
        }

        sendRboxMetricsEvent({eventName, value, type} = {}) {
            if (!TRC.MetricsManager) {
                return;
            }
            TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: `${this.id}-${eventName}`, value, type}, null);
        }

        logUsage({
            file = '', extraData = {}
        } = {}) {
            if (!TRC.RBoxUsage || !TRC.RBoxUsage.logUsage) {
                return;
            }

            TRC.RBoxUsage.logUsage(
                `${this.id}-event-${Date.now()}`,
                {
                    extraData,
                    file
                }
            );
        }
    };

    const classTreeFactory$2 = new ClassTreeFactory();
    const metricReporter$1 = classTreeFactory$2.mixin(MetricReporterMixin);

    var Promise$1 = (typeof Promise !== 'undefined' && Promise) || PromisePolyFill;

    // based on  https://gist.github.com/Rich-Harris/11010768
    const statuses = {
        PENDING: {},
        FULFILLED: {},
        REJECTED: {}
    };
    function PromisePolyFill(callback) {
        const fulfilledHandlers = [],
            rejectedHandlers = [],
            fulfil = makeResolver(statuses.FULFILLED),
            reject = makeResolver(statuses.REJECTED);
        let state = statuses.PENDING,
            result,
            dispatchHandlers;
        function makeResolver(newState) {
            return function (value) {
                if (state !== statuses.PENDING) {
                    return;
                }
                result = value;
                state = newState;
                dispatchHandlers = makeDispatcher((state === statuses.FULFILLED ? fulfilledHandlers : rejectedHandlers), result);
                // dispatch onFulfilled and onRejected handlers asynchronously
                wait(dispatchHandlers);
            };
        }
        try {
            callback(fulfil, reject);
        } catch (error) {
            reject(error);
        }
        const promise = {
            // `then()` returns a PromisePolyFill - 2.2.7
            then(onFulfilled, onRejected) {
                const promise2 = new PromisePolyFill(((fulfil, reject) => {
                    const processResolutionHandler = function (handler, handlers, forward) {
                        // 2.2.1.1
                        if (typeof handler === 'function') {
                            handlers.push(p1result => {
                                let x;
                                try {
                                    x = handler(p1result);
                                    resolve(promise2, x, fulfil, reject);
                                } catch (err) {
                                    reject(err);
                                }
                            });
                        } else {
                            // Forward the result of promise1 to promise2, if resolution handlers
                            // are not given
                            handlers.push(forward);
                        }
                    };
                    // 2.2
                    processResolutionHandler(onFulfilled, fulfilledHandlers, fulfil);
                    processResolutionHandler(onRejected, rejectedHandlers, reject);
                    if (state !== statuses.PENDING) {
                        // If the promise has resolved already, dispatch the appropriate handlers asynchronously
                        wait(dispatchHandlers);
                    }
                }));
                return promise2;
            }
        };
        promise.catch = function (onRejected) {
            return this.then(null, onRejected);
        };
        return promise;
    }

    PromisePolyFill.all = function (promises) {
        return new PromisePolyFill(((fulfil, reject) => {
            const result = [];
            let
                pending,
                i;
            if (!promises.length) {
                fulfil(result);
                return;
            }
            function processPromisePolyFill(i) {
                promises[i].then(value => {
                    result[i] = value;
                    if (!--pending) {
                        fulfil(result);
                    }
                }, reject);
            }
            pending = i = promises.length;
            while (i--) {
                processPromisePolyFill(i);
            }
        }));
    };

    PromisePolyFill.race = function (promises) {
        return new PromisePolyFill(((fulfil, reject) => {
            promises.forEach(promise => {
                promise.then(fulfil, reject);
            });
        }));
    };

    PromisePolyFill.resolve = function (value) {
        return new PromisePolyFill((fulfil => {
            fulfil(value);
        }));
    };

    PromisePolyFill.reject = function (reason) {
        return new PromisePolyFill(((fulfil, reject) => {
            reject(reason);
        }));
    };

    function wait(callback) {
        setTimeout(callback, 0);
    }

    function makeDispatcher(handlers, result) {
        return function () {
            let handler;
            while (handler = handlers.shift()) {
                handler(result);
            }
        };
    }

    function resolve(promise, x, fulfil, reject) {
        // PromisePolyFill Resolution Procedure
        let then;
        // 2.3.1
        if (x === promise) {
            throw new TypeError('A promise\'s fulfillment handler cannot return the same promise');
        }
        // 2.3.2
        if (x instanceof PromisePolyFill) {
            x.then(fulfil, reject);
        } else { // 2.3.3
            // eslint-disable-next-line no-lonely-if
            if (x && (typeof x === 'object' || typeof x === 'function')) {
                try {
                // eslint-disable-next-line prefer-destructuring
                    then = x.then; // 2.3.3.1
                } catch (e) {
                    reject(e); // 2.3.3.2
                    return;
                }
                // 2.3.3.3
                if (typeof then === 'function') {
                    let called;
                    // eslint-disable-next-line no-inner-declarations
                    function resolvePromisePolyFill(y) {
                        if (called) {
                            return;
                        }
                        called = true;
                        resolve(promise, y, fulfil, reject);
                    }
                    const rejectPromisePolyFill = function (r) {
                        if (called) {
                            return;
                        }
                        called = true;
                        reject(r);
                    };
                    try {
                        then.call(x, resolvePromisePolyFill, rejectPromisePolyFill);
                    } catch (e) {
                        if (!called) { // 2.3.3.3.4.1
                            reject(e); // 2.3.3.3.4.2
                            called = true;
                        }
                    }
                } else {
                    fulfil(x);
                }
            } else {
                fulfil(x);
            }
        }
    }

    const TIME_BETWEEN_EVENTS = 100,
        MAX_MS_BETWEEN_EVENTS = 2000,
        SCROLL_END_TIMEOUT = 500;

    class ScrollManager {
        constructor() {
            if (ScrollManager.instance) {
                return ScrollManager.instance;
            }
            ScrollManager.instance = this;

            this.ppsDetection = false;
            this.lastTimeStamp = 0;
            this.pps = 0;

            TRC.dom.on(window, 'scroll', this.onScroll.trcBind(this).trcThrottle(TIME_BETWEEN_EVENTS));
        }

        onScroll(event) {
            clearTimeout(this.scrollEnd);

            this.pps = 0;
            const MSFromLastScroll = event.timeStamp - this.lastTimeStamp;
            this.lastTimeStamp = event.timeStamp;

            const pixelDiff = window.scrollY - this.lastScrollTop;
            this.lastScrollTop = window.scrollY;

            if (MSFromLastScroll < MAX_MS_BETWEEN_EVENTS) {
                this.changePPS((pixelDiff / MSFromLastScroll) * 1000);
            }
            // Set timeout for scroll end if no event occurred during that time
            this.scrollEnd = setTimeout(
                this.onScrollEnd.bind(this),
                SCROLL_END_TIMEOUT
            );
        }

        getPps() {
            return this.pps;
        }

        changePPS(newPPS) {
            this.pps = newPPS;
        }

        onScrollEnd() {
            this.changePPS(0);
        }
    }

    /* eslint-disable */
    var dynamicContentLoader = '<!DOCTYPE html> <html> <head> <script> (function () {\n    \'use strict\';\n\n    (function () {\n        window.TBC = window.TBC || {};\n        var cmd = window.TBC.cmd = window.TBC.cmd || [];\n\n        var support = {\n            connection : window.postMessage ? true : false\n        };\n\n        var calledActions;\n        var oneActions;\n\n        // The methods are inserted into an object for testing. This way you will be able to spyOn them in UT.\n        var privateMethods = {\n            validateApiActionArguments: function(methodName, arg) {\n                if ( typeof arg[0].sizeObject !== \'object\' && typeof arg[0].iframeArgs !== \'object\' && typeof arg[1] !== \'function\') {\n                    throw new TypeError(\'invalid argument supplied for \' + methodName + \'()\');\n                }\n            },\n            init: function() {\n                calledActions = {};\n                oneActions = {};\n                window.addEventListener(\'message\', privateMethods.receiveMessage);\n                privateMethods.switchCmd();\n                privateMethods.executeCmd();\n                privateMethods.isMobileSDK() && privateMethods.registerTrcClicks();\n            },\n            registerTrcClicks: function() {\n                if (!document.body) {\n                    requestAnimationFrame(privateMethods.registerTrcClicks);\n                    return;\n                }\n\n                document.body.addEventListener("click", function (event) {\n                    var clickData = privateMethods.extractItemData(event.target);\n                    if (clickData) {\n                        event.preventDefault();\n                        TBC.click(clickData);\n                    }\n                }, true);\n            },\n            extractItemData: function(element) {\n                if (element.nodeName === "BODY") {\n                    return null;\n                }\n                if (element.nodeName === "A") {\n                    return privateMethods.collectElementData(element);\n                }\n                if (element.parentElement) {\n                    return privateMethods.extractItemData(element.parentElement);\n                }\n                return null;\n            },\n            collectElementData: function(element) {\n                var data = {\n                    url: element.href\n                };\n                data.isCardClick = !!element.parentElement.video_data;\n                if (data.isCardClick) {\n                    data.video_data = element.parentElement.video_data;\n                    var placementElement = privateMethods.getPlacementParentElement(element);\n                    data.placement_name = placementElement.dataset.placementName;\n                    data.is_organic = !placementElement.querySelector("." + TRC.SPONSORED_CONTAINER_CLASS_NAME);\n                }\n                return data;\n            },\n            getPlacementParentElement: function(element) {\n                var placementList = document.querySelectorAll("[data-placement-name]") || [];\n                for (var iPlacement = 0; iPlacement < placementList.length; iPlacement++) {\n                    if (placementList[iPlacement].contains(element)) {\n                        return placementList[iPlacement];\n                    }\n                }\n                return null;\n            },\n            switchCmd: function() {\n                cmd.push = function(func) {\n                    if (typeof func === \'function\') {\n                        func();\n                    }\n                };\n            },\n            executeCmd: function() {\n                var func;\n                while (func = cmd.shift()) {\n                    if (typeof func === \'function\') {\n                        func();\n                    }\n                }\n            },\n            receiveMessage: function(messageEvent) {\n                var data = messageEvent.data,\n                    callback;\n                if(data && data.action) {\n                    // notice this is also an assignment expression\n                    if(callback = calledActions[data.action]) {\n                        delete calledActions[data.action];\n                        callback(data.dimension, data.message);\n                    }\n                }\n            },\n            sendMessage: function(action, payload) {\n                var message = {\n                    \'id\': privateMethods.getIframeId(),\n                    \'action\': action,\n                    \'payload\': payload\n                };\n                window.parent.postMessage(message, \'*\');\n            },\n            doAction: function(actionName, arg){\n                privateMethods.validateApiActionArguments(actionName, arg);\n                if (support.connection) {\n                    if (!calledActions[actionName]) {\n                        calledActions[actionName] = arg[1];\n                        privateMethods.sendMessage(actionName, arg[0]);\n                    }\n                } else {\n                    arg[1](null, \'Taboola Connect is not supported\');\n                }\n            },\n            getValueFromParent: function (key){\n                var fromHash = privateMethods.getParamValueFromHash(key); //id for unfriendly iframes\n                var fromAttribute = frameElement && frameElement.getAttribute(key); //id for friendly iframes\n                return fromHash || fromAttribute || \'\';\n            },\n            getIframeId: function (){\n                return privateMethods.getValueFromParent(\'tbcId\');\n            },\n            isMobileSDK: function(){\n                return privateMethods.getValueFromParent(\'isMobileSDK\') === \'true\';\n            },\n            getParamValueFromHash: function(paramKey) {\n                // regex explanation (getting the value of the param): # or & than paramKey= than all the chars until the next & or end of string\n                var paramMatch = location.hash.match(new RegExp(\'(#|&)\' + paramKey + \'=([^&]*)\'));\n                return paramMatch ? paramMatch[2] : \'\';\n            }\n        };\n\n        TBC.rendered = function(sizeObject, callback) {\n            if (!oneActions[\'rendered\']) {\n                oneActions[\'rendered\'] = 1;\n                privateMethods.doAction(\'rendered\', [{"sizeObject" : sizeObject}, callback]);\n            }\n        };\n\n        TBC.expand = function(sizeObject, callback) {\n            privateMethods.doAction(\'expand\', [{"sizeObject" : sizeObject}, callback]);\n        };\n\n        TBC.collapse = function(sizeObject, callback) {\n            privateMethods.doAction(\'collapse\', [{"sizeObject" : sizeObject}, callback]);\n        };\n\n        TBC.getMaxHeight = function(callback) {\n            privateMethods.doAction(\'maxHeight\', [{}, callback]);\n        };\n\n        TBC.click = function(arg1, arg2) {\n            if(typeof arg1 === \'function\') {\n                privateMethods.doAction(\'click\', [{}, arg1]);\n            } else {\n                privateMethods.doAction(\'click\', [{"sizeObject" : arg1}, arg2]);\n            }\n\n        };\n\n        TBC.openInIframe = function(iframeArgs, callback){\n            privateMethods.doAction(\'openInIframe\', [{iframeArgs: iframeArgs}, callback]);\n        };\n\n        TBC.error = function(msg) {\n            privateMethods.doAction(\'error\', [msg, function() {return msg;}]);\n        };\n\n        TBC.supports = function() {\n            return support;\n        };\n\n        TBC.reportMetrics = function(reportObj) {\n            if (!support.connection) {\n                return;\n            }\n\n            privateMethods.sendMessage(\'reportMetrics\', reportObj);\n        };\n\n        privateMethods.init();\n\n        /* public methods for UT */\n        if (window._trcIsUTactive){\n            TBC.privateMethods = privateMethods;\n        }\n\n    })();\n\n})();\n</script><script>(function () {\n    \'use strict\';\n\n    function parseQueryString() {\n        try {\n            const pairs = location.search.slice(1).split(\'&\'),\n                result = {};\n\n            pairs.forEach(pair => {\n                const [key, value] = pair.split(\'=\');\n                result[key] = value;\n            });\n\n            return JSON.parse(JSON.stringify(result));\n        } catch (e) {\n            return {};\n        }\n    }\n\n    function htmlUnescape(value) {\n        const htmlUnescapes = {\n                \'&amp;\': \'&\',\n                \'&lt;\': \'<\',\n                \'&gt;\': \'>\',\n                \'&quot;\': \'"\',\n                \'&#39;\': \'\\\'\'\n            },\n            reEscapedHtml = /&(?:amp|lt|gt|quot|#(0+)?39);/g,\n            reHasEscapedHtml = RegExp(reEscapedHtml.source);\n\n        return (value && reHasEscapedHtml.test(value))\n            ? value.replace(reEscapedHtml, entity => htmlUnescapes[entity] || \'\\\'\')\n            : (value || \'\');\n    }\n\n    function formatHtmlString(str, isRtb) {\n        try {\n            const decoded = isRtb ? str : safeDecodeURIComponent(str),\n                unescaped = htmlUnescape(decoded);\n\n            return JSON.parse(\`{"key": "\${unescaped}"}\`).key;\n        } catch (e) {\n            reportMetrics({name: \'error-format_html_error\', data: {errorMessage: e}});\n            TBC.cmd.push(() => {\n                TBC.error(\`error while parsing html string: e=\${e} str=\${str}\`);\n            });\n            return \'\';\n        }\n    }\n\n    function safeDecodeURIComponent(str) {\n        try {\n            return decodeURIComponent(str);\n        } catch (e) {\n            return str;\n        }\n    }\n\n    function reportMetrics(reportObj) {\n        try {\n            TBC.cmd.push(() => {\n                if (TBC.reportMetrics) {\n                    TBC.reportMetrics(reportObj);\n                }\n            });\n        } catch (e) {\n            // Do nothing\n        }\n    }\n\n    function safeParseJsonString(str) {\n        try {\n            return JSON.parse(str);\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function notifyClick() {\n        // taboola-connect forces to send a callback function even though its not needed in this case\n        TBC.cmd.push(() => {\n            TBC.click(() => {\n            });\n        });\n    }\n\n    function doNothing() {\n        return true;\n    }\n\n    function prepareGenericRequest(type, url) {\n        const Request = window.XDomainRequest || window.XMLHttpRequest,\n            httpRequest = new Request();\n\n        httpRequest.open(type, url);\n\n        // Supporting IE-9 bug - all events must be defined\n        httpRequest.onload = doNothing;\n        httpRequest.onerror = doNothing;\n        httpRequest.ontimeout = doNothing;\n        httpRequest.onprogress = doNothing;\n\n        return httpRequest;\n    }\n\n    function renderContentFromHtml(contentStr, height, width) {\n        const dataObject = {};\n\n        if (height) {\n            dataObject.height = height;\n        }\n\n        const html = \`<body style="margin: 0">\n            <div class="display-thumbnail" style="margin: 0 auto; width: \${width}px">\n            \${contentStr}\n            </div>\n        </body>\n        <script>\n        TBC.cmd.push(function() {\n        TBC.rendered(\${JSON.stringify(dataObject)});\n        });\n        </script>\`;\n\n        document.open();\n        document.write(html);\n        document.close();\n\n        function htmlDecode(name) {\n            try {\n                const doc = new DOMParser().parseFromString(name, \'text/html\');\n                return doc.documentElement && doc.documentElement.textContent;\n            } catch (e) {\n                return \'\';\n            }\n        }\n\n        window.parent.addEventListener(\'blur\', handleFocusIframe);\n        window.parent.addEventListener(\'visibilitychange\', focusOutIframe);\n\n        window.parent.focus();\n\n        function handleFocusIframe() {\n            try {\n                const activeElementContent = window.parent.document.activeElement.name;\n                if (!activeElementContent) {\n                    return;\n                }\n                const activeFrameElement = htmlDecode(activeElementContent.replace(/\\\\/g, \'\'));\n                if (activeFrameElement === contentStr) {\n                    notifyClick();\n                }\n            } catch (e) {\n                reportMetrics({name: \'error-handle-focus-iframe\'});\n                TBC.cmd.push(() => {\n                    TBC.error(\`error while handle focus iframe: e=\${e}\`);\n                });\n            }\n        }\n\n        function focusOutIframe() {\n            if (!window.parent.hidden) {\n                window.parent.focus();\n            }\n        }\n    }\n\n    function renderContentFromUrl(dynamicContentObj, originalItemData) {\n        const request = prepareGenericRequest(\'GET\', dynamicContentObj.content);\n        request.onload = genOnLoadHandler(request, dynamicContentObj, originalItemData);\n        request.onerror = function () {\n            reportMetrics({name: \'error-fetching_url\'});\n        };\n        request.send();\n    }\n\n    function handleHtmlOnLoad(htmlText, dynamicContentObj) {\n        const width = parseInt(dynamicContentObj.width, 10) || getWindowWidth(),\n            ratio = parseFloat(dynamicContentObj.ratio),\n            height = parseInt(dynamicContentObj.height, 10) || ratio * width;\n\n        renderContentFromHtml(htmlText, height, width);\n    }\n\n    function genOnLoadHandler(request, dynamicContentObj, originalItemData) {\n        return function () {\n            let {responseText} = request;\n            reportMetrics({name: \`event-response_status_\${request.status}\`});\n            if (!responseText || responseText.length <= 0) {\n                reportMetrics({name: \'event-empty_response_text\'});\n                return;\n            }\n\n            if (originalItemData) {\n                responseText = replaceMacros(responseText, originalItemData);\n            }\n\n            handleHtmlOnLoad(responseText, dynamicContentObj);\n            reportAbTestData(\'dcl-url-rendered\', dynamicContentObj);\n        };\n    }\n\n    function getWindowWidth() {\n        if (!window.innerWidth) { // Supporting IE\n            if (document.documentElement.clientWidth !== 0) { // support IE strict mode\n                return document.documentElement.clientWidth;\n            } if (document.body) {\n                return document.body.clientWidth;\n            } \n            return 0;\n            \n        }\n        return window.innerWidth;\n    }\n\n    function reportAbTestData(event, data) {\n        if (window.TRCImpl && window.isReportAbTestData) {\n            TRCImpl.sendAbTestEvent(event, JSON.stringify(data));\n        }\n    }\n\n    function parseDynamicContent({contentToParse, isRtb, queryStringObj} = {}) {\n        return safeParseJsonString(contentToParse) || formatHtmlString(contentToParse || (queryStringObj && queryStringObj.c) || \'\', isRtb);\n    }\n\n    function initParentTrc() {\n        try {\n            // For testing purpose only - need to be removed/passed through TBC in the future.\n            window.TRCImpl = parent && parent.TRCImpl || {};\n            window.TRC = parent && parent.TRC || {};\n        } catch (e) {\n            // Do nothing\n        }\n    }\n\n    function getValueFromParent(key) {\n        const fromAttribute = frameElement && frameElement.getAttribute(key);\n        return fromAttribute || \'\';\n    }\n\n    function init(dataObj) {\n        initParentTrc();\n        try {\n            let dynamicContent;\n\n            const dynamicContentString = dataObj.contentString;\n            if (dynamicContentString) {\n                dynamicContent = parseDynamicContent({contentToParse: dynamicContentString, isRtb: dataObj.isRtb});\n                reportMetrics({name: \`event-content_type_\${dynamicContent.contentType || \'unknown\'}\`});\n            }\n\n            if (dynamicContent && dynamicContent.contentType === CONTENT_TYPES.URL && dynamicContent.content) {\n                window.isReportAbTestData = window.TRC.util.isPercentEnabled(window.TRCImpl.global, \'is-report-dcl-events\');\n                reportAbTestData(\'dcl-fetch-url\', dynamicContent);\n                renderContentFromUrl(dynamicContent, dataObj.originalItemData);\n            } else if (dynamicContent && dynamicContent.contentType === CONTENT_TYPES.MARKUP && dynamicContent.content) {\n                // I\'m sorry for writing this code, production incident requires backward compatibility..\n                const taboolaUrl = \`&redir=\${encodeURIComponent(dataObj.originalItemData.url)}\`;\n                dynamicContent.content = replaceClickUrl(dynamicContent.content, dataObj.originalItemData.clickUrl + taboolaUrl);\n                handleHtmlOnLoad(htmlUnescape(dynamicContent.content), dynamicContent);\n            } else {\n                const queryStringObj = parseQueryString(); // passing the content through window.name overcome length limitation in src(url)\n                dynamicContent = dynamicContent || parseDynamicContent({contentToParse: dynamicContentString, isRtb: dataObj.isRtb, queryStringObj});\n                const height = getValueFromParent(\'height\'),\n                    width = getValueFromParent(\'width\');\n\n                renderContentFromHtml(dynamicContent, height, width);\n            }\n        } catch (e) {\n            reportMetrics({name: \'error-dynamic_content_loader\', data: {errorMessage: e}});\n        }\n    }\n\n    function receiveMessage(messageEvent) {\n        const dataObj = messageEvent.data;\n        if (!dataObj) {\n            return;\n        }\n\n        if (dataObj.shouldInit) {\n            init(dataObj);\n        }\n    }\n\n    function replaceClickUrl(contentString, clickUrlString) {\n        if (!clickUrlString) {\n            return contentString;\n        }\n\n        // TODO: to be removed, quick fix for cm360\n        contentString = contentString.replace(/%%CLICK_URL%%&url/g, \'%%CLICK_URL%%&xgl=\');\n\n        // Try to replace Click_URL with the clickUrl link.\n        contentString = contentString.replace(/%%CLICK_URL%%/g, clickUrlString);\n\n        // If after replacing CLICK_URL still exist, then we have an issue with replacing the string.\n        if (contentString.indexOf(\'CLICK_URL\') !== -1) {\n            reportMetrics({name: \'error-click_url_replace\', data: {content: contentString}});\n        }\n\n        return contentString;\n    }\n\n    function replaceMacros(markupString, originalItemData, options) {\n        try {\n            const resultString = markupString.replace(/%%TABOOLA:\\s*([\\w-]+)%%/gi, ((foundMacroString, fieldToReplace) => {\n                let replacedString = originalItemData[fieldToReplace] || \'\';\n                if (options && options.encodeUrl && fieldToReplace === \'url\') {\n                    replacedString = encodeURIComponent(replacedString);\n                }\n                return replacedString;\n            }));\n\n            const taboolaUrl = \`&redir={encodeURIComponent(originalItemData.url || \'\')}\`;\n            return replaceClickUrl(resultString, originalItemData.clickUrl + taboolaUrl);\n        } catch (err) {\n            reportMetrics({name: \'error-replace_macros_exception\', data: {errorMessage: err, id: (originalItemData && originalItemData.id.slice(0, 40))}});\n            return markupString;\n        }\n    }\n\n    const CONTENT_TYPES = {\n        URL: \'url\',\n        MARKUP: \'markup\'\n    };\n\n    window.TBC = window.TBC || {};\n    window.TBC.cmd = window.TBC.cmd || [];\n    window.addEventListener(\'message\', receiveMessage);\n\n    if (window.document.documentMode) { // IF IE\n        init({contentString: window.name});\n    }\n\n})();\n </script> </head> <body style=\'margin: 0\'> </body> </html> ';

    const consumer$1 = Class => class PostMessengerReceiver extends Class {
        constructor(...args) {
            super(...args);
            this.boundedEventListener = this.eventListener.bind(this);
        }
        // eslint-disable-next-line lines-between-class-members, no-unused-vars, class-methods-use-this
        messageHandler(dataArray, callback) {}

        eventListener(event) {
            const {data, source} = event;
            if (!Array.isArray(data)) {
                return;
            }
            const responseCallback = (...message) => responseTo(source, message);
            this.messageHandler(data, responseCallback);
        }

        register() {
            window.addEventListener('message', this.boundedEventListener);
            if (!window.parent || window.parent === window) {
                return;
            }
            responseTo(window.parent, ['init']);
        }
    };

    const producer$1 = Class => {
        let frames = null;
        // eslint-disable-next-line no-empty
        try { frames = new Set(); } catch (error) {}

        return class PostMessengerManager extends consumer$1(Class) {
            eventListener(event) {
                if (!frames) { return; }
                const {source} = event;
                try {
                    if (!frames.has(source.frameElement) && source !== window.parent) {
                        return;
                    }
                } catch (error) {
                    return;
                }
                super.eventListener(event);
            }

            register(settings) {
                if (!frames || !settings.iframe) {
                    return;
                }
                frames.add(settings.iframe);
                super.register();
            }
        };
    };

    var postMessenger_es6 = {
        consumer: consumer$1,
        producer: producer$1
    };

    function responseTo(contentWindow, message) {
        setTimeout(() => {
            contentWindow.postMessage(message, '*');
        }, 0);
    }

    const singleArrayReducer = (accumulate, array) => accumulate.concat(array);

    const recursiveRipping = rule => {
        try {
            if (!rule) {
                return [];
            }
            if (rule instanceof window.CSSFontFaceRule) {
                return [[rule.cssText]];
            }
            if (rule instanceof window.StyleSheetList) {
                return Array.from(rule).map(recursiveRipping).reduce(singleArrayReducer, []);
            }
            if (!rule.cssRules) {
                return [];
            }
            const baseArray = Array.from(rule.cssRules);
            if (!baseArray.length) {
                return [];
            }
            return baseArray
                .map(recursiveRipping)
                .filter(array => array.length)
                .map(array => {
                    const isMedia = rule instanceof window.CSSMediaRule;
                    const base = isMedia && rule.conditionText ? [`@media ${rule.conditionText}`] : [];
                    return array.map(i => base.concat(i));
                })
                .reduce(singleArrayReducer, []);
        } catch (error) {
            return [];
        }
    };

    const extractor = computedStyle => {
        if (!computedStyle) {
            return '';
        }
        return ['font', 'color'].map(key => (computedStyle[key] ? `${key}: ${computedStyle[key]};` : '')).join('');
    };

    const getAllFontFaces = () => recursiveRipping(window.document.styleSheets);

    const getFirstComputedStyles = () => {
        try {
            const array = [];
            const cta = document.querySelector('.video-cta-button');
            if (cta) {
                const ctaStyle = window.getComputedStyle(cta);
                if (ctaStyle) {
                    const target = '[taboola-cta]';
                    array.push([`*${target}${target}${target} {${extractor(ctaStyle)}}`]);
                }
            }
            const base = (cta && cta.closest && cta.closest('.video-label-box')) || document.querySelector('.video-label-box');

            const titleElement = (base && base.querySelector('.video-title')) || document.querySelector('.video-title');
            const title = titleElement && window.getComputedStyle(titleElement);
            if (title) {
                const target = '[taboola-title]';
                array.push([`*${target}${target}${target} {${extractor(title)}}`]);
            }
            const brandingElement = (base && base.querySelector('.branding-inner')) || document.querySelector('.branding-inner');
            const branding = brandingElement && window.getComputedStyle(brandingElement);
            if (branding) {
                const target = '[taboola-branding]';
                array.push([`*${target}${target}${target} {${extractor(branding)}}`]);
            }

            return array;
        } catch (error) {
            return [];
        }
    };

    const unzip = array => array.map(rule => rule.slice().reduceRight((string, text) => {
        if (!string) return text;
        return `${text}{${string}}`;
    })).join('\n');

    var styleInjector_utils_es6 = {
        getAllFontFaces,
        getFirstComputedStyles,
        unzip
    };

    const label = 'style-injector';

    const consumer = Class => {
        const styleElement = document.createElement('style');
        return class StyleRipper extends Class {
            messageHandler(data, callback) {
                super.messageHandler(data, callback);
                if (data[0] !== label) {
                    return;
                }
                try {
                    const styleDataArray = Array.isArray(data[1]) ? data[1] : [];
                    styleElement.innerHTML = unzip(styleDataArray);
                    document.head.appendChild(styleElement);
                    // eslint-disable-next-line no-empty
                } catch (error) {}
            }
        };
    };

    const producer = Class => {
        let styles = null;
        return class StyleRipper extends Class {
            messageHandler(data, callback) {
                if (data[0] === 'init') {
                    styles = styles || getAllFontFaces();
                    callback(label, getFirstComputedStyles().concat(styles));
                }
                super.messageHandler(data, callback);
            }
        };
    };

    var styleInjector_es6 = {
        consumer,
        producer
    };

    const classTreeFactory$1 = new ClassTreeFactory();
    const mainIframeConnector = classTreeFactory$1.mixin(producer, producer$1);

    (function() {
        var tbc = TRC.taboolaConnect = {};
        var listening = false;
        var cardMap = {};
        var isMobileSDK = !!(TRC && TRC.mobile && TRC.mobile.reportClick);
        var contentLoaderFileName = 'dynamic-content-loader';
        var htmlMetricReporter = metricReporter$1.sub('HTML');

        tbc.createIframe = function (options) {
            var container = options.container;
            var src = options.src;
            var config = options.config;

            if (!container){
                __trcError('could not find container to create Iframe within');
                tbc.reportMetrics({name: 'error-iframe_container_missing', isRtb: config.isRtb});
                return;
            }

            var _config = config || {};
            var id = Math.floor(Math.random() * 2147483648).toString(36);
            var frame = document.createElement('iframe');
            var enableLocalDcl = options.localDynamicContentLoader;
            mainIframeConnector.register({iframe:  frame});
            if (_config.attributes) {
                setAttributes(_config.attributes, frame);
            }

            frame.style.border = frame.frameBorder = frame.border = '0';
            frame.style.display = 'block';
            frame.style.height = (parseInt(config.height)) ? parseInt(config.height) + 'px' : '0px';
            frame.style.width = '100%';
            frame.scrolling = 'no';
            frame.sandbox = _config.sandbox || 'allow-same-origin allow-scripts allow-popups allow-forms';
            frame.isRtb = config.isRtb;


            if (_config.fifr) {
                frame.style.maxWidth = TRCImpl.global['html-card-max-width'] || '800px';
                frame.style.margin = '0 auto';
                frame.setAttribute('tbcId', id);
                frame.setAttribute('isMobileSDK',  isMobileSDK);
                tbc.reportMetrics({name: 'event-iframe_friendly', data: {id: id}, isRtb: config.isRtb});
                if (!config.isRtb && !TRC.Browser.ie) { // IF fifr, and not IE remove name attribute.
                    frame.name ='';
                }
                if (enableLocalDcl) {
                    frame.setAttribute('localDcl',  true);
                    frame.options = options;
                    frame.addEventListener('load', localDclIframeOnLoad);
                    tbc.reportMetrics({name: 'event-local_dcl', data: {id: id}, isRtb: config.isRtb});
                }
            } else {
                if (enableLocalDcl) {
                    setAttributes({
                        height: options.height,
                        width: options.width,
                        tbcId: id,
                        isMobileSDK:  isMobileSDK,
                        lang:  options.language || window.navigator.language,
                        localDcl: true
                    }, frame);
                    frame.options = options;
                    frame.addEventListener('load', localDclIframeOnLoad);
                    tbc.reportMetrics({name: 'event-local_dcl', data: {id: id}, isRtb: config.isRtb});
                }
                else {
                    src = setHashParams(src, {
                        tbcId: id,
                        lang: options.language || window.navigator.language
                    });
                    if (isMobileSDK) {
                        src = addHashParam(src, 'isMobileSDK', '' + isMobileSDK);
                    }
                    frame.src = src;
                }
                tbc.reportMetrics({name: 'event-iframe_non_friendly', data: {id: id, iframeSource: src}, isRtb: config.isRtb});
            }

            cardMap[id] = {
                'origin': options.origin,
                'placementName': options.placementName,
                'frame': frame,
                'config': config,
                'container': container,
                'backgroundContainer': options.backgroundContainer,
                'localDcl': options.localDynamicContentLoader,
                'signature': options.uniqueId
            };

            container.innerHTML = "";

            if (options.renderBannerAsNative){
                var adjustBannerHeight = TRC.util.isPercentEnabled(TRCImpl.global, 'adjust-banner-height') || !TRC.dom.isDesktop();
                TRC.dom.addClass(frame, adjustBannerHeight ? "tbl-banner-to-native-iframe" : "tbl-banner-to-native-iframe-desktop");
                var frameWrap = document.createElement('div');
                frameWrap.style.margin = 'auto';
                frameWrap.style.width = getIframeWidth(options);
                container.appendChild(frameWrap);
                frameWrap.appendChild(frame);
            } else {
                container.appendChild(frame);
            }

            // To be removed when rtb will use the same dynamic content loader.
            if (config.isRtb) {
                return frame;
            }

            if (_config.fifr && !enableLocalDcl) {
                if (TRC.Browser.ie) { // IF IE
                    tbc.lazyLoadDynamicContentLoader(frame);
                    return frame;
                }
                var contentToPassObj = createInitialPostMessageContent({config: _config});
                contentToPassObj.originalItemData = TRC.util.merge({}, options.itemData, {clickUrl: options.clickUrl});
                tbc.lazyLoadDynamicContentLoader(frame).then(function () {
                    tbc.postMessage(frame, contentToPassObj, '*');
                }).catch(function (error) {
                    tbc.reportMetrics({name: 'error-lazy_load_dcl_failed', data: {id: (options.itemData && options.itemData.id), error: error}, isRtb: config.isRtb});
                });
            }

            return frame;
        };

        tbc.lazyLoadDynamicContentLoader = function(frame){
            return new Promise$1(function(resolve, reject) {
                TRC.ModuleLoader.load(contentLoaderFileName, TRC.dcl, (function () {
                    var content  = frame.contentWindow || frame.contentDocument;
                    if(content) {
                        content.document.open();
                        content.document.write(TRC.dcl);
                        content.document.close();

                        // Make sure the script was written to the page by waiting for macroTask
                        window.setTimeout(function () {
                            resolve();
                        }, 0);
                    } else {
                        reject();
                    }
                }).trcBind(frame));
            });
        };

        tbc.receiveMessage = function (messageEvent) {
            var data = messageEvent.data;

            if (!data || !cardMap[data.id]) {
                return;
            }
            var config = cardMap[data.id].config || {};

            var compareOriginTo;
            if (config.origin !== undefined) {
                compareOriginTo = config.origin;
            } else {
                compareOriginTo = cardMap[data.id].localDcl || config.fifr === 'true' ? window.location.origin : cardMap[data.id].origin;
            }

            if (compareOriginTo !== messageEvent.origin) {
                tbc.reportMetrics({name: 'event-message_origin_different', data: {messageOrigin: messageEvent.origin, comparedOrigin: compareOriginTo}, isRtb: config.isRtb});
                return;
            }

            if (this[data.action]) {
                this[data.action](data.payload ? data.payload : {'sizeObject': data.sizeObject}, cardMap[data.id]);
            }
        };

        tbc.openInIframe = function(payload, card){
            var frame = card.frame, container = card.container;
            var data = payload.iframeArgs;
            var rboxObject = {
                isSmallIOS: function() {return TRCImpl['small-ios-device'].indexOf(TRC.Device.deviceType) >= 0;},
                getPublisherBrandingName: function() {return data.publisherName},
                trc: TRCImpl,
            };
            var videoObject = {
                title: data.title,
                url : data.logger_url,
                logger_url: data.logger_url,
            };
            new TRC.FeedView(rboxObject, videoObject, container);
            tbc.postMessage(frame, {"action": "openInIframe", "message": "openInIframe done", dimension: { "height": frame.style.height }}, '*');
        };

        function drawDisplayAdAsNativeBackgroundImage (options) {
            if (options.itemData && options.itemData.thumbnail) {
                var thumbnail = TRC.imageUtils.getImageUrlBasedOnCloudinaryApi(options.itemData.thumbnail, 'f_auto') || options.itemData.thumbnail;
                options.backgroundContainer.style['background-image'] = 'url("' + thumbnail + '")';
                TRC.dom.addClass(options.container, "tbl-banner-to-native");
                TRC.dom.addClass(options.container, "tbl-banner-to-native-hidden");
                TRC.dom.addClass(options.backgroundContainer, "tbl-banner-to-native-hidden");
            }
        }

        function setIframeHeight (options) {
            options.backgroundContainer.style.height = options.height + 'px';
            options.container.style.height = options.height + 'px';
        }
        function getIframeWidth (options) {
            return options.width ? options.width + "px" : '100%';
        }

        function eventsHandler (card, event) {
            if (event === "available"){
                TRC.dispatch("available::" + card.placementName + card.signature, {"container" : card.container});
            }
            if (event === "click"){
                TRC.dispatch("click::" + card.placementName);
            }
        }

        function getParameterFromUrl(url, param) {
            var getParameter = TRC.URL.prototype.getParameter;
            return getParameter.call(url, param);
        }


        function createInitialPostMessageContent (dataObj) {
            var contentToPass = {
                shouldInit: true,
                isRtb: dataObj && dataObj.config && dataObj.config.isRtb
            };

            try {
                if (!dataObj.config || !dataObj.config.attributes || !dataObj.config.attributes.name) {
                    return contentToPass;
                }

                contentToPass.contentString = dataObj.config.attributes.name;
                return contentToPass;
            } catch (e) {
                dataObj.config = dataObj.config || {};
                tbc.reportMetrics({name: 'error-creating_initial_post_message', data: {errorMessage: e}, isRtb: dataObj.config.isRtb});
                return contentToPass;
            }
        }

        function setAttributes(attributes, frame) {
            for (var i in attributes) {
                frame.setAttribute(i, attributes[i]);
            }
        }

        function setHashParams(src, attributes) {
            for (var i in attributes) {
                src = addHashParam(src, i, attributes[i]);
            }
            return src;
        }

        window.addHashParam = function (src, paramKey, paramValue) {
            var hashIndex = src.indexOf("#");
            var paramToAdd = paramKey + '=' + paramValue;
            if (hashIndex > 0) {
                var lastChar = src.slice(-1);
                paramToAdd = (lastChar === '&' || lastChar === '#') ? paramToAdd : '&' + paramToAdd;
                return src + paramToAdd
            }
            return src + '#' + paramToAdd
        };

        function setHeight(frame, card, sizeObject) {
            var maxHeight = card.config["max-height"] && parseInt(card.config["max-height"]);
            if(maxHeight && parseInt(sizeObject.height) > maxHeight) {
                sizeObject.height = maxHeight;
            }
            frame.height = frame.style.height = parseInt(sizeObject.height) + 'px';
        }

        function getRtbTextFromObj(obj) {
            obj = obj || {};
            switch(obj.isRtb) {
                case true:
                    return '-rtb';
                case false:
                    return '-non_rtb';
                default:
                    return '';
            }
        }

        function localDclIframeOnLoad (evt) {
            try {
                var content = this.contentWindow || this.contentDocument;
                var options = evt.currentTarget.options || {};
                this.removeEventListener('load', localDclIframeOnLoad);
                content.document.open();
                content.document.write(dynamicContentLoader);
                content.document.close();
                var contentToPassObj = createInitialPostMessageContent({config: options.config});
                contentToPassObj.originalItemData = TRC.util.merge({}, options.itemData, {clickUrl: options.clickUrl});
                tbc.postMessage(this, contentToPassObj, '*');
            } catch (e) {
                tbc.reportMetrics({
                    name: 'event-unfriendly-error-writing-dcl',
                    data: {errorMessage: e},
                    isRtb: options.config && options.config.isRtb
                });
            }
        }

        tbc.createRvObserver = function(options) {
            var itemObserver = {
                targetElement: options.container,
                rootMargin: options.rvMargin + "px",
                onEnter: (function () {
                    var container = options.videoBoxContainer || options.container;
                    if (TRC.dom.closest(container, '.tbl-invisible')){
                        return;
                    }
                    if (!options.maxPixelPerSecond || options.scrollManager.getPps() < parseInt(options.maxPixelPerSecond)) {
                        TRC.intersections.unobserve(options.container.getAttribute("displayRvTargetId"));
                        container.style.removeProperty('height');
                        this.createIframe(options);
                        if (options.renderBannerAsNative) {
                            options.videoBoxContainer.style.visibility = 'visible';
                            setIframeHeight(options);
                            drawDisplayAdAsNativeBackgroundImage(options);
                        }
                    }

                }).bind(this)
            };
            options.container.setAttribute("displayRvTargetId", TRC.intersections.observe(itemObserver));
        };

        tbc.getOrigin = function (src){
            return src.match(/^(https:|http:)?\/\/[^/]+/i)[0];
        };

        tbc.postMessage = function(frame, message, origin) {
            if (!frame.contentWindow) {
                tbc.reportMetrics({name: 'error-post_message_contentWindow_missing', data: {message: message, origin: origin}, isRtb: frame.isRtb});
            }

            frame.contentWindow.postMessage(message, origin);
        };

        tbc.rendered = function (payload, card) {
            var frame = card.frame, container = card.container, sizeObject = payload.sizeObject, backgroundContainer = card.backgroundContainer;
            setHeight(frame, card, sizeObject);
            if(TRC.dom.containsClass(container, "tbl-banner-to-native-hidden")){
                TRC.dom.removeClass(container, "tbl-banner-to-native-hidden");
                container.style.removeProperty('height');
            }
            TRC.dom.removeClass(backgroundContainer, "tbl-banner-to-native-hidden");
            container.className += ' tbl-feed-card';
            eventsHandler(card, "available");
            var postMessageObject = {"action": "rendered", "message": "rendered done", dimension: { "height": frame.style.height }};
            var startMagazinePublisherUrl = TRCImpl.global['start-magazine-url'];
            if (startMagazinePublisherUrl && card.origin === startMagazinePublisherUrl) {
                postMessageObject.publisherId = TRC.publisherId;
                postMessageObject.placementName = card.placementName;
            }
            tbc.postMessage(frame, postMessageObject, '*');
            var config = card ? (card.config || {}) : {};
            tbc.reportMetrics({name: 'event-rendered', isRtb: config.isRtb});
        };

        tbc.expand = function (payload, card) {
            var frame = card.frame, sizeObject = payload.sizeObject;
            setHeight(frame, card, sizeObject);
            tbc.postMessage(frame, {"action": "expand", "message": "expand done", dimension: { "height": frame.style.height }}, '*');
        };

        tbc.click = function (payload, card) {
            var frame = card.frame, sizeObject = payload.sizeObject;
            if (sizeObject) setHeight(frame, card, sizeObject);
            eventsHandler(card, "click");
            tbc.postMessage(frame, {"action": "click", "message": "click done", dimension: { "height": frame.style.height }}, '*');

            // When we load from Mobile Loader the TRC.mobile.reportClick function is available. the TBC will report the click
            // to Mobile Loader and it will update the SDK about the click.
            if (TRC.mobile && TRC.mobile.reportClick) {
                TRC.mobile.reportClick(payload.sizeObject);
            }
            var config = card ? (card.config || {}) : {};
            tbc.reportMetrics({name: 'event-clicked', isRtb: config.isRtb});
        };

        tbc.collapse = function (payload, card) {
            var frame = card.frame, sizeObject = payload.sizeObject;
            setHeight(frame, card, sizeObject);
            tbc.postMessage(frame, {"action": "collapse", "message": "collapse done", dimension: { "height": frame.style.height }}, '*');
        };

        tbc.maxHeight = function (payload, card) {
            var frame = card.frame, message = card.config["max-height"] ? card.config["max-height"] : "";
            tbc.postMessage(frame, {"action": "maxHeight", "message": message, dimension: { "height": frame.style.height }}, '*');
        };

        tbc.createCard = function (options) {
            tbc.reportMetrics({name: 'event-available', isRtb: options.config.isRtb});

            /* in case of friendly iframe config, no need to check or change its origin */
            if(!options.config.fifr){
                var origin = this.getOrigin(options.config.origin || options.src);

                if (!origin) {
                    __trcError('non valid origin for third party card');
                    tbc.reportMetrics({name: 'error-invalid_third_party_card_origin', isRtb: options.config.isRtb});
                    return;
                }
            }

            if (!listening){
                window.addEventListener("message", this.receiveMessage.bind(this), false);
                listening = true;
            }

            if (options.rvMargin) {
                if (options.maxPixelPerSecond) {
                    var container = options.videoBoxContainer || options.container;
                    options.scrollManager = new ScrollManager();
                    container.style.height = 0;
                }
                options.container.style.height = options.height + "px";
                this.createRvObserver(TRC.util.merge({}, options, {origin: origin}));
            } else {
                this.createIframe(TRC.util.merge({}, options, {origin: origin}));
                if(options.renderBannerAsNative){
                    setIframeHeight(options);
                    drawDisplayAdAsNativeBackgroundImage(options);
                }
            }
        };

        tbc.error = function(payload, card) {
            __trcWarn('External error report to taboola-connect: ' + payload);
            var config = card ? (card.config || {}) : {};
            tbc.reportMetrics({name: 'error-external', data: payload, isRtb: config.isRtb});
        };

        tbc.reportMetrics = function (reportObj, card) {
            try {
                if (!TRC.util || !TRCImpl.global || !TRC.util.isPercentEnabled(TRCImpl.global, 'html-track-events') || (typeof reportObj !== 'object')) {
                    return;
                }

                var rtbText = getRtbTextFromObj(reportObj);

                if (!rtbText && card && card.config) {
                    rtbText = getRtbTextFromObj(card.config);
                }

                htmlMetricReporter.sendRboxMetricsEvent({eventName: reportObj.name + rtbText, value: '1', type: 'counter'});
                htmlMetricReporter.logUsage({file: 'taboola-connect.js', extraData: {eventName: reportObj.name + rtbText, data: (reportObj.data || null)}});
            } catch (e) {}
        };

        /* public methods for UT */
        if (window._trcIsUTactive){
            TRC.taboolaConnect.addHashParam = addHashParam;
        }

    })();

    class TasksExecutorQueue {
        constructor() {
            this.tasks = [];
            this.runningTask = null;
        }

        add(task) {
            this.tasks.push(task);
            if (this.tasks.length === 1) {
                this.callNext();
            }
            return this;
        }

        callNext() {
            if (this.tasks.length) {
                if (typeof this.tasks[0] === 'function') {
                    [this.runningTask] = this.tasks;
                    let doneTask = false;
                    const done = () => {
                        if (!doneTask) {
                            doneTask = true;
                            this.tasks.shift();
                            this.callNext();
                        }
                    };
                    this.runningTask.cancel = () => { doneTask = true; };
                    this.runningTask(done);
                } else {
                    this.tasks.shift();
                    this.callNext();
                }
            }
        }

        resetQueue() {
            // prevent calling next task, by tasks that were cleared from the queue
            if (this.runningTask) {
                this.runningTask.cancel();
            }
            this.tasks = [];
        }
    }

    TRC.TasksExecutorQueue = TasksExecutorQueue;

    (function (/* win, doc */) {
        /**
        * Text utilities
        */
        TRC.text = {

            /**
             * replace all instance of replace string(converted to regex) with a string or a function
             * @param  {String} target
             * @param {String} replace - (converts to a regex - can use a string in a regex syntax)
             * @param {String, Function} to - if a function then invoked to return the replacement string
             * @param {Object} to_bind - a object to bind the function
             * @return {String}
             */
            replaceAll(target, replace, to, toBind) {
                let regx;
                if ((typeof replace) !== 'undefined' && (typeof to) !== 'undefined' && replace !== to) {
                    regx = new RegExp(replace, 'gi');
                    return target.replace(regx, (typeof to === 'function' && typeof toBind === 'object') ? to.trcBind(toBind) : to);
                }
                return target;
            },

            /**
             * A utility split method to augment String.split by limiting the number of elements in the output
             * @param text String to split
             * @param delimiter Text string to split on. This can't be a regular expression!
             * @param limit maximum number of elements to return in the array - the last element will
             * contain all the remaining text after the n-1 delimiter, including any extra delimiters not removed
            */
            lsplit(text, delimiter, limit) {
                const t = text.split(delimiter);
                return t.slice(0, limit - 1).concat(t.length >= limit ? t.slice(limit - 1).join(delimiter) : []);
            },

            /**
             * Read an RFC 4180 formatted single record of data and return an array of the values encoded in that line.
             * Note - this implementation relies on the fact that the text provided is a single record so it can assume all
             * new lines in the text are part of an encoded value.
             * @param csv a single record from an RFC 4180 encoded file
             * @returns Array of string values
             */
            parseCSV(csv) {
                const parts = csv.split(',');
                const out = [];
                while (parts.length) {
                    let cur = parts.shift();
                    if (cur[0] !== '"') { // not quoted
                        out.push(cur);
                        continue;
                    }

                    // a quoted string. Figure out if it closes
                    do {
                        if (cur.slice(1).replace(/""/g, '').slice(-1) === '"') {
                            // the quoted string is full enclosed in this part, no need to reparse
                            break;
                        }
                        cur += `,${parts.shift()}`;
                    } while (parts.length);
                    out.push(cur.slice(1, cur.length - 1).replace(/""/g, '"'));
                }
                return out;
            },

            /**
             * A utility to convert any truthy value to a list of strings that are all truthy.
             * * @param data mixed any value
             * * @return Array
             * @type Array
             */
            toStringList(data) {
                if (!data) { return []; }
                if (!(data instanceof Array)) { return [`${data}`]; }
                const out = [];
                data.forEach(i => {
                    if (!i) return;
                    out.push(`${i}`);
                });
                return out;
            },
            /**
             * esacpe html encoded text
             * @param value
             * @returns {string}
             */
            htmlUnescape(value) {
                return String(value)
                    .replace(/&quot;/g, '"')
                    .replace(/&#39;/g, '\'')
                    .replace(/&#34;/g, '"')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&amp;/g, '&');
            },

            encodeHTML(text, options = {}) {
                if (typeof text !== 'string') {
                    return false;
                }

                if (!options.ignoreAmpersand) {
                    text = text.replace(/&/g, '&amp;');
                }

                return text.replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            },

            /**
             * kebab-case to UpperCamelCase
             * @param {String} string
             * @return {String}
             */
            toLowerCamelCase(str) {
                if (str.indexOf('-') === -1) { return str; }
                const upperCaseStr = str.toLowerCase()
                    .split('-')
                    .map(str => str.charAt(0).toUpperCase() + str.substr(1))
                    .join('');
                return upperCaseStr.charAt(0).toLowerCase() + upperCaseStr.substr(1);

            },

            splitAndJoin(str, func) {
                let x = str.split('.');
                x = x.map(camelString => func(camelString));
                x = x.join('.');
                return x;
            },

            /**
             * checks is string end with other string
             * @return {Boolean} true if the text is the string suffix, false otherwise
             * @param str
             * @param search
             */
            isEndWith(str, search) {
                if (!String.prototype.endsWith) {
                    const {length} = str;
                    return str.substring(length - search.length, length) === search;
                }

                return str.endsWith(search);
            }
        };
    }(window, document));

    (() => {
        let cssLoaded = false;
        const CP = {
            POSITION: {
                SPONSORED: 'syndicated-static-text-position',
                ORGANIC: 'organic-static-text-position',
                EMBLEM: 'emblem-position'
            },
            TEXT: {
                SPONSORED: 'syndicated-static-text',
                ORGANIC: 'organic-static-text'
            },
            SHOW_ORGANIC_FIXED_LABEL: 'organic-show-static-text',
            EMBLEM: 'emblem'
        };
        const CLASS_NAMES = {
            EMBLEM_WRAPPER: 'thumbnail-emblem',
            STATIC_TEXT: 'static-text',
            FIXED_LABEL: 'tbl-fixed-label',
            BIG_LABEL: 'tbl-big-label',
            SMALL_LABEL: 'tbl-small-label'
        };
        
        class ThumbnailOverlayComponents {
            constructor(thumbBlock, isSyndicated, rbox) {
                const {
                    categoryCard, recommendationList, add_span: addSpan
                } = rbox;
                
                const modeType = isSyndicated ? 'SPONSORED' : 'ORGANIC';
                
                this.categoryCard = categoryCard; 
                this.getModeClientProperty = rbox.getModeClientProperty.trcBind(rbox);
                this.size = recommendationList && recommendationList.length;
                this.addSpan = addSpan;
                this.emblemSrc = this.getModeClientProperty(CP.EMBLEM);
                this.fixedLabelPosition = this.getFixedLabelPosition(isSyndicated, CP.POSITION[modeType]);
                this.fixedLabelText = this.getModeClientProperty(CP.TEXT[modeType]);

                if (this.emblemSrc && this.emblemSrc !== 'null') {
                    ThumbnailOverlayComponents.setCss();
                    this.emblemPosition = this.getModeClientProperty(CP.POSITION.EMBLEM) || 'top-left';
                    this.addEmblem(thumbBlock, modeType);
                }
                
                /* add fixed label if emblem didn't rendered or emblem rendered on different position  */
                if (!this.emblemRenderd || this.isEmblemAndTextNotOnSamePosition()) {
                    if (this.categoryCard && this.categoryCard.isCategoryCard && !this.categoryCard.render) {
                        return; // disable creating label because it's category card but something went wrong so we don't need to render it
                    }
                    this.addFixedLabel(thumbBlock, isSyndicated);
                }
            }

            static setCss() {
                if (!cssLoaded) {
                    cssLoaded = true;
                    TRC.dom.injectStyle(`.thumbnail-emblem { height: 35px; width: 35px; }.trc_related_container .thumbnail-emblem.bottom-right, .trc_related_container .static-text.bottom-right { bottom: 0; right: 0; background-position: bottom; }.trc_related_container .thumbnail-emblem.top-right, .trc_related_container .static-text.top-right { top: 0; right: 0; background-position: top; }.trc_related_container .thumbnail-emblem.bottom-left, .trc_related_container .static-text.bottom-left { bottom: 0; left: 0; background-position: bottom; }.trc_related_container .thumbnail-emblem.top-left, .trc_related_container .static-text.top-left { top: 0; left: 0; background-position: top; }.trc_related_container .thumbnail-emblem.top, .trc_related_container .static-text.top { width: 100%; top: 0; }.trc_related_container .thumbnail-emblem.bottom, .trc_related_container .static-text.bottom { width: 100%; bottom: 0; padding: 2px 0; }.trc_related_container .videoCube .thumbBlock .static-text { position: absolute; z-index: 1; margin: 0; padding: 5px; display: block; opacity: 0.7; } .trc_related_container .videoCube .thumbBlock .static-text.tbl-fixed-label { opacity: 1; padding: 0 5px; text-align: center; } .trc_related_container .videoCube .thumbBlock .static-text.tbl-fixed-label.tbl-small-label { min-width: 107px; min-height: 27px; line-height: 27px; letter-spacing: 0.31px; } .trc_related_container .videoCube .thumbBlock .static-text.tbl-fixed-label.tbl-big-label { min-width: 140px; min-height: 33px; font-size: 14px; line-height: 33px; letter-spacing: 0.39px; }.trc_related_container .thumbnail-emblem { background-position-x: center; }`);
                }
            }
            
            isEmblemAndTextNotOnSamePosition() {
                return this.emblemRenderd && this.fixedLabelPosition !== this.emblemPosition;
            }
            
            addEmblem(thumbBlock) {
                this.emblemRenderd = true;
                const emblem = this.addSpan(CLASS_NAMES.EMBLEM_WRAPPER, null, thumbBlock);
                emblem.style.backgroundImage = `url('${this.emblemSrc}')`;
                TRC.dom.addClass(emblem, this.emblemPosition);
            }

            addFixedLabel(thumbBlock, isSyndicated) {
                // for some reason we always rendering this label for sponsored item, can we stop doing this if there's no value?
                const classNames = [CLASS_NAMES.STATIC_TEXT],
                    labelContainer = document.createElement('span');

                if (!isSyndicated) {
                    const showOrganicStaticText = this.getModeClientProperty(CP.SHOW_ORGANIC_FIXED_LABEL);
                    if (!showOrganicStaticText) {
                        return;
                    }

                    classNames.push(CLASS_NAMES.FIXED_LABEL);
                    classNames.push(this.size === 1 ? CLASS_NAMES.BIG_LABEL : CLASS_NAMES.SMALL_LABEL);

                    if (this.categoryCard && this.categoryCard.render) {
                        this.fixedLabelText = this.categoryCard.text;
                    }
                }

                /* first time we know we need to render fixed label
                 so we can add the css if it's not rendered already from other item or by emblem */
                ThumbnailOverlayComponents.setCss();
                classNames.push(this.fixedLabelPosition);
                labelContainer.className = classNames.join(' ');
                this.fixedLabelText && labelContainer.appendChild(document.createTextNode(this.fixedLabelText));
        
                thumbBlock.appendChild(labelContainer);
            }
            
            getFixedLabelPosition(isSyndicated, property) {
                const defaultPosition = isSyndicated ? 'top-right' : 'bottom-left';
                return this.getModeClientProperty(property) || defaultPosition;
            }
        }
        
        TRC.ThumbnailOverlayComponents = ThumbnailOverlayComponents;
    })();

    (win => {
        const TIME_ON_DATA_KEY = 'tn_t_on';
        const _sessionStorage = TRC.pageManager.getLocalStorageImplementation('strict-w3c-storage', 'session');
        let timeOnData = TRC.taboolaNews && TRC.taboolaNews.timeOn;
        let valueInStorage = false;

        if (!timeOnData && _sessionStorage) {
            try {
                timeOnData = JSON.parse(_sessionStorage.getValue(TIME_ON_DATA_KEY));
                valueInStorage = true;
            } catch (e) {
                __trcError('Error occurred while trying to read Taboola News data from SessionStorage but object data was corrupted.');
            }
        }
        if (!timeOnData) {
            return;
        }
        if (!valueInStorage && _sessionStorage) {
            _sessionStorage.setValue(TIME_ON_DATA_KEY, JSON.stringify(timeOnData));
        }

        function getFirstTime() {
            const CurrentTime = (new Date()).getTime();
            if (TRC.isAMP) {
                try {
                    const TimeFromPageStart = JSON.parse(win.context.ca).attributes._context.initialIntersection.time || CurrentTime;
                    return new Date(win.context.startTime - TimeFromPageStart);
                } catch (e) {
                    return CurrentTime;
                }
            } else {
                return (win.performance && win.performance.timing && win.performance.timing.navigationStart) || CurrentTime;
            }
        }

        let timePageVisible = getFirstTime();
        let timePageHidden = -1;
        let reportIndex = 0;

        function handleVisibilityChange(isVisible) {
            if (isVisible) {
                timePageVisible = (new Date()).getTime();
            } else {
                timePageHidden = (new Date()).getTime();
                reportIndex += 1;
                TRCImpl.sendAbTestEvent && TRCImpl.sendAbTestEvent('taboola_news_timeon', `${reportIndex.toString()}::${(timePageHidden - timePageVisible).toString()}`, null, true);
            }
        }

        TRC.docVisibilityUtil.addEventListener(handleVisibilityChange);
    })(window);

    /**
     * tracking-script-loader.js
     * This module is responsible for adding script tags for an Rbox video item (controlled by TRC)
     *
     * Created by Oded.B 10/7/17
     */

    (function () {
        /**
         * Add script tags to a given videoBoxContainer
         * @param videoBoxContainer - Single video item object to which the script tags should be added
         * @param jsScriptTagList - Array of js script tags
         */
        function addScriptWithTagToContainer(scriptUrl) {
            var scriptElement = document.createElement("script");
            scriptElement.setAttribute('async','');
            scriptElement.setAttribute('src',scriptUrl);
            return scriptElement;
        }

        /**
         * Add iframe or script tags to a given videoBoxContainer
         * @param videoBoxContainer - Single video item object to which the script tags should be added
         * @param jsScriptTagList - Array of js script tags
         */
        function addTagsToContainer(videoBoxContainer, jsScriptTagList) {
            var span = document.createElement("span"), //append the iframe to a span - avoids issues in IE
                tag = "";
            decorateElement(span, "span");
            for (var i = 0; i < jsScriptTagList.length; i++) {
                if (jsScriptTagList[i].tag && jsScriptTagList[i].tag.useScript) {
                    tag = addScriptWithTagToContainer(jsScriptTagList[i].tag.url);
                } else {
                    tag = getIFrameWithOnloadScripts(jsScriptTagList[i].tag || jsScriptTagList[i], videoBoxContainer);
                }
                span.appendChild(tag);
            }
            videoBoxContainer.appendChild(span);
        }

        /**
         * Return an iframe with onload event that creates the js script tags in it's body when loaded
         * @param verificationTag - a verification tag
         * @param videoBoxContainer - reference to the item container
         */
        function getIFrameWithOnloadScripts(verificationTag, videoBoxContainer) {
            var iFrame = document.createElement("iframe");
            decorateElement(iFrame, "iFrame");

            if (!verificationTag || !videoBoxContainer) {
                return iFrame;
            }

            if (verificationTag && verificationTag.trackableObject) {
                iFrame.src = "javascript:'<html><head></head><body>" + verificationTag.html + verificationTag.trackableObject +"</body></html>'";
                TRC.dom.on(iFrame, 'load', function () {
                    /*MOAT trackable object */
                    if (verificationTag.trackableObject.indexOf("moat_trackable") > -1) {
                        dispatchMoatAdLoadedEvent(TRC.TrackingScriptLoader.prepareMoatTrackableObject(iFrame, videoBoxContainer));
                    }
                });
            } else if (verificationTag.html) {
                iFrame.src = "javascript:'<html><head></head><body>" + verificationTag.html + "</body></html>'";
            } else {
                iFrame.src = "javascript:'<html><head></head><body>" + verificationTag + "</body></html>'";
            }

            return iFrame;
        }

        /**
         * Dispatches an event called adLoaded on a trackable object
         * @param trackableObject - the element who dispatches the event
         */
        function dispatchMoatAdLoadedEvent(trackableObject) {
            if (trackableObject) {
                try {
                    __trcDebug("dispatching adLoaded event for MOAT");
                    trackableObject.dispatchEvent(new CustomEvent("adLoaded", {
                        bubbles: true,
                        cancelable: false
                    }));
                } catch (e) {}
            }
        }

        function addUniqueTagIdToVideoBoxClass(videoBoxContainer, viewabilityTagId) {
            try {
                TRC.dom.addClass(videoBoxContainer, viewabilityTagId);
            } catch (e) {
                __trcError('Error occurred while trying to add tblUniqueTagId To Relevant videoBoxContainer');
            }
        }

        function setTagDetailsToRelevantTags(jsScriptTagList, viewabilityTagId, useUrlsConfig) {
            var newJsTagMap, newTagsList = [];
            try {
                for (var i = 0; i < jsScriptTagList.length; i++) {
                    newJsTagMap = TRC.TrackingScriptIdAppender && TRC.TrackingScriptIdAppender.setTagDetails(jsScriptTagList[i], viewabilityTagId, useUrlsConfig);
                    newTagsList.push(newJsTagMap);
                }
            } catch (e) {
                __trcError('Error occurred while trying to add tblUniqueTagId To Relevant Js Tags');
                return jsScriptTagList;
            }
            return newTagsList;
        }

        function decorateElement(elem, elemName) {
            elem.id = 'script-tracking-' + elemName + '-' + parseInt(Math.random() * 10000, 10);
            elem.name = elem.id;
            elem.width = 0;
            elem.height = 0;
            elem.style.display = "none";
        }

        TRC.TrackingScriptLoader = {

            TRC_SCRIPT_TAGS_ATTRIBUTE: 'viewability-tags',

            /**
             * Render the script tag - adds the tag to every video cube
             * @param videoBoxContainer -         Single video item object to which the script tags should be added
             * @param recommendation -   a recommendation object that holds the script tags links
             * @param viewabilityTagId - a unique ID composed of placementName + slotIndex
             */
            renderScriptTagIntoVideoBox: function (videoBoxContainer, recommendation, viewabilityTagId, useUrlsConfig, lazyLoadTagsMargin, isRv) {
                try {
                    if (videoBoxContainer && recommendation && recommendation[this.TRC_SCRIPT_TAGS_ATTRIBUTE] && recommendation[this.TRC_SCRIPT_TAGS_ATTRIBUTE].length > 0) {
                        var tagDetailsList = setTagDetailsToRelevantTags(recommendation[this.TRC_SCRIPT_TAGS_ATTRIBUTE], viewabilityTagId, useUrlsConfig);
                        addUniqueTagIdToVideoBoxClass(videoBoxContainer, viewabilityTagId);
                        if (!TRC.MobileSdk.isEnabled()) {
                            if (isRv && lazyLoadTagsMargin) {
                                var lazyLoadTagsObserverParams = {
                                    targetElement: videoBoxContainer,
                                    rootMargin: lazyLoadTagsMargin + "px",
                                    onEnter: (function() {
                                        addTagsToContainer(videoBoxContainer, tagDetailsList);
                                        TRC.intersections.unobserve(videoBoxContainer.getAttribute("lazyLoadTagsObserverTargetId"));
                                    }).bind(this)
                                };
                                videoBoxContainer.setAttribute("lazyLoadTagsObserverTargetId", TRC.intersections.observe(lazyLoadTagsObserverParams));
                            } else {
                                addTagsToContainer(videoBoxContainer, tagDetailsList);
                            }
                        }
                    } else {
                        __trcDebug('renderScriptTagIntoVideoBox: videoBoxContainer/recommendation is null or TRC_SCRIPT_TAGS_ATTRIBUTE not exist');
                    }
                } catch (e) {
                    __trcError('failed to add JS script tracking - ' + e.message);
                }
            },

            /**
             * adds a moatObject to the trackable object with reference to the videoBoxContainer
             * @param iFrame - iframe reference to find the trackable object
             * @param videoBoxContainer - reference to the videoBoxContainer we add to the moatObject
             */
            prepareMoatTrackableObject: function(iFrame, videoBoxContainer) {
                if (iFrame && iFrame.contentDocument && videoBoxContainer) {
                    var trackableObject;
                    trackableObject = iFrame.contentDocument.querySelector('.moat_trackable');
                    if (!trackableObject) {
                        return;
                    }
                    trackableObject.moatObject = {
                        adElement: videoBoxContainer,
                        adLoaded: 1,
                        creativeType: 'banner',
                        versions: '1'
                    };
                    return trackableObject;
                } else {
                    __trcError('Error occurred while trying to prepare trackable object for MOAT');
                }
            }
        };
    })();

    /**
     ** tracking-scripts-id-appender.js
     *  This module is responsible for adding unique id parameter to the tag URL, using the corresponding handler
     *  Created by Liran.s 04/7/19
     */

    (function () {
        var

            /** IAS Properties */
            IAS_DOMAIN = 'adsafeprotected.com',
            IAS_PARAM_NAME = 'ias_adpath',
            IAS_UNIQUE_PARAM = '.{uniqueId}',
            SCRIPT_TAG_DOMAIN_CONST = '></script>',

            /** DV Properties */
            DV_DOMAIN = 'cdn.doubleverify.com',
            DV_PARAM_NAME = 'btreg',

            /** DCM Properties - we dont replace params in DCM we just extract the url */
            DCM_DOMAIN = 'doubleclick.net',

            /** MOAT Properties */
            MOAT_DOMAIN = 'z.moatads.com',
            MOAT_PARM_NAME = 'taboolaTrackable',

            /** xandr Properties */
            XANDR_DOMAIN = 'cdn.adnxs.com',
            XANDR_PARAM_NAME = 'dom_id',
            XANDR_UNIQUE_PARAM_FORMAT = ';css_selector=.{uniqueId}',

            /** adloox */
            ADLOOX_DOMAIN = 'j.adlooxtracking.com',
            ADLOOX_PARAM_NAME = 'targetelt',
            ADLOOX_UNIQUE_PARAM_FORMAT = '.{uniqueId}',

            /** Handler Constants */
            SRC_VALUE_REGEX_PATTERN = '(src|SRC)\\s*=\\s*"?(.+?)\\"|\\|s>',
            paramRgexTemplate = '({paramName}=.*?)(&|$|;)',
            srcAttributeValueRegex = new RegExp(SRC_VALUE_REGEX_PATTERN),
            trackingCodeHandlers = [
                new ViewabilityTagHandler(IAS_DOMAIN, IAS_PARAM_NAME, IAS_UNIQUE_PARAM, iasTagUrlExtractor, false, null),
                new ViewabilityTagHandler(DV_DOMAIN, DV_PARAM_NAME, null, dvTagUrlExtractor, false,  null),
                new ViewabilityTagHandler(MOAT_DOMAIN, MOAT_PARM_NAME, null, moatTagUrlExtractor, true, createMoatTrackableDiv),
                new ViewabilityTagHandler(DCM_DOMAIN, null, null, dcmTagUrlExtractor, false,  null),
                new ViewabilityTagHandler(XANDR_DOMAIN, XANDR_PARAM_NAME, XANDR_UNIQUE_PARAM_FORMAT, xandrTagUrlExtractor, false,  null),
                new ViewabilityTagHandler(ADLOOX_DOMAIN, ADLOOX_PARAM_NAME, ADLOOX_UNIQUE_PARAM_FORMAT, adlooxTagUrlExtractor, false,  null)
            ];

        function ViewabilityTagHandler(tagDomain, tagParamName, uniqueParamFormat, tagUrlExtractor, hasTrackableObject, trackableObjectCreator) {
            this.tagDomain = tagDomain;
            this.tagParamName = tagParamName;
            this.uniqueParamFormat = uniqueParamFormat;
            this.tagUrlExtractor = tagUrlExtractor;
            this.hasTrackableObject = hasTrackableObject;
            this.trackableObjectCreator = trackableObjectCreator;
        }

        ViewabilityTagHandler.prototype.isMatchingTagDomain = function (tag) {
            return tag.indexOf(this.tagDomain) !== -1;
        };

        ViewabilityTagHandler.prototype.shouldAddTrackableObject = function () {
            return this.hasTrackableObject;
        };

        ViewabilityTagHandler.prototype.appendId = function (tag, uniqueId) {
            try {
                var tagUrl = this.tagUrlExtractor(tag);
                var newUrl = "";
                if (tagUrl) {
                    if (this.tagParamName) {
                        uniqueId = this.formatUniqueId(uniqueId);
                        var placeholder = getParamPlaceHolder(this.tagParamName, tagUrl);
                        // try to locate the param in the tag url and replace it with the param(=) + uniqueId string. if not just add it to the end of url
                        if (placeholder) {
                            newUrl = tagUrl.replace(placeholder, this.tagParamName + '=' + uniqueId);
                        } else {
                            newUrl = tagUrl + this.getUrlParamsSeparator(tagUrl) + this.tagParamName + '=' + uniqueId;
                        }
                        return { html: tag.replace(tagUrl, newUrl), url: newUrl };
                    } else {
                        return { html: tag, url: tagUrl };
                    }
                }
            } catch (e) {
                __trcWarn('failed to append unique Id to a specific tag: ' + tag);
                return tag;
            }
            return tag;
        };

        function getParamPlaceHolder(paramName, url) {
            var paramNameMacro = "{paramName}";
            var match = url.match(new RegExp(TRC.text.replaceAll(paramRgexTemplate, paramNameMacro, paramName,null)));
            if (match) {
                return match[1] || match[0] || null; // match[1] will not include '&' sperator
            }
            return null;
        };


        ViewabilityTagHandler.prototype.extractSrcValue = function (tag) {
            var regexResult = srcAttributeValueRegex.exec(tag),
                srcTagUrl = regexResult[regexResult.length - 1];

            return srcTagUrl.replace(/^"+|"+$/g, '');
        };

        ViewabilityTagHandler.prototype.formatUniqueId = function (uniqueId) {
            if (!this.uniqueParamFormat) {
                return uniqueId;
            }

            return this.uniqueParamFormat.replace('{uniqueId}', uniqueId);
        };

        ViewabilityTagHandler.prototype.getUrlParamsSeparator = function (tagURL) {
            if (tagURL.indexOf('?') !== -1 || tagURL.indexOf('#') !== -1) {
                return '&';
            }

            return '?';
        };

        ViewabilityTagHandler.prototype.createTrackableObject = function () {
            return this.trackableObjectCreator();
        };

        function iasTagUrlExtractor(tag) {
            var scriptLocation = tag.indexOf(SCRIPT_TAG_DOMAIN_CONST),
                tagScript = tag.slice(0, scriptLocation);

            return this.extractSrcValue(tagScript);
        }

        function dvTagUrlExtractor(tag) {
            return this.extractSrcValue(tag);
        }

        function moatTagUrlExtractor(tag) {
            return this.extractSrcValue(tag);
        }

        function dcmTagUrlExtractor(tag) {
            return this.extractSrcValue(tag);
        }

        function xandrTagUrlExtractor(tag) {
            return this.extractSrcValue(tag);
        }

        function  adlooxTagUrlExtractor(tag) {
            return this.extractSrcValue(tag);
        }

        function createMoatTrackableDiv() {
            return "<div class=\"moat_trackable\" style=\"display: none;\"></div>";
        }

        TRC.TrackingScriptIdAppender = {
            /**
             * Add unique id to the tag URL by the corresponding handler and adds a trackable object to relevant tags
             * @param tag - Single viewability tag that will be extended with unique id param
             * @param uniqueId - string that represents the creative element and will be appended to the corresponding tag
             */
            setTagDetails: function (tag, uniqueId, useUrlsConfig) {
                if (!tag || !uniqueId) {
                    return tag;
                }
                for (var i = 0; i < trackingCodeHandlers.length; i++) {
                    var handler = trackingCodeHandlers[i];
                    if (handler.isMatchingTagDomain(tag)) {
                        var tagObjectMap = {};
                        tagObjectMap.tag = handler.appendId(tag, uniqueId);
                        if (useUrlsConfig && trackingCodeHandlers[i].tagDomain in useUrlsConfig) {
                            tagObjectMap.tag.useScript = true;
                        }
                        if (handler.shouldAddTrackableObject()) {
                            tagObjectMap.tag.trackableObject = handler.createTrackableObject();
                        }

                        return tagObjectMap;
                    }
                }
                return tag;
            }
        };
    })();

    (() => {
        const STOP_TRANSLATIONS = 'stop_tslt';
        const customTranslations = {};
        let dynamicTranslations = {};
        let cachedTranslations = {};

        TRC.translationManager = {
            getLabel: options => {
                const featureName = options.feature;
                if (!dynamicTranslations[featureName] && !customTranslations[featureName]) {
                    return undefined;
                }
                const {cached, translation, translationId} = getCachedTranslation(options);
                if (cached) {
                    return translation;
                }
                const translatedLabel = getTranslation(featureName, options);
                if (!translatedLabel) {
                    return undefined;
                }
                cachedTranslations[translationId] = translatedLabel;
                return translatedLabel;
            },
            setTranslations: translationMap => {
                if (!translationMap || !TRC.util.hasKeys(translationMap)) {
                    return;
                }
                dynamicTranslations = translationMap;
                cachedTranslations = {};
                // this will kill the translations feature on the server side for next batches.
                TRC.pageLevelFeaturesManager.pageLevelFeatures[STOP_TRANSLATIONS] = true;
            },
            register: (featureName, customTranslation) => {
                customTranslations[featureName] = customTranslation;
            }
        };

        /**
         * if requested label was processed before, returns the previous computation,
         * if not, will return a translation id by concatenating options values
         * @param options
         * @returns {{cached: boolean, translation: string}|{cached: boolean, translation: *}}
         */
        function getCachedTranslation(options) {
            const {feature, label = '', data = []} = options;
            const translationId = feature + label + JSON.stringify(data);
            const translation = cachedTranslations[translationId];
            if (translation) {
                return {cached: true, translation};
            }
            return {cached: false, translationId};
        }

        function getTranslation(featureName, options) {
            const translationMap = getTranslationMap(featureName);
            const {label, data} = options;
            const labelSpecificTranslation = translationMap[label];
            if (labelSpecificTranslation) {
                if (data) {
                    return TRC.util.formatString(labelSpecificTranslation, data);
                }
                return labelSpecificTranslation;
            }
            return translationMap;
        }

        function getTranslationMap(featureName) {
            const dynamicTranslationMap = dynamicTranslations[featureName];
            if (dynamicTranslationMap) {
                return dynamicTranslationMap;
            }
            __trcWarn(`TRC.TranslationsManager - missing feature in translationMap: ${featureName}.`);
            return customTranslations[featureName];
        }

        function registerCustomTranslation(data) {
            Object.keys(data).forEach(translationKey => {
                TRC.translationManager.register(translationKey, data[translationKey]);
            });
        }

        if (!TRC._translationQueue) {
            TRC._translationQueue = [];
        }

        TRC._translationQueue.forEach(registerCustomTranslation);
        TRC._translationQueue.push = registerCustomTranslation;
    })();

    (win => {

        win.TRC = win.TRC || {};
        const DISABLE = 'disable';
        const DEFAULT_DELAY = 0;
        let ui;
        let sd;

        class TRCBulkLogger {

            constructor(bulkEventName) {
                this.bulkingStrategy = {
                    delay: (() => {
                        let delayedEvents = [];
                        const delayFunction = (host, type, bulkParams, explicitPublisherId, queryParams) => {
                            delayedEvents.push(bulkParams);
                            if (delayedEvents.length === 1) {
                                setTimeout(() => {
                                    const bulkBuiltParams = TRCBulkLogger.buildParamsForBulkEvent(delayedEvents);

                                    queryParams = queryParams || {};
                                    queryParams.bulkSize = delayedEvents.length;
                                    if (TRC.util.isPercentEnabled(TRCImpl.global, 'bulk-body-debug-sample-rate')) {
                                        // See DEV-70979
                                        const bulkEvents = bulkBuiltParams.events;

                                        TRC.RBoxUsage.logUsage('Debug body size of bulk events', {
                                            extraData: {
                                                name: 'bulk_body_debug',
                                                method: 'bulkPost',
                                                body: {type: typeof bulkEvents, size: (bulkEvents && bulkEvents.length) + 0}
                                            }
                                        });
                                    }

                                    TRC.TRCLogger.post(host, bulkEventName, bulkBuiltParams, explicitPublisherId, queryParams);
                                    delayedEvents = [];
                                }, TRCBulkLogger.getDelayConfig(type));
                            }
                        };
                        delayFunction.events = delayedEvents;
                        return delayFunction;
                    })(),
                    sendFirstThenDelay: (() => {
                        const sentEventOfType = {};
                        const sFTDFunction = (host, type, bulkParams, explicitPublisherId, queryParams) => {
                            if (!sentEventOfType[type]) {
                                queryParams = queryParams || {};
                                queryParams.bulkSize = 1;
                                TRC.TRCLogger.post(host, 'bulk', TRCBulkLogger.buildParamsForBulkEvent([bulkParams]), explicitPublisherId, queryParams);
                                sentEventOfType[type] = true;
                            } else {
                                this.bulkingStrategy.delay(host, type, bulkParams, explicitPublisherId, queryParams);
                            }
                        };
                        sFTDFunction.events = sentEventOfType;
                        return sFTDFunction;
                    })()
                };

                if (window._trcIsUTactive) {
                    this.getEventState = (function (method) {
                        return this.bulkingStrategy[method].events; 
                    }).bind(this);
                }
            }

            static getDelayConfig(type) {
                if (typeof TRCImpl.global[`bulk-${type}-events-delay`] === 'number') {
                    return TRCImpl.global[`bulk-${type}-events-delay`];
                }

                if (typeof TRCImpl.global[`bulk-events-delay`] === 'number') {
                    return TRCImpl.global[`bulk-events-delay`];
                }

                return DEFAULT_DELAY;
            }

            static buildParamsForBulkEvent(arrayOfBulkParams) {
                arrayOfBulkParams.forEach(event => {
                    event.data = TRC.TRCLogger.formatParams(event.data);
                });

                return {
                    sd,
                    ui,
                    events: __trcJSONify(arrayOfBulkParams)
                };
            }

            static buildBulkEventParam(type, params) {
                return {
                    type,
                    timestamp: Date.now(),
                    data: params
                };
            }

            getValidBulkingMethod(bulkStrategy) {
                if (bulkStrategy && bulkStrategy !== DISABLE) {
                    const bulkingMethod = this.bulkingStrategy[bulkStrategy];
                    if (typeof bulkingMethod === 'function') {
                        return bulkingMethod;
                    }
                }

                return null;
            }

            bulkPost(host, type, params, explicitPublisherId, queryParams) {
                const bulkStrategy = TRCImpl.global[`bulk-${type}-events-strategy`] || DISABLE;
                const bulkingMethod = this.getValidBulkingMethod(bulkStrategy);
                if (bulkingMethod) {
                    sd = sd || params.sd;
                    ui = ui || params.ui;

                    bulkingMethod(host, type, TRCBulkLogger.buildBulkEventParam(type, params), explicitPublisherId, queryParams);
                } else {
                    TRC.TRCLogger.post(host, type, params, explicitPublisherId, queryParams);
                    if (bulkStrategy !== DISABLE) {
                        __trcWarn(`FailedSendingBulkEvent for eventType: ${type}, with strategy: ${bulkStrategy}`);
                    }
                }
            }
        }

        win.TRC.TRCBulkLogger = TRC.TRCBulkLogger = TRCBulkLogger;

    })(window);

    /**
     * Created by yoni.f on 11/2/15.
     */

    (() => {
        class TrcCache {
            constructor(options, onlyClean = false) {
                this.onlyClean = onlyClean;
                this.pm = TRC.pageManager;
                this.storageType = options.storageType || 'session';
                this.localStorage = this.pm.getLocalStorageImplementation('strict-w3c-storage', this.storageType); // use true localstorage
                this.currentSize = 0;// number of entries in dummy storage
                this.trcCache = null; // dummy storage
                this.trcCacheByPlacement = null; // lookup by placement to trcCache
                this.cacheSize = options.cacheSize || 5; // max entries limit
                this.cacheTtl = options.ttl || (1000 * 60 * 20); // TTL for an entry
                this.disableFeedCache = options.disableFeedCache;
                this.trcCacheName = options.cacheName || 'trc_cache'; // name of the key for the entire trc cache in the local storage
                this.trcCacheByPlacementName = `${this.trcCacheName}_by_placement`;
                this.TRC_CACHE_ACTIVE_STORAGE_KEY = 'trc_cache_active';
                this.cacheUtils = new TRC.CacheUtils(this.localStorage, this.trcCacheName, this.cacheTtl);
                this.cacheByPlacementUtils = new TRC.CacheUtils(this.localStorage, this.trcCacheByPlacementName, this.cacheTtl);
                if (!this.localStorage) {
                    return {
                        isValidCache: false
                    };
                }
                this.isValidCache = true;
                this.init();
            }

            /**
             * extract the key from the request, and then check if there already exists a request for this placement in cache
             * @param req
             * @returns {string|*}
             */
            extractAndResolveKey(req) {
                const origKey = TRC.TrcCache.extractKey(req);
                return this.getFeedRelatedKeyFromCache(this.trcCacheByPlacement, this.trcCache, origKey) || origKey;
            }

            /**
             * compute a cache key for a specific request object
             * @param req
             * @returns {string}
             */
            static extractKey(req) {
                const itemType = req.it,
                    itemId = req.ii,
                    placements = [];
                let key = `${itemType}=${itemId}`;

                for (let i = 0; i < req.r.length; i++) {
                    placements.push(`,${req.r[i].uip}=${req.r[i].uim}`);
                }
                TrcCache.sortByPlacements(placements);
                key += placements.join();

                if (TRC.isAMPSplitFeed && typeof TRC.currentAmpFrameNum !== 'undefined') {
                    if (TRC.keyWriting === true) {
                        key += TRC.currentAmpFrameNum;
                        TRC.keyWriting = false;
                    } else {
                        key += TRC.feedContainerNum;
                    }
                }
                return key;
            }

            /**
             * cache response on the dummy storage and on the local storage
             * @param key
             * @param response
             */
            cacheResponse(key, response) {
                (TRC.tlf && console.time('in cacheResponse'));
                const cached = this.setCacheResponse(key, response);
                if (this.currentSize > this.cacheSize) {
                    this.removeToLimit();
                }
                this.localStorage.setValue(this.trcCacheName, __trcJSONify(this.trcCache.getData()));
                this.localStorage.setValue(this.trcCacheByPlacementName, __trcJSONify(this.trcCacheByPlacement.getData()));

                (TRC.tlf && console.timeEnd('in cacheResponse'));
                return cached;
            }

            /**
             * save a key value on the dummy storage and schedule it's deletion after defined TTL
             * @param key
             * @param response
             * @returns {boolean}
             */
            setCacheResponse(key, response) {
                const stamp = new Date().getTime();
                const cacheData = this.trcCache.getData();
                let responseFromCache;

                try {
                    responseFromCache = cacheData[key];
                    if (responseFromCache && responseFromCache.r.trc.f) { // feed response from cache
                        TRC.TrcCache.updateFeedConfigPropsInCache(response.trc.f, responseFromCache.r.trc.f);
                        TRC.TrcCache.addNewFeedCardsToCachedResponse(response.trc.vl, responseFromCache.r.trc.vl);
                    } else {
                        const toCache = {
                            s: stamp,
                            r: response,
                            vi: this.pm.getPageData()
                        };
                        const isSelective = (response.trc && response.trc.cga) ? !!response.trc.cga.selectiveCache : false;
                        if (isSelective) {
                            toCache.is = isSelective;
                        }
                        this.trcCache.setValue(key, toCache);
                        TrcCache.splitKeyToPlacementLookupKeys(key).forEach(placementLookupKey => {
                            this.trcCacheByPlacement.setValue(placementLookupKey, key);
                        });
                        this.currentSize++;
                        this.setCacheClean(key);
                    }
                } catch (e) {
                    __trcError('setCacheResponse Error', e);
                    return false;
                }
                return true;
            }

            /**
             * extract a cached response if :
             * 1. same key
             * 2. ttl of cache was not reached
             * @param key
             * @returns {*}
             */
            getCacheResponse(key) {
                (TRC.tlf && console.time('in getCacheResponse'));
                const value = this.trcCache.getValue(key);
                if (value && !this.isOverTtl(this.trcCache.getValue(key).s)) {
                    (TRC.tlf && console.timeEnd('in getCacheResponse'));
                    const cacheValues = this.trcCache.getValue(key);
                    return {response: cacheValues.r, viewId: cacheValues.vi, isSelective: cacheValues.is};
                }
                (TRC.tlf && console.timeEnd('in getCacheResponse'));
                return null;
            }

            /**
             *
             * @param stamp
             * @returns {boolean}
             */
            isOverTtl(stamp) {
                this.cacheUtils.isOverTtl(stamp);
            }

            /**
             * generate a separate key for every placement, to be the key in the placement
             * lookup dictionary
             * @param {string} key
             * @returns {*[]|(null|string)[]} array of keys
             */
            static splitKeyToPlacementLookupKeys(key) {
                const convertToPlacementLookupKey = (keyPart, idx, arr) => {
                    if (idx === 0 || !keyPart) return null; // 1st element is the homepage, not a placement
                    return `${arr[0]},${keyPart}`;
                };
                if (typeof key !== 'string') return [];
                return key.split(',').map(convertToPlacementLookupKey).filter(placementLookupKey => placementLookupKey !== null);
            }

            /**
             * remove a key from dummy storage and update localstorage
             * @param key
             */
            setCacheClean(key) {
                this.cacheUtils.setCacheClean(key, this.trcCache);
                TrcCache.splitKeyToPlacementLookupKeys(key).forEach(
                    placementLookupKey => this.cacheByPlacementUtils.setCacheClean(placementLookupKey, this.trcCacheByPlacement)
                );
            }

            /**
             * clean dummy storage from expired cached responses and update localstorage
             * @param keys
             */
            cleanCache(keys) {
                const flattened = arr => arr.reduce((acc, val) => acc.concat(val), []);
                this.cacheUtils.cleanCache(keys, this.trcCache, this);
                const placementLookupKeys = flattened(keys.map(TrcCache.splitKeyToPlacementLookupKeys));
                this.cacheByPlacementUtils.cleanCache(placementLookupKeys, this.trcCacheByPlacement, this);
            }

            /**
             *
             * @param key
             */
            removeKey(key) {
                const keyRemoved = TRC.CacheUtils.removeKey(key, this.trcCache);
                if (keyRemoved === true) {
                    this.currentSize--;
                }
                TrcCache.splitKeyToPlacementLookupKeys(keyRemoved).forEach(keyToPlacementLookup => {
                    TRC.CacheUtils.removeKey(keyToPlacementLookup, this.trcCacheByPlacement);
                });
            }

            /**
             * extract localstorage entry for our trc cache and create a dummy storage
             */
            getTrcCache() {
                return this.cacheUtils.getCache(this.pm);
            }

            /**
             * extract localstorage entry for our lookup by placement to trc cache and create a dummy storage
             */
            getTrcCacheByPlacement() {
                return this.cacheByPlacementUtils.getCache(this.pm);
            }

            /**
             * remove old cached entries (not necessarily expired) to confirm the
             * configured mac entries limit
             * @param keys
             */
            removeToLimit(keys) {
                keys = keys || TRC.util.keys(this.trcCache.getData());
                const remove = this.currentSize - this.cacheSize;
                let key;
                this.sortByStamp(keys);
                for (let i = 0; i < remove; i++) {
                    key = keys.shift();
                    this.removeKey(key);
                }
            }

            /**
             *
             * @param placements
             */
            static sortByPlacements(placements) {
                let temp,
                    inner;
                for (let outer = 1; outer <= placements.length - 1; ++outer) {
                    temp = placements[outer];
                    inner = outer;
                    while (inner > 0 && (placements[inner - 1] >= temp)) {
                        placements[inner] = placements[inner - 1]; --inner;
                    }
                    placements[inner] = temp;
                }
            }

            /**
             *
             * @param keys
             */
            sortByStamp(keys) {
                let temp,
                    inner;
                for (let outer = 1; outer <= keys.length - 1; ++outer) {
                    inner = outer;
                    while (inner > 0 && (this.trcCache.getValue(keys[inner - 1]).s >= temp)) {
                        temp = keys[inner];
                        keys[inner] = this.keys[inner - 1];
                        keys[inner] = temp;
                        --inner;
                    }
                }
            }

            reloadCache() {
                this.trcCache = this.getTrcCache();
                this.trcCacheByPlacement = this.getTrcCacheByPlacement();
            }

            /**
             * init the trc cache
             */
            init() {
                (TRC.tlf && console.time('in init cache trc'));
                if (this.onlyClean) {
                    this.localStorage.removeKey(this.trcCacheName);
                    return;
                }
                this.trcCache = this.getTrcCache();
                this.trcCacheByPlacement = this.getTrcCacheByPlacement();
                const keys = TRC.util.keys(this.trcCache.getData());
                this.currentSize = keys.length;
                this.cleanCache(keys);
                if (this.currentSize > this.cacheSize) {
                    this.removeToLimit(keys);
                }
                (TRC.tlf && console.timeEnd('in init cache trc'));
            }

            enableCacheViaStorageFlag() {
                this.localStorage.setValue(this.TRC_CACHE_ACTIVE_STORAGE_KEY, 'true');
            }

            isCacheEnabledViaStorageFlag() {
                return this.localStorage.getValue(this.TRC_CACHE_ACTIVE_STORAGE_KEY) === 'true';
            }

            /**
             * Feeds can be split between two requests with different placements.
             * This function finds the key for the cache entry of the feed, even if it contains other placements too.
             * @param trcCacheByPlacement
             * @param trcCache
             * @param key
             * @returns {string|*}
             */
            getFeedRelatedKeyFromCache(trcCacheByPlacement, trcCache, key) {
                const cacheData = trcCacheByPlacement.getData(),
                    placementKeyParts = key.split(',');

                if (placementKeyParts.length > 2) {
                    // we have more than one placement in the response - not relevant
                    return;
                }
                if (this.disableFeedCache) {
                    return;
                }

                const response = trcCache.getValue(key);
                if (response) {
                    return (response.r && response.r.trc && response.r.trc.f) ? key : undefined; // exact match to the cache key - simple scenario
                }
                const keyByPlacement = `${placementKeyParts[0]},${placementKeyParts[1]}`;
                return cacheData[keyByPlacement];
            }


            static addNewFeedCardsToCachedResponse(newResponsePlacements, placementsInCachedResponse) {
                newResponsePlacements.forEach(responsePlacement => {
                    let placementAlreadyExistsInCache;

                    for (let i = 0; i < placementsInCachedResponse.length; i++) {
                        if (responsePlacement.uip === placementsInCachedResponse[i].uip) {
                            placementsInCachedResponse[i] = responsePlacement;
                            placementAlreadyExistsInCache = true;
                            break;
                        }
                    }

                    if (!placementAlreadyExistsInCache) {
                        placementsInCachedResponse.push(responsePlacement);
                    }
                });
            }

            static updateFeedConfigPropsInCache(feedConfigsFromResponse, feedConfigsFromCache) {
                if (!feedConfigsFromResponse || !feedConfigsFromCache) {
                    return;
                }

                Object.keys(feedConfigsFromResponse).forEach(feedConfigKeyFromResponse => {
                    Object.keys(feedConfigsFromCache).some(feedConfigKeyFromCache => {
                        if (feedConfigKeyFromCache === feedConfigKeyFromResponse) {
                            const feedConfigFromResponse = feedConfigsFromResponse[feedConfigKeyFromResponse],
                                feedConfigFromCache = feedConfigsFromCache[feedConfigKeyFromCache];

                            feedConfigFromCache.nb = feedConfigFromResponse.nb;
                            feedConfigFromCache.eof = feedConfigFromResponse.eof;

                            return true;
                        }

                        return false;
                    });
                });
            }

            shouldRequestUseViewIdFromCache(cacheObject, key, shouldReturnResponseFromCache, trcManager) {
                const isResponseExistsInCache = cacheObject && cacheObject.response && trcManager.cachedResponses[key];
                return isResponseExistsInCache
                    && (this.isCacheEnabledViaStorageFlag()
                        || (!trcManager.global['disable-trc-cache-reuse-view-id'] && shouldReturnResponseFromCache));
            }
        }
        TRC.TrcCache = TrcCache;
    })(window, document);

    (() => {
        const trcEventsLogger = TRC.TrcEventsLogger = {};
        
        trcEventsLogger.sendPlacementEvent = function (trcManager, placementData, type, params, postParams, once, callback, timeout) {
            let wasCalled = false;
            const placementResponseData = placementData.trcResponse,
                globalResponseData = placementData.globalTrcResponseJSON,
                requestId = placementResponseData.ri,
                responseSessionData = globalResponseData.sd,
                placementName = placementData.placement,
                performanceId = Math.floor(Math.random() * 100000),
                eventParams = {
                    ri: requestId,
                    sd: trcManager.getSessionData(responseSessionData),
                    ui: TRC.pageManager.getUserId(),
                    pi: trcManager.getItemId(),
                    wi: globalResponseData.wi,
                    pt: trcManager.getItemType(),
                    vi: placementData.cachedViewId || TRC.pageManager.getPageData()
                },
                passedCallback = function () {
                    if (wasCalled) {
                        return;
                    }
                    wasCalled = true;
                    if (callback) {
                        callback();
                    }
                };

            if (placementData.cachedViewId) {
                eventParams.cache = '1';
            }

            __trcCopyProps(params, eventParams);

            if (once) {
                TRC.pConsole(placementName, 'info', `sending event type: ${type}`, eventParams, 'object');
                trcManager.log1(type, eventParams, postParams, passedCallback, placementName);
            } else {
                trcManager.logTrcEvent(type, eventParams, postParams, passedCallback);
            }
            const NO_TIME = null;
            (TRC.performance && type === 'card-visible' && TRC.performance.mark(`11.0.${performanceId}`, NO_TIME, placementName, requestId, 'card-visible', TRC.PerfEvenType.MARK));
            if (typeof timeout === 'number') {
                TRC.Timeout.set(passedCallback, timeout);
            }
        };

    })();

    (function (win, doc) {
        TRC.TRCParser = {
            parseModeName: function (response) {
                return response.mode || null;
            },
            parsePlacementName: function (response) {
                return response.placement || null;
            },
            parseABModeName: function (modeName, response) {
                var testVariant = this.parseTestVariant(response);

                if (testVariant === null) return null;

                return 'ab_' + modeName + '_' + testVariant;
            },
            parseBaseModeName: function (response) {
                if (typeof response !== 'object') return null;

                var videoList = response['video-list'];

                if(typeof videoList === 'object') {
                    if(videoList['base-mode']) {
                        return videoList['base-mode'];
                    }
                }
                return null;
            },
            parseTestVariant: function (response) {
                var videoList;

                if (typeof response !== 'object') return null;

                videoList = response['video-list'];

                if (!!response.uvpw && typeof videoList === 'object') {
                    if (videoList['test-variant'])
                        return videoList['test-variant'];
                }

                if (typeof response['test-variant'] === 'undefined') return null;

                return response['test-variant'];
            },
            IsBaseModeAndABModeExist: function (response) {
                var base_mode = this.parseBaseModeName(response),
                    test_variant = this.parseTestVariant(response);

                if (base_mode && test_variant) {
                    return true;
                }
                return false;
            },
            parseBaseModeAndABModeName: function (response) {
                var testVariant = this.parseTestVariant(response),
                    baseMode = this.parseBaseModeName(response);

                if(baseMode !== null && testVariant !== null) {
                    return 'ab_' + baseMode + '_' + testVariant;
                }
                return null;
            },
            getItemCount: function (response) {
                return response['video-list'].video ? response['video-list'].video.length : 0;
            },
            hasVariantMismatch: function (response) {
                var headerVariant = response['test-variant'];
                var widgetVariant = response['video-list']['test-variant'];


                if (!!headerVariant && !!widgetVariant)
                    return headerVariant !== widgetVariant;

                return false;
            }
        };
    })(window, document);

    (() => {
        let piggyBackData = '';
        const ENABALE_PIGGY_FF = 'rbox:serving-piggyback-enabled';
        TRC.TrcRequestPiggyBack = {
            setPiggyBackData: (response, trcImpl) => {
                if (trcImpl.global[ENABALE_PIGGY_FF] && response && response.trc && response.trc.srpg) {
                    piggyBackData = response.trc.srpg;
                }
            },
            getPiggyBackData: trcImpl => {
                if (trcImpl.global[ENABALE_PIGGY_FF] && piggyBackData) {
                    return piggyBackData;
                }
                return '';
            }
        };
    })();

    const _globalsAuctions = {};
    let initPrebidEvents$1 = true;

    const isBidderDataExist$1 = (global, auctionId, adUnitCode, bidder) => {
        const {adUnits} = _globalsAuctions[global][auctionId];
        return adUnits !== undefined && adUnits[adUnitCode].bidders !== undefined && adUnits[adUnitCode].bidders[bidder] !== undefined;
    };

    const iterateAllAdUnits = (auctionEndData, global) => {

        const {adUnits, auctionId} = auctionEndData;
        if (_globalsAuctions[global]) {
            const auctions = _globalsAuctions[global];
            auctions[auctionId] = {};
            auctions[auctionId].timestamp = auctionEndData.timestamp;
            auctions[auctionId].adUnits = {};
            adUnits.forEach(adUnit => {
                const {bids, code, ortb2Imp} = adUnit;
                if (!auctions[auctionId].adUnits[code]) {
                    auctions[auctionId].adUnits[code] = {};
                    auctions[auctionId].adUnits[code].bidders = {};
                }
                const {bidders} = auctions[auctionId].adUnits[code];
                bids.forEach(bid => {
                    const {bidder} = bid;
                    bidders[bidder] = {
                        auctionId,
                        adUnit: code,
                        ortb2Imp,
                        bidder,
                        winner: false
                    };
                });
            });
        }
    };
    const sendAuctionData = (auctionId, global) => {
        if (_globalsAuctions[global][auctionId]) {
            const auctions = _globalsAuctions[global];
            const {adUnits} = auctions[auctionId];
            Object.keys(adUnits)
                .map(key => adUnits[key])
                .forEach(adUnit => {
                    const {bidders} = adUnit;
                    Object.keys(bidders)
                        .map(key => bidders[key])
                        .filter(bidder => bidder.bidderData !== undefined)
                        .forEach(bidder => {
                            TRCImpl.sendAbTestEvent('header_bidding', bidder);
                        });
                });
            delete auctions[auctionId];
        }
    };

    const addBidsData$1 = (auctionEndData, global) => {
        const {bidsReceived, auctionId} = auctionEndData;
        bidsReceived.forEach(bid => {
            const {
                size, originalCpm, cpm, originalCurrency, currency, bidder, mediaType, adUnitCode
            } = bid;

            if (isBidderDataExist$1(global, auctionId, adUnitCode, bidder)) {
                const data = _globalsAuctions[global][auctionId].adUnits[adUnitCode].bidders[bidder];
                data.bidderData = {
                    size,
                    originalCpm,
                    cpm,
                    originalCurrency,
                    currency,
                    mediaType
                };
            }
        });

    };
    //
    const addWinData = (bidWonData, global) => {
        const {
            bidder, adUnitCode, auctionId, size
        } = bidWonData;

        if (isBidderDataExist$1(global, auctionId, adUnitCode, bidder)) {
            const data = _globalsAuctions[global][auctionId].adUnits[adUnitCode].bidders[bidder];
            data.bidderData.winSize = size;
            data.winner = true;
        }

    };

    const updateMissedAuctions$1 = (timestamp, global, globalPbjs) => {
        const auctionsIds = [];
        globalPbjs.getEvents()
            .filter(event => event.eventType === 'auctionEnd' || event.eventType === 'bidWon')
            .forEach(event => {
                if (event.args.timestamp < timestamp || event.args.timestamp === undefined) {
                    switch (event.eventType) {
                        case 'auctionEnd':
                            addAuctionData(event.args, global);
                            auctionsIds.push(event.args.auctionId);
                            break;
                        case 'bidWon':
                            addWinData(event.args, global);
                            break;
                        default:
                            break;
                    }
                }
            });
        return auctionsIds;
    };

    const reportMissedAuctions$1 = (auctionsIds, global) => {
        if (auctionsIds.length > 0) {
            auctionsIds.forEach(auctionId => {
                sendAuctionData(auctionId, global);
            });
        }
    };

    const catchUp = (catchUpToTime, global, globalPbjs) => {
        const auctionsIds = updateMissedAuctions$1(catchUpToTime, global, globalPbjs);
        reportMissedAuctions$1(auctionsIds, global);

    };
    //
    function addAuctionData(auctionEndData, global) {
        iterateAllAdUnits(auctionEndData, global);
        console.debug('test');
        addBidsData$1(auctionEndData, global);
    }

    function addEventListeners() {
        const alreadyInjectedPrebid = [];
        let stopLoop = false;
        setTimeout(() => {
            stopLoop = true;
        }, 8000);
        const isPrebidInPage = () => {
            const pbjsGlobals = window._pbjsGlobals || [];
            if (pbjsGlobals.length > 0) {
                pbjsGlobals.forEach(global => {
                    if (!alreadyInjectedPrebid.includes(global)) {
                        addSingleEventListener(global);
                        alreadyInjectedPrebid.push(global);
                    }
                });
            }
            if (!stopLoop) {
                setTimeout(() => isPrebidInPage(), 1000);
            }
        };
        isPrebidInPage();
    }

    const addPbjsToModel$1 = global => {
        if (!_globalsAuctions[global]) {
            _globalsAuctions[global] = {};
        }
    };

    const TIME_TO_WAIT_FOR_WIN_EVENTS = 2000;
    function addSingleEventListener(global) {
        const globalPbjs = window[global];
        if (globalPbjs && typeof globalPbjs.getEvents === 'function') {
            addPbjsToModel$1(global);

            globalPbjs.onEvent('auctionEnd', (auctionEndData, globalName = global) => {
                try {
                    const {auctionId} = auctionEndData;
                    console.debug(auctionId, globalName);
                    addAuctionData(auctionEndData, globalName);
                    TRC.Timeout.set(() => {
                        sendAuctionData(auctionId, globalName);
                    }, TIME_TO_WAIT_FOR_WIN_EVENTS);
                } catch (e) {
                    __trcWarn('failed to obtain data from prebid event, no data will be sent', e);
                }
            });

            globalPbjs.onEvent('bidWon', (bidWonData, globalName = global) => {
                try {
                    // console.debug(globalName);
                    addWinData(bidWonData, globalName);
                } catch (e) {
                    __trcWarn('failed to process prebid win  event', e);
                }
            });

            /*
                    the registration in rbox for events happens after few events was already sent.
                    in order not to miss them ,
                    we're running code that performs catch up for all events we missed before it,
                    this code runs only once
                   */
            catchUp(Date.now(), global, globalPbjs);
        }

    }

    function scanPrebidEvents() {
        if (initPrebidEvents$1) {
            initPrebidEvents$1 = false;
            console.debug('test1');
            addEventListeners();
        }
    }

    const MODULE = 'vignette';
    const PREFIX = 'taboola';
    const SHORT_PREFIX = 'tbl';
    const SHORT_NAME = `${SHORT_PREFIX}-${MODULE}`;

    const getSelectorName = property => [SHORT_NAME, property].join('-');
    const getPropertyName = property => `${MODULE}-${property}`;

    var CONSTANTS$1 = {
        SHORT_NAME,
        MODULE_NAME: `${PREFIX}-${MODULE}`,
        FORCE_PARAM: SHORT_NAME,
        MIXPANEL_PROJECT_ID: '8f908b612eebb4c2386577e264b153fa',
        SCANNING_LOGIC_NEW: 'new-scanning',
        SELECTORS: {
            CONTAINER: SHORT_NAME,
            RBOX_CONTAINER: 'trc_rbox',
            SHOW_VIGNETTE: getSelectorName('show'),
            TABOOLA_VIGNETTE_HANDLED: getSelectorName('handled'),
            OPPORTUNITY_VIGNETTE: getSelectorName('opportunity'),
            ATTRIBUTION: getSelectorName('attribution'),
            DESKTOP_DISCLOSURE: `.trc_desktop_disclosure_link`,
            CLOSE_BUTTON: {
                WRAPPER: getSelectorName('close-btn-wrp'),
                SVG: getSelectorName('close-btn')
            },
            BLOCK_CLICKS: getSelectorName('unintentional-clicks'),
            ACTION_BUTTON: {
                BASE: getSelectorName('btn'),
                OPEN: getSelectorName('btn-open'),
                CLOSE: getSelectorName('btn-close'),
                WRAPPER: getSelectorName('btns-wrp')
            },
            BACKGROUND: {
                BASE: getSelectorName('background'),
                CONTAINER: getSelectorName('background-container'),
                IMG: getSelectorName('background-image'),
                SCREEN: getSelectorName('background-screen')
            },
            LOADER: {
                WRP: getSelectorName('loader-wrp'),
                SVG: getSelectorName('loader')
            },
            TABOOLA_LINKS: {
                ITEM_LABEL: 'item-label-href',
                ITEM_THUMBNAIL: 'item-thumbnail-href'
            }
        },
        EVENTS: {
            BEFORE_LOAD: 'before-load',
            SCRIPT_LOADED: 'script-loaded',
            LINK_CLICKED: 'link-clicked',
            CONTAINER_VISIBLE: 'container-visible',
            MISSED: 'missed',
            CLOSE: 'close',
            REDIRECT: 'redirect',
            SESSION_STORAGE_UNSUPPORTED: 'session-storage-unsupported',
            SKIP_VIGNETTE: 'skip-vignette'
        },
        DEFAULT_EXCLUDE_BY_SELECTORS: [
            '.item-label-href', '.item-thumbnail-href'
        ],
        CSS_PROPERTIES: [
            'screenBackgroundColor', 'screenBackgroundOpacity', 'xButtonSize', 'xButtonBackgroundColor',
            'xButtonColor', 'xButtonPosition', 'closeButtonFontSize', 'closeButtonFontColor',
            'closeButtonFontFamily', 'closeButtonBackgroundColor', 'closeButtonHoverColor',
            'closeButtonText', 'openButtonFontSize', 'openButtonFontColor',
            'openButtonFontFamily', 'openButtonBackgroundColor', 'openButtonHoverColor',
            'openButtonText', 'buttonsTopSpacing'
        ].map(getPropertyName),
        SIZES: {
            DESK_SCREEN_VIGNETTE_RATIO: 2.55
        }
    };

    const {
        MODULE_NAME, EVENTS, MIXPANEL_PROJECT_ID, FORCE_PARAM, SCANNING_LOGIC_NEW
    } = CONSTANTS$1;

    class VignetteManager {
        constructor(config, placementData, trcManager) {
            this.sendEvent(EVENTS.BEFORE_LOAD);

            this.trcManager = trcManager;
            this.config = config;
            this.placementData = placementData;
            this.placementName = config.placementName;
            this.forceDebugMode = VignetteManager.shouldEnableDebugMode();
            this.instance = null;
            this._CONSTANTS = CONSTANTS$1;

            if (TRC.util.isPercentEnabled(config, 'mixpanelSample')) {
                TRC.Mixpanel.loadMixpanelScript(MIXPANEL_PROJECT_ID);
            }

            if (this.shouldRender()) {
                this.loadVignette();
            }
        }


        shouldRender() {
            try {
                const {v: recommendations, cs: addWidgetConfig} = this.placementData;

                if (TRCImpl.framework) {
                    /* exclude amp and sdk from the poc */
                    return this.shouldSkipVignette('framework loaded', TRCImpl.framework);
                }

                if (TRC.dom.isInIframe(true)) {
                    /* exclude vignette in iframe */
                    return this.shouldSkipVignette('loaded in iframe');
                }

                if (!recommendations.length) {
                    /* no items in response */
                    return this.shouldSkipVignette('no recommendations');
                }

                if (!VignetteManager.isSyndicatedItem(recommendations)) {
                    /* vignette should rendered only sc content */
                    return this.shouldSkipVignette('organic content');
                }


                if (!VignetteManager.isAddWidgetConfigured(addWidgetConfig)) {
                    /* vignette should rendered only if add widget configured */
                    return this.shouldSkipVignette('add widget not configured');
                }

                return true;


            } catch (ex) {
                this.onError('shouldRender', ex.message);
            }
        }

        static isVignettePlacement(config, uip) {
            if (!config) {
                return;
            }
            const vignetteConfig = Object.keys(config).length > 0 ? config : (TRC.vignetteManager && TRC.vignetteManager.config);
            return vignetteConfig && vignetteConfig.placementName === uip;
        }

        static isDrawingVignette(uip) {
            return uip === MODULE_NAME;
        }

        shouldSkipVignette(reason, details = '') {
            this.skipVignette = true;
            this.sendEvent(EVENTS.SKIP_VIGNETTE, {
                skipVignette: {reason, details}
            });
        }

        loadVignette() {
            this.hideVignetteOnRender();
            const vignetteModule = `${MODULE_NAME}-${SCANNING_LOGIC_NEW}`;
            TRC.ModuleLoader.load(vignetteModule, TRC.TaboolaVignette, () => {
                this.instance = new TRC.TaboolaVignette(this);
            });
        }

        static isAddWidgetConfigured(addWidgetConfig) {
            if (addWidgetConfig) {
                const {shouldCreateContainer} = addWidgetConfig[0];
                return parseInt(shouldCreateContainer, 10) === 1;
            }
            return false;

        }

        hideVignetteOnRender() {
            // eslint-disable-next-line no-unused-vars
            const {placementName} = this;
            TRC.dom.injectStyle(`[data-placement-name="${placementName}"] { position: fixed; right: -1200%; }`);
        }

        static isSyndicatedItem(recommendations) {
            return recommendations.some(recommendation => recommendation['is-syndicated'] && TRC.util.isTrue(recommendation['is-syndicated']));
        }

        sendEvent(name, value) {
            const eventName = `${MODULE_NAME}-${name}`;

            if (this.forceDebugMode) {
                return;
            }

            TRCImpl.sendAbTestEvent(eventName, JSON.stringify(value));

            if (TRC.Mixpanel.isMixPanelLoaded()) {
                TRC.Mixpanel.sendMixpanelEvent(eventName, value);
            }
        }

        // eslint-disable-next-line class-methods-use-this
        onError(name, details, stackTrace, cb = __trcError) {
            cb(`Error::prod ${MODULE_NAME}-${name} ${details}`);

            if (TRC.Mixpanel.isMixPanelLoaded()) {
                TRC.Mixpanel.sendMixpanelEvent(`${MODULE_NAME}-prod-error`, {
                    errorMsg: details,
                    errorName: name,
                    stackTrace
                });
            }
        }

        static shouldEnableDebugMode() {
            return !!TRC.URL.prototype.getParameter.call(window.location.search, FORCE_PARAM);
        }

        static getVignetteConfig(parsedCga, trcResponse, globalFlags) {
            let prodsConfig = getConfigFromTrcResponse(trcResponse);

            if (!TRC.util.isTrue(globalFlags['get-vignette-config-from-products']) || !prodsConfig) {
                prodsConfig = prodsConfig || {};
                const cgaConfig = getConfigFromCga(parsedCga) || {};
                return TRC.util.merge({}, prodsConfig, cgaConfig);
            }

            return prodsConfig || {};

            function getConfigFromCga(parsedCga) {
                return parsedCga && parsedCga.vignette;
            }

            function getConfigFromTrcResponse(trcResponse) {
                if (!trcResponse || !trcResponse.trc || !trcResponse.trc.prods || !trcResponse.trc.prods.vig) {
                    return null;
                }
                const vignetteResponse = trcResponse.trc.prods.vig;
                const config = TRC.util.merge({}, vignetteResponse, {placementName: vignetteResponse.plc});
                delete config.plc;
                return config;
            }
        }
        
        static initVignetteIfNotExists(vignetteConfig, recommendation, trcManager) {
            if (TRC.vignetteManager) {
                return false;
            }
            TRC.vignetteManager = new VignetteManager(vignetteConfig, recommendation, trcManager);
            return !TRC.vignetteManager.skipVignette;
        }
    }

    function hasSuperUTFSeq(str) {
        const charCodeArray = str.split('').map(e => e.charCodeAt(0));
        let conCounter = 0;
        for (let i = 0; i < charCodeArray.length; i++) {
            if (!isSuperUTF(charCodeArray[i])) {
                conCounter = 0;
            }
            if (conCounter >= 3) {
                return true;
            }
            conCounter++;
        }
        return false;
    }

    function isSuperUTF(charCode) {
        return charCode > 1200;
    }

    class ConfigOverrides {
        constructor(trcManager) {
            this.trcManager = trcManager;
        }

        /*
        * cgaParsed = clientGenericAction Parsed
        * dcgaParsed = demandClientGenericAction Parsed
        *
        * this function will use the cga and dcga from fpp actions to override publisher config, this.global will be changed
        */
        initPubConfigGenericActionOverride(cgaParsed, dcgaParsed, vcgaParsed) {
            const hasCga = !!(cgaParsed && cgaParsed.pubConfigOverride);
            // at current state dcgaParsed.pubConfigOverride contains placement overrides.
            // we want to distinguish placement from page level configs overrides by using dcgaParsed.pubConfigOverride.global
            const hasDcga = !!(dcgaParsed && dcgaParsed.pubConfigOverride && dcgaParsed.pubConfigOverride.global);
            const hasVcga = !!(vcgaParsed && vcgaParsed.pubConfigOverride && vcgaParsed.pubConfigOverride.global);

            if (!hasCga && !hasDcga && !hasVcga) {
                return;
            }

            // preserving legacy beahvior for web-supply
            if (hasCga && this.trcManager.isExpoTest() && TRC.util.haveMutualKeys(cgaParsed.pubConfigOverride, TRC.overrideGlobalConfig)) {
                __trcError(`client generic action override publisher config used in an expo test! expo test:${this.trcManager.getSystemFlag('experimentID')},override is:${JSON.stringify(cgaParsed.pubConfigOverride)} expo is:${JSON.stringify(TRC.overrideGlobalConfig)}`);
            }

            hasCga && hasDcga && ConfigOverrides.checkForMutualConfigs(
                {type: 'cga', obj: cgaParsed.pubConfigOverride},
                {type: 'dcga', obj: dcgaParsed.pubConfigOverride.global}
            );
            hasCga && hasVcga && ConfigOverrides.checkForMutualConfigs(
                {type: 'cga', obj: cgaParsed.pubConfigOverride},
                {type: 'vcga', obj: vcgaParsed.pubConfigOverride.global}
            );
            this.isExpoTest && hasDcga && ConfigOverrides.checkForMutualConfigs(
                {type: 'expo', obj: TRC.overrideGlobalConfig},
                {type: 'dcga', obj: dcgaParsed.pubConfigOverride.global}
            );
            this.isExpoTest && hasVcga && ConfigOverrides.checkForMutualConfigs(
                {type: 'expo', obj: TRC.overrideGlobalConfig},
                {type: 'vcga', obj: vcgaParsed.pubConfigOverride.global}
            );

            // overriding globals with the flags from fpp
            TRC.util.merge(this.trcManager.global,
                hasCga ? cgaParsed.pubConfigOverride : {},
                hasVcga ? vcgaParsed.pubConfigOverride.global : {},
                hasDcga ? dcgaParsed.pubConfigOverride.global : {});
        }

        static checkForMutualConfigs(config1, config2) {
            if (!config1.obj || !config2.obj) {
                return;
            }
            if (TRC.util.haveMutualKeys(config1.obj, config2.obj)) {
                __trcWarn(`configuration override in: ${config1.type}=${JSON.stringify(config1.obj)} with ${config2.type}=${config2.obj}`);
            }
        }
    }

    const ON_HIDE_STR = '-OnHide';
    const REPORT_TYPE = 'intervention';

    class AdHeavyManager {
        constructor(trcManager) {
            if (typeof window.ReportingObserver !== 'function' || !trcManager.global['enable-hai-report']) {
                return {status: 'not supported'};
            }
            this.trcManager = trcManager;
            this.reportingObserver = new window.ReportingObserver(this.sendReports.bind(this, false), {
                types: [REPORT_TYPE],
                buffered: false
            });
            this.reportingObserver.observe();
            window.addEventListener('pagehide', this.onHideCallback.bind(this));
            this.status = 'supported';
        }

        onHideCallback() {
            const reports = this.reportingObserver.takeRecords();
            this.sendReports(true, reports);
        }

        sendReports(onHide, reports) {
            let interventionType = '';
            if (onHide) { // "pagehide" may retrun none intervention reports so we fillter only intervention reports
                interventionType = AdHeavyManager.getInterventionType(reports.filter(report => report.type === REPORT_TYPE));
            } else {
                interventionType = AdHeavyManager.getInterventionType(reports);
            }

            if (interventionType === 'net' || interventionType === 'cpu') {
                TRC.MetricsManager.sendMetricsEvent(TRC, this.trcManager, {
                    name: `intervention-${interventionType}${onHide ? ON_HIDE_STR : ''}`,
                    value: 1,
                    type: 'counter'
                }, null, true);
                this.trcManager.sendAbTestEvent('intervention', `${interventionType}${onHide ? ON_HIDE_STR : ''}`, null, true, true);
            }
        }

        static getInterventionType(reports) {
            try {
                return reports.length ? AdHeavyManager.extractInterventionType(reports[0].body.message) : 'other';
            } catch (e) {
                return 'type-error';
            }
        }

        static extractInterventionType(message) {
            if (message) {
                if (message.toLowerCase().indexOf('network usage') > 0) {
                    return 'net';
                }
                if (message.toLowerCase().indexOf('cpu usage') > 0) {
                    return 'cpu';
                }
                return message;
            }
            return 'unknown';
        }
    }

    const ID_PROVIDERS_STORAGE_KEY = 'idproviders';
    const EXTERNAL_PARTNERS_IDS_ATTRIBUTE_NAME = 'rbox:rtb:real-time-user-sync:intent-iq:external-partners-ids';

    function getIiqIdProvidersData() {
        try {
            const externalPartnersIdsArray = TRCImpl.global[EXTERNAL_PARTNERS_IDS_ATTRIBUTE_NAME];
            if (externalPartnersIdsArray === undefined || externalPartnersIdsArray.length === 0) {
                return;
            }
            const idProvidersJsonStr = TRC.pageManager.getLocalStorageImplementation().getValue(ID_PROVIDERS_STORAGE_KEY);
            if (idProvidersJsonStr === null) {
                return;
            }
            const idProvidersJsonObj = JSON.parse(idProvidersJsonStr);
            const iiqDataJsonObj = idProvidersJsonObj.INTENT_IQ;
            const iiqDataArray = iiqDataJsonObj.c2c;
            if (iiqDataArray === undefined || iiqDataArray.length === 0) {
                return;
            }
            const result = {};
            iiqDataArray.forEach(entry => {
                const externalPartnerId = entry.pid;
                if (externalPartnersIdsArray.indexOf(externalPartnerId) > -1) {
                    result[externalPartnerId] = entry.uid;
                }
            });
            if (Object.keys(result).length === 0) {
                return;
            }
            return {INTENT_IQ: result};
        } catch (e) {
            __trcWarn('Error during getIiqIdProvidersData: ', e);
        }
    }

    TRC.opDisabled = TRC.opDisabled || false;

    function killSwitchEnabled(recommendation, hpPersonalization) {
        try {
            const feedOriginalPlacementName = recommendation.fpl;
            const hp4uOriginalPlacementName = recommendation.hpl;
            const widgetOriginalPlacementName = recommendation.uip;
            const originalPlacementName = widgetOriginalPlacementName || feedOriginalPlacementName || hp4uOriginalPlacementName;

            return isServerKillSwitchEnabled(originalPlacementName, hpPersonalization);

        } catch (e) {
            __trcError('SectionFront personalization killSwitchEnabled Error', e);
        }

        return false;
    }

    function isPlacementValidForKillSwitch(placementList, originalPlacementName) {
        let isEnabled = false;
        if (placementList.indexOf(originalPlacementName) !== -1) {
            return true;
        }

        placementList.forEach(placement => {
            // in case this is a regex pattern
            if (TRC.text.isEndWith(placement, '$')) {
                const regex = new RegExp(placement);
                if (regex.test(originalPlacementName)) {
                    isEnabled = true;
                }
            }
        });

        return isEnabled;
    }

    function isServerKillSwitchEnabled(originalPlacementName, hpPersonalization) {
        if (!validateKillSwitchSetting(hpPersonalization)) {
            return false;
        }

        return isPlacementValidForKillSwitch(hpPersonalization.ks.pl, originalPlacementName);
    }

    function validateKillSwitchSetting(hpPersonalization) {
        try {
            const placements = hpPersonalization.ks.pl || [];
            if (!hpPersonalization || !hpPersonalization.ks || !placements.length) {
                return false;
            }

            // in case we force the placement rendering
            const forcePlacement = TRC.URL.prototype.getParameter.call(location.href, 'tbl_force_taboola', false);
            return !(parseInt(forcePlacement, 10) || forcePlacement === 'true');
        } catch (e) {
            return false;
        }
    }

    (() => {
        class Hp4uManager {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.hp4uPlacements = {};
            }

            handleHp4uPlacement(recommendation, placementData) {
                const parentPlacementData = this.hp4uPlacements[recommendation.hpl]
                    || this.createNewPlacement(recommendation.hpl);

                if (placementData && !placementData.container) {
                    placementData.container = parentPlacementData.container;
                }
            }

            createNewPlacement(parentPlacement) {
                const hp4uPlacementData = this.trcManager.preloadRequest[parentPlacement];
                hp4uPlacementData.isHp4u = true;
                this.hp4uPlacements[parentPlacement] = hp4uPlacementData;
                return hp4uPlacementData;
            }
        }

        TRC.Hp4uManager = Hp4uManager;
    })();

    const _globalsAuctionsV3 = {};
    const _globalsReportedAuctions = {};
    let _winsTimeout = 2000;
    let initPrebidEvents = true;
    let _isAddPlacement = true;
    let crawlerID = 0;
    let firstAuctionFound = false;
    let firstAuctionReported = false;
    let firstAuctionId = null;

    const SALT = 'RUl2QU54VNERVSF';
    const INDEX_TO_ADD_SALT = 17;
    const ENCODING_SHIFT = 5;

    const generateUUID = () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        // eslint-disable-next-line no-bitwise
        const r = Math.random() * 16 | 0,
            // eslint-disable-next-line no-bitwise
            v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });

    function setFirstAuctionId(pbjs) {
        const events = pbjs.getEvents();

        for (let i = 0; i < events.length; i++) {
            if (events[i].eventType === 'auctionEnd') {
                firstAuctionFound = true;
                firstAuctionId = events[i].args.auctionId;
                break; // Exit the loop once a suitable event is found
            }
        }
    }

    const updateIfFirstAuction = auction => {
        if (!firstAuctionReported && auction.auctionId === firstAuctionId) {
            firstAuctionReported = true;
            auction.isFirst = true;
        }
    };

    const isBidderDataExist = (global, auctionId, adUnitCode, transactionId, bidder) => {
        const {adUnits} = _globalsAuctionsV3[global][auctionId];
        return adUnits !== undefined && adUnits[`${adUnitCode}&&${transactionId}`].bidders !== undefined && adUnits[`${adUnitCode}&&${transactionId}`].bidders[bidder] !== undefined;
    };

    const buildBidder = bid => {
        const bidderObj = {};
        bidderObj.bidder = bid.bidder;
        bidderObj.isWinner = false;
        bidderObj.madeOffer = false;
        bidderObj.noBidResponse = false;
        return bidderObj;
    };

    const buildWinBidder = bid => {
        const bidderObj = {};
        bidderObj.bidder = bid.bidder;
        bidderObj.isWinner = true;
        bidderObj.madeOffer = true;
        bidderObj.noBidResponse = false;
        bidderObj.cpm = bid.cpm;
        bidderObj.originalCpm = bid.originalCpm;
        bidderObj.size = bid.size;
        bidderObj.mediaType = bid.mediaType;
        bidderObj.currency = bid.currency;
        bidderObj.originalCurrency = bid.originalCurrency;
        return bidderObj;
    };

    const updateTaboolaTagId = (adUnit, bid) => {
        try {
            adUnit.tagId = bid.params.tagId;
        } catch (ex) {
            __trcWarn('error on header bidding, tagIdOf taboola bidder not found', ex);
        }
    };

    const buildAdUnit = adUnit => {
        const {
            bids, code, ortb2Imp, transactionId
        } = adUnit;
        const adUnitObj = {};
        adUnitObj.adUnitCode = code;
        adUnitObj.transactionId = transactionId;
        adUnitObj.ortb2Imp = ortb2Imp;
        adUnitObj.tagId = null;
        adUnitObj.winnersCount = 0;
        adUnitObj.bidders = {};
        bids.forEach(bid => {
            if (bid.bidder === 'taboola') {
                updateTaboolaTagId(adUnitObj, bid);
            }
            adUnitObj.bidders[bid.bidder] = buildBidder(bid);
        });
        return adUnitObj;
    };

    function extractPlacementFromBids(bidsReceived) {
        const transactionToPlacementMap = {};
        for (let i = 0; i < bidsReceived.length; i++) {
            const {ad, transactionId} = bidsReceived[i];

            if (ad && typeof ad === 'string') {
                const [, placementValue] = ad.match(/placement:\s*'([^']+)'/) || [];

                if (placementValue) {
                    transactionToPlacementMap[transactionId] = placementValue;
                }
            }
        }

        return transactionToPlacementMap;
    }

    const buildAuction = (auctionEndData, global) => {

        const {
            auctionId, timestamp, auctionEnd, elapsedTime, adUnits, bidsReceived
        } = auctionEndData;

        if (_globalsAuctionsV3[global]) {
            _globalsAuctionsV3[global][auctionId] = {};
            const auction = _globalsAuctionsV3[global][auctionId];
            auction.auctionId = auctionId;
            auction.crawlerInstanceID = crawlerID;
            auction.timestamp = timestamp;
            auction.auctionEnd = auctionEnd;
            auction.elapsedTime = elapsedTime;
            auction.isFirst = false;
            auction.instance = global;
            auction.version = _globalsAuctionsV3[global].version;
            auction.adUnits = {};

            const transactionToPlacementMap = _isAddPlacement ? extractPlacementFromBids(bidsReceived) : {};

            adUnits.forEach(adUnit => {
                const {code, transactionId} = adUnit;
                auction.adUnits[`${code}&&${transactionId}`] = buildAdUnit(adUnit);
                if (transactionToPlacementMap[transactionId] !== undefined) {
                    auction.adUnits[`${code}&&${transactionId}`].placement = transactionToPlacementMap[transactionId];
                }
            });
        }
    };

    const buildWinAuctionAndAddToGlobal = (auctionEndData, global) => {

        const {
            auctionId, adUnitCode, transactionId, bidder, requestTimestamp
        } = auctionEndData;

        if (_globalsAuctionsV3[global]) {
            _globalsAuctionsV3[global][auctionId] = {};
            const auction = _globalsAuctionsV3[global][auctionId];
            auction.auctionId = auctionId;
            auction.crawlerInstanceID = crawlerID;
            auction.timestamp = requestTimestamp;
            auction.auctionEnd = requestTimestamp;
            auction.elapsedTime = requestTimestamp;
            auction.isFirst = false;
            auction.instance = global;
            auction.version = _globalsAuctionsV3[global].version;
            auction.adUnits = {};

            const adUnitObj = {};
            adUnitObj.adUnitCode = adUnitCode;
            adUnitObj.transactionId = transactionId;
            adUnitObj.ortb2Imp = null;
            adUnitObj.tagId = null;
            adUnitObj.winnersCount = 0;
            adUnitObj.bidders = {};
            extractTaboolaTagId(bidder, adUnitObj, auctionEndData);
            adUnitObj.bidders[bidder] = buildWinBidder(auctionEndData);
            auction.adUnits[`${adUnitCode}&&${transactionId}`] = adUnitObj;
        } else {
            __trcWarn(`buildWinAuctionAndAddToGlobal missing global : ${global}`);
        }
    };

    function extractTaboolaTagId(bidder, adUnitObj, auctionEndData) {
        if (bidder === 'taboola') {
            try {
                adUnitObj.tagId = auctionEndData.params[0].tagId;
            } catch (ex) {
                __trcWarn('error on header bidding, tagIdOf taboola bidder not found', ex);
            }
        }
    }

    const sendAuctionDataV3 = (auctionId, global, pbjs, lookForFirstAuction = true) => {
        if (_globalsAuctionsV3[global][auctionId]) {
            if (_globalsReportedAuctions[auctionId]) {
                __trcDebug(`already _globalsReportedAuctions has auctionId : ${auctionId}`);
                return;
            }
            const auctions = _globalsAuctionsV3[global];
            if (lookForFirstAuction && !firstAuctionFound) {
                setFirstAuctionId(pbjs);
            }
            updateIfFirstAuction(auctions[auctionId]);
            auctions[auctionId].requestId = generateUUID();
            const auctionStr = JSON.stringify(auctions[auctionId]);
            if (isStringValid(auctionStr)) {
                const encodedAuctionStr = btoa(auctionStr);
                const dataWithOffset = processAuction(encodedAuctionStr);
                const postParams = {auction: dataWithOffset};
                TRCImpl.sendEvent('review-mode', null, postParams, false, null, 3000, true);
                _globalsReportedAuctions[auctionId] = true;
            }
        } else {
            __trcWarn(`sendAuctionDataV3 missing auctionId : ${auctionId}`);
        }
    };

    const processAuction = function (str) {
        try {
            const auctionSalt = str.substring(0, INDEX_TO_ADD_SALT) + SALT + str.substring(INDEX_TO_ADD_SALT);
            let decoded = '';
            for (let i = 0; i < auctionSalt.length; i++) {
                decoded += String.fromCharCode(
                    auctionSalt.charCodeAt(i) + ENCODING_SHIFT
                );
            }
            return decoded;
        } catch (e) {
            return str;
        }
    };

    const addBidRequestData = function (auctionEndData, global) {
        const {bidderRequests} = auctionEndData;
        const {auctionId} = auctionEndData;
        const auction = _globalsAuctionsV3[global][auctionId];
        let foundOrtb2 = null; // Initialize to null

        for (let i = 0; i < bidderRequests.length; i++) {
            const bidder = bidderRequests[i];
            const {bids} = bidder;

            for (let j = 0; j < bids.length; j++) {
                const bid = bids[j];

                if (bid.ortb2 !== undefined) {
                    foundOrtb2 = bid.ortb2;
                    break; // Exit the inner loop
                }
            }

            if (foundOrtb2 !== null) {
                break; // Exit the outer loop
            }
        }

        auction.ortb2 = foundOrtb2;
    };

    const isStringValid = str => typeof str === 'string' && str.trim().length > 0;

    const addBidsData = (auctionEndData, global) => {
        const {bidsReceived, auctionId} = auctionEndData;
        bidsReceived.forEach(bid => {
            const {
                size, originalCpm, cpm, originalCurrency, currency, bidder, mediaType, adUnitCode, transactionId
            } = bid;

            if (isBidderDataExist(global, auctionId, adUnitCode, transactionId, bidder)) {
                const bidderData = _globalsAuctionsV3[global][auctionId].adUnits[`${adUnitCode}&&${transactionId}`].bidders[bidder];
                bidderData.size = size;
                bidderData.mediaType = mediaType;
                bidderData.cpm = cpm;
                bidderData.currency = currency;
                bidderData.originalCpm = originalCpm;
                bidderData.originalCurrency = originalCurrency;
                bidderData.madeOffer = true;
            }
        });
    };

    const addWinDataV3 = (bidWonData, global) => {
        const {
            bidder, adUnitCode, auctionId, size, transactionId
        } = bidWonData;

        if (isBidderDataExist(global, auctionId, adUnitCode, transactionId, bidder)) {
            const adUnitData = _globalsAuctionsV3[global][auctionId].adUnits[`${adUnitCode}&&${transactionId}`];
            adUnitData.winnersCount++;
            adUnitData.bidders[bidder].winSize = size;
            adUnitData.bidders[bidder].isWinner = true;
        }
    };

    const updateMissedAuctions = (timestamp, global, globalPbjs) => {
        const auctionsIds = [];
        globalPbjs.getEvents()
            .filter(event => event.eventType === 'auctionEnd' || event.eventType === 'bidWon')
            .forEach(event => {
                if (event.args.timestamp < timestamp || event.args.timestamp === undefined) {
                    switch (event.eventType) {
                        case 'auctionEnd':
                            addAuctionDataV3(event.args, global);
                            auctionsIds.push(event.args.auctionId);
                            break;
                        case 'bidWon':
                            addWinDataV3(event.args, global);
                            break;
                        default:
                            break;
                    }
                }
            });
        return auctionsIds;
    };

    const reportMissedAuctions = (auctionsIds, global, globalPbjs) => {
        if (auctionsIds.length > 0) {
            auctionsIds.forEach(auctionId => {
                sendAuctionDataV3(auctionId, global, globalPbjs);
            });
        }
    };

    const catchUpV3 = (catchUpToTime, global, globalPbjs) => {
        const auctionsIds = updateMissedAuctions(catchUpToTime, global, globalPbjs);
        reportMissedAuctions(auctionsIds, global, globalPbjs);

    };

    function addAuctionDataV3(auctionEndData, global) {
        buildAuction(auctionEndData, global);
        addBidRequestData(auctionEndData, global);
        addBidsData(auctionEndData, global);
    }

    function addEventListenersV3() {
        const alreadyInjectedPrebid = [];
        let stopLoop = false;
        setTimeout(() => {
            stopLoop = true;
        }, 8000);
        const isPrebidInPage = () => {
            const pbjsGlobals = window._pbjsGlobals || [];
            if (pbjsGlobals.length > 0) {
                pbjsGlobals.forEach(global => {
                    if (!alreadyInjectedPrebid.includes(global)) {
                        addSingleEventListenerV3(global);
                        alreadyInjectedPrebid.push(global);
                    }
                });
            }
            if (!stopLoop) {
                setTimeout(() => isPrebidInPage(), 1000);
            }
        };
        isPrebidInPage();
    }

    const addPbjsToModel = (global, globalPbjs) => {
        if (!_globalsAuctionsV3[global]) {
            _globalsAuctionsV3[global] = {};
            _globalsAuctionsV3[global].version = globalPbjs.version;
        }
    };

    function addSingleEventListenerV3(global) {
        try {
            const globalPbjs = window[global];
            if (globalPbjs && typeof globalPbjs.getEvents === 'function') {
                addPbjsToModel(global, globalPbjs);

                globalPbjs.onEvent('auctionEnd', (auctionEndData, globalName = global) => {
                    try {
                        const {auctionId} = auctionEndData;
                        addAuctionDataV3(auctionEndData, globalName);
                        TRC.Timeout.set(() => {
                            sendAuctionDataV3(auctionId, globalName, globalPbjs);
                        }, _winsTimeout);
                    } catch (e) {
                        __trcWarn('failed on auctionEnd onEvent, no data will be sent', e);
                    }
                });

                globalPbjs.onEvent('bidWon', (bidWonData, globalName = global) => {
                    try {
                        buildWinAuctionAndAddToGlobal(bidWonData, global);
                        addWinDataV3(bidWonData, globalName);
                        sendAuctionDataV3(bidWonData.auctionId, globalName, globalPbjs);
                    } catch (e) {
                        __trcWarn('failed to process prebid bidWon event', e);
                    }
                });


                // Add event listener for 'visibilitychange'
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        // Perform actions when tab is hidden
                        catchUpV3(Date.now(), global, globalPbjs);
                    }
                });
                /*
                        the registration in rbox for events happens after few events was already sent.
                        in order not to miss them ,
                        we're running code that performs catch up for all events we missed before it,
                        this code runs only once
                       */
                catchUpV3(Date.now(), global, globalPbjs);
            }
        } catch (ex) {
            __trcWarn('header-bidding error addSingleEventListenerV3', ex);
        }
    }

    function scanPrebidEventsV3(winsTimeout, isAddPlacement) {
        if (initPrebidEvents) {
            initPrebidEvents = false;
            crawlerID = generateUUID();
            addEventListenersV3();
            _winsTimeout = winsTimeout;
            _isAddPlacement = isAddPlacement;
        }
    }

    function isDynamicLinksRecommendation(recommendation) {
        return recommendation.dlupc || recommendation.dlurl;
    }

    function createAddedDynamicLinksData(placementData) {
        return {
            placement: placementData,
            isDynamicLinks: true,
            addWidget: true
        };
    }


    (() => {
        class DynamicLinksManager {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.dynamicLinksPlacements = {};
            }

            handleDynamicLinksPlacement(recommendation, placementData) {
                const parentPlacementData = this.dynamicLinksPlacements[recommendation.uuip]
                                            || this.createNewPlacement(recommendation.uuip);

                if (placementData && !placementData.container) {
                    placementData.container = parentPlacementData.container;
                }
            }

            createNewPlacement(parentPlacement) {
                const dynamicLinksPlacementData = this.trcManager.preloadRequest[parentPlacement];
                dynamicLinksPlacementData.isDynamicLinks = true;
                this.dynamicLinksPlacements[parentPlacement] = dynamicLinksPlacementData;
                return dynamicLinksPlacementData;
            }
        }

        TRC.DynamicLinksManager = DynamicLinksManager;
    })();

    (function (win, doc) {
        var TRANSPORT_FORM_ELEMENT = 'trc-transport-form-element';

        function initEventsRedirectParams(response, trcEventsRouteResponse, eventHostTemplate) {
            if (this.enableTrcEventRoute || (response.trc.el2r && TRC.util.isArray(response.trc.el2r))) {
                // event list was supplied by configuration or by trc
                try {
                    if (response.trc.el2r) {
                        this.eventTypesToRoute = response.trc.el2r; // override with TRC response
                    }
                } catch (err) {
                    __trcError('TRC.parseResponse: even list to route is not a valid json', err);
                }

                if (response.trc.route) {
                    trcEventsRouteResponse = response.trc.route.split(':')[1];
                    eventHostTemplate = this.global['trc-event-route-template'] || '<dc>-trc-events.taboola.com'; // template from publisher config
                    this.trcEventRoute = eventHostTemplate.replace('<dc>', trcEventsRouteResponse.toLocaleLowerCase());
                }
            }
        }

        /**
         * Main TRC R-Box API and class implementation object
         */
        var Manager = TRC.Manager = function (configuration, globalParams) {

                this.feedsManager = new window.TRC.FeedsManager(this);
                this.storiesManager = new window.TRC.StoriesManager(this);
                this.hp4uManager = new window.TRC.Hp4uManager(this);
                this.dynamicLinksManager = new window.TRC.DynamicLinksManager(this);

                this.totalModeCounter = 0;
                this.renderedModeCounter = 0;
                var TRC_REQUEST_DELAY = 500; // miliseconds
                // TODO : consider 'numOfResetCssDivs' as a client property
                this.numOfResetCssDivs = 3; // number of nested divs for CSS reset
                this.eventLogger = []; // list of events that were sent
                this.eventCounter = {}; // list of events that were fired using log1
                this.NO_CONTENT = {
                    noItems: 'NO_ITEMS', mute: 'MUTE', error: 'ERROR', timeOut: 'TIMEOUT'
                };

                // eslint-disable-next-line no-unused-expressions
                this.cloudinarySortedRatios;
                this.cachedResponses = {};
                this.pendingRequests = [];
                // eslint-disable-next-line no-unused-expressions
                this.iframePixelReporter; // store for iframe that contains all pixel reported
                this.virtualPlacementsManager = new TRC.VirtualPlacementsManager();


                this.reset = function () {
                    this.reset = true;
                    TRC.dispatch('trcReset');

                    this.clearPageElements();
                    this.widgetContainerReset();

                    TRC.unifiedPlacementsProductsUtil.containersReset(this.feedsManager.feeds, 'data-feed-main-container-id');
                    TRC.unifiedPlacementsProductsUtil.containersReset(this.storiesManager.stories, 'data-stories-main-container-id');

                    Object.keys(TRC.callbacks).forEach(function (callbackId) {
                        if (callbackId.search('recommendations') >= 0) {
                            TRC.callbacks[callbackId] = function () {};
                        }
                    });

                    if (this.global['enable-old-preloadRequestLoader'] && !!this.preloadRequestLoader) {
                        TRC.Timeout.clear(this.preloadRequestLoader.timeout);
                        this.clearPreloadRequestLoader();
                    }

                    try {
                        delete win.trc_video_id;
                        delete win.trc_article_id;
                        delete win.trc_item_url;
                        delete win.trc_adPlayer;
                    } catch (e) {
                        // ie will raise: Object doesn't support this action[-2146827843: TypeError]
                        win.trc_video_id = null;
                        win.trc_article_id = null;
                        win.trc_item_url = null;
                        win.trc_adPlayer = null;
                    } finally {
                        if (!this.global['enable-old-preloadRequestLoader']) {
                            this.clearPreloadRequestLoaderAndResetQueue();
                        }
                    }
                };

                /**
                 * Activate and   render the TRCRBox
                 * @param rbox TRCRBox instance to activate
                 */
                this.renderRBox = function (rbox) {
                    var trc_container = TRC.dom.closest(rbox.getContainer(), '.trc_rbox_container');

                    rbox.load(errorHandler);

                    // silently hide the R-Box when it fails to load
                    function errorHandler() {
                        try {
                            trc_container.style.display = 'none';
                        } catch (e) {
                            __trcError('Failed to hide main container on Error', e);
                        }
                    }
                };

                /**
                 * Consolidate a global argument (and as parsed from the loader URL) into the
                 * specified options dictionary
                 * @param options dictionary to consolidate setting
                 * @param name argument name to test for
                 */
                this.getConfig = function (options, name) {
                    if (typeof options[name] !== 'undefined') {
                        return options[name];
                    }

                    if (typeof win['trc_' + name] !== "undefined" && win['trc_' + name] != null) {
                        return options[name] = win['trc_' + name];
                    }

                    if (typeof this[name] !== "undefined" && this[name] != null) {
                        return options[name] = this[name];
                    }
                    return options[name] = this[name];
                };

                /**
                 * Figure out the publisher item ID from the query string, global variables
                 * or automatic meta tag parser
                 * @returns {Number} item id
                 * @type Number
                 */
                this.getItemId = function () {
                    var itemid = this.itemid;
                    // parse item identification
                    if (win.trc_video_id || win.trc_video_id === "") {
                        itemid = win.trc_video_id;
                    } else if (win.trc_article_id || win.trc_article_id === "") {
                        itemid = win.trc_article_id;
                    }
                    if (itemid === "") {
                        itemid = this.getAutoItemMeta('item-id', null, this.urlPreNormalizer, this['normalize-item-id']);
                    }
                    return this.itemid = itemid;
                };

                this.getGlobalRequestId = function () {
                    return TRC.events_ri;
                };

                this.getGlobalSessionData = function () {
                    return TRC.session_data;
                };

                this.getSessionId = function () {
                    return this.sessionId;
                };

                this.getPlatformCode = function () {
                    return TRC.platform_code;
                };

                this.getReferrer = function () {
                    return TRC.pageManager.getReferrer();
                };

                /**
                 * Gets the query string from the source item's URL (window.location.search). If we are inside an IFrame,
                 * it will return the query string of the top frame (window.top.location.search).
                 * @returns {string}
                 */
                this.getItemUrlQueryString = function () {
                    if (this.itemUrlQueryString) {
                        return this.itemUrlQueryString;
                    }

                    var topWindow = TRC.pageManager.getTopMostWindow(),
                        qsMaxLength = this.global['item-query-string-max-length'] || 400,
                        trimmedQueryString;

                    if (TRC.isAMP) {
                        var sourceUrl = document.referrer;
                        if (window.context && window.context.sourceUrl) {
                            sourceUrl = window.context.sourceUrl;
                        }
                        var urlParts = TRC.util.splitUrlParts(sourceUrl);
                        this.itemUrlQueryString = urlParts.search || "";
                    } else {
                        this.itemUrlQueryString = topWindow.location.search;
                    }

                    if (this.itemUrlQueryString.length > qsMaxLength) {
                        trimmedQueryString = this.itemUrlQueryString.substring(0, qsMaxLength - 1);
                        // remove the last param just to make sure that we didn't cut it in the middle
                        this.itemUrlQueryString = trimmedQueryString.substring(0, trimmedQueryString.lastIndexOf('&'));
                    }

                    return this.itemUrlQueryString;
                };

                this.getListSize = function (mode) {
                    if (!mode.visible || mode.mode === 'rbox-only-video') {
                        return 0;
                    }
                    return this.calculateAutoListSize(mode);
                };
                this.getListId = function (mode) {
                    if (mode.mode === 'rbox-only-video') {
                        return 'rbox-invisible-widget';
                    }
                    return mode.list_id || (mode.mode === 'rbox-tracking') ? mode.mode : ('rbox-' + (mode.visible ? mode.origin.toString() : 'tracking'));
                };
                /**
                 * get extra recommendation number to add to the current list size for responsive mode
                 * @param mode - mode object
                 */
                this.getExtraResponsiveRecom = function (mode) {
                    var columns = this.getProperty(mode.mode_name, 'responsive-extra-columns'),
                        rows = this.getProperty(mode.mode_name, 'rows');
                    if (columns) {
                        return columns * (rows || 1);
                    }
                    return 0;
                };

                /**
                 * Get required number of recommendations for responsive modes.
                 * This function tries to conclude what is the maximum width that the user's window can get to, thus
                 * ignoring irrelevant responsive rules. e.g., if the user's screen width is 1000px, a rule that defines 20
                 * items for widths between
                 * 1500-3000px is irrelevant since the browser will never get to this width. From amongst the relevant
                 * rules, we choose the one that display the largest number of items (rows * cells), and this should be the
                 * number of items to request from the server.
                 * @param responsiveRules
                 * @returns {Object} with listSize and applied rule
                 */
                this.getResponsiveRecommendations = function (responsiveRules) {
                    var maxScreenWidth,
                        listSize = 0,
                        numItemsForRule,
                        exactRuleMatch,
                        rule,
                        hasMatchMedia = typeof (win.matchMedia) === 'function';

                    maxScreenWidth = this.getMatchMediaRuleMaxWidth(responsiveRules, hasMatchMedia);

                    //  Go over all rules and find, from between the relevant rules, the one that requires the largest number of items
                    for (var i = 0, len = responsiveRules.length; i < len; i++) {
                        rule = responsiveRules[i];
                        numItemsForRule = rule.cells * rule.rows;
                        //  next one is meant for supporting special cases where the media query matches but the device width is incorrect -
                        // see explanation next to every condition
                        exactRuleMatch = hasMatchMedia
                            && (win.matchMedia('(min-width: ' + rule.minWidth + 'px)' + (!isNaN(rule.maxWidth) ? ' and (max-width: ' + rule.maxWidth + 'px)' : '')).matches // media query matches but device with is smaller - e.g. when expanding to more than one screen
                                || win.matchMedia('screen and (min-height: ' + rule.minWidth + 'px)' + (!isNaN(rule.maxWidth) ? ' and (max-height: ' + rule.maxWidth + 'px)' : '') + ' and (orientation: portrait)').matches); // user device is in portrait mode - may rotate after request and require more items - so take the opposite direction into account as well.

                        /*
                            if the rule is relevant (meaning that the screen may fall in this range), we check if the number of
                            items that this rule needs is larger than what we already found, we assign its
                            value to listSize. eventually, the largest number of items from the relevant rules will be chosen.
                            In case that we couldn't determine the screen width for some reason, all rules will be treated as relevant.
                         */
                        if ((isNaN(maxScreenWidth) || rule.minWidth <= maxScreenWidth || maxScreenWidth < 0 || exactRuleMatch)
                            && listSize < numItemsForRule) {
                            listSize = numItemsForRule;
                        }
                    }
                    return {listSize: listSize, rule: (listSize) ? rule : null};
                };

                // noinspection FunctionWithInconsistentReturnsJS
                /**
                 * gets the maximum screen width allowed for the user
                 * @param responsiveRules
                 * @param hasMatchMedia
                 * @returns {Number}
                 */
                this.getMatchMediaRuleMaxWidth = function (responsiveRules, hasMatchMedia) {
                    var query,
                        rule;
                    // Get the maximum width for browsers supporting media queries - more accurate than screen.width
                    // (e.g. in android, screen.width gives incorrect values)
                    if (hasMatchMedia) {
                        // run a media query for each rule and find the range that is relevant for the current device
                        for (var i = 0, len = responsiveRules.length; i < len; i++) {
                            rule = responsiveRules[i];
                            query = win.matchMedia('screen and (min-device-width: ' + rule.minWidth + 'px)' + (!isNaN(rule.maxWidth) ? ' and (max-device-width: ' + rule.maxWidth + 'px)' : ''));

                            /*
                             query.matches means that the user's screen width fall between the current rule's range.
                             since we can't know the exact width from this query, we go for the worst case and take the rule's max width.
                             */
                            if (query.matches) {
                                return rule.maxWidth;
                            }
                        }

                        // For browsers that do not support media queries we simply get the screen width
                    } else {
                        return screen.width;
                    }
                };

                this.calculateAutoListSize = function (m) {
                    var listSize = this.getProperty(m.mode_name, 'list-size'),
                        extraColumns = 0,
                        responsiveRules = this.getProperty(m.mode_name, 'responsive-rules'),
                        responsiveRecomm = null,
                        containerWidth,
                        defaultListSizeForNonResponsive;

                    if (this.getProperty(m.mode_name, 'mode-is-responsive')) {
                        if (responsiveRules && responsiveRules.length) {
                            responsiveRecomm = this.getResponsiveRecommendations(responsiveRules);
                            m.matched_rule = responsiveRecomm.rule; // we need this property for UIM calibration when sending request;
                            return responsiveRecomm.listSize;
                        }
                        extraColumns = this.getExtraResponsiveRecom(m);

                    }

                    defaultListSizeForNonResponsive = listSize + extraColumns;

                    m.autoSize = this.getProperty(m.mode_name, 'auto-size');
                    if (!m.autoSize) {
                        m.autoSize = false;
                        return defaultListSizeForNonResponsive;
                    }

                    /*
                        container width should be calculated only here because this calculation is required only for auto-size modes,
                        and it is a heavy calculation.
                     */
                    containerWidth = (Math.floor((m.container.clientWidth > 0) ? m.container.clientWidth : m.container.offsetWidth));
                    if (containerWidth == 0) {
                        m.autoSize = false;
                        return defaultListSizeForNonResponsive;
                    }

                    var autoSizeRules = this.getProperty(m.mode_name, 'auto-size-rules');
                    for (var i = 0; i < autoSizeRules.length; i++) {
                        if (parseInt(autoSizeRules[i].minWc) <= containerWidth && containerWidth <= parseInt(autoSizeRules[i].maxWc)) {
                            m.AutoSizeRule = autoSizeRules[i];
                        }
                    }
                    if (!m.AutoSizeRule) return 0;
                    m.rows = this.getProperty(m.mode_name, 'rows');
                    if (m.rows <= 1) return this.modes[m.mode_name]['list-size'] = m.AutoSizeRule.n + extraColumns;
                    return this.modes[m.mode_name]['list-size'] = (m.AutoSizeRule.n * (m.rows)) + extraColumns;
                };

                this.calculateAutoSizeParameters = function (m) {
                    var Wi,
                        WiT;

                    this.calculateAutoListSize(m);
                    if (!m.AutoSizeRule) return;
                    var containerWidth = Math.floor((m.container.clientWidth > 0) ? m.container.clientWidth : m.container.offsetWidth);
                    for (var Ws = m.AutoSizeRule.minWsRange; Ws <= m.AutoSizeRule.maxWsRange; Ws++) {
                        Wi = (containerWidth - ((m.AutoSizeRule.n - 1) * Ws)) / m.AutoSizeRule.n;
                        WiT = parseInt(Wi);
                        if (WiT == Wi) {
                            m.AutoSizeRule.Wi = Wi;
                            m.AutoSizeRule.Ws = Ws;
                            break;
                        }
                    }
                };

                /**
                 * Figure out the publisher's item URL from the query string, global variables
                 * or automatic meta tag parser
                 * @returns {String} item url
                 * @type String
                 */
                this.getItemUrl = function () {
                    var itemurl = this.itemurl;
                    if (win.trc_item_url || this.itemurl == null) {
                        itemurl = this.getAutoItemMeta('item-url', null, this.urlPreNormalizer, this['normalize-item-url']);
                    }
                    return this.itemurl = itemurl;
                };

                this.getBrowserUrl = function () {
                    var currWindow = TRC.isAMP ? win.context : win;

                    return currWindow.location.href;
                };

                this.getUrlVideoPubId = function (browserUrl) {
                    var url = this.getAutoItemMeta('item-id', browserUrl, this.urlPreNormalizer, this['normalize-item-id']);
                    return this.getUrlPath(url);
                };

                this.getUrlPath = function (url) {
                    return url ? url.split(/[?#]/)[0] : '';
                };

                /**
                 * normalize URL's
                 * @param type
                 * @param uristr
                 * @returns {string}
                 */
                this.urlPreNormalizer = function (type, uristr) {
                    var rules = this['prenormalize-' + type],
                        spec;
                    if (!rules) { // no rules to live by
                        return uristr;
                    }

                    // apply 'truncate-at' before parsing because this is what the user assumes
                    (rules['truncate-at'] || []).forEach(function (val) {
                        var pos = uristr.search(val);
                        if (pos >= 0) uristr = uristr.substr(0, pos);
                    });

                    // parse the URI
                    var uri = new win.TRC.URL(uristr);

                    // apply all the other rules - I'm assuming there are orthogonal so I don't care
                    // in which order they are selected form the rules list
                    var rulesKeys = Object.keys(rules);
                    for (var i = 0; i < rulesKeys.length; i++) {
                        var rule = rulesKeys[i];
                        if (!rules[rule]) { // check if the rule should be applied
                            continue;
                        }
                        switch (rule) {
                            case 'host': // host clean up is simple - destroy schema, auth, host and port
                                delete uri.host; // URL is nice enough to handle all of this automatically
                                // if I remove the host spec
                                break;
                            case 'trailing-dirsep':
                                // remove all directory separators from the end of the path
                                while (uri.pathname.substr(uri.pathname.length - 1) === '/') {
                                    uri.pathname = uri.pathname.substr(0, uri.pathname.length - 1);
                                }
                                break;
                            case 'query':
                                // clean up all query string parameters that are not listed as exceptions
                                var newargs = [];
                                var args = uri.search.replace(/^\?/, '').split('&');
                                var spec = rules[rule];

                                if (typeof spec === 'string') {
                                    spec = new RegExp(spec);
                                }
                                var valid = function(key) {
                                    if (spec instanceof Array) {
                                        for (var i = 0; i < spec.length; i++) {
                                            if (key === spec[i]) {
                                                return true;
                                            }
                                        }
                                        return false;
                                    }
                                    if (spec instanceof RegExp) {
                                        return spec.test(key);
                                    }
                                    return false;
                                };

                                args.forEach(function(val) {
                                    if (valid(decodeURIComponent(val.split('=')[0]))) {
                                        newargs.push(val);
                                    }
                                });
                                uri.search = (newargs.length ? '?' : '') + newargs.join('&');
                                break;
                            case 'fragment':
                                var fragment = uri.hash.replace(/^#/, '');
                                spec = rules[rule];
                                if (typeof spec === 'string') {
                                    spec = new RegExp(spec);
                                }
                                uri.hash = ''; // clear the hash, see if we want to put it back
                                if (spec instanceof RegExp && spec.test(fragment)) { // because it matches the re
                                    uri.hash = '#' + fragment;
                                } else if (spec instanceof Array) { // or because it contains one of the lookups
                                    spec.forEach(function(val) {
                                        if (fragment.search(val) >= 0) {
                                            uri.hash = '#' + fragment;
                                        }
                                    });
                                }
                                break;
                            default:
                                break;
                        }
                    }

                    if (!uri.pathname) { // we may have gone and removed everything,
                        uri.pathname = '/'; // in which case we mean "the root"
                    }
                    return (type === 'item-id') ? uri.toString().toLowerCase() : uri.toString();
                };

                /**
                 * Register the specified function as a TRC callback and return the callback identifier to be sent
                 * in a TRC request.
                 * @param {Function} callback
                 * @returns {String} callback identifier
                 */
                this.genCallback = function (callback) {
                    var callbackId = 'recommendations_' + (TRC.callbacks.auto_gen_callback_seq = TRC.callbacks.auto_gen_callback_seq + 1 || 1);
                    TRC.callbacks[callbackId] = callback;
                    return 'TRC.callbacks.' + callbackId;
                };

                /**
                 * Create the TRC protocol version 3 request object for the data field in the trc request url
                 * @param preloadRequest - list of load requests
                 * @param itemType override the item type
                 * @param inRendering
                 */
                this.formatTRCRequest = function (preloadRequest, itemType, inRendering) {
                    try {
                        if (preloadRequest.hasOwnProperty('rbox-tracking') && Object.keys && Object.keys(preloadRequest).length > 1) {
                            delete preloadRequest['rbox-tracking'];
                        }
                        TRC.pageLevelFeaturesManager.disableFeatureOnIframe();
                        var globalRequestParams = new this.GlobalRequetParams();
                        if ((TRC.isOptim('geom') && !inRendering) || !TRC.isOptim('geom')) {
                            this.setGlobalParmas(globalRequestParams, itemType);
                            this.setGlobalParamsDecorators(globalRequestParams);
                        }
                        globalRequestParams.setPlacementsParamsArray(this.getPlacementsRequestParams(preloadRequest, globalRequestParams, inRendering));
                        TRC.pConsole("recommendations", "debug", "hook : normalize-request-param", this['normalize-request-param'].toString(), "string");
                        globalRequestParams.setAll(this['normalize-request-param'](globalRequestParams.getAll(), null));
                        var dynamicModulesHooks = TRC.DynamicModulesManager.getDynamicModules('normalize-request-param');
                        dynamicModulesHooks.forEach(function (module) {
                            var alteredReq = module.callback(globalRequestParams.getAll());
                            if (alteredReq && alteredReq.toString() === 'globalRequestParams') {
                                globalRequestParams.setAll(alteredReq);
                            }
                        });
                        this.setNewPlacementsInRequest(preloadRequest, globalRequestParams);
                        TRC.pConsole("recommendations", "info", "formatted request", globalRequestParams.getAll(), "object");
                        return globalRequestParams.getAll();
                    } catch (e) {
                        __trcError("TRC.formatTRCRequest", e);
                    }
                };
                /**
                 * set default global request parameters
                 * @param globalRequetParams
                 * @param itemType
                 */
                this.setGlobalParmas = function (globalRequetParams, itemType) {
                    var g = globalRequetParams,
                        conf = TRCImpl ? TRCImpl.global : {};

                    g.setItemId(this.getItemId());
                    g.setTemplate(TRC.pageTemplate);
                    g.setItemType(itemType || this.getItemType());
                    g.setSessionData(this.getSessionData(TRC.session_data));
                    g.setUserId(this.getUserId(TRC.user_id));
                    if (conf['store-userid-first-party-cookie']) {
                        g.setUserIdFirstPartyCookie(TRC.pageManager.getUserIdFirstPartyCookie());
                    }
                    g.setLoaderBuildTime(this.global.bakeTime);
                    g.setViewId(TRC.pageManager.getPageData());
                    g.setClientVersion(this.version);
                    g.setPublisherVersion(this.getPublisherVersion());
                    g.setItemUrl(this.getItemUrl());
                    g.setDeviceId(this.deviceId);
                    g.setUnifiedId(this.unifiedId);
                    g.setUserType(this.userType);
                    g.setPaywall(this.paywall);
                    g.setPremium(this.premium);
                    g.setAdvertorialSource(this.advertorialSource);
                    g.setExternalPageView(this.external_page_view);
                    g.setBlockVideoLoader(this.blockVideoLoader ? '1' : '0');
                    g.setWebComponentsAvailability(GenericWebComponent.isAvailable);
                    g.setUserLanguages(this.getUserLanguages());
                    g.setDemographic(this.demo);
                    if (conf['load-user-agent-data']) {
                        g.setUserAgentData(this.getUserAgentData());
                    }


                    g.setExperimentVariant(this.getExperimentVariant(this.getSystemFlag("experimentID")));

                    if (this.consentState) {
                        g.setCmpStatus(this.consentState.cmpStatus);
                        g.setGdprApplies(this.consentState.gdprApplies);
                        g.setConsentDaisyBit(this.consentState.consentData);
                        g.setConsentTcString(this.consentState.tcString, this.global['max-tcs-size']);
                        g.setGdprWasTimeout(this.consentState.wasTimeout);
                    }
                    // TODO: remove when generic GDPR('enable-consent') is enabled for all publishers
                    if (TRC.consentData) {
                        g.setCmpStatus(TRC.consentData.cmpStatus);
                        g.setGdprApplies(TRC.consentData.gdprApplies);
                        g.setConsentDaisyBit(TRC.consentData.consentDaisyBit);
                    }
                    this.getUSPData(function (uspData) {
                        TRC.ccpaPs = uspData;
                    });
                    g.setCex(TRC.cexConsentData);
                    g.setCcpaDns(TRC.ccpaCdns);
                    g.setCcpaPs(TRC.ccpaPs);
                    g.setExcludedPublishers(TRC.exp);
                    g.setGeoCoordinates(TRC.geo);
                    g.setBlockThumbnailVideoLoader(this.blockThumbnailVideoLoader ? '1' : '0');
                    g.setGoogleTopicsApi(conf['topics-enabled']);
                    if (typeof navigator.connection !== 'undefined') {
                        g.setConnectionType(navigator.connection.type);
                        g.setConnectionSpeed(navigator.connection.effectiveType);
                    }
                    g.setPageLevelFeature(TRC.pageLevelFeaturesManager.pageLevelFeatures);
                    g.setTrcPiggyBack(TRC.TrcRequestPiggyBack.getPiggyBackData(this));

                    var recrawlSettings = conf['oc-recrawl-settings-' + TRC.publisherId];
                    if (this.validateRecrawlSettings(recrawlSettings)) {
                        g.setItemRecrawlData(this.getAutoRecrawlData(recrawlSettings.fields));
                    }

                    g.setCseg(TRC.cseg);
                    if (this.global['pass-browser-url']) {
                        var browserUrl = this.getBrowserUrl();
                        g.setBrowserUrl(browserUrl);
                    }
                    g.setUrlVideoPubId(this.getUrlVideoPubId(browserUrl));
                    g.setBlockerList(this.global['blocker-list']);
                };

                /**
                 * pushes new placements found in the placement params array but not in the preloadRequest object
                 * preloadRequest must hold a entry for each requested placement from trc.
                 * this may occur when the 'normalize-request-param' hook changes the placement name in the request object
                 * but doesn't update the preloadRequest object with the new placement name
                 * @param preloadRequest
                 * @param globalParams
                 */
                this.setNewPlacementsInRequest = function (preloadRequest, globalParams) {
                    var uip,
                        orig_uip,
                        placementsParamsArr = globalParams.getPlacementsParamsArray();
                    if (preloadRequest) {
                        for (var i = 0, len = placementsParamsArr.length; i < len; i++) {
                            uip = placementsParamsArr[i].uip;
                            orig_uip = placementsParamsArr[i].orig_uip;
                            if (!preloadRequest[uip]) {
                                preloadRequest[uip] = preloadRequest[orig_uip];
                                preloadRequest[orig_uip] = preloadRequest[uip];
                                preloadRequest[orig_uip].new_uip = uip;
                            }
                        }
                    }
                };
                /**
                 * adds a meta data to the global request parameters
                 * @param globalParams
                 */
                this.setRequestMetaData = function (globalParams) {
                    var reqMetadata = {};
                    if (this.tags && this.tags.length) {
                        reqMetadata.k = this.tags.join(',');
                    }

                    var metadata = this.metadata;
                    Object.keys(metadata).forEach(function (p) {
                        if (metadata[p]) {
                            reqMetadata[this.parseMetaName(p)] = metadata[p];
                        }
                    }, this);

                    if (TRC.util.hasKeys(reqMetadata)) {
                        globalParams.setMetaData(reqMetadata);
                    }
                };
                /**
                 * parse collected meta data names an return equvilent trc parameter name
                 * @returns {string}
                 * @param name
                 */
                this.parseMetaName = function (name) {
                    switch (name) {
                        case 'user':
                            return 'u';
                        case 'uploader':
                            return 'U';
                        case 'content-rating':
                            return 'c';
                        case 'publish-date':
                            return 't';
                        case 'duration':
                            return 'd';
                        case 'category':
                            return 'x';
                        case 'v':
                        case 'r':
                        default:
                            return name;
                    }
                };
                /**
                 * returns all placements related parameters and values in an array
                 * @param preloadRequest
                 * @param globalParams
                 * @param inRendering
                 * @return {Array}
                 */
                this.getPlacementsRequestParams = function (preloadRequest, globalParams, inRendering) {
                    var r = [],
                        placementParams,
                        placements = TRC.util.keys(preloadRequest),
                        mode,
                        p;

                    for (var i = 0; i < placements.length; i++) {
                        p = placements[i];
                        mode = preloadRequest[p];

                        __trcInfo(mode.placement + " " + mode.mode_name);

                        if (!mode.placement) {
                            continue;
                        }
                        this.setModeGlobalParamsDecorators(globalParams, mode);
                        placementParams = this.createNewPlacementParams(mode, preloadRequest[p], inRendering);
                        /* why??? looks like it works fine without it....
                        if (typeof mode.container == 'string'){
                            mode.container = document.getElementById(mode.container);
                        }
                        */
                        placementParams.setAll(this['normalize-request-param'](placementParams.getAll(), mode.mode_name));
                        r.push(placementParams.getAll());
                    }
                    return r;
                };
                /**
                 * cerates a new placement request object and populates it with known parameters and values
                 * @param mode
                 * @param placementData
                 * @param inRendering
                 * @returns {TRC.Manager.PlacementParams}
                 */
                this.createNewPlacementParams = function (mode, placementData, inRendering) {
                    var placementParams = new this.PlacementParams();
                    placementParams.setListId(this.getListId(mode));
                    placementParams.setListSize(this.getListSize(mode));
                    placementParams.setUIMode(this.computeUIM(placementData));
                    placementParams.setUIPlacement(mode.placement);
                    placementParams.setOriginalUIPlacement(mode.placement);
                    this.setPlacementParamsDecorators(placementParams, mode, inRendering);
                    return placementParams;
                };
                /**
                 * add specific placement parameters
                 * @param placementParams
                 * @param mode
                 * @param inRendering
                 */
                this.setPlacementParamsDecorators = function (placementParams, mode, inRendering) {
                    var ra = this.getProperty(mode.mode_name, 'required-attributes');
                    if (typeof ra === "string" && ra !== "none") {
                        placementParams.setRequiredAttr(ra);
                    }
                    if (mode.dfp && mode.dfp.campaign_id) { // dfp integration
                        placementParams.setNativeCampaignID(mode.dfp.campaign_id);
                    }
                    if (mode.category) {
                        placementParams.setAllowedCategories(mode.category);
                    }
                    /* seems that this are not used on trc
                    if (mode['article']) {
                        placementParams["sii"] = mode['article'];
                        placementParams["sit"] = "text";
                    } else if(mode.video) {
                        placementParams["sii"] = mode.video;
                        placementParams["sit"] = "video";
                    }
                    */
                    if (this.enablePlacementGeometry && ((TRC.isOptim('geom') && !inRendering) || !TRC.isOptim('geom'))) {
                        this.addGeometryPlacementData(placementParams, mode.container);
                    }

                    if (mode.exclude) {
                        placementParams.setExclusions(TRC.text.toStringList(mode.exclude));
                    }

                    if (mode.fi) {
                        if (TRC.isAMPSplitFeed) {
                            mode.fi = this.ampSplitFeedManager.handleFeedIndexOffset(mode);
                        }
                        placementParams.setFeedIndex(mode.fi);
                    }
                    if (mode.fb) {
                        if (TRC.isAMPSplitFeed) {
                            var syncFb = Number(this.ampSplitFeedManager.syncFb);
                            if (syncFb !== null) {
                                mode.fb = syncFb;
                            }
                        }
                        placementParams.setFeedBatch(mode.fb);
                    }
                    if (mode.fti) {
                        placementParams.setFeedTemplateId(mode.fti);
                    }
                };

                /**
                 *
                 * @param globalParams
                 * @param selectors {String} (W3C css selector )
                 * @returns {Object}
                 */
                this.addGeometryPageData = function (globalParams, selectors) {
                    try {
                        (TRC.tlf && console.time('page geometry'));
                        globalParams.setArticlePos(this.getGeometryPageData(selectors));

                        // [screen]:
                        globalParams.setScreenWidth(window.screen.availWidth);
                        globalParams.setScreenHeight(window.screen.availHeight);

                        // [browser/viewport]:
                        globalParams.setBrowserWidth(TRC.dom.getWindowWidth());

                        (TRC.tlf && console.timeEnd('page geometry'));
                    } catch (e) {
                        globalParams.bad = -5; // something went wrong...
                    }
                };

                /**
                 *
                 * @returns {Object}
                 * @param globalParams
                 */
                this.addGeometryExtendedPageData = function (globalParams) {
                    try {
                        (TRC.tlf && console.time('page geometry extended'));

                        // [screen]:
                        globalParams.setScreenDensity(TRC.dom.getScreenDensity());

                        // [browser/viewport]:
                        globalParams.setBrowserHeight(TRC.dom.getWindowHeight());

                        // [document]:
                        globalParams.setDocumentWidth(TRC.dom.getDocumentWidth());
                        globalParams.setDocumentHeight(TRC.dom.getDocumentHeight());

                        (TRC.tlf && console.timeEnd('page geometry extended'));
                    } catch (e) {
                        globalParams.bad = -6;
                    }
                };

                /**
                 *
                 * @param placementParams
                 * @param container {Element}
                 * @returns {Object}
                 */
                this.addGeometryPlacementData = function (placementParams, container) {
                    try {
                        (TRC.tlf && console.time('mode geometry - ' + placementParams.getAll().uim));
                        placementParams.setContainerPos(this.getPosFromDocTop(container, 'top'));
                        var modeWidth = this.getModeWidth(container);
                        placementParams.setContainerWidth(modeWidth);
                        if (modeWidth === 0 && this.global['send-alternate-container-width']) {
                            placementParams.setAlternateContainerWidth(this.getAlternateContainerWidth(container));
                        }
                        (TRC.tlf && console.timeEnd('mode geometry - ' + placementParams.getAll().uim));
                    } catch (e) {
                        placementParams.cd = -5; // something went wrong...
                    }

                };
                /**
                 *
                 * @param container {Element}
                 * @returns {Number}
                 */
                this.getAlternateContainerWidth = function (container) {
                    var div = document.createElement('div');
                    div.style.visibility = 'hidden';
                    div.style.height = '0px';
                    div.innerHTML = Array(100).fill('.').join(' ');
                    container.appendChild(div);
                    var result = this.getModeWidth(container);
                    container.removeChild(div);
                    return result;
                };
                /**
                 *
                 * @param container {Element}
                 * @returns {Number}
                 */
                this.getModeWidth = function (container) {
                    return container.getBoundingClientRect().width;
                };

                /**
                 *
                 * @param selectors {String}
                 */
                this.getGeometryPageData = function (selectors) {
                    var elem,
                        i;
                    switch (true) {
                        case typeof doc.querySelector !== 'function':
                            return -4; // old browsers. not supported
                        case typeof selectors === 'string':
                            return this.computeGeometryPageData(selectors);
                        case selectors instanceof Array && selectors.length > 0: {
                            for (i = 0; i < selectors.length; i++) {
                                elem = this.computeGeometryPageData(selectors);
                                if (elem > -1) {
                                    return elem;
                                }
                            }
                            return -2; // no element located
                        }
                        default:
                            return -1; // no selector configured
                    }
                };
                /**
                 *
                 * @param selectors
                 * @returns {*}
                 */
                this.computeGeometryPageData = function (selectors) {
                    try {
                        var elem = doc.querySelector(selectors);
                        if (elem) {
                            return this.getPosFromDocTop(elem, 'bottom');
                        }
                        return -2; // no element located

                    } catch (e) {
                        return -3;// not a valid css selector
                    }
                };

                this.getPosFromDocTop = function (elem, section) {
                    return elem.getBoundingClientRect()[section] + TRC.dom.getPageVerticalScroll();
                };

                /**
                 * Compute the additional data object based on additional_data and additional_data_once loader parameters
                 */
                this.computeAdditionalData = function () {
                    var additionalDataOnceExist = this.ad_first_request && !TRC.adFirstRequestSent;
                    var additionalDataMergedData = {};

                    if (!this.additional_data && !additionalDataOnceExist) {
                        return;
                    }

                    if (this.additional_data) {
                        TRC.util.merge(additionalDataMergedData, this.additional_data);
                    }

                    if (additionalDataOnceExist) {
                        TRC.util.merge(additionalDataMergedData, this.ad_first_request);
                        // set flag indicates that additional data for the first request already been sent
                        TRC.adFirstRequestSent = true;
                    }

                    return additionalDataMergedData;
                };

                /**
                 * add specific global requ
                 * est parameters
                 * @param globalParams
                 * @param mode
                 */
                this.setGlobalParamsDecorators = function (globalParams) {
                    if (TRC.pageManager.getValue('past-exclusions')) {
                        globalParams.setPastExclusions(TRC.pageManager.getValue('past-exclusions'));
                    }
                    if (this.excludedItems) {
                        globalParams.setExclusions(TRC.text.toStringList(this.excludedItems));
                    }
                    if (this.getReferrer()) {
                        globalParams.setReferrer(this.getReferrer());
                    }
                    if (this.enablePageGeometry) {
                        this.addGeometryPageData(globalParams, this.global['page-geometry-selectors']);
                    }

                    if (this.enablePageGeometryExtended) {
                        this.addGeometryExtendedPageData(globalParams);
                    }

                    this.setRequestMetaData(globalParams);

                    if (this.global['send-item-query-string-in-req'] === true) {
                        globalParams.setItemUrlQueryString(this.getItemUrlQueryString());
                    }
                    if (TRC.networkId) {
                        globalParams.setNetworkID(TRC.networkId);
                    }
                    if (this.tracking_codes) {
                        globalParams.setUTMParams(this.buildUTMParams(this.tracking_codes));
                    }
                    if (this.additional_data || this.ad_first_request) {
                        globalParams.setAdditionalData(this.computeAdditionalData());
                    }

                    if (TRC.rtbRealTimeUserId) {
                        (TRC.performance && TRC.performance.mark('RealTimeUserSyncMainStop', null, 'RealTimeUserSyncMain', 0, 'RealTimeUserSyncMain', TRC.PerfEvenType.STOP));
                        globalParams.setRtui(TRC.rtbRealTimeUserId);
                    }
                    if (this.global['send-id-providers-data']) {
                        var idProvidersData = getIiqIdProvidersData();
                        globalParams.setIdProvidersData(idProvidersData);
                    }
                };

                Manager.prototype.buildUTMParams = function (utmObject) {
                    var utmFinalParams = [];

                    Object.keys(utmObject).forEach(function (utmProp) {
                        utmFinalParams.push(encodeURIComponent(utmProp) + '=' + encodeURIComponent(utmObject[utmProp]));
                    });

                    return utmFinalParams.join('&');
                };

                /**
                 * add global paraemets to the globalParams object with parameters originated in a mode request
                 *
                 * @param globalParams
                 * @param mode
                 */
                this.setModeGlobalParamsDecorators = function (globalParams, mode) {
                    this.setPlayerGlobalParams(globalParams, mode);
                    // eslint-disable-next-line eqeqeq
                    if (mode.origin.toString().indexOf('h2') == 0) {
                        globalParams.setItemId('_homepage_');
                    }
                };
                /**
                 * adds global params send from a player notification (_taboola.push)
                 * this will overide page configurations
                 * @param globalParams
                 */
                this.setPlayerGlobalParams = function (globalParams, mode) {
                    globalParams.setItemId(mode.item_id);
                    globalParams.setItemType(mode.item_type);
                    globalParams.setItemUrl(mode.item_url);
                };
                /**
                 * computes the uim value - only the mode name or extra parameters
                 * @param {Object} modeRequestObject
                 * @returns {string}
                 */
                this.computeUIM = function (modeRequestObject) {
                    var modeName = modeRequestObject.mode_name,
                        networkId = (this.global['disable-network-uim'] || typeof TRC.networkId === "undefined") ? "" : ":pub=" + TRC.networkId, // if the networkId is undefined there was no network solution
                        adBlockPlusParam = (TRC.blocker.blockedState > -2 && this.global['use-abp-uim']) ? ":abp=" + TRC.blocker.blockedState : "",
                        calibUIMParam = (this.global['use-calibration-uim'] && this.getProperty(modeName, "mode-is-responsive")) ? this.computeCalbUIM(modeRequestObject) : "";

                    return modeName + networkId + adBlockPlusParam + calibUIMParam;
                };

                /**
                 *  return a special computed UIM format that contains the next extracted adn computed parameters :
                 *  1. Thumbnail position
                 *  2. Number of rows and number of cells per row
                 *  3. Thumbnail aspect ratio (if relevant)
                 *  4. Thumbnail width (if relevant)
                 *  the motivation for this format is a server side mode calibration
                 *
                 */
                this.computeCalbUIM = function (modeRequestObject) {
                    if (!modeRequestObject.matched_rule) { // most likely because we have a modification done for an "ab test"
                        return "";
                    }
                    var rbox = TRC.implClasses.TRCRBox,
                        mode = this.modes[modeRequestObject.mode_name], // mode configuration object
                        rule = modeRequestObject.matched_rule,
                        pos = (mode["thumbnail-position"] !== "none" && mode["thumbnail-position"]) || undefined,
                        thumbRatio = (pos) ? TRC.math.round10(rbox.prototype.getRuleAspectRatio(rule, "ratio") || rbox.prototype.getThumbAspectRatio(mode, "ratio") || rbox.prototype.DEFAULT_THUMB_RATIO, -1) : undefined,
                        thumbWidth = (pos) ? this.caclculateThumbnailWidth(modeRequestObject.container, rule) : undefined;
                    return ":type=responsive,rows=" + rule.rows + ",cells=" + rule.cells + ",thumb-pos=" + pos + ((pos && pos != "none") ? ",thumb-ratio=" + thumbRatio + ",thumb-width=" + thumbWidth : "");
                };
                /**
                 * calculates the estimated thumbnail width base on the
                 * current container width and the calculated percentage with of a thumbnail
                 */
                this.caclculateThumbnailWidth = function (container, rule) {
                    var widthPercent = TRC.css.responsive.getRulePercentageWidth(rule.cells, rule.margin.h) / 100,
                        containerWidth,
                        ROUND_FACTOR = 50;
                    if (container && widthPercent) {
                        containerWidth = parseInt(((container.clientWidth > 0) ? container.clientWidth : container.offsetWidth), 10);
                        return TRC.math.roundByDecimal(containerWidth * widthPercent, ROUND_FACTOR);
                    }
                    return null;
                };

                this.dispatchLoadRequest = function (preloadRequest) {
                    if (this.global['enable-old-preloadRequestLoader']) {
                        this.performDispatchLoadRequest(preloadRequest);
                    } else {
                        TRC.recoRequestsQueue.add(this.performDispatchLoadRequest.bind(this, preloadRequest));
                    }
                };

                this.getCalculatedTimeout = function () {
                    var trcDebugParam = TRC.URL.prototype.getParameter.call(location.href, 'trc_debug');
                    return (TRC.util.isTrue(trcDebugParam) || trcDebugParam === 'yes') ? 0 : (this.getProperty(null, 'timeout') || 8000); // default timeout is 8 seconds
                };

                this.timeoutForNextBatch = function (args, timeToWait) {
                    TRC.Timeout.set((function () {
                        args.callee.apply(this, [].slice.call(args).concat([true]));
                    }).trcBind(this), timeToWait);
                };

                /**
                 * Send the grouped dispatch request (protocol version 3)
                 * @param preloadRequest
                 */
                this.performDispatchLoadRequest = function (preloadRequest, doneCurrentRequest) {
                    if (!TRC.util.hasKeys(preloadRequest)) {
                        return;
                    }
                    var args = arguments;
                    if (this.global['enable-old-preloadRequestLoader'] && !!this.preloadRequestLoader && !this.global['disable-simultaneous-req-protection']) {
                        this.timeoutForNextBatch(args, 100);
                        return;
                    }

                    var notFirstPreloadRequestBatch = !!(Object.keys(preloadRequest)
                        && Object.keys(preloadRequest)[0]
                        && preloadRequest[Object.keys(preloadRequest)[0]]
                        && preloadRequest[Object.keys(preloadRequest)[0]].fb);

                    if (TRC.isAMP && notFirstPreloadRequestBatch && this.global['feed-batches'] && (this.global['feed-batches'].nextFbBlock === 'true')) {
                        return;
                    }

                    if (TRC.isAMP && notFirstPreloadRequestBatch && this.global['feed-batches'] && this.global['feed-batches'].nextFbTimeout && !!this.allowTimeout) {
                        this.allowTimeout = false;
                        this.timeoutForNextBatch(args, this.global['feed-batches'].nextFbTimeout * 1000);
                        return;
                    } if (!this.allowTimeout) {
                        this.allowTimeout = true;
                    }

                    var timeout = this.getCalculatedTimeout(),
                        req,
                        url,
                        usingCache = false;

                    this.preloadRequest = preloadRequest;

                    if (this.getItemId() == null) {
                        // ask for a delay until playVideo() can provide us with an ID
                        this.delayedDispatchLoadRequest = this.dispatchLoadRequest.trcBind(this, preloadRequest);
                        return;
                    }
                    // make sure playVideo() is not blocked
                    this.delayedDispatchLoadRequest = null;


                    try {
                        this.formattedTRCRequest = req = this.formatTRCRequest(this.preloadRequest);
                        if (TRC.isAMPSplitFeed) {
                            this.ampSplitFeedManager.copyReqToReqForCacheKey(req);
                        }
                        // create request URL
                        // monitor user timings
                        TRC.utm.push((new Date()).getTime() - TRC.utm.start);
                        if (this.isValidForCache(req.it)) {
                            usingCache = this.activateTrcCache(req, this.trcCache, this.trcCacheItemType, this.handleLoadResponse, this);
                            if (usingCache) {
                                if (typeof doneCurrentRequest === 'function') {
                                    doneCurrentRequest();
                                }
                                TRC.usingCacheForPageRefresh = !this.trcCache.isCacheEnabledViaStorageFlag();
                                return;
                            }
                        }
                        req.cb = this.genCallback(this.handleLoadResponse.trcBind(this, req.cacheKey));

                        if (this.useAlternativeDomain(preloadRequest) && this.global['requests-domain-alternative']) {
                            req.trcDomain = TRC.shiftDomain(this.global['requests-domain-alternative']);
                        }

                        url = this.createRequestUrl(req);
                        var enableTrcAjax = typeof this.global['enable-trc-ajax'] === 'undefined' || TRC.util.isTrue(this.global['enable-trc-ajax']);

                        if (!TRC.workerInited) {
                            TRC.initWorkerIfAvailable(url, timeout);
                        }
                        if (TRC.worker) {
                            this.callTrcByWorker(url, req, timeout);
                        } else if (enableTrcAjax) {
                            this.callTrcByAjax(url, req, timeout, doneCurrentRequest);
                        } else {
                            this.callTrc(url, req, timeout, doneCurrentRequest);
                        }
                        delete req.cacheKey;

                        if (enableTrcAjax && TRC.externalLoadRequest) {
                            return; // no need to report LoadRequestSent it's will be handled in trecs
                        }

                        TRC.MetricsManager.sendMetricsEvent(TRC, this, {
                            name: 'LoadRequestSent',
                            value: '1',
                            type: 'counter'
                        }, null);
                    } catch (e) {
                        __trcError("TRC.dispatchLoadRequest: Error in request processing", e);
                    }
                };

                this.useAlternativeDomain = function (preloadRequest) {
                    var useAlternativeDomain = false;

                    var preloadRequestKeys = Object.keys(preloadRequest);
                    for (var i = 0; i < preloadRequestKeys.length; i++) {
                        var prop = preloadRequestKeys[i];
                        if (preloadRequest[prop].alternative_domain) {
                            useAlternativeDomain = true;
                            break;
                        }
                    }

                    return useAlternativeDomain;
                };
                this.isValidForCache = function (itemType) {
                    return !!(this.trcCache && this.trcCache.isValidCache
                        && (this.trcCache.isCacheEnabledViaStorageFlag()
                            || (this.trcCacheItemType[itemType] && (this.trcParams === "" || TRC.pageManager.getForceTrcCache()))));
                };

                this.activateTrcCache = function (req, trcCache, trcCacheItemType, callback, context) {
                    if (!req.r && !req.r.length) {
                        return false;
                    }
                    if (typeof TRC.currentAmpFrameNum === 'undefined') {
                        TRC.currentAmpFrameNum = 1;
                    }
                    var key = trcCache.extractAndResolveKey(req),
                        cacheObject = trcCache.getCacheResponse(key);

                    var shouldReturnResponseFromCache = trcCacheItemType[req.it] === 'c';
                    if (cacheObject && cacheObject.response && !this.cachedResponses[key]) {
                        if (shouldReturnResponseFromCache || trcCache.isCacheEnabledViaStorageFlag() || cacheObject.isSelective) {
                            this.setCachedResponse(cacheObject, callback, context); // the correct key is determined inside setCachedResponse
                            this.cachedResponses[key] = true;
                            return true;
                        } if (trcCacheItemType[req.it] === 'd') { // we could use cache, but NOT going to (only for analyzing data)
                            req.cache = 1;
                            req.cacheKey = key; // this is actually a flag for the rbox to cache a response when it gets back
                        }
                    } else {
                        req.cacheKey = key; // this is actually a flag for the rbox to cache a response when it gets back

                        // send new batch req with previous vi, that we received from cache in previous batches
                        if (trcCache.shouldRequestUseViewIdFromCache(cacheObject, key, shouldReturnResponseFromCache, this)) {
                            // feed scenario - already have cached batches of this feed - use the same view id in following requests
                            req.vi = cacheObject.viewId;
                        }
                    }
                    return false;
                };

                this.setCachedResponse = function (cacheObject, callback, context) {
                    cacheObject.response.cached = true;
                    cacheObject.response.cachedViewId = cacheObject.viewId;
                    TRC.Timeout.set(
                        callback.trcBind(context, null, cacheObject.response, true),
                        0
                    );

                    TRC.pConsole("recommendations", "warn", "using cached recommendations", "");
                };

                /**
                 * create and return trc request recommendation url
                 *
                 * @param req
                 * @returns {string}
                 */
                this.createRequestUrl = function (req) {
                    // send loader type here because its called from both trc ui and trcManager.
                    if (this.systemFlags && this.systemFlags.loaderType) {
                        req.lt = this.systemFlags.loaderType;
                    }
                    var cache = '';
                    if (req.cache) {
                        cache = "&cache=1";
                        delete req.cache;
                    }

                    var trcDomain = req.trcDomain ? req.trcDomain : this.domain;
                    if (this.global['load-user-agent-data'] && !req.uad) {
                        req.uad = this.getUserAgentData();
                    }
                    var url = protocol
                        + "//" + trcDomain
                        + "/" + encodeURIComponent(TRC.publisherId)
                        + "/trc/3/json?"
                        + 'tim=' + encodeURIComponent(__trcClientTimestamp())
                        + ((this.trcByPass) ? "&trc_skip_failover=yes&" : "&")
                        + ((this.enableTrcRoute && this.trcRoute) ? 'route=' + this.trcRoute + "&" : "")
                        + ((this.enableExperimentsVariantIdEvent && this.experimentsVariantIdParamsStr) ? this.experimentsVariantIdParamsStr + "&" : "")
                        + (this.getLoaderTypesValue() ? (this.getLoaderTypesValue() + "&") : "")
                        + 'data=' + encodeURIComponent(__trcJSONify(req))
                        + this.getOptOut()
                        + TRC.pageManager.additionalDispatchParams() //  for state changes done by the backstage WC
                        + cache
                        + ((win.trc_debug_level > 1) ? '&llvl=' + win.trc_debug_level : "");

                    if (this.enableTrcEventRouteExperiment) { // :todo *remove if block* after events route bypass experiment is over
                        url += "&trc_evi=21|1434|2154";
                    }
                    return url;
                };
                /**
                 * Abort a running grouped dispatch request (protocol version 3) and handle
                 * the fallout
                 */
                this.abortLoadRequest = function (timeout, callbackId) {
                    if(TRC.externalLoadRequest) {
                        this.clearPreloadRequestLoaderAndCallNext();
                        return;
                    }

                    if (timeout) {
                        TRC.EventsAPI.dispatchNoContent(TRCImpl.NO_CONTENT.timeOut);
                    } else {
                        TRC.EventsAPI.dispatchNoContent(TRCImpl.NO_CONTENT.error);
                    }
                    Object.keys(this.preloadRequest).forEach(function (pl) {
                        if (pl.search('rbox-tracking') >= 0) {
                            return;
                        }
                        if (timeout) {
                            timeout = false;
                            __trcWarn("TRC.abortLoadRequest: pv3 timeout");

                            // make the callback of the timed out request o-op - so it will not render anything
                            // if and when we finally get the response, since this may cause issues in infinite scroll
                            if (callbackId) {
                                TRC.callbacks[callbackId.replace('TRC.callbacks.', '')] = function () {
                                };
                            }
                        }
                        TRC.dispatch('onRboxFlowError', {placement: pl});
                        var opt = this.preloadRequest[pl];
                        delete this.preloadRequest[pl];

                        opt.loadRBoxRequestFailed = true;

                        this.internalDrawRBox(opt);
                    }, this);

                    this.clearPreloadRequestLoaderAndCallNext();
                };
                this.getOptOut = function () {
                    if (typeof (this.userOptOut) !== 'undefined' && this.userOptOut !== null
                        && [true, 'true', false, 'false'].indexOf(this.userOptOut) > -1) {
                        return '&user.opt_out=' + this.userOptOut;
                    }
                    return '';

                };

                /**
                 * Event handler for the loadRBox onload/onerror
                 * This will detect if an error occurred and handle the error by calling {@link TRC#abortLoadRequest()}
                 * to terminate the request and reissue the internalDrawRBox() commands
                 */
                this.handleLoadResponseFailure = function (e) {
                    (TRC.performance && TRC.performance.mark("5.1.8", null, "TrcPv3", this.lastReqId, 'pv3call', TRC.PerfEvenType.STOP));
                    if (this.preloadRequestLoader == null
                        || (!this.global['disable-simultaneous-req-protection'] && e && e.target && this.preloadRequestLoader.src !== e.target.src)) {
                        return; // loading was successful
                    }
                    // need to abort
                    __trcError("Server did not respond to loadRBox");
                    this.abortLoadRequest();
                };
                /**
                 *  return true if a placement has an active placement data(a slot in preloadRequest) -
                 *  a non active placement can be a result of a hook that changes the placement name in the request url for
                 * recommendations this will result in two placement slots in the preloadRequest object
                 * @param placementData
                 * @param placementName
                 * @returns {boolean}
                 */
                this.isActivePlacementData = function (placementData, placementName) {
                    if (placementData.new_uip) {
                        return placementName === placementData.new_uip;
                    }
                    return true;


                };

                this.sendUserIdsMapping = function (response) {
                    if (this.global['user-mapping-enabled'] && !response.trc.DNT && !response.trc.cm && TRC.user_id) {
                        var userIdFromReferrer = TRC.pageManager.getUserIdFromReferrer();
                        if (userIdFromReferrer && TRC.user_id !== userIdFromReferrer) {
                            var querystring = [];
                            querystring.push('uils=' + TRC.user_id);
                            querystring.push('uiref=' + userIdFromReferrer);
                            var image = new Image();
                            image.src = TRC.PROTOCOL + "//trc.taboola.com/sg/taboola-rbox/1/um/?" + querystring.join('&');
                            return image;
                        }
                    }
                };

                /**
                 * Handle the response for a grouped dispatch request (protocol version 3)
                 * @param cacheKey {string}
                 * @param response {Object} the TRC response or an event object if this method was
                 * @param isCache {boolean}
                 *    called as the onload/onerror event handler.
                 */
                this.handleLoadResponse = function (cacheKey, response, isCache) {
                    /* TEMPORARY CODE FOR DELTA / TRANSFORMER SIDE-BY-SIDE TESTING */
                    (TRC.performance && TRC.performance.mark("handleLoadResponseStart", null, "handleLoadResponse", "", "handleLoadResponse", TRC.PerfEvenType.START));

                    if (!this.global['disable-delta-mode-switch']) {
                        TRC.deltaModeAdapter.switchModeNamesIfInDeltaTest(this, response);
                    }

                    if (this.cssLiteInject) {
                        TRC.css.utils.bakeCss(response, this);
                    }

                    TRC.ItemOverride.run(this, response);
                    var placementData,
                        conf = TRCImpl ? TRCImpl.global : {};

                    function parseTrcResponse() {

                        this.parseResponse(response, isCache);

                        if (TRC.util.isPercentEnabled(this.global, 'enable-feed-view-iframe-report')) {
                            TRC.FeedViewInIframeReport.report();
                        }

                        if (this.global['enable-old-preloadRequestLoader']) {
                            this.checkPreloadRequest(placementData);
                        }

                        if (this.global['smart-ellipsis']) {
                            TRC.dom.on(win, "resize", TRC.util.debounce(this._repaintEllipsis, 500, false, this));
                            // TRC.dispatch("ellipsis", {data: this.boxes}); // Main dispatch, called after all boxes were rendered.
                        }

                        // clear the loader
                        this.clearPreloadRequestLoaderAndCallNext();

                        // call the spotlight script if we are spotlight users
                        try {
                            TRC.SpotlightLoader.load(response);
                        } catch (e) {
                            __trcError("Error while trying to load Spotlight");
                        }

                        (TRC.tlf && console.timeEnd('in handleLoadResponse'));
                        (TRC.tlf && console.timeStamp('end handleLoadResponse'));
                        (TRC.performance && TRC.performance.mark("6.0.9", null, "TrcPv3", "", 'pv3prase', TRC.PerfEvenType.STOP));
                    }

                    try {
                        (TRC.tlf && console.timeStamp('start handleLoadResponse(pv3)'));
                        (TRC.tlf && console.time('in handleLoadResponse'));
                        (TRC.performance && TRC.performance.mark("6.0.1", null, "TrcPv3", "", 'pv3prase', TRC.PerfEvenType.START));
                        TRC.pConsole("recommendations", "info", "recommendations response", response, (response.trc.verbose ? "verbose" : "object"));
                        TRC.pConsole("", "time", "recommendations loaded", "");

                        // monitor user timings
                        TRC.utm.push((new Date()).getTime() - TRC.utm.start);
                        if (response && response.trc && response.trc.f) {
                            var feeds = Object.keys(response.trc.f);
                            for (var i = 0; i < feeds.length; i++) {
                                var currentFeed = feeds[i];
                                if (this.feedsManager && this.feedsManager.feeds && this.feedsManager.feeds[currentFeed]) {
                                    var selectedFeed = this.feedsManager.feeds[currentFeed];
                                    if (selectedFeed && selectedFeed.infiniteScrollEngine && selectedFeed.infiniteScrollEngine.preventReachingTheFooter) {
                                        var preventReachingTheFooter = selectedFeed.infiniteScrollEngine.preventReachingTheFooter;
                                        if (preventReachingTheFooter && preventReachingTheFooter.lateRenderEnabled) {
                                            selectedFeed.infiniteScrollEngine.preventReachingTheFooter.handleBatch(cacheKey, response);
                                        }
                                    }
                                }
                            }
                        }

                        if (response && response.trc && response.trc.ui) {
                            // this is an hack "user_id_ready" will trigger a global trc event ("social")
                            // we need to set some values that the global events need send as parameters and are found in the response object
                            this.watchedItem = response.trc.wi;
                            this.globaleRequestId = (response.trc.vl && response.trc.vl.length) ? response.trc.vl[0].ri : this.globaleRequestId;
                            TRC.events_ri = this.globaleRequestId;
                            TRC.session_data = (response && response.trc) ? response.trc.sd : null;
                            TRC.platform_code = (response && response.trc) ? response.trc.plc : null;
                            TRC.user_id = response.trc.ui || null;

                            if (TRC.isOptim('defer-events')) {
                                setTimeout(function () {
                                    TRC.eventDelegator.dispatch("user_id_ready");
                                }, 0);
                            } else {
                                TRC.eventDelegator.dispatch("user_id_ready");
                            }
                            TRC.eventDelegator.dispatch("user_id_ready");

                            var deferCookieReportTime = TRC.util.parseTimeout(this.global['defer-cookie-sync']);
                            if (response.trc.stp) {
                                if (deferCookieReportTime === -1) {
                                    TRC.dispatch("send_user_id", response.trc.stp);
                                } else {
                                    setTimeout(function () {
                                        TRC.dispatch("send_user_id", response.trc.stp);
                                    }, deferCookieReportTime);
                                }
                            }
                            if (response.trc.jst) {
                                if (deferCookieReportTime === -1) {
                                    TRC.dispatch("load_script_tags", response.trc.jst);
                                } else {
                                    setTimeout(function () {
                                        TRC.dispatch("load_script_tags", response.trc.jst);
                                    }, deferCookieReportTime);
                                }
                            }

                            TRC.responseLoaded = true;
                            TRC.alertVVResponseLoaded && TRC.alertVVResponseLoaded(TRC.version);
                        }

                        TRC.CustomModulesManager.getCustomModulesFromResponse(response, this);
                        !TRC.BlockClicksManager.BCA && TRC.BlockClicksManager.getBlockClicksFromResponse(response);

                        var trecsFiltered = response && response.trc && response.trc.trecsFiltered;
                        if ((!response || !response.trc || !response.trc.vl || !response.trc.vl.length) && !trecsFiltered) {
                            if (!TRC.externalLoadRequest) {
                                __trcError("Invalid response from server: " + response);
                                TRC.MetricsManager.sendMetricsEvent(TRC, this, {
                                    name: 'EmptyResponse',
                                    value: '1',
                                    type: 'counter'
                                }, null);
                            }
                            this.abortLoadRequest();
                            return;
                        } if (response.trc.tc && !TRC.taboolaConsole) {
                            TRC.Manager.prototype.loadExternal("//c2.taboola.com/console/console_loader.js", "js");
                        }

                        TRC.UserIdMerger.notifyPossibleUserChange(this, TRC.publisherId, response.trc.ui, response.trc.sd);
                        if (!response.trc.cm) {
                            TRC.pageManager.storePublisherValue(TRC.publisherId, 'session-data', response.trc.sd);
                        }

                        TRC.TrcRequestPiggyBack.setPiggyBackData(response, this);
                        // If DNT is on remove previous cookies and local storage resources

                        TRC.translationManager.setTranslations(response.trc.tslt);

                        if (response.trc.DNT && response.trc.DNT.toUpperCase() === 'TRUE') {
                            TRC.doNotTrack = true;
                            TRC.pageManager.removeAllKeys();

                            // Don't remove this line. We want to make sure to remove user-id.
                            // it's for cases where we stored it before we implemented removeAllKeys for DNT.
                            TRC.pageManager.removeUserId();
                        } else {
                            // store the user-id locally
                            TRC.pageManager.storeUserId(response.trc.ui, response.trc.cm);
                            // store the session-data in first party cookie if client properties enabled
                            if (conf['store-sessiondata-first-party-cookie'] === true || conf['store-sessiondata-first-party-cookie'] === "true") {
                                TRC.pageManager.storeSessionId(response.trc.sd, response.trc.cm);
                            }
                            TRC.pConsole("page", "debug", "Storing user-id: " + response.trc.ui);
                        }

                        this.sendUserIdsMapping(response);

                        if (cacheKey) {
                            this.trcCache.cacheResponse(cacheKey, response, TRC.pageManager.state.moreDispatchParams);
                            this.cachedResponses[cacheKey] = true;
                        }

                        if (!conf['disable-page-level-feature']) {
                            TRC.pageLevelFeaturesManager.getFeature(response);
                        }

                        parseTrcResponse.call(this);

                        if (this.global['enable-old-preloadRequestLoader']) {
                            this.handleLoadResponseFailure();
                        } else {
                            this.checkPreloadRequest();
                        }

                        if (TRC.util.isPercentEnabled(this.global, 'header-bidding-enabled')) {
                            if (this.global['header-bidding-v3']) {
                                scanPrebidEventsV3(this.global['header-bidding-wait-for-win-events-timeout'], this.global['header-bidding-is-add-placement']);
                            } else {
                                scanPrebidEvents();  // this is temp legacy code to allow gradual migration to new version
                            }
                        }

                        this.triggerAfterHandleLoadResponseCustomModuleHook(cacheKey, response, isCache);

                        TRC.dispatch('trcResponseHandled', {res: response});
                        (TRC.performance && TRC.performance.mark("handleLoadResponseStop", null, "handleLoadResponse", "", "handleLoadResponse", TRC.PerfEvenType.STOP));
                    } catch (e) {
                        __trcError("Error in TRC.handleLoadResponse : ", e);
                    }
                };
                this.triggerAfterHandleLoadResponseCustomModuleHook = function (cacheKey, response, isCache) {
                    TRC.CustomModulesManager.runHook('after-handle-load-response', null, this, [cacheKey, response, isCache]);
                };

                function isYieldingEnabled(preloadRequest, trcImpl) {
                    var conf = trcImpl ? trcImpl.global : {};
                    if (conf['disable-yield']) {
                        return false;
                    }

                    if (TRC.URL.prototype.getParameter.call(win.location.href, 'yield-batch')) {
                        return true;
                    }

                    var isModeGroupOrderDefined = false;
                    Object.keys(preloadRequest).forEach(function (placement) {
                        var placementData = preloadRequest[placement];
                        if (typeof placementData.modeGroupOrder !== 'undefined') {
                            isModeGroupOrderDefined = true;
                        }
                    }, this);

                    return isModeGroupOrderDefined;
                }

                /**
                 * parse the recommendation response and initiate widget drawing
                 * @param response
                 * @param isCache
                 */
                this.parseResponse = function (response, isCache) {
                    var placement,
                        placementData,
                        i,
                        recommendation,
                        formattedResponse,
                        cssOverride = {},
                        trcRouteResponse,
                        trcEventsRouteResponse,
                        eventHostTemplate,
                        placementsList = response.trc.vl;

                    // check if publisher set yielding order
                    this.yieldingEnabled = isYieldingEnabled(this.preloadRequest, this);
                    this.testData = response.trc.td;
                    this.experimentsData = response.trc.evi;
                    this.experimentsHash = response.trc.evh;
                    this.sourceCategory = response.trc.scat;
                    this.visibleOnItemLevel = response.trc.voil;

                    if (response.trc.vpl) {
                        this.virtualPlacementsManager.response = response.trc.vpl;
                    }

                    var parsedCga = this.parseClientGenericAction(response, 'cga');
                    var parsedDcga = this.parseClientGenericAction(response, 'dcga');
                    var parsedVcga = this.parseClientGenericAction(response, 'vcga');

                    this.initCcpa(parsedCga, response);

                    this.configOverrides.initPubConfigGenericActionOverride(parsedCga, parsedDcga, parsedVcga);

                    var vignetteConfig = VignetteManager.getVignetteConfig(parsedCga, response, this.global);

                    // TODO: remove after stories will use fpp configs - now this for overiding lr global configurations for stories pv
                    this.renderController.setLazyConfig();
                    this.renderController.setPlacementsConfig(response.trc.lzr); // should override the lazy-render configuration from the response

                    if (this.enableTrcRoute) {
                        trcRouteResponse = response.trc.route;
                        if (trcRouteResponse) {
                            this.trcRoute = trcRouteResponse;
                        }
                    }

                    if (this.enableLoaderCacheBuster) {
                        var loaderUrl,
                            reloadLoaderRequest;
                        try {
                            if (window.fetch && window.Request && this.systemFlags.loaderType === 'deflated') {
                                loaderUrl = TRC.PROTOCOL + '//cdn.taboola.com/libtrc/' + globalParams.publisher + '/loader.js';
                                if (response.trc.lfr) {
                                    reloadLoaderRequest = new Request(loaderUrl, {cache: 'reload', mode: 'no-cors'});
                                    fetch(reloadLoaderRequest);
                                }
                            } else {
                                __trcDebug('Cache Bust not supported');
                            }
                        } catch (e) {
                            __trcError('failed to run cache busting on this browser on: ' + loaderUrl, e);
                        }
                    }

                    initEventsRedirectParams.call(this, response, trcEventsRouteResponse, eventHostTemplate);

                    if (this.experimentsData) {
                        this.tbtExperimentsVariantIdsStr = this.buildExperimentsVariantIdParams();

                        if (this.enableExperimentsVariantIdEvent) {
                            this.experimentsVariantIdParamsStr = this.tbtExperimentsVariantIdsStr;
                        }
                    }

                    if (response.trc.s) {
                        var storiesPlacements = placementsList.filter(function (placementData) {
                            return !!placementData.stpl;
                        });
                        this.storiesManager.createNewStories(response.trc, storiesPlacements.length);
                    }

                    var feedsData = response.trc.f;
                    if (TRC.isAMPSplitFeed) {
                        if (feedsData) {
                            this.ampSplitFeedManager.updateFeedIndexAndBatch(response);
                            this.ampSplitFeedManager.cacheOrAssignFeedResponseData(response);
                        } else {
                            __trcWarn('AMP split feed detected but response don\'t have feed');
                        }
                    }
                    __trcCopyProps(feedsData, this.feedsManager.configs);

                    this.renderController.addResponse(response);

                    for (i = 0; i < placementsList.length; i++) {
                        // TODO: distinct from mediation to regular
                        recommendation = placementsList[i];

                        if (VignetteManager.isVignettePlacement(vignetteConfig, recommendation.uip)) {
                            var vignetteCreated = VignetteManager.initVignetteIfNotExists(vignetteConfig, recommendation, this);
                            if (!vignetteCreated) {
                                continue;
                            }
                        }

                        if (this.global['force-set-reco-reel-container']) {
                            if (TRC.RecommendationReel.isPlacementRecoReel(placementsList[i], this)) {
                                TRC.RecommendationReel.setContainerForRRPlacement(placementsList[i], this.preloadRequest, response.trc.f);
                            }
                        }


                        if (recommendation.pcp && TRC.isAMPSplitFeed) {
                            this.ampSplitFeedManager.handlePubCardInResponse(response, i);
                        }

                        // in case of daisy chain 'dc' will hold the original placement
                        placement = recommendation.uip;

                        if (!this.global['disable-skip-placement'] && this.shouldSkipPlacement(recommendation, response)) {
                            __trcDebug('\'parseResponse\' : Skip on placement \'' + placement + '\'');

                            continue;
                        }

                        this.sessionId = response.trc.si;

                        placementData = this.getOrCreatePlacementData(placement, recommendation);

                        if (typeof placementData === 'undefined') {
                            __trcWarn('Invalid placement in server response ' + placement);
                            continue;
                        }

                        placementData.unifiedPlacement = recommendation.uuip;
                        placementData.globalTrcResponseJSON = response.trc;
                        placementData.trcResponse = recommendation;
                        this.currentRecommendation = recommendation;

                        var shouldSkipPlacementRender = !TRC.fallbackApi.shouldRenderPlacement(recommendation, this.preloadRequest)
                            || killSwitchEnabled(recommendation, response.trc.op);

                        if (shouldSkipPlacementRender) {
                            TRC.EventsAPI.dispatchPlacementNoRendered(placementData, "notAllowedToRender");
                            continue; // to next vl
                        }

                        if (placement.search('rbox-tracking') >= 0) {
                            placementData.response = this.formatPlacementRecommendations(response, i);
                            continue;
                        }

                        if (this.feedsManager.hasFeedConflict(placement, recommendation.fpl)) {
                            __trcWarn('Feed conflict detected for \'' + placement + '\' with feed placement \'' + recommendation.fpl + '\' and test data \'' + this.td + '\' and \'' + JSON.stringify(this.experimentsData) + '\'');
                            TRC.EventsAPI.dispatchNoContent(TRCImpl.NO_CONTENT.noItems, placement, true);
                            continue;
                        }

                        if (recommendation.et) {
                            placementData.expandOptions = this.getExpandOptions(recommendation);
                        }

                        placementData.isCache = isCache;

                        if (response.cachedViewId) {
                            placementData.cachedViewId = response.cachedViewId;
                        }

                        if (recommendation.fpl) {
                            if (this.feedsManager.invalidFeedsMap[recommendation.fpl]) {
                                continue;
                            }

                            this.feedsManager.handleFeedCardPlacement(recommendation, placementData);
                            if (!placementData.parentFeed) {
                                continue;
                            }
                        } else if (recommendation.stpl) {
                            this.storiesManager.handleStoryPlacement(recommendation, placementData);
                        } else if (recommendation.hpl) {
                            this.hp4uManager.handleHp4uPlacement(recommendation, placementData);
                        } else if (recommendation.dlupc || recommendation.dlurl) {
                            this.dynamicLinksManager.handleDynamicLinksPlacement(recommendation, placementData);
                        }

                        if (TRC.isAMPSplitFeed && this.ampSplitFeedManager.shouldBreakForAMPSplitFeed === true) {
                            break;
                        }

                        if (placementData.scriptData || placementData.publisherCardData) {
                            continue;
                        }

                        if (recommendation.es) {
                            TRC.ExternalContainerAppender.move(recommendation.es, placementData.container);
                        } else if (this.isStandaloneVideo(recommendation)) {
                            placementData.videoTagLoader = new TRC.VideoTagLoader(this, recommendation.vtag, placementData, null, {
                                'session-data': response.trc.sd,
                                req: recommendation.ri
                            });
                            placementData.videoTagLoader.loadVideo();
                        } else {
                            formattedResponse = this.formatPlacementRecommendations(response, i, cssOverride);
                            // TODO : explain the phase
                            placementData.response = formattedResponse;

                            this.addFormattedResponseToWidgetAddedFromTrc(recommendation, formattedResponse, placementData.addWidget);

                            if (placementData.response) {
                                if (placementData.dc) {
                                    delete placementData.dc;
                                }

                                var videoList = formattedResponse.trc['video-list'];
                                if (TRC.FloatingUnitGenerator.isFloatingUnit(videoList)) {
                                    this.floatingUnitGenerator = new TRC.FloatingUnitGenerator(formattedResponse, placementData, this);
                                } else {
                                    if (videoList) { // Pass move and add widget selectors to placement data
                                        placementData['container-selectors'] = videoList['container-selectors'];
                                        placementData['render-on-orig-container'] = videoList['render-on-orig-container'];
                                    }

                                    if (!recommendation.fpl && TRC.FeedViewWidgetLoaderManager.isFeedViewWidget(this, placementData)) {
                                        new TRC.FeedViewWidgetLoaderManager(placementData);
                                    }

                                    this.initRBoxDrawingIfPlacementEligible(placementData);
                                }
                            }
                        }
                    }

                    if (cssOverride.text) {
                        if (TRC.cssStack) {
                            TRC.cssStack.addStyle('override', cssOverride.text, TRC.styleInjected);
                        } else {
                            TRC.dom.injectStyle(cssOverride.text);
                        }
                    }
                    if (this.yieldingEnabled) {
                        // get time between render from conf , default 0
                        var conf = this.global ? this.global : {};
                        var timeBetweenYield = conf['yield-delay'] ? conf['yield-delay'] : 0;
                        this.executeRBoxDrawQueue(timeBetweenYield);
                    }

                    TRC.unmaskedIpParser.parse(response);
                };

                this.checkPreloadRequest = function () {
                    var deferTimeScriptRender = TRC.util.parseTimeout(this.global['defer-scripts-render']);

                    Object.keys(this.preloadRequest).forEach(function (pl) {
                        var placementData = win.placementData = this.preloadRequest[pl];
                        if (!placementData) {
                            return
                        }
                        if (this.placementShouldHaveResponseData(placementData, pl) && !this.placementHasResponseData(placementData)) {
                            __trcWarn("Server did not provide response for '" + pl + '"!');
                            delete this.preloadRequest[pl];
                            if (this.shouldRetryFailedPlacementRequest(placementData)) {
                                this.retryFailedPlacementRequest(pl, placementData);
                            } else {
                                TRC.dispatch('onRboxFlowError', {placement: pl});
                            }
                        }
                        if (this.isActivePlacementData(placementData, pl) && placementData.dc) {
                            placementData.dc.renderAd();
                        }
                        if (placementData.scriptData) {
                            if (deferTimeScriptRender !== -1) {
                                setTimeout(function (scriptData, placementData) {
                                    TRC.ScriptRenderer.render(placementData.scriptData, placementData);
                                }.trcBind(null, placementData.scriptData, placementData), deferTimeScriptRender);
                            } else {
                                TRC.ScriptRenderer.render(placementData.scriptData, placementData);
                            }
                        }

                        if (!this.shouldRenderBannerAsNative(placementData)) {
                            if (this.isCreateTaboolaConnectCard(placementData)) {
                                var taboolaConnectCardConfig = this.getTaboolaConnectCardConfig(placementData);
                                if (!taboolaConnectCardConfig) {
                                    TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: 'HTML-filter-no_connect_card_config', value: '1', type: 'counter'}, null);
                                    return;
                                }
                                TRC.taboolaConnect.createCard(taboolaConnectCardConfig);
                            }
                        }
                    }, this);
                };

                this.shouldRenderBannerAsNative = function (placementData, currItem) {
                    currItem = currItem || (placementData.trcResponse && placementData.trcResponse.v && placementData.trcResponse.v[0]);
                    return this.global['display-ad-to-native'] && currItem && currItem.rban;

                };

                this.isCreateTaboolaConnectCard = function (placementData, videoData) {
                    var isHtmlCard = placementData.trcResponse && placementData.trcResponse.ifr;
                    var displayInSlot = videoData && videoData.ifrObj;
                    return !!placementData.iframeData || !!isHtmlCard || !!displayInSlot;
                };

                this.getTaboolaConnectCardConfig = function (placementData, displayDataItem) {
                    var placementConfig = placementData.trcResponse && placementData.trcResponse.config,
                        trcResponse = placementData.trcResponse || {},
                        cardSize = trcResponse.cd || {},
                        iframeData = placementData.iframeData || {},
                        displayInSlotData = displayDataItem && displayDataItem.ifrObj || {},
                        config = iframeData.config || placementConfig || (displayInSlotData.config) || {},
                        language = this.language === 'tb-jp' ? 'ja-JP' : this.language,
                        url = iframeData.url || (trcResponse && trcResponse.url) || (displayInSlotData.url),
                        placementUniqueId = this.getItemSignature(trcResponse);

                    displayDataItem = displayDataItem || (iframeData && iframeData.v ? iframeData.v[0] : {});

                    var video;
                    var clickUrl = '';
                    config.isRtb = null;
                    if (displayDataItem || (trcResponse.v && trcResponse.v.length > 0)) {
                        video = displayDataItem || trcResponse.v[0];
                        var rboxId = placementData.multiWidgetModeLevelData && placementData.multiWidgetModeLevelData.RBox
                            ? placementData.multiWidgetModeLevelData.RBox.id : placementData.container._trcRboxId;

                        var trcrBox = this.boxes[rboxId];
                        var isRtb = video['is-rtb'] === 'true';
                        config.isRtb = isRtb;

                        if (!trcrBox) {
                            var rtbText = isRtb ? '-rtb' : '-non_rtb';
                            TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: 'HTML-error-no_rbox' + rtbText, value: '1', type: 'counter'}, null);
                            return null;
                        }

                        video = __trcCopyProps(video, {}, { // update video object with meta data
                            isSyndicated: video["is-syndicated"] || video["is-in-network"] || video["is-native"],
                            isPhoto: video.type === 'photo',
                            isText: video.type === 'text',
                            imageIframe: video.hasOwnProperty('image-iframe') && video['image-iframe'],
                            tags: (typeof video.tags === 'string') ? TRC.text.parseCSV(video.tags) : [], // parse the tags field (if exists) into a list
                            placement: trcrBox.placement,
                            mode: trcrBox.mode
                        });

                        if (Object.keys(displayDataItem).length === 0) {
                            displayDataItem = video;
                        }

                        clickUrl = trcrBox.createVideoBoxClickUrl(video);
                    }

                    return {
                        itemData: video,
                        container: placementData.container,
                        src: url,
                        config: config,
                        placementName: placementData.placement,
                        language: language,
                        clickUrl: clickUrl,
                        rvMargin: displayDataItem && displayDataItem.rvpm && displayDataItem.rv ? displayDataItem.rvpm : false,
                        maxPixelPerSecond: this.getPixelPerSecond(displayDataItem),
                        localDynamicContentLoader: this.shouldUseLocalDcl(displayDataItem),
                        renderBannerAsNative: this.shouldRenderBannerAsNative(placementData, displayDataItem),
                        uniqueId: placementUniqueId || '',
                        height: cardSize.ch || 0,
                        width: cardSize.cw || 0
                    };
                };

                this.getItemSignature = function (response) {
                    if (response && response.v && response.v[0] && response.v[0].rvpm) {
                        return response.v[0].sig || response.ri || '';
                    }
                    return '';
                };

                this.getPixelPerSecond = function (iframeDataItem) {
                    if (iframeDataItem && iframeDataItem.rvpps && iframeDataItem.rv) {
                        return iframeDataItem.rvpps;
                    }
                    return this.global['display-rv-maxpps'];
                };

                this.initRBoxDrawingIfPlacementEligible = function (placementData) {
                    this.renderController.placementRender(placementData);
                };

                this.buildExperimentsVariantIdParams = function () {
                    var rboxReportedExperimentsLayers = this.global['rbox-reported-experiments-layers'] || [2, 6, 48, 50];
                    this.experimentsVariantIdParamsStr = '';

                    this.experimentsVariantIdParamsMap = Object.keys(this.experimentsData).reduce(function (params, layer) {
                        if (rboxReportedExperimentsLayers.indexOf(Number(layer)) > -1) {
                            params['tvi' + layer] = this.experimentsData[layer].split('|')[1];
                        }
                        return params;
                    }.trcBind(this), {});

                    return TRC.TRCLogger.formatParams(this.experimentsVariantIdParamsMap);
                };

                this.addFormattedResponseToWidgetAddedFromTrc = function (recommendation, formattedResponse, addedWidget) {
                    if (addedWidget) {
                        this.preloadRequest[recommendation.uip].response = formattedResponse;
                    }
                };

                this.shouldUseLocalDcl = function (iframeDataItem) {
                    if (iframeDataItem && typeof iframeDataItem.rvdcl !== undefined && iframeDataItem.rv) {
                        return iframeDataItem.rvdcl == 'true' ? true : false;
                    }
                    return TRC.util.isPercentEnabled(this.global, 'enable-local-dcl');
                };

                /**
                 * returns a valid container for rbox to be loaded on.
                 * container can be fetched from fpp originated list in the trc response
                 * or the original push container.
                 * @param placementData
                 * @param warnMsg
                 * @returns validContainer
                 */
                this.getWidgetContainer = function (placementData, warnMsg) {
                    var originalContainer = placementData.container;
                    var shouldRenderOnOriginalContainer = !(placementData['render-on-orig-container'] == 0); // Only 0 or '0' should be considered as false

                    if (!doc.querySelectorAll) {
                        // querySelector not supported
                        return originalContainer;
                    }

                    var validContainer = this.getOrCreateContainerForMoveOrAddWidget(placementData['container-selectors'], originalContainer, warnMsg);
                    if (validContainer) {
                        return validContainer;
                    }

                    if (shouldRenderOnOriginalContainer) {
                        return originalContainer;
                    }

                    __trcWarn('TRC.getWidgetContainer: Not falling back to original container even though could not find valid container when trying to move ' + warnMsg);
                    return null;
                };

                this.getOrCreateContainerForMoveOrAddWidget = function (containerSelectorsTupleArray, originalContainer, warnMsg) {
                    if (containerSelectorsTupleArray) {
                        try {
                            for (var i = 0; i < containerSelectorsTupleArray.length; i++) {
                                var containerSelector = __trcCopyProps(containerSelectorsTupleArray[i], {});
                                if (this.global["immutable-placement-data-on-add-widget"]) {
                                    containerSelector = containerSelectorsTupleArray[i]; // rollback flag in case of issue with copy instead of immutable
                                }
                                var container = this.getOrCreateContainer(containerSelector, originalContainer);
                                if (container) {
                                    return container;
                                }
                            }
                            __trcWarn('TRC.extractValidContainer: Could not find any valid container when trying to move ' + warnMsg);
                        } catch (err) {
                            __trcError('TRC.extractValidContainer: Error occured while trying to find valid container', err);
                        }
                    }

                    return null;
                };

                /**
                 * @param containerSelector = { container, shouldCreateContainer, location, isFloatingUnit }
                 * @param originalContainer
                 */
                this.getOrCreateContainer = function (containerSelector, originalContainer) {
                    var currentSelector = this.getAddedContainerSelector(containerSelector);
                    var shouldCreateContainer = containerSelector.shouldCreateContainer;
                    var currNodeList = doc.querySelectorAll(currentSelector);

                    // Currently allowing to move widget only to unique selector on the page
                    if (currNodeList && currNodeList.length === 1) {

                        // Checking if we need to add new container to the page
                        if (TRC.util.isTrue(shouldCreateContainer)) {
                            // Creating new container with timestamp as id
                            containerSelector.shouldCreateContainer = false;
                            currNodeList = [this.createNewContainer(containerSelector.location, currNodeList[0], containerSelector.id)];
                        }

                        // Found selector on the page
                        var validContainer = this.ensureValidContainer(currNodeList[0]);
                        if (validContainer === originalContainer) {
                            return originalContainer;
                        }

                        if (validContainer) {
                            if (!containerSelector.isFloatingUnit) {
                                this.cleanContainerClasses(originalContainer);
                            }
                            return validContainer;
                        }
                    } else {
                        TRC.dispatch('vp-selector-not-found');
                    }
                };

                this.getAddedContainerSelector = function (containerSelector) {
                    var addedContainerSelector = containerSelector.container;
                    if (addedContainerSelector) {
                        return addedContainerSelector;
                    }
                    var originalPlacementName = containerSelector.originalPlacementName;
                    if (originalPlacementName) {
                        var requestList = this.preloadRequest;
                        var pushedContainerId;
                        Object.keys(requestList).some(function (preloadedPlacementName) {
                            if (preloadedPlacementName === originalPlacementName) {
                                var publisherPushedContainerId = requestList[preloadedPlacementName].original_container;
                                pushedContainerId = '#' + publisherPushedContainerId;
                                return true;
                            }
                        });
                        return pushedContainerId;
                    }
                };

                this.createNewContainer = function (location, ancestorContainer, id) {
                    var newContainer,
                        containerId,
                        locationTranslated;
                    var idPrefix = this.global['add-widgets-id-prefix'] === false ? '' : 'tbl_';
                    newContainer = doc.createElement('div');
                    containerId = id || idPrefix + new Date().getTime();
                    newContainer.id = containerId;

                    // Creating new container with timestamp as id
                    locationTranslated = this.getLocationContainer(location);
                    if (locationTranslated) {
                        ancestorContainer.insertAdjacentElement(locationTranslated, newContainer);
                    }

                    return newContainer;
                };

                this.getLocationContainer = function (location) {
                    switch (location) {
                        case 'first':
                            return 'afterbegin';
                        case 'last':
                            return 'beforeend';
                        case 'before':
                            return 'beforebegin';
                        case 'after':
                            return 'afterend';
                        default:
                            return '';
                    }
                };

                this.cleanContainerClasses = function (container) {
                    if (container) {
                        // Currently removing all classes, assuming its fine since the container will not be used.
                        container.className = '';
                    }
                };

                /**
                 * add ab related variants properties to formatted response
                 * @param response
                 * @param index
                 * retrun formattedResponse
                 */
                this.addVariantProperties = function (formattedResponse, response, index) {
                    var list = response.trc.vl[index],
                        recommendationSet = formattedResponse || {
                            trc: {
                                "video-list": {}
                            }
                        };
                    recommendationSet.trc["test-variant"] = response.trc.t;
                    recommendationSet.trc.uvpw = response.trc.uvpw;
                    recommendationSet.trc["video-list"]["base-mode"] = list.m;
                    recommendationSet.trc["video-list"]["test-variant"] = list.t;
                    return recommendationSet;
                };

                /**
                 * returns a formated(with global properties) recommendation object.
                 * @param response
                 * @param index
                 * @param cssOverride
                 * @returns {Object}
                 */
                this.formatPlacementRecommendations = function (response, index, cssOverride) {
                    var list = response.trc.vl[index],
                        cssText,
                        preloadRequest = this.preloadRequest[list.uip] || {},
                        recommendationSet = {
                            trc: {
                                req: list.ri,
                                "session-id": response.trc.si,
                                "session-data": response.trc.sd,
                                "user-id": response.trc.ui,
                                "watched-item": response.trc.wi,
                                "country-code": response.trc.cc,
                                "test-variant": response.trc.t,
                                "is-provider": !!response.trc.iframeData,
                                uvpw: response.trc.uvpw,
                                placement: list.uip,
                                mode: preloadRequest.mode,
                                DNT: response.trc.DNT, // "Do Not Track"
                                cpb: response.trc.cpb, // piggyback parameter,
                                sl: response.trc.sl,
                                pi: response.trc.pi,
                                bdp: response.trc.bdp,
                                ppb: list.ppb, // piggyback parameter
                                "test-data": response.trc.td,
                                "placement-group": list.pg,
                                "organic-personalization": response.trc.op // organic personalization
                            }
                        };

                    if (list.prty || list.caty) {
                        recommendationSet.trc.prty = list.prty;
                        recommendationSet.trc.caty = list.caty;
                    }

                    if (response.cached) {
                        recommendationSet.cached = true;
                        recommendationSet.cachedViewId = response.cachedViewId;
                    }

                    if (list.dc && list.typ !== 'tbl') {
                        recommendationSet.trc.tag = list;
                    } else {
                        recommendationSet.trc["video-list"] = {
                            video: list.v,
                            "base-mode": list.m,
                            "test-variant": list.t,
                            "properties-override": (list.po && TRC.util.jsonParseCustomNative('{' + list.po + '}')) || null,
                            "container-selectors": list.cs,
                            "next-up-widget": list.nup,
                            "removed-widget": list.rw,
                            "taboola-reminder": list.tr,
                            "render-on-orig-container": list.rooc,
                            vtag: list.vtag,
                            pvc: list.pvc,
                        };
                    }

                    if (response.trc.cm) {
                        recommendationSet.trc['consent-missing'] = response.trc.cm;
                    }

                    if (cssText = list.csso) {
                        cssOverride.text = this.getModeOverrideCss(cssOverride, cssText, preloadRequest);
                    }

                    if (list.fpl) {
                        recommendationSet.feedPlacement = list.fpl;
                    }

                    if (response.trc.evi) {
                        recommendationSet.experimentsData = response.trc.evi;
                    }

                    return this.addVariantProperties(recommendationSet, response, index);
                };

                this.getModeOverrideCss = function (cssOverride, cssText, preloadRequest) {
                    if (cssText.indexOf('$container_id$') > -1) {
                        try {
                            cssText = TRC.text.replaceAll(cssText, '\\$container_id\\$', "#" + preloadRequest.container.id, null);
                        } catch (e) {
                            cssText = TRC.text.replaceAll(cssText, '\\$container_id\\$', "", null);
                        }
                    }
                    return (cssOverride.text) ? cssOverride.text + cssText : cssText;
                };

                this.loadSpotlight = function () {
                    if (!document.querySelectorAll) {
                        return; // old browser - ie < 8
                    }
                    if (this.spotlightLoaded) {
                        TRC.dispatch('trc_afterRboxDraw');
                    } else {
                        this.spotlightLoaded = TRC.URL.prototype.switchProtocol.call(TRC.getBackstageUrl() + "resources/js/1.1.0/spotlight.js", protocol);
                        this.loadExternal(this.spotlightLoaded, 'js');
                    }
                };

                this.sendUserIdTags = function (event) {
                    // Sending external tracking for urls array in event.data (this.trc.stp)
                    return this.sendExternalTracking(event.data, win.TRC.sharedObjects.loadedPixels);
                };

                this.initFrameworks = function (framework) {
                    if (framework === 'amp' && TRC.amp) {
                        TRC.amp.setAMPmodule(this);
                        return;
                    }
                    if (framework === 'mobile-sdk') {
                        this.manualVisibilityTrigger = true;

                    }

                };

                /*
                * disable cache for investigate json trc response
                * just add to the url "tbl_disable_cache" and it will disable cache for all session
                * */
                function disableCacheUrlParam(global) {
                    try {
                        var shouldDisableCacheCurrentSession = window.sessionStorage && window.sessionStorage.getItem('tbl_disable_cache');
                        if (global['enable-trc-cache'] && (shouldDisableCacheCurrentSession || TRC.URL.prototype.getParameter.call(location.href, 'tbl_disable_cache'))) {
                            window.sessionStorage.setItem('tbl_disable_cache', 'true');
                            global['enable-trc-cache'] = false;
                        }
                    } catch (e) { /* for session storage throw error - browser setting 3rd party denied */
                    }
                }

                /**
                 *  Initialize the TRC client internal data structures and fetch metadata from the current page.
                 */
                this.init = function (configuration) {
                    (TRC.tlf && console.timeStamp('init TRCImpl'));
                    var emulateABP = TRC.URL.prototype.getParameter.call(location.href, 'trc_abp');
                    __trcCopyProps(configuration, this);
                    if (TRC.util.hasKeys(this["trc-network-mapping"])) {
                        TRC.networkId = TRC.publisherId;
                        this.shiftPublisherId(this["trc-network-mapping"]);
                        var netPubsGlobal = this['network-pubs-global'];
                        if (netPubsGlobal && netPubsGlobal[TRC.publisherId]) {
                            TRC.util.merge(this.global, netPubsGlobal[TRC.publisherId]);
                        }
                    }
                    (globalParams.framework && this.initFrameworks(globalParams.framework));
                    this.boxes = {};
                    this.unique_placement_count = {};
                    this.tags = []; // current item's metadata tags
                    this.metadata = {};
                    this.trcRequestDelay = this.global['trc-request-delay'] || TRC_REQUEST_DELAY;
                    this.trcByPass = (this["trc-skip-failover"] === true); // Akamai internal DSA skip flag
                    this.enablePageGeometry = this.global['has-page-geometry'];
                    this.enablePageGeometryExtended = this.global['has-page-geometry-extended'];
                    this.enableSlotsGeometry = this.global['has-slots-geometry'];
                    this.enableSlotsSaliency = this.global['has-slots-saliency'];
                    // mobile safari has an issue with css lite inject
                    this.cssLiteInject = this.global['enable-mode-injection'] && !(window.navigator && typeof window.navigator.userAgent === 'string' && (/(iPhone|iPad)(?=.*AppleWebKit)(?!.*CriOS)/i.test(window.navigator.userAgent)));
                    this.spatialSlotsThrottleMax = this.global['spatial-slots-throttle-max'];
                    this.spatialSlotsThrottleTH = this.global['spatial-slots-throttle-th'];
                    this.spatialSlotsThrottleTHPerPage = this.global['spatial-slots-throttle-th-per-page'];
                    this.enablePlacementGeometry = this.global['has-mode-geometry'];
                    this.maxRetriesPerFailedPlacementRequest = this.global['max-retries-per-failed-placement-req'] || 1;
                    if (doc.browsingTopics && this.global['topics-enabled']) {
                        TRC.ModuleLoader.load('google-topics-api', TRC.GoogleTopicsApi, function () {
                        });
                    }
                    this.configForPostEvent = {
                        available: this.global['send-avail-as-post'],
                        visible: this.global['send-event-as-post'],
                        "new-visible": this.global['send-event-as-post'],
                        explore: this.global['send-explore-as-post'],
                        "content-hub-available": this.global['send-avail-as-post'],
                        "content-hub-visible": this.global['send-event-as-post'],
                        "content-hub-explore": this.global['send-explore-as-post'],
                        "required-viewability-available": this.global['send-rv-avail-as-post'],
                        perf: true,
                        "rtb-win": true,
                        metrics: true,
                        "api-rtb-win": true,
                        "review-mode": true
                    };
                    this.configForGetEvent = {
                        available: this.global['send-avail-as-get'],
                        visible: this.global['send-visible-as-get'],
                        "new-visible": this.global['send-visible-as-get'],
                        explore: this.global['send-explore-as-get'],
                        "content-hub-available": this.global['send-avail-as-get'],
                        "content-hub-visible": this.global['send-visible-as-get'],
                        "content-hub-explore": this.global['send-explore-as-get'],
                        "required-viewability-available": this.global['send-rv-avail-as-get'],
                        perf: false,
                        "rtb-win": false,
                        metrics: false,
                        "api-rtb-win": false
                    };

                    this.trcRoute = null;
                    this.enableTrcRoute = this.global["enable-trc-route"] === true;
                    this.enableLoaderCacheBuster = this.global["enable-loader-cache-buster"] === true;
                    this.eventTypesToRoute = this.global['event-types-to-route'] || [];
                    this.enableTrcEventRoute = this.eventTypesToRoute.length > 0;
                    this.trcEventRoute = this.enableTrcEventRoute ? this.global['default-event-route'] || false : null;
                    this.enableTrcEventRouteExperiment = this.global['enable-trc-event-route-experiment'] === true; // :todo *remove declaration* after events route bypass experiment is over
                    this.enableExperimentsVariantIdEvent = this.global["enable-experiments-variant-id-event"];
                    this.enableLoaderTypeEvent = this.global["enable-loader-type-event"];
                    this.isDeferredAvailable = this.global['enable-deferred-available'];
                    this.enableExpoImageTag = this.global["enable-expo-img-tag"] !== false;
                    this.trcParams = TRC.pageManager.additionalDispatchParams();
                    this.trcCacheClean = this.global['clean-trc-cache'];
                    disableCacheUrlParam(this.global);
                    this.trcCache = (this.global['enable-trc-cache']) ? new TRC.TrcCache(this.global['trc-cache-conf'] || {}) : null;
                    this.trcCacheItemType = this.global['trc-cache-it'];
                    this.disableReadMore = (this.global['enable-read-more'] === false || this.disableReadMore === false);
                    this.blockVideoLoader = this.shouldBlockVideoLoader(this.global['block-video-prob']);
                    this.blockThumbnailVideoLoader = this.shouldBlockThumbnailVideoLoader(this.global['block-thumbnail-video-prob']);

                    if (this.global['enable-consent']) {
                        this.setConsentConfig(this.consentConfigOverride, this.global['consent-presets']);
                    }
                    // return backstage url
                    // will be called by spotlight
                    TRC.getBackstageUrl = (function () {
                        var backstageDomainPrefix = TRC.backstageDomainPrefix || 'backstage';
                        var backstageDomainSuffix = TRC.backstageDomainSuffix || 'taboola.com';
                        return this['backstage-domain-url'] || 'https://' + backstageDomainPrefix + '.' + backstageDomainSuffix + '/backstage/';
                    }).trcBind(this);

                    if (emulateABP) {
                        this.setABPEmulation(emulateABP);
                    } else if (this.global["abp-detection-enabled"]) {
                        TRC.blocker.blockedState = TRC.blocker.getBlockedState(this.global["abp-detection-class-names"] || ['banner_ad', "sponsored_ad"], this.global['abp-ignore-cached-state']);
                    } else {
                        TRC.blocker.blockedState = TRC.blocker.states.ABP_DETECTION_DISABLED;
                    }

                    // set up the style sheets
                    if (!TRC.styleInjected && !this.cssLiteInject) {
                        this.bakedStyelInjection();
                    }

                    this.domain = TRC.shiftDomain(this.global['requests-domain'] ? this.global['requests-domain'] : 'trc.taboola.com');

                    if (!(this.origin instanceof Array)) {
                        this.origin = [this.origin];
                    }
                    // take into account publisher provided user meta-data
                    if (this.userMetadata != null) {
                        this.metadata.user = __trcJSONify(this.userMetadata);
                    } else if (typeof win.trc_user_id === 'undefined') this.metadata.user = this['get-user'](); // 'get-user' - a client property
                    else this.metadata.user = win.trc_user_id;
                    // execute publisher_start and other start actions
                    try {
                        TRC.pConsole("page", "debug", "Hook : publisher_start", this['publisher-start'].toString());
                        this['publisher-start']();
                    } catch (e) {
                        __trcError("Error running publisher-start", e);
                    }

                    // Execute all dynamic module that were registered to publisher-start lifecycle
                    try {
                        TRC.DynamicModulesManager.executeDynamicModules('publisher-start', this.global);
                    } catch (e) {
                        __trcError("Error running Dynamic module start", e);
                    }

                    // "client crawling" meta data on current page
                    this.metadata.uploader = this['get-creator']();
                    this.tags = this['get-tags']();
                    try {
                        this.metadata.v = this['get-views']();
                        this.metadata.r = this['get-rating']();
                        this.metafields.split(',').forEach((function (i) {
                            if (!i) return;
                            this.metadata[i] = (this['get-' + i]) ? this['get-' + i]() : this.readMetaTag(i);
                        }).trcBind(this));
                    } catch (e) {
                        // publisher methods may break, make sure I don't break because of that.
                    }

                    this.initFraudDetection();
                    this.configOverrides = new ConfigOverrides(this);


                    TRC.listen("send_user_id", this.sendUserIdTags.trcBind(this));

                    TRC.listen("load_script_tags", this.loadScriptTags.trcBind(this));

                    if (window.context && window.context.data && window.context.data.feedContainerNum
                        && parseInt(window.context.data.feedContainerNum, 10) >= 1) {
                        TRC.isAMPSplitFeed = true;
                        TRC.feedContainerNum = window.context.data.feedContainerNum;
                    }

                    var isMobileSDK = !!(TRC.mobile && TRC.mobile.reportClick);
                    if (!isMobileSDK && !TRC.isAMP && TRC.util.isPercentEnabled(this.global, 'spa-detection-enabled')) {
                        var trcResponseHandledEventOccurred = false;
                        TRC.listen('trcResponseHandled', function () {
                            trcResponseHandledEventOccurred = true;
                            if (TRC.SpaDetector) {
                                TRC.SpaDetector.getInstance(this).sendSpaData();
                            }
                        });
                        TRC.ModuleLoader.load('spa-detector', TRC.SpaDetector, (function () {
                            var spaInstance = TRC.SpaDetector.getInstance(this);
                            if (trcResponseHandledEventOccurred) {
                                spaInstance.sendSpaData();
                            }
                        }).trcBind(this));
                    }

                    if (TRC.util.isPercentEnabled(this.global, 'guarantee-card-clash-detection')) {
                        TRC.ModuleLoader.load('card-interference-detector', TRC.CardInterferenceDetector, function () {
                        });
                    }

                    TRC.pageManager.initReferrer(this.global);

                    this.renderController = new TRC.RenderControl(this);

                    this.init = function () {
                        // init was completed, remove init from circulation to prevent it being called twice
                    };
                    TRC.isPageLoaded = false;
                    // lets clean the users localstorage from unused trc cache
                    if (this.trcCacheClean && !this.trcCache) {
                        this.trcCache = new TRC.TrcCache({}, true);
                        this.trcCache = null;
                    }

                    this.listenToRenderedModes();
                    if (this.global['enable-always-track'] && !TRC.pushedRboxTracking) {
                        pushRboxTrackingMode();
                        TRC.pushedRboxTracking = true;
                    }
                    if (!TRC.adHeavyManager) {
                        TRC.adHeavyManager = new AdHeavyManager(this);
                    }
                };

                this.initFraudDetection = function () {
                    if (this.shouldEnableFraudDetection()) {
                        // send report to monitor how much we  load protected media
                        __trcWarn('protected media: enableFraudDetection');
                        var listenedEvent = this.global.test_for_fraud_from_tag_loader ? 'fraud-consent' : 'trcResponseHandled';
                        TRC.listen(listenedEvent, this.enableFraudDetection.trcBind(this));
                    }
                };

                var _expoImageTag = null;
                this.getExpoImageTag = function () {
                    if (_expoImageTag !== null) {
                        return _expoImageTag;
                    }
                    _expoImageTag = "";
                    if (!!this.enableExpoImageTag && this.getSystemFlag("imageExternal") !== null) {
                        _expoImageTag = 'tb_expo_img=' + this.getSystemFlag("imageExternal");
                    }
                    return _expoImageTag;
                };

                var _loaderTypesValue = null;
                var _loaderTypesObject = null;
                this.getLoaderTypesValue = function () {
                    if (_loaderTypesObject) {
                        return _loaderTypesValue;
                    }

                    _loaderTypesValue = "";
                    _loaderTypesObject = {};
                    if (!this.enableLoaderTypeEvent) {
                        return _loaderTypesValue;
                    }
                    if (this.systemFlags.loaderType) {
                        _loaderTypesValue = "lti=" + this.systemFlags.loaderType;
                        _loaderTypesObject.lti = this.systemFlags.loaderType;
                    }

                    var eventExternal = this.systemFlags.eventExternal;
                    if (!eventExternal) {
                        return _loaderTypesValue;
                    }

                    Object.keys(eventExternal).forEach(function (key) {
                        _loaderTypesValue += (_loaderTypesValue ? "&" : "") + ("ex_" + key + "=" + eventExternal[key]);
                        _loaderTypesObject["ex_" + key] = eventExternal[key];
                    });
                    return _loaderTypesValue;
                };

                this.getLoaderTypesObject = function () {
                    if (!_loaderTypesObject) {
                        this.getLoaderTypesValue();
                    }
                    return _loaderTypesObject;
                };

                function pushRboxTrackingMode() {
                    if (!document.body) {
                        return;
                    }
                    var reqName = 'rbox-tracking';
                    var divId = reqName + '-div';
                    if (!document.getElementById(divId)) {
                        var div = document.createElement('div');
                        div.id = divId;
                        document.body.appendChild(div).style.display = 'none';
                    }
                    win._taboola.push({
                        mode: reqName,
                        container: divId
                    });
                }

                this.stackedStyleInjection = function (defaultCss, customPublisherCss, rtlCss, signEntryPoint) {
                    if (!TRC.cssStack) {
                        TRC.cssStack = new TRC.css.Stack({
                            idPrefix: 'tab_',
                            stack: [
                                {
                                    type: 'default',
                                    cssText: defaultCss + (rtlCss || '')
                                },
                                {
                                    type: 'mode',
                                    cssText: ''
                                },
                                {
                                    type: 'publisher',
                                    cssText: customPublisherCss
                                },
                                {
                                    type: 'custom',
                                    cssText: ''
                                }
                            ]
                        }, signEntryPoint);
                    }
                };

                this.bakedStyelInjection = function () {
                    var cssText = this.defaults.style + this.global.style;
                    if (this.global['css-ie-split'] && TRC.Browser.ieUpto(9)) {
                        // we just want to use the css split utilities of the css isolation feature without augmenting the rules
                        TRC.css.utils.setStyleElements(TRC.css.utils.setStyleTextIdPrefix(cssText, null));
                    } else {
                        TRC.dom.injectStyle(cssText);
                    }
                };

                this.setABPEmulation = function (abpState) {
                    TRC.blocker.blockedState = abpState;
                    this.global["abp-detection-enabled"] = true;
                    this.global["use-abp-uim"] = true;
                    TRC.pConsole("page", "warn", "emulating Ad Blocker Plus detection.");
                };

                this.setConsentConfig = function (configOverride, presets) {
                    if (TRC.consent.hasCMP()) return;
                    if (presets) {
                        TRC.consent.setPresets(presets);
                    }
                    if (configOverride) {
                        TRC.consent.setConsentSource(TRC.util.merge({source: 'iab_override'}, configOverride));
                    } else if (typeof window.__tcfapi === 'function') {
                        TRC.consent.setConsentSource({source: 'tcf'});
                    } else if (typeof window.__cmp === 'function') {
                        TRC.consent.setConsentSource({source: 'iab'});
                    }
                };

                this.countTrcContainerMissingError = 0;

                /**
                 * Initialize the primary DOM container for the R-Box UI
                 * @param {*} publisher_container An existing DOM container if the publisher provided one
                 * @param {Boolean} isRetryOnError - if true and publisher_container is not found, return null instead of
                 *                         creating a new default container
                 */
                this.ensureValidContainer = function (publisher_container, isRetryOnError) {
                    var origContainer = publisher_container,
                        TRC_CONTAINER_NAME = "trc_related_container",
                        TRC_IN_IFRAME_CLASS = (TRC.dom.isInIframe(true)) ? " trc_in_iframe" : "",
                        RTL_CLASS = this.direction === 'rtl' ? ' tbl-rtl' : '',
                        containerCSSClass = " " + TRC_CONTAINER_NAME + " trc_spotlight_widget" + TRC_IN_IFRAME_CLASS + RTL_CLASS;

                    if (typeof publisher_container === "string") {
                        // need to resolve "container by ID"
                        publisher_container = document.getElementById(publisher_container);
                        if (isRetryOnError) {
                            if (!publisher_container) {
                                // too soon! return null to try again later
                                return null;
                            }
                        }
                    }

                    if (typeof publisher_container !== "object") { // safety first
                        publisher_container = null;
                    }

                    // if the publisher provided a container, clear it and we're done
                    if (publisher_container != null) {
                        if (publisher_container.className.match(TRC_CONTAINER_NAME)) {
                            return publisher_container; // prevent double init.
                        }

                        while (publisher_container.hasChildNodes()) {
                            publisher_container.removeChild(publisher_container.firstChild);
                        }
                        publisher_container.origClassName = publisher_container.className;
                        publisher_container.className += containerCSSClass;
                        return publisher_container;
                    }

                    // the publisher may as well provide a container by simply setting a DOM element with the specified ID
                    if ((publisher_container = document.getElementById(TRC_CONTAINER_NAME)) != null) {
                        // make sure that it has the correct class, even when created by the publisher
                        if (publisher_container.className.search(TRC_CONTAINER_NAME) <= 0) {
                            publisher_container.origClassName = publisher_container.className;
                        }

                        publisher_container.className += containerCSSClass;
                        return publisher_container;
                    }

                    if (!document.body) {
                        return null;
                    }

                    if (this.countTrcContainerMissingError < 2) {
                        this.countTrcContainerMissingError += 1;
                        __trcError("Didn't manage to find TRC container for R-Box with ID " + origContainer + " (retry=" + this.countTrcContainerMissingError + ") "
                            + (TRC.dom.isReady ? "(Document is Ready)" : "") + "!");
                    }

                    return null;
                };

                this.getPublisherVersion = function () {
                    return "default";
                };

                this.getItemType = function () {
                    // since source is common to all instances
                    // we might as well check the global listOrigin object
                    switch (TRC.listOrigin.getSource()) {
                        case 'h':
                            return 'home';
                        case 'c':
                            return 'category';
                        case 't':
                            return 'text';
                        case 's':
                            return 'search';
                        case 'p':
                            return 'photo';
                        case 'o':
                            return 'other';
                        case 'z':
                            return 'content_hub';
                        case 'v':
                        default:
                            return 'video';
                    }
                };

                this.getUserLanguages = function () {
                    if (navigator.languages) {
                        return navigator.languages;
                    }
                    return navigator.language ? [navigator.language] : [];
                };

                this.getUserAgentData = function () {
                    return TRC.userAgentDataObject;
                };

                /* Hookups for the public API */

                /**
                 * Hookup for the playVideo public API
                 * @param {Object} param  - contains:
                 *          id - the publisher's item identification for the item to play
                 *          url the publisher's item's canonical URL for the item to play (optional)
                 */
                this.playVideo = function (param) {
                    TRC.RBoxUsage.logUsage('TRCImpl.playVideo');
                    try {
                        TRC.dispatch('videoPlaying', param);
                    } catch (e) {
                        __trcError("Problem in playVideo:videoPlaying", e);
                    }
                    if (typeof param.id === "undefined") { // fail fast
                        return;
                    }
                    // set our global arguments
                    if (win.trc_video_id == param.id) { // if this is not a new item
                        return; // then there is no need to continue
                    }
                    var source = TRC.listOrigin.getSource();
                    if (typeof param.url === 'undefined') {
                        if (!win.trc_video_id && source === 'v') {
                            param.url = this.getAutoItemMeta('item-url', null, this.urlPreNormalizer, this['normalize-item-url']);
                            this.trc_url_auto_detection = param.id;
                        } else param.url = null;
                    }
                    win.trc_video_id = param.id;
                    win.trc_item_url = param.url;
                    // if loadRBox is waiting for us, call it now
                    if (this.delayedDispatchLoadRequest != null) {
                        this.delayedDispatchLoadRequest();
                    }
                };

                /**
                 * Hookup for the setUser public API
                 * @param params - dictionary of user specific metadata
                 */
                this.setUser = function (params) {
                    this.userMetadata = params;
                    TRC.pConsole("page", "info", "user meta data ", params, "object");
                };

                this.calculatePlacement = function (options) {
                    if (options.mode_name.search('rbox-tracking') >= 0) return options.mode_name;
                    var placement = (options.mode_name + (options.category ? '!' + options.category : ''));
                    if (typeof this.unique_placement_count[placement] !== "undefined") placement += "#" + (++this.unique_placement_count[placement]);
                    return placement;
                };

                this.computeRBoxOptions = function (options) {
                    if (typeof options === 'string') options = {mode_name: options};
                    if (options.pubOpts) return options;
                    options.pubOpts = __trcCopyProps(options, {});
                    if (options.on_error) {
                        TRC.fallbackApi.setOnError(options);
                    }

                    // support tracking
                    options.tracking = ((this.tracking) ? this.tracking : '') + ((options.tracking) ? options.tracking : '');
                    // support 'target_type'
                    options.target_type = options.target_type
                        || this.target_type
                        || this.getProperty(options.mode_name, 'target_type')
                        || 'video';

                    options.origin = new TRC.ListOriginBuilder(TRC.listOrigin.getSource(), options.target_type);

                    // support requesting a specific UI mode
                    options.mode_name = (!!options.mode && options.mode) // current mode param
                        || (!!options.mode_name && options.mode_name) // legacy mode param
                        || (!!win.trc_mode_name && win.trc_mode_name) // support query string param
                        // or if none specified - compute default mode
                        || 'rbox-' + options.origin.toString();
                    options.mode_name = options.mode_name.replace(/\s+/g, '');
                    options.category = (!!options.category && options.category);

                    // support 'link_target'
                    options.link_target = options.link_target || this.link_target;


                    // compute placement if not specified
                    if (typeof options.placement === "undefined") {
                        options.placement = this.calculatePlacement(options);
                    }
                    this.unique_placement_count[options.placement] = 0;

                    // parse visible property
                    options.visible = typeof options.visible === 'boolean' ? options.visible : !this.invisible;

                    if (typeof options.autoplaybox === "string") { // support "auto play list" container provided as an id
                        options.autoplaybox = document.getElementById(options.autoplaybox);
                    }

                    // verify that we have a container setup correcly unless we have a player
                    // and going to render inside it.

                    if (!options.player && options.slider !== true && options.visible) {
                        options.original_container = options.container;
                        options.container = this.ensureValidContainer(options.container);
                    }

                    if (!options.addWidget) {
                        options.response = null;
                    }
                    options.computed = true;
                    return options;
                };

                this.listenToPlayer = function (options, playerContainer) {
                    var TRC_CONTAINER_NAME = 'trc_related_container',
                        RTL_CLASS = this.direction === 'rtl' ? ' tbl-rtl' : '';

                    var mylistener = TRC.listen('videoPlaying', (function (data) {
                        var player = document.getElementById(data.player_id),
                            mainCont;
                        if (!player) {
                            __trcError("TRC.listenToPlayer: wrong player_id was passed");
                            return;
                        }
                        if (TRC.dom.isAncestor(playerContainer, player, true)) {
                            mylistener.remove();
                            TRC.listen('videoPlaying', function (data) {
                                if (data.player_id === playerContainer.player_id) {
                                    mainCont.style.left = '-999999em';
                                } else {
                                    __trcError("TRC.listenToPlayer: wrong player_id was used for videoPlaying");
                                }
                            });

                            playerContainer.player_id = data.player_id;
                            if (options.container) {
                                if (typeof options.container === 'string') {
                                    options.container = document.getElementById(options.container);
                                }
                                mainCont = options.container;
                            }
                            if (!mainCont) {
                                options.container = mainCont = document.createElement("div");
                            }
                            mainCont.className = TRC_CONTAINER_NAME + ' trc-inplayer-rbox' + RTL_CLASS;
                            mainCont.style.left = '-999999em';
                            mainCont.style.width = player.offsetWidth + 'px';
                            mainCont.style.marginTop = '-' + player.offsetHeight + 'px';

                            playerContainer.appendChild(mainCont);

                            // ff + kaltura player bug. ff seems to render a new player after
                            // we append our widget to its parent
                            // we need to restart kaltura support
                            if (TRC.kaltura_API && TRC.Browser.firefox) {
                                delete TRC.kaltura_API;
                                TRC.kaltura_support();
                            }

                            options.getListId = function () {
                                return "rplayer-after";
                            };

                            options.list_id = options.getListId();
                            options.loaded = true;
                            this.internalDrawRBox(options);
                        } else {
                            __trcError("TRC.listenToPlayer: object with player_id wasn't found in playerContainer that was passed");
                        }
                    }).trcBind(this));

                    TRC.listen('videoDone', function (data) {
                        var mainCont = options.container;
                        if (!mainCont) {
                            __trcError("TRC.listenToPlayer:videoDone mainContainer wasn't found");
                            return;
                        }
                        if (data.player_id === playerContainer.player_id) {
                            mainCont.style.left = '0';
                        } else {
                            __trcError("TRC.listenToPlayer: wrong player_id was used for videoDone");
                        }

                    });

                    // ooyala specific events:

                    if (TRC.ooyala_API) {
                        TRC.listen('ooyala_stateChanged', function (data) {
                            var mainCont = options.container;
                            if (!mainCont) return;
                            if (data.player_id === playerContainer.player_id) {
                                mainCont.style.left = '-999999em';
                            } else __trcError("TRC.listenToPlayer: wrong player_id was used for ooyala_stateChanged");
                        });

                        TRC.listen('ooyala_activePanelChanged', function (data) {
                            var mainCont = options.container;
                            if (!mainCont) return;
                            if (data.player_id === playerContainer.player_id) {
                                mainCont.style.left = (data.activePanel === 'more' || data.activePanel === 'info') ? '0' : '-999999em';
                            } else __trcError("TRC.listenToPlayer: wrong player_id was used for ooyala_activePanelChanged");
                        });
                    }
                };
                this.loadRBoxDrawQueue = function LoadInternalDrawRBoxQ(widgetData) {
                    function isUrlOverrideYield(placement) {
                        if (!this.urlOverrideYieldArr) {
                            var yieldBatchParam = TRC.URL.prototype.getParameter.call(win.location.href, 'yield-batch');
                            this.urlOverrideYieldArr = yieldBatchParam ? yieldBatchParam.split('|') : [];
                        }
                        return this.urlOverrideYieldArr.indexOf(placement) > -1;
                    }

                    if (isUrlOverrideYield(widgetData.placement)) {
                        widgetData.modeGroupOrder = 0;
                    }

                    this.itemsToDraw = this.itemsToDraw || [];
                    this.itemsToDrawWithoutOrder = this.itemsToDrawWithoutOrder || [];

                    if (widgetData.modeGroupOrder !== undefined) {
                        var group = parseInt(widgetData.modeGroupOrder, 10);
                        if (isNaN(group)) {
                            this.itemsToDrawWithoutOrder.push(widgetData);
                        } else {
                            // init if first box in array
                            this.itemsToDraw[group] = this.itemsToDraw[group] || [];
                            this.itemsToDraw[group].push(widgetData);
                        }
                    } else {
                        this.itemsToDrawWithoutOrder.push(widgetData);
                    }
                };


                this.executeRBoxDrawQueue = function executeRBoxDrawQ(timeToWait, counter) {
                    TRC.yieldingOrderArr = TRC.yieldingOrderArr || [];
                    var counter = counter || 0;
                    if (TRC.taboola_yield_report && counter == 0) {
                        console.time('executeRBoxDrawQ');
                        performance.mark('start executeRBoxDrawQueue');
                    }
                    // insert widgets with no order to end of Q
                    if (this.itemsToDrawWithoutOrder.length > 0) {
                        this.itemsToDraw.push(this.itemsToDrawWithoutOrder);
                        this.itemsToDrawWithoutOrder = [];
                    }

                    var groupToDraw = this.itemsToDraw.shift();
                    TRC.yieldingOrderArr.push(groupToDraw ? groupToDraw.length : 0);
                    if (groupToDraw) {
                        if (TRC.taboola_yield_report) {
                            console.time('executeRBoxDrawQueue batch-' + counter);
                            performance.mark('start executeRBoxDrawQueue batch-' + counter);
                        }

                        var renderedBoxes = {};
                        groupToDraw.forEach((function renderWidget(placementData) {
                            var box = this.internalDrawRBox(placementData);

                            if (box) {
                                renderedBoxes[box.id] = box;
                            }
                        }).trcBind(this));

                        TRC.dispatch("batchrender", {data: {boxes: renderedBoxes}});
                        if (TRC.taboola_yield_report) {
                            console.timeEnd('executeRBoxDrawQueue batch-' + counter);
                            performance.mark('end executeRBoxDrawQueue batch-' + counter);
                        }
                    }

                    var callExecuteRBoxDrawQueue = (function (timeToWait, counter) {
                        this.executeRBoxDrawQueue(timeToWait, counter);
                    }).bind(this);
                    if (this.itemsToDraw.length > 0) {
                        // check if group had widgets to draw
                        // true  : do yield
                        // false : go to next group§
                        if (groupToDraw) {
                            TRC.Timeout.set(function () {
                                callExecuteRBoxDrawQueue(timeToWait, ++counter);
                            }, timeToWait);

                        } else {
                            // group was empty so move to next group
                            callExecuteRBoxDrawQueue(timeToWait, ++counter);

                        }

                    } else {
                        // rendered all
                        if (TRC.taboola_yield_report) {
                            console.timeEnd('executeRBoxDrawQ');
                            performance.mark('end executeRBoxDrawQueue');
                            performance.measure('total rbox rendering time', 'start executeRBoxDrawQueue', 'end executeRBoxDrawQueue');
                        }

                        var allrenderData = this;
                        // if rendered in batches send empty box list to allrender event sins batchrender was fired
                        if (counter > 0) {
                            allrenderData = {boxes: {}};
                        }

                        TRC.dispatch("allrender", {data: allrenderData});
                    }
                };
                /**
                 * Hookup for the drawRBox public API
                 */
                this.internalDrawRBox = function (options) {
                    var main_cont,
                        moveWidgetWarnMsg = 'widget';

                    // Find the requested container selector in which to render the widget
                    options.container = this.getWidgetContainer(options, moveWidgetWarnMsg);

                    // handle runtime configuration through loader parameters or global arguments:
                    options = this.computeRBoxOptions(options);

                    // if we need to render inside a flash player
                    // lets delay this function call till after the movie has started
                    if (options.player) {
                        var playerContainer = options.player;
                        delete options.player;
                        this.listenToPlayer(options, document.getElementById(playerContainer));
                        return;
                    }

                    main_cont = options.container;

                    if (!main_cont) {
                        // probably an invisible rbox
                        // silently ignore
                        return;
                    }

                    // support 'visible'
                    if (!options.visible) {
                        main_cont.style.display = "none";
                    }

                    if (options.spotlight) {
                        main_cont.setAttribute('data-spotlight-publisher-id', options['spotlight-publisher-id']);
                    }

                    // check if we have a preloaded request for this placement
                    if (options.response == null && this.loadCalled
                        && typeof this.preloadRequest[options.placement] !== 'undefined') {
                        options.response = this.preloadRequest[options.placement].response;
                        __trcCopyProps(options, this.preloadRequest[options.placement]);
                        if (options.response == null) { // still null, means we're not loaded yet
                            // give the preload request our container and wait for it to call us
                            this.preloadRequest[options.placement].container = options.container;
                            return;
                        }
                    }

                    try {
                        TRC.SpotlightLoader.registerOnMainContainer(main_cont, options.response);
                    } catch (e) {
                        __trcError("Error while trying to register Spotlight data on main container");
                    }

                    // multi-widget flow
                    if (options.trcResponse && options.trcResponse.multiWidget) {
                        TRC.multiWidget.init.call(this, {
                            originalContainer: main_cont,
                            multiWidget: options.trcResponse.multiWidget,
                            widgetOptions: options,
                            initRBox: this.initRBox,
                            trcManager: this
                        });

                        return this.boxes;
                    }

                    // normal flow - load a single widget
                    return this.initRBox.call(this, main_cont, options);
                };

                this.handleAMPSplitFeedRequest = function (request) {
                    var shouldEnableAmpSplitFeedFix = this.global['enable-ampsplitfeedfix'];
                    TRC.AmpSplitFeedManager = TRC.AmpSplitFeedManager.getAmpSplitFeedManager(shouldEnableAmpSplitFeedFix);
                    if (typeof this.ampSplitFeedManager === 'undefined') {
                        var isFirstIframe = parseInt(TRC.feedContainerNum, 10) === 1;
                        this.ampSplitFeedManager = new TRC.AmpSplitFeedManager(this, isFirstIframe);
                    }
                    if (this.ampSplitFeedManager) {
                        var ampSplitFeedManagerDidInit = this.ampSplitFeedManager.initAmpSplitFeedIframe && this.ampSplitFeedManager.didInit !== true;
                        if (ampSplitFeedManagerDidInit) {
                            var callback = this.ampSplitFeedManager.initAmpSplitFeedIframe.trcBind(this.ampSplitFeedManager);
                            this.ampSplitFeedManager.checkAMPSplitFeedFlagsAndInit(request, callback);
                        }
                    }

                };

                this.handlePushedRequest = function (request) {
                    if (!this.global['disable-skip-load-request'] && this.shouldSkipPushedRequest(request)) {
                        __trcDebug('\'handlePushedRequest\' : Skip on push request');
                        return;
                    }

                    if (TRC.isAMPSplitFeed) {
                        this.handleAMPSplitFeedRequest(request);
                    } else if (request[Object.keys(request)[0]] && request[Object.keys(request)[0]].rec) {
                        this.preloadRequest = request; // needed in getOrCreatePlacementData()
                        this.handleLoadResponse('', request[Object.keys(request)[0]].rec);
                    } else {
                        this.dispatchRequestWrapper(request);
                    }
                };

                this.dispatchRequestWrapper = function (request) {
                    this.loadCalled = true;
                    this.dispatchLoadRequest(request);
                    this.isPendingLoadRBox = false;
                };

                this.dispatchCMPRequest = function (trcManager, request) {
                    var requestNumber = parseInt(Math.random() * 100000);
                    this.pendingRequests[requestNumber] = 1;

                    TRC.cmp('getConsentData', null, function (consentState) {
                        if (trcManager.pendingRequests[requestNumber]) {
                            delete trcManager.pendingRequests[requestNumber];
                            trcManager.consentState = consentState;
                            trcManager.handlePushedRequest(request);
                        }
                    });

                    if (this.global["max-wait-for-cmp"]) {
                        TRC.Timeout.set(function () {
                            if (trcManager.pendingRequests[requestNumber]) {
                                TRC.consent.setConsent({wasTimeout: true});
                            }
                        }, this.global["max-wait-for-cmp"]);
                    }
                };

                this.dispatchAmpConsentRequest = function (trcManager, request) {
                    if (this.global['amp-consent-enable'] === false) {
                        trcManager.handlePushedRequest(request);
                    } else {
                        var requestNumber = parseInt(Math.random() * 100000);
                        this.pendingRequests[requestNumber] = 1;

                        TRC.consent.getAMPConsent(function (cexConsentData, consentState) {
                            if (trcManager.pendingRequests[requestNumber]) {
                                delete trcManager.pendingRequests[requestNumber];
                                if (consentState) {
                                    trcManager.consentState = consentState;
                                    TRC.ccpaPs = consentState.ccpaString;
                                }
                                TRC.cexConsentData = cexConsentData;
                                trcManager.handlePushedRequest(request);
                            }
                        });

                        if (this.global["max-wait-for-cmp"]) {
                            TRC.Timeout.set(function () {
                                if (trcManager.pendingRequests[requestNumber]) {
                                    trcManager.consentState = {wasTimeout: true};
                                }
                            }, this.global["max-wait-for-cmp"]);
                        }
                    }
                };

                this.getUSPData = function (callback) {
                    if (this.global['ccpa-ps-enable'] !== false) {
                        var usPrivacyCookie = TRC.util.getCookieByName('usprivacy');
                        if (typeof __uspapi === 'function') {
                            try {
                                __uspapi('getUSPData', 1, function (uspData, success) {
                                    if (success && uspData) {
                                        callback(uspData.uspString);
                                    } else if (usPrivacyCookie) {
                                        callback(usPrivacyCookie);
                                    }
                                });
                            } catch (e) {
                                __trcError('Error while calling __uspapi for getUSPData', e);
                                if (usPrivacyCookie) {
                                    callback(usPrivacyCookie);
                                }
                            }
                        } else if (usPrivacyCookie) {
                            callback(usPrivacyCookie);
                        }
                    }
                };

                /**
                 * Hook up for loadRBox public API
                 */
                this.loadRBox = function () {
                    var origArgs = arguments,
                        args = Array.prototype.slice.call(arguments),
                        request = {},
                        options,
                        POLL_INTERVAL = 40,
                        trcManager = this;

                    if (args.length < 1) {
                        return;
                    }

                    try {
                        if (this.isPendingLoadRBox || this.preloadRequestLoader) {
                            // we have another loadRBox request pending, try sending this one again later
                            setTimeout((function () {
                                this.loadRBox.apply(this, origArgs);
                            }).trcBind(this), 100);
                            return;
                        }

                        // support providing a single array that contains the list of arguments
                        if (args[0] instanceof Array) {
                            args = args[0];
                        }

                        this.till_request_count = 0;
                        for (var i = 0; i < args.length; i++) {
                            if (!args[i].player) this.till_request_count++;
                        }

                        function dispatchPlacementRequestSeparately(request, options) {
                            var separateRequestObj = {};
                            separateRequestObj[options.placement] = options;
                            this.handlePushedRequest(separateRequestObj);
                        }

                        // parse the arguments first
                        while (args.length) {
                            var firstArg = args.shift();
                            try {
                                // send Placement push commands
                                if (firstArg.placement && firstArg.mode) {
                                    __trcInfo(JSON.stringify(firstArg));
                                }
                            } catch (e) {
                                __trcWarn("failed to send Placement commands");
                            }

                            // compute R-Box parameters for each mode specified
                            options = this.computeRBoxOptions(__trcCopyProps(firstArg, {}));
                            if (options.player || options.slider === true) {
                                if (options.slider === true) {
                                    this.createContainerForEscalatorWidget(options);
                                }

                                /* nasty hook! we need the slider and player widgets to go separately
                                 * on a different request then normal widgets PV3 request
                                 */
                                TRC.Timeout.set(dispatchPlacementRequestSeparately.trcBind(this, request, options), 0);
                                continue;
                            }

                            if (request[options.placement]) {
                                throw new Error("Placement '" + options.placement + "' is not unique in loadRBox()!");
                            }
                            request[options.placement] = options;

                            (function (options, POLL_INTERVAL, request) {
                                this.isPendingLoadRBox = true;

                                if (!options.container || options.container.nodeType !== 1) {
                                    // if we failed locating one or more containers, lets schedule a later container detection
                                    if (!TRC.dom.isReady) {
                                        if (!options.player && options.visible) {
                                            options.container = this.ensureValidContainer(options.original_container);
                                        }
                                        // eslint-disable-next-line no-restricted-properties
                                        if (arguments.callee) {
                                            // eslint-disable-next-line no-restricted-properties
                                            TRC.Timeout.set(arguments.callee.trcBind(this, options, POLL_INTERVAL, request), POLL_INTERVAL);
                                        }
                                        return;
                                    }
                                    this.error("Invalid container provided for request " + options.placement + " (" + options.container + ")!");
                                    delete request[options.placement];
                                    this.till_request_count--;
                                } else {
                                    this.till_request_count--;
                                }
                                if (this.till_request_count <= 0) {
                                    if (TRC.isAMP) {
                                        this.dispatchAmpConsentRequest(trcManager, request);
                                    } else if (TRC.consent.hasCMP()) {
                                        this.dispatchCMPRequest(trcManager, request);
                                    } else {
                                        this.handlePushedRequest(request);
                                    }
                                }
                            }).trcBind(this, options, POLL_INTERVAL, request)();
                        }
                    } catch (e) {
                        __trcError("Error in loadRBox()", e);
                        throw e;
                    }
                };
                /**
                 * Get meta or json ld value from object
                 * @param {Object} attribute
                 * @param {'tag' | 'json'} attribute.t - type
                 * @param {string} attribute.n - name
                 * @param {Object} [attribute.f] - optional fallback object
                 * @returns {string|null}
                 */
                this.getAutoRecrawlValue = function (attribute) {
                    var attributeValue;
                    if (attribute.t === 'json' && attribute.n) {
                        attributeValue = TRC.dom.getJsonLdValueFromKey(attribute.n);
                    } else if (attribute.t === 'tag' && attribute.n) {
                        attributeValue = TRC.dom.getPageMetaPropertyValue(attribute.n);
                    }
                    if (!attributeValue && attribute.f) {
                        attributeValue = this.getAutoRecrawlValue(attribute.f);
                    }
                    return attributeValue;
                };

                /**
                 * Get meta or json ld values from {@link this.global['oc-recrawl-settings-#publisher-name']} config for auto re-crawling articles with
                 * updated data.
                 * @param attributes
                 * @returns {object}
                 */
                this.getAutoRecrawlData = function (attributes) {
                    var autoRecrawlData = {};
                    Object.keys(attributes).forEach(function (attributeKey) {
                        var attribute = attributes[attributeKey];
                        var attributeValue = this.getAutoRecrawlValue(attribute);
                        if (attributeValue) {
                            autoRecrawlData[attributeKey] = attributeValue;
                        }
                    }, this);
                    return autoRecrawlData;
                };

                this.validateRecrawlSettings = function (recrawlSettings) {
                    if (recrawlSettings && recrawlSettings.fields && recrawlSettings.sampleRate) {
                        var pageTypesList = recrawlSettings.pageType && Array.isArray(recrawlSettings.pageType) ? recrawlSettings.pageType : ['t', 'p', 'v'];
                        var isPageSourceAllowed = pageTypesList.indexOf(TRC.listOrigin.getSource()) !== -1;
                        return TRC.util.isPercentEnabled(recrawlSettings, 'sampleRate') && isPageSourceAllowed;
                    }

                    return false;
                };

                this.getExperimentVariant = function(val) {
                    var experimentList = [];
                    if (val) {
                        experimentList.push(val);
                    }

                    var pubExperimentConfig = this.global['publisher-experiments'];
                    var experimentID = TRC.pubExperiment && pubExperimentConfig
                        ? pubExperimentConfig[TRC.pubExperiment] : null;
                    if (experimentID) {
                        experimentList.push(experimentID);
                    }

                    return experimentList.join(',') || undefined;
                };

                // initialization sequence - started by libtrc.js
                this.parseLoaderParams(globalParams);
                TRC.dom.init();
                this.init(configuration);

                return this;
            },
            protocol = TRC.PROTOCOL;

        TRC.recoRequestsQueue = new TRC.TasksExecutorQueue();

        /* Constants and default parameters */
        Manager.prototype['list-size'] = 0;
        Manager.prototype.MAX_RETRY = 2;
        // noinspection JSUnusedGlobalSymbols
        Manager.prototype.drawInterface = false;

        /* Instance state variables */
        Manager.prototype.delayedDispatchLoadRequest = null; // whether we are waiting for playVideo to trigger a PV3 dispatch
        Manager.prototype.invisible = false; // whether the publisher is using a tracking-only integration
        Manager.prototype.excludedItems = null;
        /** @type {TRCRBox[]} */
        Manager.prototype.boxes = {}; // collection to hold TRCRBox instances
        Manager.prototype.itemid = null; // current publisher's item ID
        Manager.prototype.itemurl = null; // current publisher's item canonical URL
        Manager.prototype.tags = []; // current item's metadata tags
        Manager.prototype.metadata = {}; // collection of metadata to be sent to the server in requests
        Manager.prototype.userMetadata = null; // Storage for setUser() public API
        Manager.prototype.loadCalled = false;
        Manager.prototype.unique_placement_count = {};
        Manager.prototype.trc_url_auto_detection = null;

        /**
         * set new publisher id using domain mapping object in network
         * @method shiftPublisherId
         * @param {Object} mapObject - mapping domain to publisher id
         */
        Manager.prototype.shiftPublisherId = function (mapObject) {
            var fakeUrl = TRC.URL.prototype.getParameter.call(location.href, "taboola_sim_domain") || TRC.URL.prototype.getParameter.call(location.href, "fakeurl"),
                mapUrl = win.trc_map_url && new TRC.URL(win.trc_map_url),
                pageUrl = win.trc_item_url && new TRC.URL(win.trc_item_url),
                itemUrl = mapUrl || pageUrl || null,
                host = (fakeUrl || (itemUrl ? itemUrl.host : null) || location.host).toLowerCase(),
                href = (fakeUrl || (itemUrl ? itemUrl.href : null) || location.href).toLowerCase(),
                newPubId = mapObject[host], // for supporting sub domain formats in mapObject
                HREF_MATCH = "/",
                SPECIAL_PREFIX = ["m", "mobile", "www2", "www3"], // ! lowercase only
                mapArray,
                i,
                len,
                key,
                regex,
                newHost;
            if (!newPubId) { // for supporting domain substring formats in mapObject
                win.__trcToArray(mapObject, mapArray = []); // this will return the object as an array of the form [[key, value],[...],...]
                mapArray.sort(function (a, b) { // this function will sort the array by the string/key length
                    if (a[0].length > b[0].length) {
                        return -1;
                    } if (a[0].length < b[0].length) {
                        return 1;
                    }
                    return 0;
                });
                for (i = 0, len = mapArray.length; i < len; i++) {
                    key = mapArray[i][0].toLowerCase();
                    if (key.indexOf(HREF_MATCH) > 0) {
                        if (href.match(key)) { // match the url
                            newPubId = mapArray[i][1];
                            break;
                        }
                        if (key.indexOf("www.") > -1 && href.match(key.replace("www.", ""))) {
                            newPubId = mapArray[i][1];
                            break;
                        }
                    } else if (host.match(key)) { // match the host
                        newPubId = mapArray[i][1];
                        break;
                    }
                }
                if (!newPubId && host.indexOf("www.") < 0) {
                    for (i = 0, len = SPECIAL_PREFIX.length; i < len; i++) {
                        regex = new RegExp("(https:\/\/|http:\/\/|^)" + SPECIAL_PREFIX[i] + "\.");
                        newHost = host.replace(regex, "www.");
                        newPubId = mapObject[newHost];
                        if (newPubId) {
                            break;
                        }
                    }
                    if (!newPubId) {
                        newHost = "www." + host;
                        newPubId = mapObject[newHost];
                    }
                }
            }
            TRC.publisherId = ((newPubId) || 'unknown-site-on-' + TRC.publisherId);
            TRC.pConsole("page", "info", "in 'Network-Solution' : publisher-id was set to - " + TRC.publisherId, "");
        };

        Manager.prototype.widgetContainerReset = function () {
            Object.keys(this.boxes).forEach(function (key) {
                var boxContainer = this.boxes[key].container,
                    boxObserver;

                if (boxContainer) {
                    boxObserver = boxContainer.getAttribute(TRC.intersections.TARGET_ATTRIB);
                    boxContainer.className = boxContainer.origClassName;

                    delete boxContainer._trc_container;
                    delete boxContainer._trc_anonbox;

                    while (boxContainer.hasChildNodes()) {
                        boxContainer.removeChild(boxContainer.lastChild);
                    }

                    if (boxObserver) {
                        TRC.intersections.unobserveAll(boxObserver);
                    }
                }

                TRC.Timeout.reset();
                TRC.Interval.reset();

                delete this.boxes[key];
            }, this);
        };

        /**
         * Configuration property accessor
         * @param mode UI mode name for which to retrieve the property
         * @param property_name name of the property to retrieve
         * @return property value for the current mode or a global property
         */
        Manager.prototype.getProperty = function (mode, property_name, propertiesOverride) {
            if (propertiesOverride && propertiesOverride.hasOwnProperty(property_name) && typeof propertiesOverride[property_name] !== "undefined") {
                return propertiesOverride[property_name];
            } if (typeof this.modes === "undefined" || typeof this.modes[mode] === "undefined"
                || typeof this.modes[mode][property_name] === "undefined") {
                return this[property_name];
            } if (TRC.propertiesOverride && typeof TRC.propertiesOverride[property_name] !== "undefined") {
                return TRC.propertiesOverride[property_name];
            }
            return this.modes[mode][property_name];
        };

        /**
         * Extend of the getFunction configurable hook with out source module support
         * @param {object} context - instance of the caller
         * @param {String} mode - UI mode name for which to retrieve the hook
         * @param {String} property_name - name of the hook to execute
         * @param propertiesOverride
         * @returns {*} value returned from the hook or undefined if no hook is found
         */
        Manager.prototype.runHook = function (context, mode, property_name, propertiesOverride, useCustomModules) {
            var args = Array.prototype.slice.call(arguments, 5);
            var functionRes = this.getFunction(mode, property_name, propertiesOverride, args);
            useCustomModules && TRC.CustomModulesManager.dispatchHook(property_name, mode, context, args);
            return functionRes;
        };

        /**
         * Call a configurable hook
         * @param {String} mode - UI mode name for which to retrieve the hook
         * @param {String} property_name - name of the hook to execute
         * @param propertiesOverride
         * @param args
         * @returns {*} value returned from the hook or undefined if no hook is found
         */
        Manager.prototype.getFunction = function (mode, property_name, propertiesOverride, args) {
            if (this.global['disable-runHook']) {
                args = Array.prototype.slice.call(arguments, 3);
            }
            var property = this.getProperty(mode, property_name, propertiesOverride);
            if (typeof property === "function") {
                TRC.pConsole(mode, "debug", "Hook : " + property_name, property.toString(), "function");
                return property.apply(this, args);
            }
            return undefined;
        };

        /**
         * Generic meta tag reader to read meta data from the current page
         * @param name meta name to read
         * @returns value read or null if no value is found
         */
        Manager.prototype.readMetaTag = function (name) {
            var m = document.head.getElementsByTagName('meta');
            var out = null;
            for (var i = 0; i < m.length; i++) {
                if (!m[i].name) {
                    continue;
                }
                if (m[i].name.toLowerCase() === 'item-' + name.toLowerCase()) {
                    return m[i].content;
                }
                if (m[i].name.toLowerCase() === name.toLowerCase()) {
                    out = m[i].content;
                }
            }
            return out;
        };

        /**
         * Logic to figure out the viewer's intent in playing the current video
         * @returns {String} "intent" detected. Supported values are "p", "s", "u" and "n"
         */
        Manager.prototype.get_intent = function () {
            var url = win.location.href;
            var intent = TRC.pageManager.getPublisherValue(TRC.publisherId, "auto-play-intent");
            if (intent != null) {
                // PageManger.storePublisherValue(TRC.publisherId,"auto-play-intent",null);
                var params = intent.split(":");
                if (parseInt(params[0]) > new Date().getTime() - 30000 && params[1] == this.getItemId()) {
                    if (typeof params[2] !== "undefined") {
                        return params[2];
                    }
                    return "n";
                }
            }
            if (url.search(this.getItemId()) >= 0) return "s";
            return "u";
        };

        /* defaults for metadata readers */
        Manager.prototype['get-creator'] = function () {
            return this.readMetaTag('uploader') || this.readMetaTag('creator');
        };
        Manager.prototype['get-tags'] = function () {
        };
        // collection of available UI implementations
        TRC.implClasses = TRC.implClasses || {};

        /* Activity logging */

        /**
         * Main logging routine
         * @param {String} type event name to send
         * @param {Object} params list of name/value params for this event
         * @param postParams
         * @param {Function} callback method to invoke when the log has completed
         * @param {String} placement name (for specific events if required)
         * @param sendBeacon
         */
        Manager.prototype.logTrcEvent = function (type, params, postParams, callback, placement, sendBeacon) {
            var postError = false,
                finalPostParams,
                ajaxPostEventPrefix,
                ajaxEventType,
                shouldPostEventAsAjax,
                isAjaxFullRolloutMode;

            params.tim = win.__trcClientTimestamp();
            params.id = parseInt(Math.random() * 10000);
            params.llvl = win.trc_debug_level;

            // TODO: remove condition after june 2015
            if (!this.global['tmp-disable-cv']) {
                params.cv = this.version;
            }

            if (this.configForPostEvent[type]) {
                // try to send a post request
                try {
                    finalPostParams = this.global['send-full-list'] && postParams ? __trcCopyProps(params, {}, postParams) : params;
                    shouldPostEventAsAjax = this.shouldPostEventAsAjax(type);
                    isAjaxFullRolloutMode = this.global['rbox-ajax-post-events-full-rollout'];
                    ajaxPostEventPrefix = isAjaxFullRolloutMode ? '' : 'new-';
                    ajaxEventType = ajaxPostEventPrefix + type;

                    if (shouldPostEventAsAjax) { // post events ajax flow
                        try {
                            this.logPostTrcEventAsAjax(ajaxEventType, finalPostParams, sendBeacon);
                            // error in post - fallback to "get" (relevant only to iframe + ajax side by side mode support,
                            // this can be removed if sbs support not needed because the upper level try/catch handles this
                        } catch (e) {
                            if (this.configForGetEvent[type] === false || !isAjaxFullRolloutMode) {
                                params.fbe = 1;// force trc to process the get event
                                this.logGetTrcEvent(ajaxEventType, params, callback, postParams, placement);
                            }
                        }
                    }

                    if (!isAjaxFullRolloutMode) { // post in iframe only on temporary "side by side" mode
                        this.logPostTrcEvent(type, finalPostParams);
                    }
                } catch (e) {
                    postError = true;// this will enable a get fallback event
                    __trcError("Error in sending post event", e);
                }
            }
            // if post event is not enabled(per event type!) for the publisher at least send GET event, or an error in post event
            if (postError || this.configForGetEvent[type] !== false || this.configForPostEvent[type] !== true) {
                if (this.configForGetEvent[type] === false || postError) {
                    params.fbe = 1;// force trc to process the get event
                }
                this.logGetTrcEvent(type, params, callback, postParams, placement);
            }
        };

        Manager.prototype.isValidForFill = function (type, placement) {
            try {
                if ((type === 'available' || type === 'visible')
                    && this.global['enable-get-fil']
                    && this.global['get-fil-n-items'] >= this.preloadRequest[placement].response.trc['video-list'].video.length
                ) {
                    return true;
                }
            } catch (e) {
                // Empty catch block
            }
            return false;
        };

        Manager.prototype.shouldEnableFraudDetection = function () {
            var enableFraudTest = this.global.test_for_fraud,
                fraudTrafficPercentage,
                random;

            if (enableFraudTest) {
                fraudTrafficPercentage = this.global['fraud-traffic-percentage'];

                if (fraudTrafficPercentage === 0) {
                    return false;
                }

                fraudTrafficPercentage = fraudTrafficPercentage || 10;
                random = Math.floor(Math.random() * 100);

                return random <= fraudTrafficPercentage;
            }

            return false;
        };

        Manager.prototype.enableFraudDetection = function () {
            // init fraud script - if not initialized yet
            if (!TRC.clickFraudDetect.isInitialized) {
                try {
                    TRC.clickFraudDetect.init(TRC.publisherId, TRC.pageManager.getUserId(), this.getReferrer(), this, TRC.pageManager.getPageData());
                } catch (e) {
                    __trcWarn('failed to init fraud detection');
                }
            }
        };

        Manager.prototype.logGetTrcEvent = function (type, params, callback, postParams, placement) {
            if (this.trcEventRoute && this.eventTypesToRoute.indexOf(type) > -1) {
                this.logGetTrcEventImpl(this.trcEventRoute, type, params, callback, postParams, placement);

                if (this.enableTrcEventRouteExperiment) { // :todo *remove if block* after events route bypass experiment is over
                    this.logGetTrcEventImpl(this.domain, type, params, callback, postParams, placement);
                }

            } else {
                this.logGetTrcEventImpl(this.domain, type, params, callback, postParams, placement);
            }
        };

        Manager.prototype.logGetTrcEventImpl = function (host, type, params, callback, postParams, placement) {
            (TRC.tlf && console.time('in logGetTrcEvent - ' + type));
            var url,
                eventImage;

            Object.keys(params).forEach(function (p) {
                params[p] = this['normalize-log-param'](p, params[p]);
            }, this);

            type = this['normalize-log-param']('type', type);

            if (this.isValidForFill(type, placement)) {
                params = __trcCopyProps(params, {}, postParams);
            }

            try {
                url = this.composeGetURL(type, params, host);

                eventImage = new Image();
                this.eventLogger.push(eventImage);
                if (callback) {
                    eventImage.onload = eventImage.onerror = function () {
                        if (typeof callback === "function") {
                            try {
                                callback();
                            } catch (e) {
                                __trcError("Error in event callback", e);
                            }
                        }
                        return true;
                    };
                }
                eventImage.src = url;
            } catch (e) {
                __trcError("Error in sending event", e);
            }
            (TRC.tlf && console.timeEnd('in logGetTrcEvent - ' + type));
            (TRC.performance && type === 'available' && TRC.performance.mark("8.1.9"));
            (TRC.performance && type === 'visible' && TRC.performance.mark("9.1.9"));
        };

        Manager.prototype.logPostTrcEvent = function (type, params) {
            if (this.trcEventRoute && this.eventTypesToRoute.indexOf(type) > -1) {
                this.logPostTrcEventImpl(this.trcEventRoute, type, params);

                if (this.enableTrcEventRouteExperiment) { // :todo *remove if block* after events route bypass experiment is over
                    this.logPostTrcEventImpl(this.domain, type, params);
                }

            } else {
                this.logPostTrcEventImpl(this.domain, type, params);
            }
        };

        Manager.prototype.logPostTrcEventImpl = function (host, type, params) {
            (TRC.tlf && console.time('in logPostTrcEvent - ' + type));
            var publisher = this['normalize-log-param']('publisher', TRC.publisherId),
                type = this['normalize-log-param']('type', type),
                frameId = "tb-trc-transportFrame-" + type + "-" + params.id,
                form = this.getTransportForm(frameId),
                frame = document.getElementById(frameId),
                frameDoc;

            Object.keys(params).forEach(function (param) {
                var input = doc.createElement("input");
                input.name = (param.charAt(0) === '_' ? param.substr(1) : param).replace(/unescape-/g, "");
                input.type = "hidden";
                input.value = this['normalize-log-param'](param, params[param]);
                form.appendChild(input);
            }, this);

            if (frame) {
                // TODO : set this behavior to all browsers after verified
                if (TRC.Browser.ie) {
                    frameDoc = frame.contentDocument ? frame.contentDocument : frame.contentWindow.document;
                    frameDoc.write('');
                    frameDoc.close(); // on IE the we need to be sure the iframe has fire "onload" event for the parent page
                }
            } else {
                throw new Error("post iframe can be created");
            }

            var querystring = [];
            if (this.trcByPass) {
                querystring.push('trc_skip_failover=yes');
            }
            if (this.enableTrcRoute && this.trcRoute) {
                querystring.push('route=' + this.trcRoute);
            }
            if (this.enableExperimentsVariantIdEvent && this.experimentsVariantIdParamsStr) {
                querystring.push(this.experimentsVariantIdParamsStr);
            }
            if (this.getLoaderTypesValue()) {
                querystring.push(this.getLoaderTypesValue());
            }

            form.action = protocol + '//' + host + '/' + publisher + '/log/3/' + escape(type) + (querystring.length > 0 ? "?" + querystring.join("&") : "");
            form.submit();
            (TRC.tlf && console.timeEnd('in logPostTrcEvent - ' + type));
            (TRC.performance && type === 'available' && TRC.performance.mark("8.2.9"));
            (TRC.performance && type === 'visible' && TRC.performance.mark("9.2.9"));
        };

        Manager.prototype.getTransportForm = function (frameId) {
            var span,
                form;

            form = doc.createElement("form");
            form.className = "trc-hidden " + TRANSPORT_FORM_ELEMENT;
            form.target = frameId;
            form.style.display = "none";
            form.method = "post";
            doc.body.appendChild(form);

            // we use innerHTML to set an iframe because of  a bug in IE7+:
            // DEV-2409
            // TODO: create the iframe only once -  needs verification
            span = doc.createElement("span");
            span.className = TRANSPORT_FORM_ELEMENT;
            span.innerHTML = '<iframe class="trc-hidden" id="' + frameId + '" name="' + frameId + '" width="0" height="0" style="display:none"><\/iframe>';
            doc.body.appendChild(span);

            return form;
        };

        Manager.prototype.shouldPostEventAsAjax = function (eventType) {
            var postEventsAsAjax = this.global['rbox-post-events-as-ajax'];

            return postEventsAsAjax
                && (typeof postEventsAsAjax === 'boolean' || postEventsAsAjax.indexOf(eventType) !== -1);
        };

        Manager.prototype.logPostTrcEventAsAjax = function (type, finalPostParams, sendBeacon) {
            var ajaxPostError = false,
                isOldAjaxBrowser = win.XDomainRequest || TRC.Browser.ieUpto(9);

            if (!isOldAjaxBrowser) { // only IE10 and above support ajax cross domain
                try {
                    this.queryParamsObj = __trcCopyProps(this.experimentsVariantIdParamsMap, {});
                    if (this.enableTrcRoute && this.trcRoute) {
                        this.queryParamsObj.route = this.trcRoute;
                    }
                    __trcCopyProps(this.getLoaderTypesObject(), this.queryParamsObj);

                    var postTrcEvent = function (me, host) {
                        if (!sendBeacon && TRC.util.isPercentEnabled(me.global, 'enable-bulk-events') && me.global['bulk-' + type + '-events-strategy']) {
                            TRC.BulkLoggerManager.bulkPost(host, type, finalPostParams, null, me.queryParamsObj);
                        } else {
                            TRC.TRCLogger.post(host, type, finalPostParams, null, me.queryParamsObj, sendBeacon);
                        }
                    };

                    if (this.trcEventRoute && this.eventTypesToRoute.indexOf(type) > -1) {
                        postTrcEvent(this, protocol + '//' + this.trcEventRoute);

                        if (this.enableTrcEventRouteExperiment) { // :todo *remove if block* after events route bypass experiment is over
                            postTrcEvent(this, protocol + '//' + this.domain);
                        }
                    } else {
                        postTrcEvent(this, protocol + '//' + this.domain);
                    }

                } catch (e) {
                    ajaxPostError = true;
                    __trcError("Error in sending post event as ajax", e);
                }
            }

            if (isOldAjaxBrowser || ajaxPostError) { // IE9 or ajax error - fallback to iframe post
                this.logPostTrcEvent(type, finalPostParams);
            }
        };

        /**
         * Logging wrapper to log events that should only be called once.
         * For taking into account "single events", the following event parameters
         * will be considered: the type, "li", "ii" and "ri"
         * @param {String} type event name to send
         * @param {Object} params list of name/value params for this event
         * @param {Function} callback optional callback to invoke after the event is received by the server
         * @param {String} placement (optional)
         * @param {Function} loggerFunction (optional) - custom logger function
         */
        Manager.prototype.log1 = function (type, params, postParams, callback, placement, loggerFunction) {
            var id = type + ":" + ((placement) || (params.li + params.ii)) + params.ri;
            if (params.ii && params.it) id = type + ":" + params.li + params.ii + params.ri;
            if (this.eventCounter[id]) {
                this.eventCounter[id]++;
                return;
            }

            if (typeof loggerFunction === 'function') {
                loggerFunction();
            } else {
                this.logTrcEvent(type, params, postParams, callback, placement);
            }

            this.eventCounter[id] = 1;
        };

        /**
         * Load external scripts or CSS files
         * @returns {*} the script or style element that was created
         */
        Manager.prototype.loadExternal = function () {
            return TRC.net.loadScript.apply(null, arguments);
        };

        /**
         * Parse global runtime configuration provided by the publisher
         * @param {Object} pushParams configuration properties
         */
        Manager.prototype.parseLoaderParams = function (pushParams) {
            Object.keys(pushParams).forEach(function (prop) {
                var val = pushParams[prop];
                if (val === 'unknown') {
                    return; // Skip the current iteration
                }
                if (val === 'auto') {
                    val = ''; // mimic "auto behavior" from parseParams()
                }
                switch (prop) {
                    case 'visible':
                        // eslint-disable-next-line eqeqeq
                        this.invisible = !(typeof val === 'boolean' ? val : val != "false");
                        break;
                    case 'video':
                        win.trc_video_id = val;
                        TRC.listOrigin.setSource('v');
                        break;
                    case 'url':
                        win.trc_item_url = val;
                        break;
                    case 'mapUrl':
                        win.trc_map_url = val;
                        break;
                    case 'article':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('t');
                        break;
                    case 'category':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('c');
                        break;
                    case 'home':
                    case 'homepage':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('h');
                        break;
                    case 'search':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('s');
                        break;
                    case 'photo':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('p');
                        break;
                    case 'other':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('o');
                        break;
                    case 'content_hub':
                        win.trc_article_id = val;
                        TRC.listOrigin.setSource('z');
                        break;
                    case 'link_target':
                        this.link_target = val;
                        break;
                    case 'video_source':
                        this.video_source = val;
                        break;
                    case 'callback':
                        this.video_player_callback = val;
                        break;
                    case 'player_reference':
                        this.video_player_reference = val;
                        break;
                    case 'target_type':
                        TRC.listOrigin.setTarget(this.target_type = val);
                        break;
                    case 'exclude':
                        this.excludedItems = val instanceof Array ? val : [val];
                        break;
                    case 'tracking':
                        this.tracking = val;
                        break;
                    case 'referrer':
                        TRC.pageManager.updateReferrer(val);
                        break;
                    case 'amp_disable_resize':
                        this.amp_disable_resize = val;
                        break;
                    case 'user_opt_out':
                        // eslint-disable-next-line eqeqeq
                        this.userOptOut = (val && val != 'false' && val != '0') ? true : val;
                        break;
                    case 'device':
                        this.deviceId = val;
                        break;
                    case 'unified_id':
                        this.unifiedId = val;
                        break;
                    case 'user_type':
                        this.userType = val;
                        break;
                    case 'paywall':
                        this.paywall = val;
                        break;
                    case 'premium':
                        this.premium = !!val;
                        break;
                    case 'advertorial_source':
                        this.advertorialSource = val;
                        break;
                    case 'external_page_view':
                        if (window.TRCImpl && TRCImpl.global['override-external_page_view']) {
                            TRCImpl.external_page_view = val;
                        }
                        this.external_page_view = val;
                        break;
                    case 'tracking_codes':
                        this.tracking_codes = val;
                        break;
                    case 'additional_data':
                        this.additional_data = val;
                        break;
                    case 'ad_first_request':
                        this.ad_first_request = val;
                        break;
                    case 'framework':
                        this.framework = val;
                        break;
                    case 'iab_alternative_config':
                        this.consentConfigOverride = val;
                        break;
                    case 'consentMessage':
                        TRC.consent.setConsent(val);
                        break;
                    case 'demo':
                        this.demo = val;
                        break;

                    default:
                        break;
                    }
            }, this);
        };

        /**
         * locate meta tag with name of "type"
         * @param type
         * @returns {String, null}
         */
        Manager.prototype.getItemByMetaValue = function (type) {
            var m = document.head.getElementsByTagName('meta');
            for (var i = 0; i < m.length; i++) {
                if (m[i].name == type) return m[i].content;
            }
            return null;
        };

        /**
         * get normalized canonical url
         * @param type
         * @param {func} normalizer - normalizer method
         * @returns {String, null}
         */
        Manager.prototype.getItemByCanonicalValue = function (type, normalizer) {
            var m = document.head.getElementsByTagName('link');
            for (var i = 0; i < m.length; i++) {
                if (m[i].rel == 'canonical') return normalizer.call(this, type, m[i].href);
            }
            return null;
        };

        /**
         * get normalized open graph url
         * @param type
         * @param {func} normalizer - normalizer method
         * @returns {String, null}
         */
        Manager.prototype.getItemByOgValue = function (type, normalizer) {
            var m = document.head.getElementsByTagName('meta');
            for (var i = 0; i < m.length; i++) {
                if (m[i].getAttribute('property') == 'og:url' && m[i].content.length > 5) {
                    var ogUrlToUse = (this.global['encode-irregular-og:url']
                        && hasSuperUTFSeq(m[i].content))
                        ? encodeURI(m[i].content) : m[i].content;
                    return normalizer.call(this, type, ogUrlToUse);
                }
            }
            return null;
        };

        /**
         * get normalized location(window.location) url
         * @param type
         * @param {func} normalizer - normalizer method
         * @returns {String, null}
         */
        Manager.prototype.getItemByLocationValue = function (type, normalizer) {
            return normalizer.call(this, type, TRC.pageManager.getCurrentURL().toString());
        };

        /**
         *
         * @param type
         * @param {func} normalizer - normalizer method
         * @returns {*}
         */
        Manager.prototype.getItemByParamUrl = function (type, normalizer) {
            if (win.trc_item_url && (type == "item-id" || type == "item-url")) {
                return normalizer.call(this, type, win.trc_item_url);
            }
            return null;
        };

        /**
         * Retrieve item identification data from the current page using auto-detection and normalization.
         * This method looks for 'meta' and 'link' tags, as well as open-graph definitions, and
         * can normalize the resulting method using a configured normalization rule. If all else fails
         * this method will return the current page's URL.
         * @param type which meta data to retrieve. Currently supported are item-id and item-url
         * @param norm - url for pre-normalization
         * @return the requested item identification.
         */
        Manager.prototype.getAutoItemMeta = function (type, norm, preNormalizer, typeNormalizer) {
            var DEFAULT_URL_EXTRACT_ORDER = ["paramUrl", "meta", "canonical", "og", "location"], // default order of url extraction
                itemExtractMethods = {
                    paramUrl: "getItemByParamUrl",
                    meta: "getItemByMetaValue",
                    canonical: "getItemByCanonicalValue",
                    og: "getItemByOgValue",
                    location: "getItemByLocationValue"
                },
                pageUrlExtractOrder = (this.global["url-extract-order"]) ? this.global["url-extract-order"] : DEFAULT_URL_EXTRACT_ORDER,
                i = 0,
                func,
                lastMethodUsed,
                isCanonical;

            /* location should always be one of the options for resolving the item's url as a last resort,
                so we always push it as an option to the methods array. this is ok even if
                the configuration already has it, because in such cases it will early return after it runs
                (resolving by location always returns a value), and our pushed method will not be called again.
             */
            pageUrlExtractOrder.push("location");

            norm = (norm) ? preNormalizer.call(this, type, norm) : null;
            while (i < pageUrlExtractOrder.length && TRC.util.isEmptyString(norm)) {
                lastMethodUsed = pageUrlExtractOrder[i];
                func = this[itemExtractMethods[pageUrlExtractOrder[i]]];
                try {
                    norm = func ? func.call(this, type, preNormalizer) : null;
                } catch (e) {
                    if (this.global['tmp-catch-item-url-err']) {
                        norm = "";
                    } else {
                        throw new Error(e.message);
                    }
                }
                i++;
            }
            if (type == "item-url" && lastMethodUsed == "getItemByParamUrl") {
                return norm;
            }
            isCanonical = (lastMethodUsed != "getItemByLocationValue");
            norm = (typeNormalizer) ? typeNormalizer.call(this, norm, (win.trc_video_id) ? 'video' : 'text', isCanonical) : norm;

            return norm;
        };

        Manager.prototype.getEventParams = function (overrideEventParams) {
            return {
                ri: overrideEventParams && overrideEventParams.ri || TRC.events_ri,
                sd: this.getSessionData(TRC.session_data),
                ui: TRC.pageManager.getUserId(),
                pi: this.getItemId(),
                wi: this.watchedItem ? this.watchedItem : null,
                pt: this.getItemType(),
                vi: TRC.pageManager.getPageData()
            };
        };

        Manager.prototype.sendEvent = function (type, params, postParams, once, callback, timeout, sendBeacon) {
            var wasCalled = false,
                eventParams = this.getEventParams(),

                passedCallback = function () {
                    if (wasCalled) {
                        return;
                    }
                    wasCalled = true;
                    if (callback) {
                        callback();
                    }
                };
            __trcCopyProps(params, eventParams);

            if (once) {
                this.log1(type, eventParams, postParams, passedCallback, this.placement);
                TRC.pConsole("page", "info", "event type : " + type + " - this event will be sent only once for the widget", eventParams, "object");
            } else {
                this.logTrcEvent(type, eventParams, postParams, passedCallback, null, sendBeacon);
                TRC.pConsole("page", "info", "sending event type : " + type, eventParams, "object");
            }

            if (typeof timeout === 'number') {
                TRC.Timeout.set(passedCallback, timeout);
            }
        };

        /**
         * access al system flags
         * @param name - name of the flag
         *
         */
        Manager.prototype.getSystemFlag = function (name) {
            if (this.systemFlags && typeof this.systemFlags[name] !== 'undefined') {
                return this.systemFlags[name];
            }
            return null;
        };

        /**
         * Get session data from local storage if it is not empty or it is preferred (configured), otherwise from response
         * @param responseSessionData Response session data
         * @returns {String}
         */
        Manager.prototype.getSessionData = function (responseSessionData) {
            var localStorageSessionData = TRC.pageManager.getPublisherValue(TRC.publisherId, 'session-data'),
                preferResponseSessionData = this.global['prefer-response-session-data'] === true,
                useResponseSessionData = (preferResponseSessionData || !localStorageSessionData);
            return (useResponseSessionData && responseSessionData) ? responseSessionData : localStorageSessionData;
        };

        Manager.prototype.getUserId = function (responseUserId) {
            var localStorageUserId = TRC.pageManager.getValue('user-id');
            return (localStorageUserId || responseUserId) || TRC.pageManager.getUserIdFromReferrer() || null;
        };

        /**
         * global request parameters
         * @constructor
         */
        Manager.prototype.GlobalRequetParams = function () {
            var globalParams = {
                id: parseInt(Math.random() * 1000),
                toString: function () {
                    return 'globalRequestParams';
                }
            };
            this.setItemId = function (val) {
                if (val) {
                    globalParams.ii = val;
                }
            };
            this.setTemplate = function (val) {
                if (val) {
                    globalParams.tmpl = val;
                }
            };
            this.setItemType = function (val) {
                if (val) {
                    globalParams.it = val;
                }
            };
            this.setItemRecrawlData = function (val) {
                if (val && typeof val === 'object' && Object.keys(val).length > 0) {
                    globalParams.ar = val;
                }
            };
            this.setSessionData = function (val) {
                globalParams.sd = val;
            };
            this.setUserId = function (val) {
                globalParams.ui = val;
            };
            this.setLoaderBuildTime = function (val) {
                if (val) { // expo should set null or false to disable
                    globalParams.lbt = val;
                }

            };
            this.setUserIdFirstPartyCookie = function (val) {
                globalParams.uifp = val;
            };
            this.setUserLanguages = function (val) {
                if (val) {
                    globalParams.ul = val;
                }
            };
            this.setUserAgentData = function (val) {
                if (val) {
                    globalParams.uad = val;
                }
            };
            this.setCmpStatus = function (val) {
                if (typeof val === 'number') {
                    globalParams.cmps = val;
                }
            };
            this.setConsentDaisyBit = function (val) {
                if (typeof val === 'string') {
                    globalParams.cdb = val;
                }
            };
            this.setConsentTcString = function (val, maxTcsSize) {
                if (typeof val === 'string' && (!maxTcsSize || val.length < maxTcsSize)) {
                    globalParams.tcs = val;
                }
            };
            this.setCmpStatus = function (val) {
                if (typeof val === 'number') {
                    globalParams.cmps = val;
                }
            };
            this.setGdprApplies = function (val) {
                if (typeof val === 'boolean') {
                    globalParams.ga = val;
                }
            };
            this.setGdprWasTimeout = function (val) {
                if (typeof val === 'boolean') {
                    globalParams.gwto = val;
                }
            };
            this.setCex = function (val) {
                if (val && typeof val === 'string') {
                    globalParams.cex = val; // "true" | "false" | "none"
                }
            };
            this.setCcpaDns = function (val) {
                if (val && typeof val === 'string') {
                    globalParams.ccpa_dns = val; // "true" | "false" | "none"
                }
            };
            this.setCcpaPs = function (val) {
                if (val && typeof val === 'string') {
                    globalParams.ccpa_ps = val;
                }
            };
            this.setExcludedPublishers = function (val) {
                if (val && typeof val === 'string') {
                    globalParams.exp = val;
                }
            };
            this.setGeoCoordinates = function (val) {
                if (val) {
                    globalParams.geo = val;
                }
            };
            this.setCseg = function (val) {
                if (val && typeof val === 'string') {
                    globalParams.cseg = val;
                }
            };

            this.setViewId = function (val) {
                globalParams.vi = val;
            };
            this.setClientVersion = function (val) {
                globalParams.cv = val;
            };
            this.setPublisherVersion = function (val) {
                globalParams.uiv = val;
            };
            this.setItemUrl = function (val) {
                if (val) {
                    globalParams.u = val;
                }
            };
            this.setBrowserUrl = function (browserUrl) {
                if (browserUrl && typeof browserUrl === 'string') {
                    globalParams.bu = browserUrl;
                }
            };
            this.setUrlVideoPubId = function (browserUrl) {
                if (browserUrl && typeof browserUrl === 'string') {
                    globalParams.vpi = browserUrl;
                }
            };
            this.setPlacementsParamsArray = function (arr) {
                globalParams.r = arr;
            };
            this.getPlacementsParamsArray = function () {
                return globalParams.r;
            };
            this.setExperimentVariant = function (val) {
                if (val) {
                    globalParams.pev = val;
                }
            };
            this.setPastExclusions = function (val) {
                globalParams.px = val;
            };

            // page geometry - start:
            this.setScreenHeight = function (val) {
                globalParams.sh = val;
            };

            this.setScreenWidth = function (val) {
                globalParams.sw = val;
            };

            this.setBrowserWidth = function (val) {
                globalParams.bw = val;
            };

            this.setArticlePos = function (val) {
                globalParams.bad = val;
            };
            // page geometry - end.

            // page geometry extended - start:
            this.setScreenDensity = function (val) {
                globalParams.sde = val;
            };

            this.setBrowserHeight = function (val) {
                globalParams.bh = val;
            };

            this.setDocumentWidth = function (val) {
                globalParams.dw = val;
            };

            this.setDocumentHeight = function (val) {
                globalParams.dh = val;
            };
            // page geometry extended - end.

            this.setExclusions = function (val) {
                globalParams.ex = val;
            };
            this.enableTrcTesMode = function () {
                globalParams.y = true;
            };
            this.setReferrer = function (val) {
                globalParams.e = val;
            };
            this.setMetaData = function (val) {
                globalParams.m = val;
            };
            this.setItemUrlQueryString = function (val) {
                if (val) {
                    globalParams.qs = val;
                }
            };
            this.setNetworkID = function (val) {
                globalParams.nsid = val;
            };
            this.getId = function () {
                return globalParams.id;
            };
            this.setAll = function (_globalParams) {
                if (_globalParams) {
                    globalParams = _globalParams;
                }
            };
            this.getAll = function () {
                return globalParams;
            };

            this.setRtui = function (val) {
                globalParams.rtui = val;
            };

            this.setIdProvidersData = function (val) {
                if (val !== undefined) {
                    globalParams.idpd = val;
                }
            };

            this.setDeviceId = function (val) {
                if (val) {
                    globalParams.did = val;
                }
            };

            this.setUnifiedId = function (val) {
                if (val) {
                    globalParams.unuid = val;
                }
            };

            this.setUserType = function (val) {
                if (val) {
                    globalParams.usrtyp = val;
                }
            };

            this.setPaywall = function (val) {
                if (val) {
                    globalParams.pywl = val;
                }
            };

            this.setPremium = function (val) {
                if (val) {
                    globalParams.prem = val;
                }
            };

            this.setAdvertorialSource = function (val) {
                if (val) {
                    globalParams.advrtsrc = val;
                }
            };

            this.setExternalPageView = function (val) {
                if (val) {
                    globalParams.extpvid = val;
                }
            };

            this.setUTMParams = function (val) {
                if (val) {
                    globalParams.pp = val;
                }
            };

            this.setBlockVideoLoader = function (val) {
                if (val) {
                    globalParams.bv = val;
                }
            };

            this.setWebComponentsAvailability = function (val) {
                if (val) {
                    globalParams.wc = val;
                }
            };

            this.setGoogleTopicsApi = function (config) {
                if (config && TRC.GoogleTopicsApi) {
                    var topics = TRC.GoogleTopicsApi.readGoogleTopicsApiFromLocalStorage();
                    if (topics) {
                        globalParams.top = topics;
                    }
                }
            };

            this.setBlockThumbnailVideoLoader = function (val) {
                if (val) {
                    globalParams.btv = val;
                }
            };

            this.setConnectionType = function (val) {
                if (val) {
                    globalParams.con = val;
                }
            };

            this.setConnectionSpeed = function (val) {
                if (val) {
                    globalParams.cos = val;
                }
            };

            this.setAdditionalData = function (val) {
                if (val) {
                    globalParams.ad = val;
                }
            };

            this.setPageLevelFeature = function (val) {
                if (val && Object.keys(val).length > 0) {
                    globalParams.plf = val;
                }
            };

            this.setTrcPiggyBack = function (val) {
                if (val) {
                    globalParams.srpg = val;
                }
            };

            this.setDemographic = function (val) {
                if (val) {
                    globalParams.demo = val;
                }
            };

            this.setBlockerList = function (val) {
                var blockAllValue = "all";
                if (!val) {
                    return;
                }
                if(typeof val != "string"){
                    __trcError('blocker-list should be of type string');
                    return;
                }
                if (val.toLowerCase() === blockAllValue) {
                    globalParams.bl = [];
                    return;
                }
                var blockerListArray = val.split(',').map(function (value){
                    return parseInt(value)
                }).filter(function (value){
                    return !isNaN(value)
                });
                if (!blockerListArray.length) {
                    __trcError('blocker-list config is invalid');
                    return;
                }
                globalParams.bl = blockerListArray;
            };
        };
        /**
         * placement request parameters
         * @constructor
         */
        Manager.prototype.PlacementParams = function () {
            var placementParams = {};

            this.setListId = function (val) {
                placementParams.li = val;
            };
            this.setListSize = function (val) {
                placementParams.s = val;
            };
            this.setUIMode = function (val) {
                placementParams.uim = val;
            };
            this.setUIPlacement = function (val) {
                placementParams.uip = val;
            };

            // page geometry
            this.setContainerPos = function (val) {
                placementParams.cd = val;
            };

            // page geometry
            this.setContainerWidth = function (val) {
                placementParams.mw = val;
            };
            this.setAlternateContainerWidth = function (val) {
                placementParams.amw = val;
            };
            this.setOriginalUIPlacement = function (val) {
                placementParams.orig_uip = val;
            };
            this.setRequiredAttr = function (val) {
                placementParams.ra = val;
            };
            this.setAllowedCategories = function (val) {
                placementParams.ac = val;
            };
            this.setNativeCampaignID = function (val) {
                placementParams.nvcid = val;
            };
            this.setExclusions = function (val) {
                placementParams.ex = val;
            };
            this.setAll = function (_placementParams) {
                placementParams = _placementParams;
            };
            this.getAll = function () {
                return placementParams;
            };

            // feed things
            this.setFeedBatch = function (val) {
                placementParams.fb = val;
            };
            this.setFeedTemplateId = function (val) {
                placementParams.fti = val;
            };
            this.setFeedIndex = function (val) {
                placementParams.fi = val;
            };
        };

        /* helper logging methods, based on the __trc globals */
        Manager.prototype.log = __trcLog;
        Manager.prototype.error = __trcError;
        Manager.prototype.warn = __trcWarn;
        Manager.prototype.info = __trcInfo;
        Manager.prototype.debug = __trcDebug;

        // Private functions
        Manager.prototype._repaintEllipsis = function (event) {
            var eventBoxes = event.data && event.data.boxes;
            TRC.Ellipsis.doEllipsis(TRC.util.filterObj(function (mode) {
                return mode.shouldUseSmartEllipsis();
            }, eventBoxes || this.boxes));
        };

        /**
         * Send pixels for external tracking events.
         * Creates image tag for every pixel url and appends to an iframe
         * (except for old browsers) - in order to prevent delay of document onload event
         *
         * @param urls - urls of tracking pixels
         * @param loadedPixels - array for keeping which pixel urls were fired (share with tfa/trk)
         */
        Manager.prototype.sendExternalTracking = function (urls, loadedPixels) {
            if (TRC.botDetected) {
                return;
            }
            var pixelsMarkup = this.generatePixelsMarkup(urls, loadedPixels),
                pixelsContainer,
                writeToIFrame = this.shouldWritePixelsToIframe(urls);
            try {
                if (pixelsMarkup) {
                    if (writeToIFrame) { // try to write to iframe
                        writeToIFrame = this.appendPixelsToIFrame(pixelsMarkup);
                    }

                    // if writing to iframe failed / or we didn't mean to write to iframe in the first place
                    // append to the body
                    if (!writeToIFrame) {
                        pixelsContainer = doc.createElement('span');
                        pixelsContainer.innerHTML = pixelsMarkup;
                        doc.body.appendChild(pixelsContainer);
                    }
                }
            } catch (e) {
                __trcError('Error in Manager.sendExternalTracking', e);
            }
            return pixelsMarkup;
        };

        Manager.prototype.shouldWritePixelsToIframe = function (urls) {
            return (urls && this.isInternalPixels(urls)) || this.global['disable-iframe-for-tracking-pixel'] === undefined || !this.global['disable-iframe-for-tracking-pixel'];
        };

        Manager.prototype.isInternalPixels = function (urls) {
            for (var i = 0; i < urls.length; i++) {
                var domain = this.stripDomainFromPixel(urls[i]);
                if (domain.indexOf('taboola.com') > -1) {
                    return true;
                }
            }

            return false;
        };

        Manager.prototype.stripDomainFromPixel = function (url) {
            var domain = url.replace(/(http[s]*:\/\/)|(^\/\/)/, '');
            if (domain.indexOf('?') > -1) {
                domain = domain.substring(0, domain.indexOf('?'));
            }
            if (domain.indexOf('/') > -1) {
                domain = domain.substring(0, domain.indexOf('/'));
            }

            return domain;
        };

        /**
         * Injects script tags
         *
         * Creates script tag for every JavaScript URL and appends it to the head tag
         * Each loaded script url is loaded only once
         *
         * @param event.data - list of URLs s of JavaScript files
         */
        Manager.prototype.loadScriptTags = function (event) {
            var urls = event.data,
                url,
                i,
                loadedUrls = win.TRC.sharedObjects.loadedScripts,
                scriptElements = [];

            for (i = 0; urls && i < urls.length; i++) {
                url = urls[i];
                if (url && !loadedUrls[url]) {
                    try {
                        loadedUrls[url] = true;
                        url = TRC.URL.prototype.switchProtocol.call(url, TRC.PROTOCOL);
                        scriptElements.push(TRC.net.loadScript(url, 'js', null, null, true));
                    } catch (e) {
                        __trcWarn('Error appending script at position ' + i + ", url=" + url, e);
                    }
                }
            }
            return scriptElements;
        };

        Manager.prototype.listenToRenderedModes = function () {
            TRC.eventDelegator.subscribe("onrender", function () {
                this.renderedModeCounter++;
                if (this.renderedModeCounter === this.totalModeCounter && !TRC.yieldingEnabled) {
                    TRC.dispatch("allrender", {data: this});
                }
            }.trcBind(this));
        };

        /**
         * Generate markup of <img> tags from every pixel url
         * @param urls - array of pixels urls
         * @param loadedPixels - object for keeping which pixel urls were fired (share with tfa/trk)
         * @returns {string} - markup of pixels
         */
        Manager.prototype.generatePixelsMarkup = function (urls, loadedPixels) {
            var pixelsMarkup = '',
                url,
                htmlEncodedURL;

            for (var i = 0; urls && i < urls.length; i++) {
                // encode the url - safety measure against XSS
                url = urls[i];
                if (url && (!loadedPixels || loadedPixels && !loadedPixels[url])) {
                    if (loadedPixels) {
                        loadedPixels[url] = true;
                    }
                    htmlEncodedURL = TRC.text.encodeHTML(url);
                    if (htmlEncodedURL) {
                        pixelsMarkup += '<img width="0" height="0" src="' + TRC.URL.prototype.switchProtocol.call(htmlEncodedURL, protocol, true) + '">';
                    }
                }
            }

            return pixelsMarkup;
        };


        Manager.prototype.appendPixelsToIFrame = function (pixelsMarkup) {
            var urlRegex = /<img [^>]*src="([^"]+)"[^>]*>/gm;
            var success;
            if (this.global['disable-unified-iframe-pixel-reporter']) {
                success = this.appendPixelsToIFrameMultipleIframes(pixelsMarkup);
            } else {
                success = this.appendPixelsToIFrameUnifiedIframes(pixelsMarkup);
            }

            if (success && this.global['track-external-pixel-traffic']) {
                if (this.global['track-external-pixel-traffic'] > (Math.random() * 100)) {
                    TRC.modDebug.logMessageToServer(1, 'fire external pixel', {
                        idx: 'pix',
                        plat: this.getPlatformCode(),
                        urls: pixelsMarkup.match(urlRegex)
                    });
                }
            }

            return success;
        };

        /**
         * Append a given markup to an iframe
         * @param pixelsMarkup - string of pixels markup (img tags)
         * @returns {boolean} - whether creation + appending to iframe succeeded
         */
        Manager.prototype.appendPixelsToIFrameUnifiedIframes = function (pixelsMarkup) {
            var pixelWrapper,
                frameId = 'trc-pixel-iframe-' + parseInt(Math.random() * 10000, 10),
                frame,
                frameDoc,
                success = false,
                pixelsContainer;

            if (!pixelsMarkup) {
                return;
            }

            try {
                if (!this.iframePixelReporter) {
                    pixelWrapper = this.getPixelWrapper(frameId);
                    doc.body.appendChild(pixelWrapper);
                    frame = doc.getElementById(frameId);
                    this.iframePixelReporter = frame;
                } else {
                    frame = this.iframePixelReporter;
                }

                frameDoc = frame.contentDocument ? frame.contentDocument : frame.contentWindow.document;
                pixelsContainer = doc.createElement('span');
                pixelsContainer.innerHTML = pixelsMarkup;
                frameDoc.body.appendChild(pixelsContainer);
                success = true;
                // make sure to close the iframe to prevent continous spinning of browser loading indicator
                frameDoc.close();


            } catch (e) {
                __trcDebug('Failed to create IFrame for external tracking');
            }

            return success;
        };

        /**
         * Append a given markup to an iframe
         * @param pixelsMarkup - string of pixels markup (img tags)
         * @returns {boolean} - whether creation + appending to iframe succeeded
         */
        Manager.prototype.appendPixelsToIFrameMultipleIframes = function (pixelsMarkup) {
            var frameId = 'trc-pixel-iframe-' + parseInt(Math.random() * 10000, 10),
                frame,
                pixelWrapper,
                frameDoc,
                success = false;

            if (!pixelsMarkup) {
                return;
            }

            try {
                pixelWrapper = this.getPixelWrapper(frameId);
                doc.body.appendChild(pixelWrapper);
                frame = doc.getElementById(frameId);
                this.iframePixelReporter = frame;

                frameDoc = frame.contentDocument ? frame.contentDocument : frame.contentWindow.document;
                frameDoc.body.innerHTML = pixelsMarkup;
                success = true;

                // make sure to close the iframe to prevent continous spinning of browser loading indicator
                frameDoc.close();
            } catch (e) {
                __trcDebug('Failed to create IFrame for external tracking');
            }

            return success;
        };

        Manager.prototype.getPixelWrapper = function (frameId) {
            var element;
            if (!this.global['disable-iframe-span-wrapping'] || TRC.Browser.ieUpto(8)) { // append the iframe to a span - avoids issues in IE
                element = doc.createElement("span");
                element.innerHTML = '<iframe class="trc-hidden" id="' + frameId + '" name="' + frameId + '" width="0" height="0" style="display:none"><\/iframe>';
            } else {
                element = doc.createElement("iframe");
                element.className = "trc-hidden";
                element.id = frameId;
                element.name = frameId;
                element.style.height = "0px";
                element.style.width = "0px";
                element.style.display = "none";
            }
            return element;
        };

        Manager.prototype.isRemovedWidget = function (videoList) {
            var isWithRemoveWidgetIndication = videoList && videoList['removed-widget'];
            if (!isWithRemoveWidgetIndication) {
                return false;
            }
            return !!this.global['prevent-avail-for-removed-widget'];
        };

        Manager.prototype.placementShouldHaveResponseData = function (placementData, placementName) {
            return placementName.search('rbox-tracking') < 0
                && !placementData.isFeed
                && !placementData.isStories
                && !placementData.isIframeCard
                && !placementData.externalContainerSelector
                && !placementData.isStandaloneVideo
                && !placementData.scriptData
                && !placementData.publisherCardData
                && !placementData.isHp4u
                && !placementData.isDynamicLinks;
        };

        Manager.prototype.placementHasResponseData = function (placementData) {
            return placementData.response != null || placementData.dc;
        };

        Manager.prototype.getOrCreatePlacementData = function (placement, recommendation) {
            var placementData = this.preloadRequest[placement];
            if (!placementData) {
                placementData = this.createPlacementData(placement, recommendation);
                if (placementData) {
                    this.preloadRequest[placement] = placementData;
                }
            }
            return placementData;
        };

        Manager.prototype.createPlacementData = function (placement, recommendation) {
            if (this.isRegularWidget(recommendation)) {
                return this.createAddedWidgetData(placement, recommendation);
            }

            if (this.isStandaloneVideo(recommendation)) {
                return this.createStandaloneVideoWidgetData(placement, recommendation);
            }

            if (TRC.FeedsManager.isFeedIframe(recommendation)) {
                return TRC.FeedsManager.createFeedIframe(placement, recommendation);

            }
            if (TRC.FeedsManager.isFeedScriptWidget(recommendation)) {
                return TRC.FeedsManager.createFeedScriptWidgetData(placement, recommendation);

            }
            if (TRC.FeedsManager.isExternalContainerWidget(recommendation)) {
                return TRC.FeedsManager.createExternalWidgetData(placement, recommendation);

            }

            if (TRC.FeedsManager.isPublisherCard(recommendation)) {
                return TRC.FeedsManager.createPublisherCardData(placement, recommendation);
            }

            if (this.isHp4uCard(recommendation)) {
                return this.createAddedHp4uData(placement);
            }

            if (isDynamicLinksRecommendation(recommendation)) {
                return createAddedDynamicLinksData(placement);
            }
        };

        Manager.prototype.isRegularWidget = function (recommendation) {
            return recommendation.m && !recommendation.ifr;
        };

        Manager.prototype.isHp4uCard = function (recommendation) {
            return recommendation.hpl;
        };

        Manager.prototype.createAddedWidgetData = function (placement, recommendation) {
            return {
                placement: placement,
                mode: recommendation.m,
                mode_name: recommendation.m,
                addWidget: true
            };
        };

        Manager.prototype.createAddedHp4uData = function (placement) {
            return {
                placement: placement,
                isHp4u: true,
                addWidget: true
            };
        };

        Manager.prototype.isStandaloneVideo = function (recommendation) {
            return recommendation.vtag
                && recommendation.vtag.position === TRC.VideoTagLoader.prototype.LOCATION_TYPES.STANDALONE;
        };

        Manager.prototype.createStandaloneVideoWidgetData = function (placement) {
            return {
                placement: placement,
                isStandaloneVideo: true
            };
        };

        Manager.prototype.getSortedCloudinaryRatios = function () {
            var cloudinaryRatios,
                originalCloudinaryRatios,
                currRatio;

            if (!this.cloudinarySortedRatios) {
                // Ratios refer to height / width
                originalCloudinaryRatios = this.global['cloudinary-aspect-ratios-list'] || [[1, 2], [1, 1.9], [1, 1.8], [9, 16], [1, 1.7], [1, 1.6], [1, 1.5], [1, 1.4], [3, 4], [1, 1.3], [1, 1.2], [1, 1.1], [1, 1], [1, 0.9], [6, 5], [1, 0.8], [4, 3], [1, 0.7], [3, 2], [1, 0.6], [16, 9], [2, 1]];
                cloudinaryRatios = [];
                for (var ratioIndex = 0; ratioIndex < originalCloudinaryRatios.length; ratioIndex++) {
                    currRatio = originalCloudinaryRatios[ratioIndex];
                    cloudinaryRatios[ratioIndex] = currRatio[0] / currRatio[1];
                }

                this.cloudinarySortedRatios = cloudinaryRatios.sort();
            }

            return this.cloudinarySortedRatios;
        };

        Manager.prototype.getExpandOptions = function (placementResponseData) {
            var expandOptions = {
                expandType: placementResponseData.et
            };

            if (placementResponseData.ch) {
                expandOptions.collapsedHeight = placementResponseData.ch;
            }

            if (placementResponseData.ebc) {
                expandOptions.expandButtonCaption = placementResponseData.ebc;
            }

            if (placementResponseData.cbc) {
                expandOptions.collapseButtonCaption = placementResponseData.cbc;
            }

            return expandOptions;
        };

        Manager.prototype.clearPageElements = function () {
            this.clearTransportFrames();
            this.clearUserXElements();
            this.clearStyleSheets();
        };

        Manager.prototype.clearTransportFrames = function () {
            if (!document.querySelector) {
                return;
            }

            var transportFrames = [].slice.call(document.querySelectorAll('.' + TRANSPORT_FORM_ELEMENT));

            transportFrames.forEach(function (frameElement) {
                frameElement.parentNode.removeChild(frameElement);
            });
        };

        Manager.prototype.clearUserXElements = function () {
            if (TRC.userX) {
                TRC.userX.reset();
            }
        };

        Manager.prototype.clearStyleSheets = function () {
            if (!this.global['clear-styles-on-reset']) {
                return;
            }

            TRC.dom.removeAllInjectedStyleSheets();
        };

        Manager.prototype.shouldBlockVideoLoader = function (blockVideoLoaderProbability) {
            var blockVideoLoader = false;
            if (!isNaN(blockVideoLoaderProbability)) {
                blockVideoLoader = Math.random() < (blockVideoLoaderProbability / 100);
            }
            TRC.pConsole("page", "info", "Blocked video: " + blockVideoLoader + ", block-video-prob: " + blockVideoLoaderProbability, "string");

            return blockVideoLoader;
        };

        Manager.prototype.shouldBlockThumbnailVideoLoader = function (blockThumbnailVideoLoaderProbability) {
            var blockThumbnailVideoLoader = false;
            if (!isNaN(blockThumbnailVideoLoaderProbability)) {
                blockThumbnailVideoLoader = Math.random() < (blockThumbnailVideoLoaderProbability / 100);
            }
            TRC.pConsole("page", "info", "Blocked thumbnail video: " + blockThumbnailVideoLoader + ", block-Thumbnail-video-prob: " + blockThumbnailVideoLoaderProbability, "string");

            return blockThumbnailVideoLoader;
        };

        Manager.prototype.getPublisherVersionPropertyWithFallbackToNetwork = function (propertyName) {
            return this[propertyName][TRC.publisherId] || (TRC.networkId && this[propertyName][TRC.networkId]);
        };

        Manager.prototype.getSiteNameOgValue = function () {
            if (!this.siteName) {
                this.siteName = TRC.dom.getPageMetaPropertyValue('og:site_name');
            }
            return this.siteName;
        };

        Manager.prototype.composeGetURL = function (type, params, host) {
            var publisher = this['normalize-log-param']('publisher', TRC.publisherId);
            var url = protocol + '//' + (host || this.domain) + '/' + publisher + '/log/3/' + escape(type) + '?';
            url += (this.trcByPass) ? "trc_skip_failover=yes&" : "";
            url += (this.enableTrcRoute && this.trcRoute) ? "route=" + this.trcRoute + "&" : "";
            url += (this.enableExperimentsVariantIdEvent && this.experimentsVariantIdParamsStr) ? this.experimentsVariantIdParamsStr + "&" : "";
            url += this.getLoaderTypesValue() ? this.getLoaderTypesValue() + "&" : "";

            Object.keys(params).forEach(function (name) {
                    win.nam = name.charAt(0) == '_' ? name.substr(1) : name;
                    if (typeof params[name] !== 'undefined' && params[name] != null) {
                        if (name.indexOf("unescape-") == 0) {
                            url += name.replace("unescape-", "") + '=' + params[name] + '&';
                        } else {
                            url += escape(nam) + '=' + escape(params[name]) + '&';
                        }
                    }

            });
            return url;
        };

        Manager.prototype.sendPubsGenericEvent = function (eventName, eventType, callback, isSendAsync) {
            var eventData = {
                data: JSON.stringify(eventType),
                type: eventName,
                eventTime: new Date().getTime()
            };

            this.generateEvent('pubs-generic', eventData, callback, isSendAsync);
        };

        Manager.prototype.sendAbTestEvent = function (eventName, eventType, callback, isSendAsync) {
            var eventData = {
                abTestsEventType: 'simple',
                name: eventName,
                type: eventType,
                eventTime: new Date().getTime()
            };

            this.generateEvent('abtests', eventData, callback, isSendAsync);
        };

        Manager.prototype.sendExternalRevenueEvent = function (eventName, eventPayload, callback, isSendAsync) {
            var eventData = {
                name: eventName,
                payload: eventPayload,
                eventTime: new Date().getTime()
            };

            this.generateEvent('external-revenue', eventData, callback, isSendAsync);
        };

        Manager.prototype.generateEvent = function (eventName, eventData, callback, isSendAsync, overrideEventParams) {
            var data = {'unescape-d': encodeURIComponent(__trcJSONify(eventData))};
            if (isSendAsync && TRC.hasNetworkAsyncSupport()) {
                data.tim = __trcClientTimestamp();
                data.id = parseInt(Math.random() * 10000);
                data.llvl = win.trc_debug_level;

                __trcCopyProps(this.getEventParams(overrideEventParams), data);
                var url = this.composeGetURL(eventName, data, this.trcEventRoute);
                TRC.sendPostAsyncCall(url);
            } else {
                this.sendEvent(eventName, data, null, false, callback, null, isSendAsync);
            }
        };

        Manager.prototype.shouldSkipRender = function () {
            if (!this.currentRecommendation) {
                return false;
            }

            if (this.currentRecommendation.hpl) {
                return true;
            }

            return !TRC.fallbackApi.shouldRenderPlacementByRequest(this.currentRecommendation, this.preloadRequest);
        };

        Manager.prototype.initRBox = function (containerElm, options) {
            //   options.container = containerElm; // enabling this will give each widget a style as independent card
            var mybox = new TRC.implClasses.TRCRBox(options.origin.toString(), options, this);

            TRC.dispatch("preBoxRender", {mybox: mybox});
            if (this.shouldSkipRender()) {
                return mybox;
            }

            containerElm._trcRboxId = mybox.id;

            // remember this box in my collection
            this.boxes[mybox.id] = mybox;

            // generate main containers if not done yet
            if (!containerElm._trc_container) {
                // generate CSS reset containers
                containerElm._trc_container = document.createElement("div");
                containerElm._trc_container.className = 'trc_rbox_container';

                containerElm._trc_anonbox = document.createElement("div");
                containerElm._trc_container.appendChild(containerElm._trc_anonbox);

                containerElm.appendChild(containerElm._trc_container);

                mybox.outermostContainer = containerElm;
            }

            // Handle High Impact Placement
            TRC.dispatch("beforeBoxRender", {mybox: mybox, containerElm: containerElm, boxesList: this.boxes});

            // finally setup my box
            mybox.render(containerElm._trc_anonbox);

            // and activate it
            this.renderRBox(mybox);
            win.TRC.trc_drawRBox = true; // done

            return mybox;
        };

        Manager.prototype.shouldRetryFailedPlacementRequest = function (placementData) {
            return !placementData.addWidget && !placementData.fpl
                && (!placementData.numFailedRequests || placementData.numFailedRequests < this.maxRetriesPerFailedPlacementRequest);
        };

        Manager.prototype.retryFailedPlacementRequest = function (placementName, placementData) {
            placementData.numFailedRequests = placementData.numFailedRequests || 0;

            var retryPreloadRequest = {};
            retryPreloadRequest[placementName] = placementData;

            placementData.numFailedRequests++;
            this.dispatchLoadRequest(retryPreloadRequest);
        };

        Manager.prototype.createContainerForEscalatorWidget = function (options) {
            options.container = document.createElement('div');
            options.container.id = 'trc_rbox_slider_' + Math.floor(Math.random() * 2147483648).toString(36);
            options.container.className = 'trc_related_container';
        };

        Manager.prototype.callTrc = function (url, req, timeout, doneCurrentRequest) {
            if (TRC.isAMPSplitFeed) { // if AMP Split Feed
                if (this.ampSplitFeedManager.ampSplitFeedCache.getCacheData('tbl_syncViewID') !== req.vi) {
                    __trcError('View ID Not Synched Between AMP Split Feed iFrames');
                }
            }
            this.preloadRequestLoader = this.loadExternal(url, 'js', this.handleLoadResponseFailure.trcBind(this), true);
            this.preloadRequestLoader.doneCurrentRequest = doneCurrentRequest;
            this.preloadRequestLoader.timeout = TRC.Timeout.set(this.abortLoadRequest.trcBind(this, true, req.cb), timeout);
            this.lastReqId = req.id;
            (TRC.performance && TRC.performance.mark("5.1.0", null, "TrcPv3", this.lastReqId, 'pv3call', TRC.PerfEvenType.START));
            TRC.pConsole("", "time", "dispatch recommendation request", "");
        };

        Manager.prototype.callTrcByWorker = function (url, req, timeout) {
            (TRC.performance && TRC.performance.mark("5.1.0", null, "TrcPv3", this.lastReqId, 'pv3call', TRC.PerfEvenType.START));

            this.lastReqId = req.id;

            TRC.worker.xhr(url, timeout, function (data) {
                try {
                    // eslint-disable-next-line no-eval
                    eval(data);
                } catch (e) {
                    __trcError("TRC.worker: Worker Error in trc response", e);
                }

            }, this.handleLoadResponseFailure.bind(this));
            TRC.pConsole("", "time", "dispatch recommendation request", "");
        };

        Manager.prototype.callTrcByAjax = function (url, req, timeout, doneCurrentRequest) {
            (TRC.performance && TRC.performance.mark("5.1.0", null, "TrcPv3", this.lastReqId, 'pv3call', TRC.PerfEvenType.START));

            this.lastReqId = req.id;

            var failureHandler = (function (message, reportError) {
                this.handleLoadResponseFailure();
                this.abortLoadRequest(true, req.cb);
                if (reportError) {
                    reportError(message);
                }
            }).trcBind(this);
            var responseHandler = this.handleLoadResponse.trcBind(this, req.cacheKey);
            this.preloadRequestLoader = {};
            this.preloadRequestLoader.doneCurrentRequest = doneCurrentRequest;

            if (TRC.externalLoadRequest) {
                TRC.externalLoadRequest({
                    responseCallback: responseHandler,
                    errorCallback: failureHandler,
                    abortRequestCallBack: this.abortLoadRequest.trcBind(this),
                    requestedPlacements: req.r.map(function (placementData) {
                        return placementData.orig_uip;
                    })
                });
                return;
            }

            var http = new XMLHttpRequest();
            http.open("GET", url, true);
            http.setRequestHeader("Content-Type", "text/plain");
            http.withCredentials = true;
            http.timeout = timeout;
            http.addEventListener("readystatechange", this.handleTrcAjaxResponseStatus.trcBind(this, http, responseHandler, failureHandler));
            http.addEventListener("error", function () {
                failureHandler("Network error", window.__trcWarn);
            });
            http.addEventListener("timeout", function () {
                failureHandler("Network timeout: " + timeout, window.__trcWarn);
            });
            http.send("");

            TRC.pConsole("", "time", "dispatch recommendation request", "");
            /* public methods for UT */
            if (window._trcIsUTactive) {
                TRC.ajaxFailureHandler = failureHandler;
            }
        };

        Manager.prototype.handleTrcAjaxResponseStatus = function (http, responseHandler, failureHandler) {
            if (http.readyState !== 4 || http.status === 0) {
                return;
            }
            if (http.status < 200 || http.status >= 300) {
                failureHandler("Ajax status code not valid", window.__trcWarn);
                return;
            }
            var textResponse = http.responseText;
            if (!textResponse || textResponse.indexOf('{"trc":{}}') > -1) {
                var errorMsg = "Invalid ajax response from server";
                failureHandler(errorMsg, window.__trcWarn);
                TRC.MetricsManager.sendMetricsEvent(TRC, this, {
                    name: 'EmptyResponse',
                    value: '1',
                    type: 'counter'
                }, null);
                return;
            }
            if (textResponse.indexOf('TRC.callbacks.mute()') > -1) {
                TRC.callbacks.mute();
                return;
            }
            var enableBreakline = TRC.util.isEnabledByDefault(this.global['enable-breakline-in-json']);
            var RegexJsonContent = enableBreakline ? /^[^{]*([^]*)\)$/ : /^[^{]*(.*)\)$/;
            var responseMatch = textResponse.match(RegexJsonContent);
            if (!responseMatch) {
                failureHandler("Can't validate TRC response, JSON extract with regex failed", window.__trcError);
                return;
            }
            try {
                responseHandler(JSON.parse(responseMatch[1]));
            } catch (e) {
                failureHandler("TRC response not a valid JSON", window.__trcError);
            }
        };
        Manager.prototype.clearPreloadRequestLoader = function () {
            if (this.preloadRequestLoader) {
                TRC.Timeout.clear(this.preloadRequestLoader.timeout);
                this.preloadRequestLoader.parentNode && this.preloadRequestLoader.parentNode.removeChild(this.preloadRequestLoader);
                this.preloadRequestLoader = null;
            }
        };

        Manager.prototype.clearPreloadRequestLoaderAndCallNext = function () {
            var done;
            if (this.preloadRequestLoader && typeof this.preloadRequestLoader.doneCurrentRequest === 'function') {
                done = this.preloadRequestLoader.doneCurrentRequest;
            }
            this.clearPreloadRequestLoader();
            if (done) {
                done();
            }
        };

        Manager.prototype.clearPreloadRequestLoaderAndResetQueue = function () {
            this.clearPreloadRequestLoader();
            TRC.recoRequestsQueue.resetQueue();
        };

        Manager.prototype.enableExploreMore = function (exploreMoreConfig, feedParentPlacement) {
            exploreMoreConfig.shouldNotCopyPublisherHeaderHtml = this.global.shouldNotCopyPublisherHeaderHtml || false;
            this.loadExploreMoreModule(exploreMoreConfig);

            var exploreMoreContainer = this.createAndAppendExploreMoreContainer(exploreMoreConfig.exm.container);
            this.setPlacementDataInPreloadRequest(feedParentPlacement, exploreMoreContainer);

            TRC.exploreMoreInitialized = true;
        };

        Manager.prototype.setPlacementDataInPreloadRequest = function (feedParentPlacement, container) {
            this.preloadRequest[feedParentPlacement] = this.computeRBoxOptions({
                container: container,
                placement: feedParentPlacement,
                target_type: 'mix',
                addedWidget: true
            });
        };

        Manager.prototype.createAndAppendExploreMoreContainer = function (containerId) {
            var exploreMoreContainer = document.createElement('div');
            exploreMoreContainer.id = containerId;
            TRC.dom.addClass(exploreMoreContainer, 'tbl-invisible');
            var enableExploreMoreNewDisplay = TRC.util.isTrue(this.global['enable-explore-more-new-display']);

            if (enableExploreMoreNewDisplay) {
                exploreMoreContainer.style.display = 'none';
                TRC.dom.addClass(exploreMoreContainer, 'tbl-new-display');
                document.documentElement.insertAdjacentElement('afterbegin', exploreMoreContainer);
            } else {
                document.body.appendChild(exploreMoreContainer);
            }
            return exploreMoreContainer;
        };

        Manager.prototype.loadExploreMoreModule = function (config) {
            TRC.ModuleLoader.load('explore-more', TRC.ExploreMore, (function () {
                this.exploreMore = new TRC.ExploreMore(this, config);
            }).trcBind(this));
        };

        Manager.prototype.shouldSkipPlacement = function (recommendation, response) {
            if (TRC.exploreMoreInitialized) {
                return TRC.ExploreMore && TRC.ExploreMore.shouldSkipPlacement(recommendation, response, this.feedsManager);
            }
            return false;
        };

        /**
         * Skip on pushed requests with non Explore More placement once Explore More is visible
         * @param request - request data
         * @returns {boolean} - whether we should skip pushed request
         */
        Manager.prototype.shouldSkipPushedRequest = function (request) {
            if (TRC.exploreMoreInitialized) {
                return TRC.ExploreMore && TRC.ExploreMore.shouldSkipPushedRequest(request);
            }

            return false;
        };

        Manager.prototype.parseClientGenericAction = function (response, type) {
            var clientGenericAction = this.emulateCga(type) || response.trc[type];

            if (clientGenericAction) {
                return TRC.util.jsonParseSafe(clientGenericAction);
            }
        };

        Manager.prototype.emulateCga = function (type) {
            return TRC.URL.prototype.getParameter.call(location.href, 'trc_' + type);
        };

        Manager.prototype.initCcpa = function (clientGenericActionParsed, response) {
            var responseValidation = clientGenericActionParsed && clientGenericActionParsed.ccpa;
            if (!this.global['disable-ccpa'] && responseValidation && TRC.ccpa
                && (!TRC.ccpa.isInitialized || TRC.ccpa.browserUrl !== this.getBrowserUrl())) {

                if (!TRC.ccpaPs) {
                    TRC.ccpa.init(response.trc.vl, clientGenericActionParsed.ccpa);
                } else {
                    /* no need to render ccpa (rendered by the publisher) */
                    TRC.ccpa.isInitialized = true;
                    TRC.ccpa.sendCcpaEvent('publisher');
                }
                /**
                 *  TRC.ccpa.browserUrl - This will help to check in case
                 *  if publisher's url are changed with the previous url
                 *  without refreshing the page.
                 */
                TRC.ccpa.browserUrl = this.getBrowserUrl();
            }
        };


        Manager.prototype.isExpoTest = function () {
            return !!(this.getSystemFlag('experimentID'));
        };

    }(window, document));

    const isPerformanceSupported = !!(window.performance && window.performance.mark && window.performance.measure);

    const MeasurePerformanceMixin = Class => class extends (Class) {
        constructor(settings = {}) {
            super(settings);
            this.settings.classTreeArr = this.settings.classTreeArr || [];
            this.id = this.settings.classTreeArr.slice(-1)[0] || '';
            this.markEventMap = {};
        }

        mark(eventName, mode) {
            if (!isPerformanceSupported) {
                return null;
            }
            const eventPrefix = this.settings.classTreeArr.slice(-2)[0] || '';
            const markName = `${eventPrefix}-${eventName}-${mode}`;
            if (TRC.performance) {
                return TRC.performance.mark(markName, null, '', this.id, `${eventPrefix}-${eventName}`, mode);
            }

            // Else use window.performance mark and not TRC.performance
            window.performance.mark(markName);
            return markName;
        }

        start(eventName) {
            if (!isPerformanceSupported) {
                return null;
            }
            const start = TRC.PerfEvenType ? TRC.PerfEvenType.START : 'start';
            this.markEventMap[eventName] = this.mark(eventName, start);
            return this.markEventMap[eventName];
        }

        stop(eventName) {
            if (!isPerformanceSupported) {
                return null;
            }
            const startMarkId = this.markEventMap[eventName];
            if (!startMarkId) {
                return null;
            }

            const stop = TRC.PerfEvenType ? TRC.PerfEvenType.STOP : 'stop';
            const endMarkId = this.mark(eventName, stop);
            const measureObj = window.performance.measure(eventName, startMarkId, endMarkId);
            delete this.markEventMap[eventName];

            // Needed for Jenkins unit test window.measure problem.
            if (!measureObj) {
                return null;
            }

            return {
                startTime: measureObj.startTime,
                duration: measureObj.duration
            };
        }
    };

    const classTreeFactory = new ClassTreeFactory();
    const measurePerformance = classTreeFactory.mixin(MeasurePerformanceMixin);

    /**
     * Created by dotan.l on 11/12/2016, and deprecated!!!
     */

    (function () {
        var pVideoLoaderPerformance = new ClassTreeFactory().mixin(MeasurePerformanceMixin, MetricReporterMixin).sub('motion-ads');

        TRC.InvokePOldVideoLoader = function() {
            var random = Math.random();

            TRC.POldVideoLoader = function PVideoLoader(rbox, videoConfig, trcResponse, trcManager, itemId, metricsEvents) {
                this.blockVideo = trcManager.blockThumbnailVideoLoader;
                this.itemPerformance = pVideoLoaderPerformance.sub(itemId);
                this.metricsEvents = metricsEvents || [];
                if (this.shouldTrackEvents()) {
                    this.metricsEvents.forEach(function (eventName) {
                        this.itemPerformance.start(eventName);
                    }.bind(this));
                }

                // Inheritance mechanism
                if(!this.blockVideo) {
                    TRC.VideoLoader.call(this, rbox.trc, videoConfig, rbox.placement, rbox.container, trcResponse);
                    this.rbox = rbox;
                }
            };

            // Inheritance mechanism
            TRC.POldVideoLoader.prototype = __trcObjectCreate(TRC.VideoLoader.prototype);

            TRC.VideoLoader.prototype.ITEM_ID_SEPARATOR = '~~';

            /**
             * The function returns a key name for the object that will hold all callbacks of the p-video-loader.
             * The function will be used at the generateCallbackName function.
             * @returns {string} - the key of the callbacks object to be stored over TRC object (e.g. pVideoCallbacks)
             */
            TRC.POldVideoLoader.prototype.getCallbacksObjectKey = function () {
                return 'pVideoCallbacks';
            };

            /**
             * Generate a callback function for the main video script and to save it on the
             * video callback namespace (TRC.videoCallbacks).
             * The callback name is sequential - every time that such a callback is created,
             * its numeric suffix is incremented.
             *
             * @param videoCallbackParams - an Object that holds the parameters of each video such as url, playerContainer etc.
             * @returns {string} - the path to the generated callback (e.g. TRC.pVideoCallbacks.videoCallback1)
             */
            TRC.POldVideoLoader.prototype.genVideoCallback = function (videoCallbackParams) {

                var videoCallbackName = this.generateCallbackName(),
                    that = this;

                TRC.pVideoCallbacks[videoCallbackName] = function(data) {

                    if (TRCImpl.global['enable-video-ajax']) {
                        if (!TRC.VideoTagLoader.prototype.isXHRDone(data.target)) {
                            return;
                        }
                        (TRC.performance && TRC.performance.mark('videoAjaxStop', null, '', '', 'videoAjaxRoundtrip', TRC.PerfEvenType.STOP));
                        data = TRC.VideoTagLoader.prototype.parseTBResponse(data.target.responseText);
                    }

                    (TRC.performance && TRC.performance.mark('videoJsonpRequestStop', null, '', '', 'videoJsonpRequestTime', TRC.PerfEvenType.STOP));

                    data = data || {};
                    if (data.tags && data.tags[0]) {
                        var unitBootSrc = data.tags[0].unitBootSrc || that.videoConfig.unitBootSrc;
                        var script = document.createElement('script');
                        script.src = unitBootSrc;
                        script.setAttribute('type', 'text/javascript');
                        script.setAttribute('src', unitBootSrc);

                        script.onload = function() {
                            var unit = eval(data.tags[0].url),
                                viewabilityConfig = that.videoConfig['autoTriggerConfig']['viewabilityConfig'];

                            if (viewabilityConfig.time == -1) {
                                viewabilityConfig.time = 0;
                                viewabilityConfig.percentage = 101;
                            }

                            unit.set('pVideoUrl', videoCallbackParams.url);
                            unit.set('playerContainer', videoCallbackParams.playerContainer);
                            unit.set('components.PosterView', {
                                isActive: true,
                                imageLocation: videoCallbackParams.poster
                            });
                            unit.set('customization.placeHolder.background-color', 'black');
                            unit.set('viewPercent', viewabilityConfig.percentage);
                            unit.set('secondsInView', viewabilityConfig.time);
                            unit.set('isPlayOnHover', that.videoConfig['autoTriggerConfig']['hover']);
                            unit.set('isRepeat', that.videoConfig.repeat);

                            var trackEvents = that.shouldTrackEvents();
                            if (trackEvents) {
                                var videoDataForEvent = that.getVideoDataForEvent(videoCallbackParams.itemIndex, videoCallbackParams.itemId);
                                unit.on('error', function() {that.sendDebugEvent('error', videoDataForEvent);});
                                unit.on('eligible', function() {that.sendDebugEvent('eligible', videoDataForEvent);});
                                unit.on('play', function(data) {that.sendDebugEvent('play', videoDataForEvent, data);});
                                unit.on('render', function() {that.sendDebugEvent('rendered', videoDataForEvent);});
                                unit.on('quarterly', function(data) {that.sendDebugEvent('quarterly', videoDataForEvent, data);});
                                unit.on('complete', function() {that.sendDebugEvent('complete', videoDataForEvent);});
                                unit.on('render', function () {
                                    setTimeout(function () {
                                        var video = that.rbox.element.querySelector('video');
                                        that.metricsEvents.forEach(function (eventName) {
                                            video.addEventListener(eventName, function () {
                                                var eventDataObj = {
                                                    label: 'event-' + eventName,
                                                    itemIndex: videoCallbackParams.itemIndex,
                                                    itemId: videoCallbackParams.itemId
                                                };

                                                var measureObj = that.itemPerformance.stop(eventName);
                                                if (measureObj) {
                                                    eventDataObj.measureObj = measureObj;
                                                    pVideoLoaderPerformance.sendRboxMetricsEvent({eventName: 'old-duration-' + eventName , value: Math.round(eventDataObj.measureObj.duration), type: 'histogram'});
                                                }
                                                pVideoLoaderPerformance.sendRboxMetricsEvent({eventName: 'old-event-' + eventName, value: '1', type: 'counter'});

                                                sendEvent(eventDataObj);
                                            }, {once: true});
                                        });
                                    }, 0);
                                });
                            }
                            (TRC.tlf && console.timeEnd('in setVideoPlayerLoad'));
                            (TRC.tlf && console.timeStamp('end setVideoPlayerLoad'));

                            sendEvent({
                                label: 'script-loaded',
                                trackEvents: trackEvents,
                                itemIndex: videoCallbackParams.itemIndex,
                                itemId: videoCallbackParams.itemId,
                            });
                        };

                        document.getElementsByTagName('head')[0].appendChild(script);
                    }
                };

                return 'TRC.' + this.getCallbacksObjectKey() + '.' + videoCallbackName;
            };

            TRC.POldVideoLoader.prototype.shouldTrackEvents = function () {
                return !!(typeof TRCImpl != 'undefined' &&  TRCImpl && TRCImpl.global && TRCImpl.global['motion-ads-track-events'] >= random);
            };

            TRC.POldVideoLoader.prototype.sendDebugEvent = function(eventTitle, videoData, eventData){
                var message,
                    old_debug_level = window.trc_debug_level;
                message = {
                    event: eventTitle,
                    data: eventData ? eventData : null,
                    rii: videoData.rii,
                    placement: videoData.placement,
                    mode: videoData.modeName,
                    itemIndex: videoData.itemIndex,
                    itemId: videoData.itemId
                };
                window.trc_debug_level = 3;
                __trcDebug('Performance Video Event: ' + JSON.stringify(message));
                // we retrieve the  debug level to it's initial state
                window.trc_debug_level = old_debug_level;
            };

            TRC.POldVideoLoader.prototype.getVideoDataForEvent = function(itemIndex, itemId){
                return {
                    rii: this.rbox['response']['trc']['req'],
                    placement: this.rbox['placement'],
                    modeName: this.rbox['mode_name'],
                    itemIndex: itemIndex,
                    itemId: this.extractRealItemId(itemId)
                };
            };

            TRC.POldVideoLoader.prototype.extractRealItemId = function(dataItemId){
                if (!dataItemId) return null;
                var id = dataItemId.split(this.ITEM_ID_SEPARATOR)[2];
                return (id && id.length > 0 && !isNaN(parseFloat(id)) && isFinite(id)) ? id : null;
            };

            TRC.POldVideoLoader.prototype.loadVideo = function(videoCallbackParams, pVideoOverlayData) {
                var overlayContainer, overlayComponent, overlayContainers,
                    isLoaded = TRC.VideoLoader.prototype.loadVideo.call(this, videoCallbackParams);

                if (isLoaded && pVideoOverlayData) {
                    overlayContainers = pVideoOverlayData.container.getElementsByClassName('thumbBlock_holder');
                    overlayContainer = overlayContainers && overlayContainers[0];
                    if (overlayContainer && pVideoOverlayData.isCreatePVideoOverlay) {
                        overlayComponent = TRC.pVideoOverlay.create(pVideoOverlayData.video_data, pVideoOverlayData.language, pVideoOverlayData.isSendEvents);
                        overlayContainer.appendChild(overlayComponent);
                    }
                };

                return isLoaded;
            };
        };

        function sendEvent(extraData) {
            setTimeout(function () {
                if (!TRC.RBoxUsage || !TRC.RBoxUsage.logUsage) {
                    return;
                }
                extraData = extraData || {};
                extraData.label = extraData.label || 'no-label';
                extraData.label = 'motion-ads-' + extraData.label;
                TRC.RBoxUsage.logUsage(
                    'motion-ads-event-' + Date.now(),
                    { extraData: extraData, file: 'p-old-video-loader' }
                );
            }, 0);
        }
    })();

    class ESLogger {

        static get DEFAULT_UPDATE_INTERVAL() {
            return 5000;
        }

        static get MINIMUM_UPDATE_INTERVAL() {
            return 250;
        }

        static get LOADER_VARIANT() {
            return window.TRCImpl && window.TRCImpl.systemFlags && window.TRCImpl.systemFlags.loaderType;
        }

        static get updateIntervalTime() {
            let interval;
            try {
                const confInterval = TRCImpl.global['rbox-es-events-interval'];
                interval = confInterval ? Math.max(parseInt(confInterval, 10), ESLogger.MINIMUM_UPDATE_INTERVAL) : ESLogger.DEFAULT_UPDATE_INTERVAL;
            } catch (e) {
                interval = ESLogger.DEFAULT_UPDATE_INTERVAL;
            }
            return interval;
        }
        
        constructor({id, name, index}) {
            this.index = index;
            this.created = Date.now();
            this.data = {
                _id: id || TRC.util.generateUid(40),
                name,
                updatesCount: 0,
                variant: ESLogger.LOADER_VARIANT
            };
            this._sendData = TRC.util.debounce(this._sendData.trcBind(this), ESLogger.updateIntervalTime, false, this);
        }

        push({key, valueObj = {}}) {
            if (!this.data) {
                return;
            }
            this._addTimeStamp(valueObj);
            if (this._shouldAppend(key)) {
                this._converToArray(key);
                this.data[key].push(valueObj);
            } else {
                this.data[key] = valueObj;
            }
            this._sendData();
        }

        _addTimeStamp(valueObj) {
            valueObj.time = Date.now() - this.created;
        }

        _shouldAppend(key) {
            return Object.prototype.hasOwnProperty.call(this.data, key);
        }

        _converToArray(key) {
            if (!Array.isArray(this.data[key])) {
                this.data[key] = [this.data[key]];
            }
        }

        _sendData() {
            if (this.data) {
                this.data.updatesCount++;
            }
            this._dataChanged = false;
            TRC.TRCLogger.reportES(this);
        }   

    }

    const pVideoLoaderPerformance = new ClassTreeFactory().mixin(MeasurePerformanceMixin, MetricReporterMixin).sub('motion-ads');
    let styleInjected = false;

    class PVideoLoader {

        constructor({id} = {}) {
            this.itemPerformance = pVideoLoaderPerformance.sub(id);
            this.initElasticLogger({id});
            this.occuredEvents = {};
        }

        static loadVideo({
            playerContainer,
            poster,
            url,
            itemIndex,
            itemId,
            // old version support
            overlayData,
            trcRBox
        } = {}) {
            const pVideoLoaderInstance = new PVideoLoader({id: itemId});
            try {
                const {cloudinaryUrlPrefix} = PVideoLoader;
                if (cloudinaryUrlPrefix) {
                    url = cloudinaryUrlPrefix + encodeURIComponent(url);
                }
            } catch (error) {
                pVideoLoaderInstance.sendMetric({
                    label: `resolution_adjustment_error-${error}`,
                    itemIndex,
                    itemId
                });
            }

            return pVideoLoaderInstance.loadVideo({
                playerContainer,
                poster,
                url,
                itemIndex,
                itemId,
                // old version support
                overlayData,
                trcRBox
            });
        }

        initElasticLogger({id} = {}) {
            this.eslogger = new ESLogger({
                name: 'motion-ads',
                index: 'adexperience'
            });
            let cleanItemId = 0;
            try {
                cleanItemId = id.replace(/(^~~V1~~)|(~~.+$)/g, '');
            } catch (e) {
                cleanItemId = 0;
            }
            this.eslogger.push({
                key: 'started',
                valueObj: {
                    itemId: id,
                    cleanItemId,
                    checkInView: PVideoLoader.shouldCheckIfInViewport,
                    preloadAttr: PVideoLoader.preloadAttribute,
                    viewportMargin: PVideoLoader.viewportCheckerMargin
                }
            });
        }

        loadVideo({
            playerContainer,
            poster,
            url,
            itemIndex,
            itemId,
            // old version support
            overlayData,
            trcRBox
        } = {}) {
            let returnedPromise = null;
            if (PVideoLoader.shouldLoadOldVersion) {
                returnedPromise = PVideoLoader.loadOldVersion({
                    playerContainer,
                    poster,
                    url,
                    itemIndex,
                    itemId,
                    overlayData,
                    trcRBox
                });
            }

            this.eslogger.push({
                key: 'loadVideo',
                valueObj: {
                    url,
                    itemIndex,
                    poster,
                    placement: overlayData && overlayData.video_data && overlayData.video_data.placement
                }
            });

            this.sendMetric({
                label: PVideoLoader.videoEventForAvailable,
                itemIndex,
                itemId
            });

            returnedPromise = returnedPromise || PVideoLoader.isInViewport(playerContainer)
                .then(() => new Promise$1((resolve, reject) => {
                    PVideoLoader.injectStyleOnce();

                    const videoNode = PVideoLoader.createVideoTag(url);
                    this.addMetricEventListeners({videoNode, itemId, itemIndex});

                    const wrapperNode = PVideoLoader.createWrapper(videoNode);

                    const posterLoaded = loadPoster(poster)
                        .then(() => {
                            wrapperNode.style['background-image'] = poster;
                        });

                    const posterChecked = posterLoaded.catch(() => {
                        this.sendMetric({
                            label: `poster-cannot-be-loaded`,
                            itemIndex,
                            itemId
                        });
                    });

                    const onError = event => {
                        if (videoNode.parentElement) {
                            videoNode.parentElement.removeChild(videoNode);
                        }
                        posterLoaded.then(() => {
                            wrapperNode.className = wrapperNode.className.replace(/is-playing/g, '').trim();
                            wrapperNode.style['background-image'] = poster;
                        });

                        reject(new Error('motion ads event error', {cause: event}));
                    };

                    const onShouldShowVideo = () => {
                        if (videoNode.style.visibility) {
                            posterChecked.then(() => {
                                videoNode.style.visibility = 'visible';
                                wrapperNode.className += ' is-playing ';
                                wrapperNode.style['background-image'] = '';
                            });
                        }

                        this.sendMetric({
                            label: PVideoLoader.videoEventForFirstFrame,
                            itemIndex,
                            itemId,
                            measureObj: this.itemPerformance.stop(PVideoLoader.videoEventForFirstFrame)
                        });
                        resolve();
                    };

                    videoNode.addEventListener(PVideoLoader.videoEventsForStatusChange.error, onError, {once: true});
                    videoNode.addEventListener(PVideoLoader.videoEventsForStatusChange.visible, onShouldShowVideo, {once: true});

                    playerContainer.className += ' motion-ads-wrapper ';
                    playerContainer.appendChild(wrapperNode);
                    videoNode.muted = true; // without this line there is no autoplay
                    videoNode.play();
                    if (PVideoLoader.videoRetryPlayTimeout) {
                        window.setTimeout(() => {
                            if (videoNode && !this.occuredEvents.playing) {
                                this.eslogger.push({
                                    key: 'retry-video-play',
                                    valueObj: {
                                        timeout: PVideoLoader.videoRetryPlayTimeout
                                    }
                                });
                                videoNode.play();
                            }
                        }, PVideoLoader.videoRetryPlayTimeout);
                    }
                }));

            returnedPromise.catch(() => {
                this.sendMetric({
                    label: `load-video-error`,
                    itemIndex,
                    itemId
                });
            });

            return returnedPromise;
        }

        addMetricEventListeners({
            videoNode,
            itemIndex,
            itemId
        }) {
            const metricEventCallback = event => {
                const {type} = event || {};
                const metricDataObj = {
                    label: type,
                    itemIndex,
                    itemId,
                    measureObj: event.measureObj
                };

                this.sendMetric(metricDataObj);
            };

            this.itemPerformance.start(PVideoLoader.videoEventForFirstFrame);
            PVideoLoader.videoEventNamesForMetrics.forEach(eventName => {
                this.itemPerformance.start(eventName);
                videoNode.addEventListener(eventName, evt => {
                    this.occuredEvents[eventName] = true;
                    const measureObj = this.itemPerformance.stop(eventName);
                    evt.measureObj = measureObj;
                    metricEventCallback(evt);
                }, {once: true});
            });
        }

        sendMetric(metricDataObj = {}) {
            this.eslogger.push({
                key: `event_${metricDataObj.label}`
            });
            if (!PVideoLoader.shouldSendMetrics) {
                return;
            }
            setTimeout(() => {
                PVideoLoader.logUsage(metricDataObj);
                PVideoLoader.sendRBoxMetricsEvent(metricDataObj);
            }, 0);
        }

        static logUsage(metricDataObj) {
            const obj = {
                checkInView: PVideoLoader.shouldCheckIfInViewport,
                preloadAttr: PVideoLoader.preloadAttribute,
                viewportMargin: PVideoLoader.viewportCheckerMargin
            };
            pVideoLoaderPerformance.logUsage({
                extraData: TRC.util.merge(obj, metricDataObj, {label: `motion-ads-${metricDataObj.label}`, oldVersion: PVideoLoader.shouldLoadOldVersion}),
                file: 'p-video-loader'
            });
        }

        static sendRBoxMetricsEvent(metricDataObj = {}) {
            if (metricDataObj.measureObj) {
                pVideoLoaderPerformance.sendRboxMetricsEvent({eventName: `duration-${metricDataObj.label}`, value: Math.round(metricDataObj.measureObj.duration), type: 'histogram'});
            }
            pVideoLoaderPerformance.sendRboxMetricsEvent({eventName: `event-${metricDataObj.label}`, value: '1', type: 'counter'});
        }

        static createWrapper(video) {
            const div = document.createElement('div');
            div.className = 'motion-ads-container';
            div.appendChild(video);
            return div;
        }

        static createVideoTag(url) {
            const video = document.createElement('video');
            video.setAttribute('preload', 'auto');
            video.style.visibility = 'hidden';
            PVideoLoader.videoAttributesToSetAsTrue.forEach(attribute => {
                video.setAttribute(attribute, '');
            });
            const preload = PVideoLoader.preloadAttribute;
            if (preload) {
                video.setAttribute('preload', preload);
            } else {
                video.setAttribute('autoplay', '');
            }

            video.setAttribute('src', url);
            return video;
        }

        static loadOldVersion({
            playerContainer,
            poster,
            url,
            itemIndex,
            itemId,
            // old version support
            overlayData,
            trcRBox
        } = {}) {
            const pVideoLoaderInstance = new PVideoLoader({id: itemId});
            return pVideoLoaderInstance.loadOldVersion({
                playerContainer,
                poster,
                url,
                itemIndex,
                itemId,
                // old version support
                overlayData,
                trcRBox
            });
        }

        loadOldVersion({
            playerContainer,
            poster,
            url,
            itemIndex,
            itemId,
            // old version support
            overlayData,
            trcRBox
        } = {}) {
            return new Promise$1(resolve => {
                const {trc} = trcRBox;
                const response = trcRBox.response || {};
                const responseTrc = response.trc;
                const pvc = responseTrc && responseTrc['video-list'] && responseTrc['video-list'].pvc;
                const oldVersion = new TRC.POldVideoLoader(trcRBox, pvc, responseTrc, trc, itemId, PVideoLoader.videoEventNamesForMetrics);
                oldVersion.loadVideo({
                    playerContainer,
                    url,
                    poster,
                    itemIndex,
                    itemId
                }, overlayData);

                this.sendMetric({
                    label: `old-version-execution`,
                    itemIndex,
                    itemId
                });
                resolve();
            });
        }

        static isInViewport(targetElement) {
            if (!PVideoLoader.shouldCheckIfInViewport
                || typeof TRC === 'undefined'
                || !TRC.intersections
                || !TRC.intersections.isInViewPort) {
                return Promise$1.resolve();
            }
            return new Promise$1(resolve => {
                const observerId = TRC.intersections.observe({
                    targetElement,
                    enableDelayedVisibilityCheck: true,
                    rootMargin: PVideoLoader.viewportCheckerMargin,
                    onEnter: () => {
                        resolve();
                        TRC.intersections.unobserve(observerId);
                    }
                });
            });
        }

        static injectStyleOnce() {
            if (styleInjected) { return; }
            TRC.dom.injectStyle(`.motion-ads-wrapper { overflow: hidden; } .motion-ads-wrapper .motion-ads-container { height: 100%; width: 100%; background-color: transparent; background-size: auto; text-align: center; overflow: hidden; display: block; } .motion-ads-wrapper .motion-ads-container.is-playing { background-color: black; } .motion-ads-wrapper .motion-ads-container video { width: 100%; height: 100%; object-fit: contain; object-position: 50% 50%; -o-object-fit: contain; -o-object-position: 50% 50%; }`, null);
            styleInjected = true;
        }

        static get videoAttributesToSetAsTrue() {
            return [
                'loop', 'muted', 'playsinline'
            ];
        }

        static get videoEventsForStatusChange() {
            return {
                visible: 'canplaythrough',
                error: 'error'
            };
        }

        static get videoEventForAvailable() {
            return 'available';
        }

        static get videoEventForFirstFrame() {
            return 'first-frame';
        }

        static get videoEventNamesForMetrics() {
            return [
                'error',
                'canplaythrough',
                'ended',
                'loadeddata',
                'loadedmetadata',
                'pause',
                'play',
                'playing'
            ];
        }

        // testing cloudinary
        static get cloudinaryUrlPrefix() {
            const prefix = `${getGlobalValue('motion-ads-cloudinary-prefix')}`.trim()
                .split(',')
                .filter(string => /(^q_auto:)|(^fps_)/.test(string))
                .join(',');
            if (!prefix) {
                return '';
            }
            return `https://videos.taboola.com/taboola/video/fetch/${prefix}/`;
        }

        static get videoRetryPlayTimeout() {
            return (+getGlobalValue('motion-ads-retry-play-timeout')) || 0; // for ensuring a number value if there is a bug/error or a faulty setting
        }

        static get preloadAttribute() {
            const attribute = `${getGlobalValue('motion-ads-preload-attribute')}`.trim();
            if (!/^(auto|metadata|none)$/.test(attribute)) {
                return '';
            }
            return attribute;
        }

        static get viewportCheckerMargin() {
            const percentage = Number(getGlobalValue('motion-ads-viewport-lazy-load-margin')) || 0;
            return `${(100 * percentage).toFixed(2)}%`;
        }

        static get shouldCheckIfInViewport() {
            return checkGlobalFlag('motion-ads-viewport-lazy-load');
        }

        static get shouldSendMetrics() {
            return checkGlobalFlag('motion-ads-track-events');
        }

        static get shouldLoadOldVersion() {
            return checkGlobalFlag('motion-ads-load-old-version') && !!TRC.POldVideoLoader;
        }
    }
    function getGlobalValue(key) {
        return (
            typeof TRCImpl !== 'undefined'
            && TRCImpl
            && TRCImpl.global
            && TRCImpl.global[key]
        );
    }

    function checkGlobalFlag(flag) {
        return !!(
            typeof TRCImpl !== 'undefined'
            && TRCImpl
            && TRCImpl.global
            && typeof TRC !== 'undefined'
            && TRC
            && TRC.util
            && TRC.util.isPercentEnabled(TRCImpl.global, flag)
        );
    }

    function loadPoster(url) {
        return new Promise$1((resolve, reject) => {
            const poster = new Image();
            poster.onload = () => resolve();
            poster.onerror = error => reject(error);
            poster.src = url;
        });
    }

    const filename$1 = 'trcrbox-ui-branding-utils';

    const createScBranding = ({
        trcRBoxUI,
        video,
        labelsBox
    }) => {
        loadedStyle();
        switch (true) {
            case (video['is-app-install'] === 'true'):
                return generateAppInstallBranding({
                    trcRBoxUI,
                    video,
                    labelsBox
                });
            case !!video['branding-text']:
                return trcRBoxUI.add_span('branding', trcRBoxUI.formatData('syndicator', video['branding-text']), labelsBox);
            case !!video['branding-url']:
                return trcRBoxUI.add_span('branding', `<img src='${video['branding-url']}'>`, labelsBox);
            default:
        }
    };

    var brandingUtils_es6 = {
        createScBranding
    };


    const appInstallMetricReporter = metricReporter$1.sub('app_install');
    const brandingHook = 'app-install-branding-title';
    const generateAppInstallBranding = ({
        trcRBoxUI,
        video,
        labelsBox
    }) => {
        const reporter = buildAppInstallReporter({trcRBoxUI, video});
        reportAppInstallPreRender({reporter, video});
        if (!video['branding-url'] || !video['branding-text']) {
            return;
        }
        const starRating = TblStarRating.isAvailable && video['stars-rating']
            ? `<tbl-star-rating rating="${video['stars-rating']}" post-rating-number></tbl-star-rating>`
            : '';
        const brandingSpan = `
    <span class="app-install-branding-wrapper">
        <img class="app-install-logo" src="${video['branding-url']}">
        <span class="app-install-branding-text">
            <div class="${brandingHook}">
            <span class="app-install-branding-text-inner">${trcRBoxUI.formatData('syndicator', video['branding-text'])}</span>
            </div>
            ${starRating}
        </span>
    <span>
    `;

        const element = trcRBoxUI.add_span('branding', brandingSpan, labelsBox);
        const disclosureTextSponsored = trcRBoxUI.add_span(null,
            trcRBoxUI.trc.getProperty(
                trcRBoxUI.mode_name,
                'disclosure-link-text-sponsored',
                trcRBoxUI.propertiesOverride
            ));

        const brandingHookElement = element.querySelector && element.querySelector(`.${brandingHook}`);

        if (brandingHookElement && disclosureTextSponsored) {
            brandingHookElement.appendChild && brandingHookElement.appendChild(generateSpanSeparator());
            trcRBoxUI.generateLinksBox(
                brandingHookElement, disclosureTextSponsored, '', 'disclosure', 'sponsored', 'bottom'
            );
        }
        reporter({eventName: appInstallReportEventMap.hasRendered, finished: true});
        return element;
    };


    const generateSpanSeparator = () => {
        const span = document.createElement('span');
        span.innerHTML = '&nbsp;|&nbsp;';
        return span;
    };

    let styleHasLoaded = false;
    const loadedStyle = () => {
        if (!styleHasLoaded) {
            try {
                TRC.dom.injectStyle(`.app-install-branding-wrapper { display: inline-block; display: inline-flex; flex-direction: row; align-items: stretch; gap: 5px; width: 100%; min-height: 100%; } .app-install-branding-wrapper .app-install-branding-text { margin: 0; display: flex; flex-direction: column; width: calc(100% - (36px + 5px)); } .app-install-branding-wrapper .app-install-branding-text .video-branding-flex-cta-rating { padding: 0; margin: 0; line-height: 1; display: flex; align-items: flex-end; direction: inherit; } .app-install-branding-wrapper .app-install-branding-title { line-height: 1; display: inline; }.videoCube:not(:last-of-type) tbl-app-install-grid[version="2"].tbl-app-install-grid-multi-slot { padding-bottom: 13px; border-bottom-width: 1px; border-bottom-style: solid; display: block; }tbl-app-install-grid .app-install-branding-wrapper .app-install-branding-title { display: flex; align-items: center; flex-wrap: wrap; }tbl-app-install-grid .branding.branding.branding { line-height: 1; float: none; direction: inherit; min-height: 36px; display: flex; } tbl-app-install-grid .branding.branding.branding .app-install-branding-wrapper { min-height: 36px; } tbl-app-install-grid .branding.branding.branding .app-install-branding-text-inner { max-width: calc(100% - 11px); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: inline-block; } tbl-app-install-grid .branding.branding.branding:before, tbl-app-install-grid .branding.branding.branding:after { display: none; }`, null);
            // eslint-disable-next-line no-empty
            } catch (error) {}
            styleHasLoaded = true;
        }
    };

    const appInstallReportEventMap = {
        hasAppInstall: `event-has_app_install`,
        hasRendered: 'event-label_box_rendered',
        noBrandingText: `error-no_branding_text`,
        noLogo: `error-no_logo`,
        noStarRating: `event-no_star_rating`,
        noCTA: `error-no_cta`
    };

    const reportAppInstallPreRender = ({reporter, video}) => {
        reporter({eventName: appInstallReportEventMap.hasAppInstall});
        if (!video['branding-text']) {
            reporter({eventName: appInstallReportEventMap.noBrandingText});
        }
        if (!video['branding-url']) {
            reporter({eventName: appInstallReportEventMap.noLogo});
        }
        if (!video['stars-rating']) {
            reporter({eventName: appInstallReportEventMap.noStarRating});
        }
        if (!video['cta-text']) {
            reporter({eventName: appInstallReportEventMap.noCTA});
        }
    };

    const buildAppInstallReporter = ({trcRBoxUI, video}) => {
        const flag = 'app-install-report';
        if (!TRC.util.isPercentEnabled(trcRBoxUI.trc.global, flag)) {
            return () => {};
        }
        const itemId = (video.id || video['item-id'] || '').slice(0, 40);
        const extraData = {itemId};
        if (!video['branding-text']) {
            extraData['no branding'] = true;
        }
        if (!video['branding-url']) {
            extraData['no logo'] = true;
        }
        if (!video['stars-rating']) {
            extraData['no rating'] = true;
        }
        if (!video['cta-text']) {
            extraData['no cta'] = true;
        }
        return ({eventName, finished}) => {
            if (finished) {
                video['is-app-install-branding-rendered'] = true;
            }
            setTimeout(() => {
                appInstallMetricReporter.logUsage({
                    file: filename$1,
                    extraData: TRC.util.merge({}, extraData, {eventName})
                });
                appInstallMetricReporter.sendRboxMetricsEvent({eventName, value: '1', type: 'counter'});
            }, 0);
        };
    };

    class DisplayInSlotManager {
        constructor(trcResponse) {
            this.displayInSlotItemsArr = [];
            this.nativeItemsArr = [];

            this.buildItemsArrays(trcResponse.v);
        }

        buildItemsArrays(placementItemsArray) {
            placementItemsArray.forEach(item => {
                if (DisplayInSlotManager.isItemDisplayInSlot(item)) {
                    this.displayInSlotItemsArr.push(item);
                    if (this.displayInSlotItemsArr.length > 1) {
                        // Should be removed when we will allow few Displays in same placement
                        __trcWarn('DisplayInSlotManager error:  Should be only 1 displayInSlot per placement');
                    }
                } else {
                    this.nativeItemsArr.push(item);
                }
            });
        }

        isExistDisplayInSlot() {
            return Boolean(this.getDisplayInSlotItemData());
        }

        getDisplayInSlotItemData() {
            return this.displayInSlotItemsArr[0];
        }

        getDisplayInSlotItemsIds() {
            return DisplayInSlotManager.getItemsIds(this.displayInSlotItemsArr);
        }

        getNativeItemsArr() {
            return this.nativeItemsArr;
        }

        getNativeItemsIds() {
            return DisplayInSlotManager.getItemsIds(this.nativeItemsArr);
        }

        sendAvailableEvent(trcbox, utmParams, postData) {
            try {
                const itemData = this.getDisplayInSlotItemData();
                const currentParams = TRC.util.merge({ii: itemData['item-id'], it: itemData.type}, utmParams);
                const currentPostData = postData.getSpecificItemsPostData(this.getDisplayInSlotItemsIds());
                trcbox.sendAvailableEvent(currentParams, currentPostData, false, true);
            } catch (e) {
                __trcWarn('DisplayInSlotManager sendAvailableEvent error ', e);
            }
        }

        static getItemsIds(itemsArray) {
            return itemsArray.map(item => item['item-id']);
        }

        static isItemDisplayInSlot(item) {
            return Boolean(item && item.ifrObj);
        }

        static isResponseHasDisplayInSlotItem(response) {
            if (response && response.v && response.v.length > 0) {
                for (let i = 0; i < response.v.length; i++) {
                    const item = response.v[i];
                    if (this.isItemDisplayInSlot(item)) {
                        return true;
                    }
                }
            }
            return false;
        }

        static createVideoBoxAspectWithBackgroundImage(container, videoBoxContainer, thumbnail) {
            const aspectWithBackgroundImage = document.createElement('div');
            aspectWithBackgroundImage.className = 'videoCube_aspect tbl-banner-to-native-image-desktop';
            aspectWithBackgroundImage.style['background-image'] = `url("${thumbnail}")`;
            // instead of using prepend;
            const firstChild = container.firstElementChild;
            container.insertBefore(aspectWithBackgroundImage, firstChild);

            TRC.dom.addClass(videoBoxContainer, 'display-to-native-item-box');
            videoBoxContainer.thumbnail_aspect = aspectWithBackgroundImage;
        }
    }

    const safeTags = [
        'a', 'abbr', 'address', 'article', 'aside', 'area', 'b', 'bdi', 'bdo', 'blockquote', 'body', 'br',
        'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'dd', 'del', 'details', 'dfn',
        'div', 'dl', 'dt', 'em', 'figcaption', 'figure', 'footer', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'head', 'header', 'hr', 'html', 'i', 'img', 'ins', 'kbd', 'label', 'legend', 'li', 'link', 'main',
        'map', 'mark', 'nav', 'ol', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp',
        'section', 'small', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td',
        'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'u', 'ul', 'var', 'wbr',

        // svg
        'animate', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'defs', 'desc',
        'discard', 'ellipse', 'feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite',
        'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow',
        'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge',
        'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight',
        'feTile', 'feTurbulence', 'filter', 'foreignObject', 'g', 'image', 'line', 'linearGradient',
        'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient',
        'rect', 'set', 'stop', 'style', 'svg', 'switch', 'symbol', 'text', 'textPath', 'title',
        'tspan', 'use', 'view'
    ];

    const sanitize = innerHTML => {
        const template = document.createElement('template');
        template.innerHTML = innerHTML;
        const root = template.content || template; // for IE support
        let hasSanitized = false;

        Array.prototype.slice.call(
            /* :not with multiple values is not supported on IE and some browsers */
            root.querySelectorAll(`${safeTags.map(i => `:not(${i})`).join('')},*[is]`)
        ).reverse().forEach(node => {
            const parent = node.parentElement || root;
            if (node.tagName !== 'SCRIPT') {
                Array.prototype.slice.call(node.childNodes).forEach(child => {
                    parent.insertBefore(child, node);
                });
            }
            parent.removeChild(node);
            hasSanitized = true;
        });

        /* :is with and without multiple values is not supported on IE and some browsers */
        const linksOnlyAttributes = ['href', 'xlink:href'];
        const valid = /^(#|https?:\/\/)/i;
        // xlink:href doesn't work on different browser without :is as a query selector
        const cleanLinks = element => {
            const hasAttribute = linksOnlyAttributes.reduce((sum, attribute) => element.hasAttribute(attribute) || sum, false);
            if (!/^(a|area)$/i.test(element.tagName) && !hasAttribute) {
                return;
            }

            linksOnlyAttributes.forEach(attributeName => {
                const attributeValue = element.getAttribute(attributeName);
                if (attributeValue && !valid.test(attributeValue)) {
                    element.removeAttribute(attributeName);
                    hasSanitized = true;
                }
            });
            element.setAttribute('target', '_blank');
            element.setAttribute('rel', 'noopener noreferrer');
        };

        const removeBadAttributes = element => {
            let attributes = getAttributeNames(element);
            attributes = attributes.filter(i => /^(on\w+|formaction|to)$/i.test(i));
            attributes.forEach(attribute => {
                element.removeAttribute(attribute);
                hasSanitized = true;
            });
        };

        const treeWalker = document.createTreeWalker(
            root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_TEXT
        );
        let {currentNode} = treeWalker; // start with root
        while (currentNode = treeWalker.nextNode()) {
            if (!currentNode.hasAttribute
                || !currentNode.getAttribute
                || !currentNode.removeAttribute) {
                continue;
            }
            cleanLinks(currentNode);
            removeBadAttributes(currentNode);
        }

        return {
            hasSanitized,
            html: template.innerHTML
        };
    };

    var disclamer_utils_es6 = {
        sanitize
    };


    const getAttributeNames = element => {
        if (element.getAttributeNames) {
            return element.getAttributeNames();
        }
        const {attributes} = element;
        if (!attributes) { return []; }
        const {length} = attributes;
        if (!length) { return []; }
        const result = [];
        for (let i = 0; i < length; i++) {
            result[i] = attributes[i].name;
        }
        return result;
    };

    class TblDisclaimer extends GenericWebComponent {
        constructor() {
            super();
            this._reporterObj = {
                reporterId: 'tbl_disclaimer',
                isReportingEnabledFlag: 'tbl_disclaimer-metric-report'
            };
            this.createReporter();
            this.attachShadow();
            this.animationTimeStamp = 0;
            this._isScrollEnd = false;
            this.observerId = '';
            this.itemId = '';
            this.autoScrollObj = {
                fps: 24,
                pps: 24,
                delay: 2000,
                allowAutoScroll: true,
                animationStarted: false
            };
            this.requestAnimationFrameId = 0;
        }

        static get reportTypes() {
            return {
                event: 'event',
                error: 'error',
                filter: 'filter'
            };
        }

        static get reportNameToReportObjMap() {
            return {
                available: {eventType: TblDisclaimer.reportTypes.event, eventName: 'available'},
                visible: {eventType: TblDisclaimer.reportTypes.event, eventName: 'visible'},
                innerLinkClicked: {eventType: TblDisclaimer.reportTypes.event, eventName: 'innerLinkClicked'},
                userScrolled: {eventType: TblDisclaimer.reportTypes.event, eventName: 'user_scrolled'},
                disclaimerNoHeight: {eventType: TblDisclaimer.reportTypes.error, eventName: 'disclaimer_no_height'},
                disclaimerNoOverflowAuto: {eventType: TblDisclaimer.reportTypes.error, eventName: 'disclaimer_no_overflow_auto'},
                disclaimerNoScrollbar: {eventType: TblDisclaimer.reportTypes.error, eventName: 'disclaimer_no_scrollbar'},
                autoScrollDidntStart: {eventType: TblDisclaimer.reportTypes.error, eventName: 'auto_scroll_didnt_start'},
                closestNotSupported: {eventType: TblDisclaimer.reportTypes.error, eventName: 'closest_not_supported'},
                forcingLinkAttribute: {eventType: TblDisclaimer.reportTypes.error, eventName: 'forcing_link_attribute'},
                appendStyles: {eventType: TblDisclaimer.reportTypes.error, eventName: 'append_styles'},
                failedToFetchMarkup: {eventType: TblDisclaimer.reportTypes.error, eventName: 'failed_fetching_markup'},
                hasSanitized: {eventType: TblDisclaimer.reportTypes.event, eventName: 'bad_markup_has_been_sanitized'}
            };
        }

        get isScrollEnd() {
            return this._isScrollEnd;
        }

        set isScrollEnd(value) {
            this._isScrollEnd = value;
            if (value === true) {
                this.cancelRequestAnimationFrame();
                this.removeInteractionEvents();
            }
        }

        set markup(markup) {
            // flow starts here
            try {
                let promise;
                if (markup.match('^https?:\\/\\/')) {
                    promise = this.fetchMarkup(markup);
                } else {
                    promise = Promise$1.resolve(markup);
                }

                promise.then(markupText => {
                    this.markupText = markupText;
                    const disclaimerContainer = this.createElementStructure();
                    this.createEvents(disclaimerContainer);
                    this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.available);
                }).catch(error => {
                    if (!error) {
                        return;
                    }
                    this.reportMetrics({eventType: TblDisclaimer.reportTypes.error, eventName: `set_markup_promise_${error}`});
                });
            } catch (error) {
                this.reportMetrics({eventType: TblDisclaimer.reportTypes.error, eventName: `set_markup_${error}`});
            }
        }

        get isMetricReportingEnabled() {
            return TRC.util.isPercentEnabled(TRCImpl.global, this._reporterObj.isReportingEnabledFlag);
        }

        set reporterObj({reporterId = this._reporterObj.reporterId, isReportingEnabledFlag = this._reporterObj.isReportingEnabledFlag}) {
            this._reporterObj = {
                reporterId,
                isReportingEnabledFlag
            };

            if (this.metricReporter) {
                this.metricReporter.id = reporterId;
            }
        }

        fetchMarkup(markupUrl) {
            return new Promise$1((resolve, reject) => {
                const http = new window.XMLHttpRequest();
                http.open('GET', markupUrl, true);
                http.onload = () => {
                    this.reportMetrics({eventType: TblDisclaimer.reportTypes.event, eventName: (`markup_fetch_status_${http.status}`)});
                    if (http.status !== 200) {
                        reject();
                        return;
                    }

                    resolve(http.responseText);
                };

                http.onerror = () => {
                    this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.failedToFetchMarkup);
                    reject();
                };

                http.send();
            });
        }

        createElementStructure() {
            this.shadowRoot.innerHTML = '';
            const style = this.generateStyles();
            this.shadowRoot.appendChild(style);
            const disclaimerContainer = document.createElement('div');
            disclaimerContainer.classList.add('disclaimer-container');
            this.innerContainer = document.createElement('div');
            this.innerContainer.classList.add('inner-container');
            const sanitized = sanitize(this.markupText);
            this.innerContainer.innerHTML = sanitized.html;
            disclaimerContainer.appendChild(this.innerContainer);
            this.shadowRoot.appendChild(disclaimerContainer);
            if (sanitize.hasSanitized) {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.hasSanitized);
            }
            return disclaimerContainer;
        }

        testAndReportDisclaimer() {
            if (!this.isMetricReportingEnabled) {
                return;
            }

            const computedStyle = window.getComputedStyle(this);
            if (parseInt(computedStyle.height, 10) <= 1) {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.disclaimerNoHeight);
            }

            if (computedStyle.overflow !== 'auto') {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.disclaimerNoOverflowAuto);
            } else if (this.scrollHeight <= this.clientHeight) {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.disclaimerNoScrollbar);
            }

            window.setTimeout(() => {
                if (this.scrollTop === 0 && this.autoScrollObj.allowAutoScroll && !this.isScrollEnd) {
                    this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.autoScrollDidntStart);
                }
            }, this.autoScrollObj.delay + 2000);
        }

        allowOnlyInternalLinks(container) {
            container.onclick = evt => {
                evt.stopPropagation();
                if (!TRC.dom.closest(evt.target, 'a')) {
                    return false;
                }
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.innerLinkClicked);
            };
        }

        createEvents(disclaimerContainer) {
            this.allowOnlyInternalLinks(disclaimerContainer);
            this.pauseAutoScrollOnUserInteractionEvents();
            this.initiateAutoScrollWhenAdOnViewport();
        }

        forceLinkAttributes(container) {
            try {
                const aTagNodeList = container.querySelectorAll('a');
                Array.prototype.forEach.call(aTagNodeList, link => {
                    if (!link.href || (link.href === '#')) {
                        return;
                    }

                    link.setAttribute('target', '_blank');
                    link.setAttribute('rel', 'noopener noreferrer');
                });
            } catch (error) {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.forcingLinkAttribute);
            }
        }

        initiateAutoScrollWhenAdOnViewport() {
            this.observerId = TRC.intersections.isInViewPort({
                targetElement: this,
                enableDelayedVisibilityCheck: true,
                onEnter: (() => {
                    if (this.autoScrollObj.animationStarted) {
                        return;
                    }

                    this.reportMetrics({eventType: 'event', eventName: `visible`});
                    this.unsubscribeFromObserver();
                    this.autoScrollObj.animationStarted = true;
                    this.waitWithInitialAnimation = true;
                    this.autoScroll();
                    this.testAndReportDisclaimer();
                })
            });
        }

        unsubscribeFromObserver() {
            try {
                if (this.observerId) {
                    TRC.intersections.unobserve(this.observerId);
                    this.observerId = '';
                }
            } catch (error) {
                this.reportMetrics({eventType: TblDisclaimer.reportTypes.error, eventName: `unobserve_${error}`});
            }
        }

        autoScroll() {
            try {
                if (!this.startingAnimationTime) {
                    this.startingAnimationTime = performance.now();
                }

                if (!this.autoScrollObj.allowAutoScroll || this.isScrollEnd) {
                    return;
                }

                const totalTimeElapsed = performance.now() - this.startingAnimationTime;

                if (!this.waitWithInitialAnimation) {
                    this.isScrollEnd = ((this.offsetHeight + this.scrollTop) >= (this.innerContainer.offsetHeight + this.innerContainer.offsetTop - 1));
                    if (this.isScrollEnd) {
                        return;
                    }

                    this.lastTickTimestamp = performance.now();
                    const scrollTopNewPosition = totalTimeElapsed / 1000 * this.autoScrollObj.fps;
                    this.scrollTo({
                        top: Math.round(scrollTopNewPosition),
                        behavior: 'smooth'
                    });
                }

                window.setTimeout(() => {
                    if (this.waitWithInitialAnimation && (totalTimeElapsed > this.autoScrollObj.delay)) {
                        // waitWithInitialAnimation will delay the initial autoScroll animation by given this.autoScrollObj.delay
                        this.waitWithInitialAnimation = false;
                        this.startingAnimationTime = performance.now();
                    }
                    window.cancelAnimationFrame(this.requestAnimationFrameId);
                    this.requestAnimationFrameId = window.requestAnimationFrame(() => this.autoScroll());
                }, 1000 / this.autoScrollObj.fps);
            } catch (error) {
                this.reportMetrics({eventType: TblDisclaimer.reportTypes.error, eventName: `autoscroll_${error}`});
            }
        }

        cancelRequestAnimationFrame() {
            if (!this.requestAnimationFrameId) {
                return;
            }

            window.cancelAnimationFrame(this.requestAnimationFrameId);
            this.requestAnimationFrameId = 0;
        }

        adjustStartingAnimationTimeAfterPause() {
            this.startingAnimationTime += performance.now() - this.lastTickTimestamp;
        }

        pauseAutoScrollOnUserInteractionEvents() {
            const listenerOptionsObj = {};
            if (window.AbortController) {
                this.abortSignal = new window.AbortController();
                listenerOptionsObj.signal = this.abortSignal.signal;
            }

            let onEnterScrollTop = 0;
            const onEnter = () => {
                onEnterScrollTop = this.scrollTop;
                this.autoScrollObj.allowAutoScroll = false;
                this.cancelRequestAnimationFrame();
            };

            const onLeave = () => {
                if (this.isScrollEnd) {
                    return;
                }

                if (this.endAutoScrollOnUserInteraction(onEnterScrollTop, this.scrollTop)) {
                    return;
                }

                this.autoScrollObj.allowAutoScroll = true;
                this.adjustStartingAnimationTimeAfterPause();
                this.autoScroll();
            };

            const onVisibilitychange = () => {
                document.visibilityState === 'visible' ? onLeave() : onEnter();
            };

            const onMouseWheel = TRC.util.debounce(() => {
                if (this.isScrollEnd) {
                    return;
                }

                this.endAutoScrollOnUserInteraction(onEnterScrollTop, this.scrollTop);
            }, 200, true, this);

            this.addEventListener('mousewheel', onMouseWheel, listenerOptionsObj);
            this.addEventListener('mouseenter', onEnter, listenerOptionsObj);
            this.addEventListener('touchstart', onEnter, listenerOptionsObj);
            this.addEventListener('mouseleave', onLeave, listenerOptionsObj);
            this.addEventListener('touchend', onLeave, listenerOptionsObj);
            document.addEventListener('visibilitychange', onVisibilitychange, listenerOptionsObj);
        }

        endAutoScrollOnUserInteraction(startInteractionScrollTop, endInteractionScrollTop) {
            const scrollDifferenceInPixels = 5;
            if (Math.abs(startInteractionScrollTop - endInteractionScrollTop) >= scrollDifferenceInPixels) {
                this.isScrollEnd = true;
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.userScrolled);
                return true;
            }

            return false;
        }

        removeInteractionEvents() {
            if (this.abortSignal) {
                this.abortSignal.abort();
                this.abortSignal = null;
            }
        }

        createReporter() {
            if (this.metricReporter) {
                return;
            }

            if (!TblDisclaimer.metricReporter) {
                TblDisclaimer.metricReporter = metricReporter$1.sub(this._reporterObj.reporterId);
            }

            this.metricReporter = TblDisclaimer.metricReporter;
        }

        generateStyles() {
            try {
                const style = document.createElement('style');
                style.innerHTML = ':host { scroll-behavior: smooth; position: relative; width: 100%; height: 100%; overflow: auto; cursor: default; background: #fff; /* firefox */ scrollbar-color: #888 #f1f1f1; scrollbar-width: thin; /* webkit */ } :host::-webkit-scrollbar { width: 5px; } :host::-webkit-scrollbar-track { background: #f1f1f1; } :host::-webkit-scrollbar-thumb { background: #888; } :host::-webkit-scrollbar-thumb:hover { background: #555; }.disclaimer-container { position: absolute; left: 0; right: 0; top: 0; bottom: 0; font-size: 15px; line-height: 1.5; line-height: clamp(20px, 1.5em, 30px); color: #000; -webkit-text-fill-color: #000; font-weight: 400; } .disclaimer-container img { max-width: 100%; object-fit: contain; }.warning-container { border: 1px solid #000; margin: 1em; padding: 0 10%; text-align: center; font-weight: bold; }';
                return style;
            } catch (error) {
                this.reportMetrics(TblDisclaimer.reportNameToReportObjMap.appendStyles);
            }
        }

        disconnectedCallback() {
            this.removeInteractionEvents();
        }

        reportMetrics({eventType = 'event', eventName = '', itemId = this.itemId} = {}) {
            if (!this.isMetricReportingEnabled) {
                return;
            }

            const metricDataObj = {
                eventName: `${eventType}-${eventName}`,
                itemId
            };

            window.setTimeout(() => {
                this.metricReporter.logUsage({
                    extraData: metricDataObj,
                    file: 'tbl_disclaimer'
                });
                this.metricReporter.sendRboxMetricsEvent({eventName: metricDataObj.eventName, value: '1', type: 'counter'});
            }, 0);
        }
    }

    GenericWebComponent.registerElement({name: 'tbl-disclaimer', component: TblDisclaimer});

    class ISIManager {
        constructor({videoBoxContainer} = {}) {
            this.reporterObj = {
                reporterId: 'isi_manager',
                isReportingEnabledFlag: 'isi-metric-report'
            };
            this.createReporter();
            this.injectStyle();
            this.videoBoxContainer = videoBoxContainer;
            this.data = videoBoxContainer ? videoBoxContainer.video_data : {};
            this.thumbnailLinkDomElement = (this.videoBoxContainer && this.videoBoxContainer.thumbBlock) ? TRC.dom.closest(this.videoBoxContainer.thumbBlock, '.item-thumbnail-href') : null;
            this.template = document.createElement('template');
        }

        static get reportTypes() {
            return {
                event: 'event',
                error: 'error',
                filter: 'filter'
            };
        }

        static get reportNameToReportObjMap() {
            return {
                hasIsi: {eventType: ISIManager.reportTypes.event, eventName: 'has_isi'},
                webComponentNotSupported: {eventType: ISIManager.reportTypes.filter, eventName: 'web_component_not_supported'},
                noVideoBoxContainer: {eventType: ISIManager.reportTypes.filter, eventName: 'no_video_box_container'},
                noThumbnailLinkElement: {eventType: ISIManager.reportTypes.filter, eventName: 'no_thumbnail_link_element'},
                noDisclaimerMarkup: {eventType: ISIManager.reportTypes.filter, eventName: 'no_disclaimer_markup'},
                styleInjectError: {eventType: ISIManager.reportTypes.error, eventName: 'style_inject_error'},
                noLogo: {eventType: ISIManager.reportTypes.error, eventName: 'no_logo'}
            };
        }

        get isMetricReportingEnabled() {
            return TRC.util.isPercentEnabled(TRCImpl.global, this.reporterObj.isReportingEnabledFlag);
        }

        static initialize({videoBoxContainer} = {}) {
            const isiManager = new ISIManager({videoBoxContainer});
            try {
                if (!isiManager.isISISupported()) {
                    return;
                }

                isiManager.itemId = (isiManager.data.id || isiManager.data['item-id'] || '').slice(0, 40);
                isiManager.addISIClassesToVideoBoxContainer();
                isiManager.createAndAppendDisclaimerComponent();
                isiManager.reportIfLogoDoesNotExist();
            } catch (error) {
                isiManager.reportMetrics({eventType: ISIManager.reportTypes.error, eventName: `initialize_${error}`});
            }
        }

        isISISupported() {
            if (this.data['is-isi-card'] !== 'true') {
                return false;
            }
            this.reportMetrics(ISIManager.reportNameToReportObjMap.hasIsi);

            if (!GenericWebComponent.isAvailable) {
                this.reportMetrics(ISIManager.reportNameToReportObjMap.webComponentNotSupported);
                return false;
            }

            if (!this.videoBoxContainer) {
                this.reportMetrics(ISIManager.reportNameToReportObjMap.noVideoBoxContainer);
                return false;
            }

            if (!this.thumbnailLinkDomElement) {
                this.reportMetrics(ISIManager.reportNameToReportObjMap.noThumbnailLinkElement);
                return false;
            }

            if (!this.data.disclaimer) {
                this.reportMetrics(ISIManager.reportNameToReportObjMap.noDisclaimerMarkup);
                return false;
            }

            return true;
        }

        addISIClassesToVideoBoxContainer() {
            this.videoBoxContainer.classList.add('tbl-isi-card');
            this.thumbnailLinkDomElement.classList.add('tbl-isi-container');
        }

        createAndAppendDisclaimerComponent() {
            try {
                const disclaimer = document.createElement('tbl-disclaimer');
                disclaimer.itemId = this.itemId;
                disclaimer.reporterObj = {reporterId: 'isi_disclaimer', isReportingEnabledFlag: this.reporterObj.isReportingEnabledFlag};
                disclaimer.markup = TRC.text.htmlUnescape(this.data.disclaimer);
                this.thumbnailLinkDomElement.appendChild(disclaimer);
            } catch (error) {
                this.reportMetrics({eventType: ISIManager.reportTypes.error, eventName: `create_append_disclaimer_${error}`});
            }
        }

        injectStyle() {
            try {
                if (ISIManager.styleInjected) {
                    return;
                }

                TRC.dom.injectStyle(`.tbl-isi-card .tbl-isi-container { position: relative; display: grid; grid-template-rows: 0.5fr 0.5fr; }.tbl-isi-card .thumbBlock_holder { min-height: 100%; height: 100%; } .tbl-isi-card .thumbBlock_holder .thumbBlock .thumbnail-emblem { width: 20%; height: 50%; background-size: contain; margin: 2%; background-position: 0 0; }`, null);
                ISIManager.styleInjected = true;
            } catch (error) {
                this.reportMetrics(ISIManager.reportNameToReportObjMap.styleInjectError);
            }
        }

        createReporter() {
            if (!ISIManager.metricReporter) {
                ISIManager.metricReporter = metricReporter$1.sub(this.reporterObj.reporterId);
            }

            this.metricReporter = ISIManager.metricReporter;
        }

        reportMetrics({eventType = 'event', eventName = '', itemId = this.itemId || ''} = {}) {
            if (!this.isMetricReportingEnabled) {
                return;
            }

            const metricDataObj = {
                eventName: `${eventType}-${eventName}`,
                itemId
            };

            window.setTimeout(() => {
                this.metricReporter.logUsage({
                    extraData: metricDataObj,
                    file: 'isi_manager'
                });
                this.metricReporter.sendRboxMetricsEvent({eventName: metricDataObj.eventName, value: '1', type: 'counter'});
            }, 0);
        }

        reportIfLogoDoesNotExist() {
            window.setTimeout(() => {
                if (!this.thumbnailLinkDomElement.querySelector('.thumbnail-emblem')) {
                    this.reportMetrics(ISIManager.reportNameToReportObjMap.noLogo);
                }
            }, 0);
        }
    }

    class NewCta {
        constructor({styleSettings, data} = {}) {
            this.styleSettings = styleSettings;
            this.data = data;
            this.button = this.createButton();
            this.setCtaButtonStyle(this.styleSettings);
            this.ctaButtonContainer = NewCta.createCtaButtonContainer();
            this.ctaButtonContainer.appendChild(this.button);
        }

        createButton() {
            const btn = TRC.dom.createHTMLElement('button');
            btn.type = 'button';
            btn.classList.add('video-cta-button', 'video-cta-style');
            const ctaButtonTextAmountOfChars = 40;
            btn.innerText = this.data.label.slice(0, ctaButtonTextAmountOfChars);

            return btn;
        }

        static createCtaButtonContainer() {
            const ctaButtonContainer = TRC.dom.createHTMLElement('div');
            // adding class which originated in "a" element for backward compatibility
            ctaButtonContainer.classList.add('video-cta-href');

            return ctaButtonContainer;
        }

        setCtaButtonStyle(styleSettings) {
            Object.keys(styleSettings).forEach(attribute => {
                if (styleSettings[attribute]) {
                    this.button.style[attribute] = styleSettings[attribute];
                }
            });
        }

        getDomElement() {
            return this.ctaButtonContainer;
        }
    }

    class GenericGridComponent extends GenericWebComponent {
        constructor() {
            super();
            this.attachShadow({mode: 'open'});
            this.shadowRoot.appendChild(this.constructor.generateInnerStyle());
            this.hook = this.constructor.generateInnerDomStructure();
            this.shadowRoot.appendChild(this.hook);
        }

        static get gridRolesArray() {
            return ['branding', 'title', 'description', 'thumbnail', 'cta'];
        }

        static generateInnerDomStructure() {
            const main = document.createElement('div');
            main.classList.add('grid-container');
            GenericGridComponent.gridRolesArray.forEach(role => {
                const div = document.createElement('div');
                div.setAttribute('grid-role', role);
                const slot = document.createElement('slot');
                slot.setAttribute('name', role);
                div.appendChild(slot);
                main.appendChild(div);
            });
            return main;
        }

        static generateInnerStyle() {
            const style = document.createElement('style');
            style.innerHTML = `a, a:link { text-decoration: none; outline: none; }.grid-container { display: grid; gap: 5px; grid-template: "branding cta" "thumbnail thumbnail" "title title" "description description"; grid-template-columns: minmax(0, 1fr); }div[grid-role=cta] { grid-area: cta; display: flex; }div[grid-role=branding] { grid-area: branding; }div[grid-role=title] { grid-area: title; }div[grid-role=description] { grid-area: description; }div[grid-role=thumbnail] { grid-area: thumbnail; }`;
            return style;
        }

        setWrapperLink(link) {
            const {hook} = this;
            this.shadowRoot.insertBefore(link, hook);
            link.appendChild(hook);
            this.hook = link;
        }
    }

    class TblAppInstallGrid extends GenericGridComponent {
        static generateInnerDomStructure() {
            const main = super.generateInnerDomStructure();
            main.classList.add('app-install');
            return main;
        }

        static generateInnerStyle() {
            const gridStyle = super.generateInnerStyle();
            const fragment = document.createDocumentFragment();
            fragment.appendChild(gridStyle);
            const appInstallStyle = document.createElement('style');
            appInstallStyle.innerHTML = `:host([version="2"]) .app-install { grid-template: "thumbnail thumbnail" "title title" "description description" "branding cta"; grid-template-columns: minmax(0, 1fr); }`;
            fragment.appendChild(appInstallStyle);
            return fragment;
        }

    }

    GenericGridComponent.registerElement({
        name: 'tbl-app-install-grid',
        component: TblAppInstallGrid
    });

    let newCtaManagerInstance;

    class NewCtaManager {

        constructor({rbox} = {}) {
            this.globalConfig = [];
            this.styleSettings = null;
            this.metricReporter = metricReporter$1.sub('New_CTA');
            this.trcImpl = rbox.trc;
            this.createInitialStyleSettings({rbox});
            this.subscribeToOnRenderEvent();
        }

        static get reportTypes() {
            return {
                event: 'event',
                error: 'error',
                filter: 'filter',
                report: 'report'
            };
        }

        static get reportNameToReportObjMap() {
            return {
                disableByCp: {eventType: NewCtaManager.reportTypes.event, eventName: 'disabled_by_cp'},
                hasCta: {eventType: NewCtaManager.reportTypes.event, eventName: 'has_cta'},
                available: {eventType: NewCtaManager.reportTypes.event, eventName: 'available'},
                visible: {eventType: NewCtaManager.reportTypes.event, eventName: 'visible'},
                ctaButtonClicked: {eventType: NewCtaManager.reportTypes.event, eventName: 'cta_button_clicked'},
                appInstallRendered: {eventType: NewCtaManager.reportTypes.event, eventName: 'cta_rendered'},
                appInstallLabelBoxAndCtaRendered: {eventType: NewCtaManager.reportTypes.event, eventName: 'label_box_and_cta_rendered'},
                ctaBottomCut: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_cta_bottom_cut'},
                brandingWidthThreshold: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_branding_width_threshold'},
                brandingPositionAbsolute: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_branding_absolute'},
                brandingOverlappingCta: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_branding_overlapping'},
                brandingMissingPostRender: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_branding_missing'},
                footerDisclosure: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_footer_disclosure'},
                disclosureEllipsis: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_disclosure_ellipsis'},
                noBranding: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_no_branding'},
                ctaAlignmentOverflow: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_alignment_overflow'},
                appInstallNoSpace: {eventType: NewCtaManager.reportTypes.filter, eventName: 'post_render_app_install_no_space'},
                ctaAlignmentOverflowFix: {eventType: NewCtaManager.reportTypes.report, eventName: 'alignment_overflow_fix'},
                ctaAlignmentPaddingFix: {eventType: NewCtaManager.reportTypes.report, eventName: 'alignment_padding_fix'},
                itemContainerHidden: {eventType: NewCtaManager.reportTypes.report, eventName: 'item_container_hidden'},
                noItemId: {eventType: NewCtaManager.reportTypes.error, eventName: 'no_item_id'}
            };
        }

        static getInstance() {
            return newCtaManagerInstance;
        }

        static injectStyle() {
            if (!NewCtaManager.styleInjected) {
                TRC.dom.injectStyle(`.videoCube a.video-cta-style { width: 100%; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta { display: flex; flex-wrap: wrap; align-content: flex-start; align-items: center; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.video-label-box-cta-non-ie { justify-content: space-between; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid { align-items: center; align-content: center; display: grid; grid-template-columns: 8fr 2fr; min-width: 100%; width: 100%; padding: 0; margin: 0 0 8px; direction: inherit; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid .video-cta-href { min-width: 65px; max-height: 36px; min-height: 36px; height: 36px; margin: 0; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid.app-install-bottom { row-gap: 3px; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid.app-install-bottom .video-title { grid-column: 1 / -1; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid.app-install-bottom .video-description { grid-column: 1 / -1; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid .video-cta-button { min-height: 100%; height: 100%; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid .video-branding-flex-cta-item { white-space: normal; overflow: visible; text-overflow: clip; padding: 0; border: 0; margin: 0; display: flex; height: 100%; min-height: 100%; direction: inherit; } .videoCube a.video-cta-style span.video-label-box.video-label-box-cta.app-install-full-grid.app-install-full-grid .video-branding-flex-cta-item::after { display: none; } .videoCube a.video-cta-style span.video-label-flex-cta-item { flex-basis: 100%; } .videoCube a.video-cta-style span.video-branding-flex-cta-item { margin-top: 1px; flex-grow: 1; flex-basis: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }.videoCube .video-cta-href { display: inline-block; margin-top: 1px; margin-inline-start: 2px; padding: 0; max-width: 100%; min-width: 72px; min-width: calc(min(100%, 72px)); bottom: 0; vertical-align: top; position: relative; box-sizing: content-box; flex-shrink: 0; font-size: 10px; line-height: 13.2px; } .videoCube .video-cta-href button.video-cta-button { margin: 0; height: 24px; font-size: 10px; line-height: 13.2px; border-radius: 4px; border: 1px solid; background-color: inherit; border-color: #999999; text-transform: none; letter-spacing: normal; box-sizing: border-box; font-weight: 400; cursor: pointer; outline: none; font-family: Helvetica; padding: 1px 4px; width: 100%; min-width: 1px; opacity: 1; box-shadow: none; user-select: none; transition: none; text-decoration: none; transform: none; } .videoCube .video-cta-href button.video-cta-button:hover { color: inherit; border-color: inherit; background-color: inherit; letter-spacing: normal; }tbl-app-install-grid .video-cta-href.video-cta-href.video-cta-href { padding: 0; } tbl-app-install-grid .video-cta-href.video-cta-href.video-cta-href, tbl-app-install-grid .video-cta-href.video-cta-href.video-cta-href .video-cta-button { min-width: 100%; min-height: 36px; max-width: 100%; height: 36px; margin: 0; } tbl-app-install-grid .video-cta-href.video-cta-href.video-cta-href .video-cta-button { padding: 0 5px; white-space: nowrap; }`, null);
                NewCtaManager.styleInjected = true;
            }
        }

        static initialize({rbox, itemContainer} = {}) {
            try {
                const itemId = NewCtaManager.getItemId(itemContainer);
                if (!TRC.util.isPercentEnabled(rbox.trc.global, 'enable-cta-component')) {
                    return false;
                }

                if (NewCtaManager.blockedOnPubConfig) {
                    return false;
                }

                if (!newCtaManagerInstance) {
                    const isCallToActionEnable = NewCtaManager.getPubConfigOverrideFromRboxResponse(
                        {configAttribute: 'enable-call-to-action-creative-component', rbox}
                    );
                    if (!isCallToActionEnable || isCallToActionEnable !== 'true') {
                        NewCtaManager.blockedOnPubConfig = true;
                        return false;
                    }

                    NewCtaManager.injectStyle();
                    newCtaManagerInstance = new NewCtaManager({rbox});
                }

                newCtaManagerInstance.trcImpl = rbox.trc;

                if (!rbox.trc.getProperty(rbox.mode_name, 'ctaWidget')) {
                    newCtaManagerInstance.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.disableByCp, {itemId}));
                    return false;
                }

                if (!itemContainer.video_data['cta-text']) {
                    return false;
                }

                newCtaManagerInstance.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.hasCta, {itemId}));
                const filterReason = NewCtaManager.getFilterOutItemForCTAReason({rbox, itemContainer});
                if (filterReason) {
                    newCtaManagerInstance.reportMetrics({eventType: NewCtaManager.reportTypes.filter, eventName: filterReason, itemId});
                    return false;
                }

                return newCtaManagerInstance.createCtaButton({itemContainer});
            } catch (error) {
                __trcError('NewCtaManager error', error);
                if (!newCtaManagerInstance) {
                    return;
                }
                newCtaManagerInstance.reportMetrics({eventType: NewCtaManager.reportTypes.error, eventName: `initialize error${error}`, itemId: NewCtaManager.getItemId(itemContainer)});
            }
        }

        static getItemId(itemContainer) {
            const data = itemContainer.video_data;
            const maximumIdCharacters = 40;
            return (data.id || data['item-id'] || '').slice(0, maximumIdCharacters);
        }

        static reportIfBrandingCausingProblems({
            branding, cta, itemContainer, itemId, additionalData
        } = {}) {
            let ctaRemovedBecauseOfBrandingReason;

            if (!branding.offsetWidth) {
                ctaRemovedBecauseOfBrandingReason = NewCtaManager.reportNameToReportObjMap.brandingMissingPostRender;
            } else {
                const container = branding.parentNode;
                if (!container || !container.offsetWidth || (branding.parentNode !== cta.parentNode)) {
                    return false;
                }

                // cta renders in the same line as branding, the sum of both width should not overpass container width
                if ((cta.offsetWidth + branding.offsetWidth) > container.offsetWidth) {
                    ctaRemovedBecauseOfBrandingReason = NewCtaManager.reportNameToReportObjMap.brandingOverlappingCta;
                }
            }

            if (ctaRemovedBecauseOfBrandingReason) {
                newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                    ctaRemovedBecauseOfBrandingReason, {itemId, additionalData}));
                NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                return true;
            }

            return false;
        }

        static checkForCtaProblems({rbox, itemContainer} = {}) {
            const itemId = NewCtaManager.getItemId(itemContainer);

            try {
                const cta = itemContainer.ctaInstance.getDomElement();
                const additionalData = {
                    mode: rbox.mode_name,
                    itemIndex: itemContainer.video_data.itemIndex
                };

                if (itemContainer.gridComponent instanceof TblAppInstallGrid) {
                    const appInstallWrapper = itemContainer.querySelector('.app-install-branding-wrapper');
                    // clear cta in case that branding overflowing over its slot width.
                    if (appInstallWrapper.clientWidth < appInstallWrapper.scrollWidth) {
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.appInstallNoSpace, {itemId, additionalData}));
                        NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                    }
                    return;
                }

                const branding = itemContainer.querySelector('.video-label-box .branding');
                if (!branding) {
                    newCtaManagerInstance.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.noBranding, {itemId, additionalData}));
                    NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                    return;
                }

                if (itemContainer.rbox.footer && (itemContainer.rbox.footer instanceof Element)) {
                    const footerMargin = NewCtaManager.getComputedStyleProp({element: itemContainer.rbox.footer, propertyName: 'margin'});
                    if ((footerMargin < 0) && (itemContainer.video_data.itemIndex === (itemContainer.rbox.boxes.length - 1))) {
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.footerDisclosure, {itemId, additionalData}));
                        NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                        return;
                    }
                }

                const disclosure = rbox.trc.getProperty(rbox.mode_name, 'disclosure-link-text-sponsored', rbox.propertiesOverride);
                const brandingInnerText = itemContainer.querySelector('.branding-inner') || branding;
                if (disclosure && brandingInnerText) {
                    const brandingTextPixelLimit = 30;
                    const isEllipsisShown = (brandingInnerText.offsetWidth < brandingInnerText.scrollWidth);
                    const isTextWidthBelowLimit = brandingInnerText.offsetWidth < brandingTextPixelLimit;
                    if (isEllipsisShown && isTextWidthBelowLimit) {
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.brandingWidthThreshold, {itemId, additionalData}));
                        NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                        return;
                    }
                }

                const brandingPosition = NewCtaManager.getComputedStyleProp({element: branding, propertyName: 'position'});
                if (brandingPosition && brandingPosition === 'absolute') {
                    newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                        NewCtaManager.reportNameToReportObjMap.brandingPositionAbsolute, {itemId, additionalData}));
                    NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                    return;
                }

                const offsetTopDelta = cta.offsetTop - branding.offsetTop;
                const allowedNonOverflowOffset = 5;
                // check if button position overflows after PS hooks e.g videoContainer height 0, and try to fix its position
                if ((cta.scrollHeight > cta.clientHeight) || (cta.scrollWidth > cta.clientWidth)) {
                    if (NewCtaManager.reportIfBrandingCausingProblems({
                        branding, cta, itemContainer, itemId, additionalData
                    })) {
                        return;
                    }

                    if (offsetTopDelta > 0) {
                        cta.style.marginTop = `-${offsetTopDelta * 2}px`;
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.ctaAlignmentOverflowFix, {itemId, additionalData}));
                    } else {
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.ctaAlignmentOverflow, {itemId, additionalData}));
                        NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                        return;
                    }
                } else if ((offsetTopDelta > allowedNonOverflowOffset)) {
                    if (NewCtaManager.reportIfBrandingCausingProblems({
                        branding, cta, itemContainer, itemId, additionalData
                    })) {
                        return;
                    }
                    // fix button position miss-alignment by PS hook e.g branding with padding bottom 24px;
                    cta.style.marginTop = `-${offsetTopDelta}px`;
                    newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                        NewCtaManager.reportNameToReportObjMap.ctaAlignmentPaddingFix, {itemId, additionalData}));
                }

                if ((cta.offsetTop + cta.offsetHeight) > itemContainer.offsetHeight) {
                    newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                        NewCtaManager.reportNameToReportObjMap.ctaBottomCut, {itemId, additionalData}));
                    NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                    return;
                }

                window.setTimeout(() => {
                    if (!cta.parentNode || !branding) {
                        return;
                    }

                    // filter disclosure ellipsis bug
                    const brandingDisplay = NewCtaManager.getComputedStyleProp({element: branding, propertyName: 'display'});
                    const disclosureDomElement = itemContainer.querySelector('.link-disclosure');
                    if (brandingDisplay !== 'flex' && brandingInnerText && branding && (branding.scrollWidth > branding.offsetWidth)) {
                        let hasDisclosureEllipsis = false;

                        if (disclosureDomElement) {
                            hasDisclosureEllipsis = true;
                        } else {
                            const brandingPseudoContent = brandingInnerText && window.getComputedStyle(brandingInnerText, '::after').content;
                            if (brandingPseudoContent && (brandingPseudoContent !== 'none')) {
                                try {
                                    hasDisclosureEllipsis = !!JSON.parse(brandingPseudoContent || '').trim();
                                    // eslint-disable-next-line no-empty
                                } catch (error) {}
                            }
                        }

                        if (hasDisclosureEllipsis) {
                            newCtaManagerInstance.reportMetrics(
                                TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.disclosureEllipsis, {itemId, additionalData})
                            );
                            NewCtaManager.removeCtaFromDom({ctaDomElement: cta, itemContainer});
                        }
                    }
                }, 0);

                const reportOrderMap = {
                    cta,
                    branding
                };
                Object.keys(reportOrderMap).forEach(key => {
                    const element = reportOrderMap[key];
                    if (!element) {
                        return;
                    }
                    const computedOrder = NewCtaManager.getComputedStyleProp({element, propertyName: 'order'});
                    if (computedOrder && parseInt(computedOrder, 10)) {
                        newCtaManagerInstance.reportMetrics({eventType: NewCtaManager.reportTypes.report, eventName: `publisher_order_${key}`, itemId});
                    }
                });
            } catch (error) {
                newCtaManagerInstance.reportMetrics({eventType: NewCtaManager.reportTypes.error, eventName: `checkForCtaProblems_${error}`, itemId});
            }
        }

        static removeCtaFromDom({ctaDomElement, itemContainer} = {}) {
            if (!ctaDomElement.parentNode) {
                return;
            }

            ctaDomElement.parentNode.removeChild(ctaDomElement);
            const link = NewCtaManager.getVideoLabelBoxLink(itemContainer);
            if (link && (itemContainer.video_data['is-app-install'] !== 'true')) {
                link.classList.remove('video-cta-style');
                link.classList.add('video-cta-style-removed');
            }
        }

        static getFilterOutItemForCTAReason({rbox, itemContainer}) {
            return NewCtaManager.isNextUp(rbox)
                   || (TRC.util.isPercentEnabled(rbox.trc.global, 'cta-ignore-detail-order') ? null : NewCtaManager.isDetailOrderBlocked(itemContainer))
                   || NewCtaManager.hasLink(itemContainer)
                   || NewCtaManager.isHeroWidget(itemContainer)
                   || NewCtaManager.isStoryWidget(rbox)
                   || NewCtaManager.areVideoLabelBoxAndBrandingExist(itemContainer)
                   || NewCtaManager.isInNetwork(itemContainer);
        }

        static isNextUp(rbox) {
            const isNextUp = rbox.options && rbox.options.trcResponse && !!rbox.options.trcResponse.nup;
            return isNextUp ? 'next_up' : null;
        }

        static isDetailOrderBlocked(itemContainer) {
            const detailOrder = itemContainer.detail_order;
            if (detailOrder && detailOrder.length && detailOrder[0] === 'branding') {
                return 'item_branding_before_title';
            }

            return null;
        }

        static hasLink(itemContainer) {
            if (itemContainer.gridComponent instanceof TblAppInstallGrid) {
                if (!itemContainer.gridComponent.hook) {
                    return 'no_link_grid_component';
                }
                return;
            }
            const titleLink = itemContainer.link;
            if (!titleLink) {
                return 'no_link';
            }

            return null;
        }

        static isHeroWidget(itemContainer) {
            if (itemContainer.rbox.mode_name && itemContainer.rbox.mode_name.indexOf('hero') > -1) {
                return 'item_in_hero_widget';
            }

            return null;
        }

        static isStoryWidget(rbox) {
            if (TRC.RecommendationReel.shouldInitRecommendationReel(rbox)) {
                return 'item_in_reco_reel_story_widget';
            }
            return null;
        }

        static areVideoLabelBoxAndBrandingExist(itemContainer) {
            if (itemContainer.gridComponent instanceof TblAppInstallGrid) {
                return;
            }
            const videoLabelBox = itemContainer.querySelector('.video-label-box');
            if (!videoLabelBox) {
                return 'no_video_label_box';
            }

            const branding = videoLabelBox.querySelector('.branding');
            if (!branding) {
                return 'no_branding';
            }
        }

        static isInNetwork(itemContainer) {
            return itemContainer.video_data['is-in-network'] ? 'in_network' : null;
        }

        // static hasIcon(itemContainer) {
        //     if (itemContainer.querySelector('.added-icon-svg')) {
        //         return 'item_branding_has_icon';
        //     }
        //
        //     return null;
        // }

        static getComputedStyleProp({element, propertyName, defaultValue} = {}) {
            const propertyValue = window.getComputedStyle(element)[propertyName];

            if (!propertyValue) {
                return defaultValue || null;
            }

            const number = parseInt(propertyValue, 10);
            return isNaN(number) ? propertyValue : number;
        }

        static getPubConfigOverrideFromRboxResponse({configAttribute, rbox} = {}) {
            const pubConfigOverride = rbox && rbox.globalTrcResponseJSON
                                      && rbox.globalTrcResponseJSON.dcga
                                      && rbox.globalTrcResponseJSON.dcga.pubConfigOverride;

            return pubConfigOverride && pubConfigOverride[configAttribute];
        }

        static addCtaToVideoLabelBox({
            ctaDomElement, videoLabelBox, branding, itemContainer
        } = {}) {
            const link = NewCtaManager.getVideoLabelBoxLink(itemContainer);

            if (link) {
                link.classList.add('video-cta-style');

                if (!itemContainer.rbox.isFeedCard) {
                    link.classList.add('non-feed-cta-item');
                }
            }

            videoLabelBox.classList.add('video-label-box-cta');
            if (itemContainer.video_data['is-app-install'] === 'true') {
                videoLabelBox.classList.add('app-install-full-grid');
                const appInstallVersion = itemContainer.rbox.trc && itemContainer.rbox.trc.getProperty(itemContainer.rbox.mode_name, 'app-install-version', itemContainer.rbox.propertiesOverride);
                if (appInstallVersion === '2') {
                    videoLabelBox.classList.add('app-install-bottom');
                }
            }

            if (!TRC.Browser.ie) {
                videoLabelBox.classList.add('video-label-box-cta-non-ie');
            }

            const videoLabelItems = videoLabelBox.querySelectorAll('.video-label');
            if (videoLabelItems) {
                for (let index = 0; index < videoLabelItems.length; index++) {
                    const videoLabel = videoLabelItems[index];
                    videoLabel.classList.add('video-label-flex-cta-item');
                }
            }

            branding.classList.add('video-branding-flex-cta-item');
            if (NewCtaManager.isDetailOrderBlocked(itemContainer)) {
                videoLabelBox.insertBefore(ctaDomElement, branding.nextSibling);
            } else {
                videoLabelBox.appendChild(ctaDomElement);
            }
        }

        static getVideoLabelBoxLink(itemContainer) {
            const labelLink = itemContainer.querySelector('.item-label-href');
            const isLinkDirectsToLabelLink = !labelLink || !itemContainer.link || itemContainer.link === labelLink;

            if (isLinkDirectsToLabelLink) {
                return itemContainer.link;
            }

            return labelLink;
        }

        get shouldReportMetrics() {
            return TRC.util.isPercentEnabled(this.trcImpl.global, 'report-cta-metrics');
        }

        get shouldReportAppInstall() {
            return TRC.util.isPercentEnabled(this.trcImpl.global, 'app-install-report');
        }

        reportMetrics({
            eventType = 'event', eventName = '', itemId = '', additionalData
        } = {}) {
            if (!this.shouldReportMetrics) {
                return;
            }

            const metricDataObj = {
                eventName: `${eventType}-${eventName}`,
                itemId
            };

            if (additionalData) {
                metricDataObj.additionalData = additionalData;
            }

            window.setTimeout(() => {
                this.metricReporter.logUsage({
                    extraData: metricDataObj,
                    file: 'new-cta-manager'
                });
                this.metricReporter.sendRboxMetricsEvent({eventName: metricDataObj.eventName, value: '1', type: 'counter'});
            }, 0);
        }

        subscribeToOnRenderEvent() {
            TRC.eventDelegator.subscribe('onrender', data => {
                let trcRbox;

                trcRbox = this.trcImpl.boxes[data.container._trcRboxId];
                if (!trcRbox) {
                    // Handle situations like multi-widget
                    try {
                        const boxes = data.container.querySelectorAll('[data-item-id]');
                        trcRbox = boxes[0].rbox;
                        if (trcRbox.ctaPostRenderFix) {
                            return;
                        }
                        trcRbox.boxes = boxes;
                        trcRbox.ctaPostRenderFix = true;
                    } catch (error) {
                        return;
                    }
                }

                if (!trcRbox) {
                    return;
                }

                let styles;
                trcRbox.boxes.forEach(itemContainer => {
                    if (!itemContainer.ctaInstance) {
                        return;
                    }

                    if (!itemContainer.offsetWidth) {
                        newCtaManagerInstance.reportMetrics(TRC.util.merge({},
                            NewCtaManager.reportNameToReportObjMap.itemContainerHidden, {
                                itemId: NewCtaManager.getItemId(itemContainer),
                                additionalData: {mode: trcRbox.mode_name, itemIndex: itemContainer.video_data.itemIndex}
                            }));
                        return;
                    }

                    if (!styles) {
                        styles = this.adjustColorsAfterRender({rbox: trcRbox, itemContainer});
                    }

                    if (styles) {
                        itemContainer.ctaInstance.setCtaButtonStyle(styles);
                    }

                    NewCtaManager.checkForCtaProblems({rbox: trcRbox, itemContainer});
                    delete itemContainer.ctaInstance;
                });
            });
        }

        subscribeToVisibilityEvent({ctaDomElement, itemContainer} = {}) {
            if (!this.shouldReportMetrics) {
                return false;
            }

            const observerId = TRC.intersections.isInViewPort({
                targetElement: itemContainer,
                enableDelayedVisibilityCheck: true,
                onEnter: (() => {
                    if (!observerId) {
                        return;
                    }

                    TRC.intersections.unobserve(observerId);
                    if (!ctaDomElement.parentNode) {
                        return;
                    }

                    this.reportMetrics(
                        TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.visible, {itemId: NewCtaManager.getItemId(itemContainer)})
                    );
                })
            });
        }

        getPubConfigOverride({configAttribute, rbox, isGlobal} = {}) {
            const pubConfigValue = NewCtaManager.getPubConfigOverrideFromRboxResponse({configAttribute, rbox});

            if (pubConfigValue != null && isGlobal) {
                this.globalConfig[configAttribute] = pubConfigValue;
            }

            return pubConfigValue != null ? pubConfigValue : this.globalConfig[configAttribute];
        }

        createInitialStyleSettings({rbox} = {}) {
            const styleSettingsObj = {
                borderColor: this.getPubConfigOverride({configAttribute: 'border-color', rbox, isGlobal: true}),
                color: this.getPubConfigOverride({configAttribute: 'title-color', rbox, isGlobal: true}),
                fontSize: this.getPubConfigOverride({configAttribute: 'cta-font-size', rbox, isGlobal: true}),
                fontWeight: this.getPubConfigOverride({configAttribute: 'font-weight', rbox, isGlobal: true})
            };

            this.styleSettings = styleSettingsObj;
        }


        reportAppInstall({itemId} = {}) {
            if (!this.shouldReportAppInstall) {
                return;
            }
            const appInstallReporter = metricReporter$1.sub('app_install');
            const appInstallReporterContext = {metricReporter: appInstallReporter, shouldReportMetrics: true};
            this.reportMetrics.call(appInstallReporterContext,
                TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.appInstallRendered, {itemId}));
            this.reportMetrics.call(appInstallReporterContext,
                TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.appInstallLabelBoxAndCtaRendered, {itemId}));
        }

        createCtaButtonForAppInstall({itemContainer} = {}) {
            const data = {
                label: TRC.util.getHtmlDecodeText(itemContainer.video_data['cta-text'])
            };
            const ctaInstance = new NewCta({styleSettings: this.styleSettings, data});
            const ctaDomElement = ctaInstance.getDomElement();
            ctaDomElement.setAttribute('slot', 'cta');
            itemContainer.gridComponent.appendChild(ctaDomElement);
            const itemId = NewCtaManager.getItemId(itemContainer);
            itemContainer.ctaInstance = ctaInstance;
            this.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.available, {itemId}));
            ctaDomElement.onclick = () => {
                this.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.ctaButtonClicked, {itemId}));
            };
            this.subscribeToVisibilityEvent({ctaDomElement: ctaInstance.getDomElement(), itemContainer});
            this.reportAppInstall({itemId});
            return ctaInstance;

        }

        createCtaButton({itemContainer} = {}) {
            if (itemContainer.gridComponent instanceof TblAppInstallGrid) {
                return this.createCtaButtonForAppInstall({itemContainer});
            }
            const itemId = NewCtaManager.getItemId(itemContainer);
            const videoLabelBox = itemContainer.querySelector('.video-label-box');
            const branding = videoLabelBox.querySelector('.branding');

            const data = {
                label: TRC.util.getHtmlDecodeText(itemContainer.video_data['cta-text'])
            };

            const ctaInstance = new NewCta({styleSettings: this.styleSettings, data});
            const ctaDomElement = ctaInstance.getDomElement();
            NewCtaManager.addCtaToVideoLabelBox({
                ctaDomElement, videoLabelBox, branding, itemContainer
            });

            itemContainer.ctaInstance = ctaInstance;
            this.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.available, {itemId}));

            ctaDomElement.onclick = () => {
                this.reportMetrics(TRC.util.merge({}, NewCtaManager.reportNameToReportObjMap.ctaButtonClicked, {itemId}));
            };

            this.subscribeToVisibilityEvent({ctaDomElement: ctaInstance.getDomElement(), itemContainer});

            if (itemContainer.video_data['is-app-install'] === 'true') {
                this.reportAppInstall({itemId});
            }
            return ctaInstance;
        }

        adjustColorsAfterRender({rbox, itemContainer} = {}) {
            try {
                const branding = (itemContainer.gridComponent instanceof TblAppInstallGrid)
                    ? itemContainer.querySelector('.app-install-branding-title') : itemContainer.querySelector('.video-label-box .branding');
                if (!branding) {
                    return;
                }
                const styleSettings = {
                    'font-family': NewCtaManager.getComputedStyleProp({element: branding, propertyName: 'font-family'})
                };

                // After rendering...
                if (this.getPubConfigOverride({configAttribute: 'inherit-title-color', rbox, isGlobal: true})) {
                    const title = itemContainer.querySelector('.video-title');
                    if (!title) {
                        return styleSettings;
                    }
                    styleSettings.color = NewCtaManager.getComputedStyleProp({element: title, propertyName: 'color'});
                    styleSettings['border-color'] = NewCtaManager.getComputedStyleProp({element: title, propertyName: 'border-color'});
                } else if (!this.getPubConfigOverride({configAttribute: 'title-color', rbox, isGlobal: true})) {
                    styleSettings.color = NewCtaManager.getComputedStyleProp({element: branding, propertyName: 'color'});
                }

                return styleSettings;
            } catch (error) {
                this.reportMetrics({eventType: NewCtaManager.reportTypes.error, eventName: `adjust_colors_render_${error}`, itemId: NewCtaManager.getItemId(itemContainer)});
            }
        }
    }

    const constants = {
        FETCH_PREFIX: 'https://images.taboola.com/taboola/image/fetch/'
    };

    const filename = 'trcrbox-ui-image-utils';

    const metricReporter = metricReporter$1.sub('image_utils');

    const computeImageOptimizationConfig = ({
        trcRBoxUI, imgContDim, video
    }) => {
        const imageOptimizationConfig = {};
        try {
            const trcManager = trcRBoxUI.trc;
            imageOptimizationConfig.allowedRatiosSorted = trcManager.getSortedCloudinaryRatios();
            // eslint-disable-next-line prefer-destructuring
            imageOptimizationConfig.imageMinRatio = imageOptimizationConfig.allowedRatiosSorted[0];
            imageOptimizationConfig.imageSizeFactor = trcRBoxUI.getImageSizeFactor();
            imageOptimizationConfig.imageMinWidth = trcManager.getProperty(trcRBoxUI.mode_name, 'image-min-width', trcRBoxUI.propertiesOverride) || 110;
            imageOptimizationConfig.imageMaxWidth = trcManager.getProperty(trcRBoxUI.mode_name, 'image-max-dimension', trcRBoxUI.propertiesOverride) || 1500;
            imageOptimizationConfig.imageSizeRound = parseInt(trcRBoxUI.customImageSizeRound, 10)
                || trcManager.getProperty(trcRBoxUI.mode_name, 'image-size-round', trcRBoxUI.propertiesOverride)
                || 20;
            imageOptimizationConfig.imageMaxRatio = trcManager.getProperty(trcRBoxUI.mode_name, 'image-max-ratio', trcRBoxUI.propertiesOverride)
                || imageOptimizationConfig.allowedRatiosSorted[imageOptimizationConfig.allowedRatiosSorted.length - 1];
            imageOptimizationConfig.computedWidth = Math.min(
                Math.ceil(
                    Math.max(
                        imgContDim.width * imageOptimizationConfig.imageSizeFactor,
                        imageOptimizationConfig.imageMinWidth
                    ) / imageOptimizationConfig.imageSizeRound
                ) * imageOptimizationConfig.imageSizeRound,
                imageOptimizationConfig.imageMaxWidth
            );
            imageOptimizationConfig.computedRatio = Math.max(
                Math.min(trcRBoxUI.getAllowedRatio(imgContDim), imageOptimizationConfig.imageMaxRatio),
                imageOptimizationConfig.imageMinRatio
            );
            imageOptimizationConfig.computedHeight = Math.ceil(imageOptimizationConfig.computedWidth * imageOptimizationConfig.computedRatio);
        } catch (error) {
            const reporterCallback = buildAReporterCallback({trcRBoxUI, video});
            reporterCallback({
                eventName: reportEventMap.computeImageOptimizationConfigError,
                error: error.toString()
            });
        }
        return imageOptimizationConfig;
    };

    const parseCroppingPrefix = ({
        trcRBoxUI, video, imageOptimizationConfig
    }) => {
        const reporterCallback = buildAReporterCallback({trcRBoxUI, video});
        try {
            const trcManager = trcRBoxUI.trc;
            if (!video.cropping
            || !TRC.util.isPercentEnabled(trcRBoxUI.trc.global, 'image-cropping-active')) {
                return '';
            }
            const ratioList = trcManager.global['image-cropping-ratios-list'];
            if (!ratioList || !ratioList.length) {
                reporterCallback({
                    eventName: reportEventMap.parseCroppingPrefix.noRatioList,
                    length: ratioList && ratioList.length
                });
                return '';
            }
            const deltas = ratioList.map(([w, h]) => Math.abs((h / w) - imageOptimizationConfig.computedRatio));
            const minimalDeltaIndex = deltas.reduce(
                (selectedIndex, delta, currentIndex) => (deltas[selectedIndex] > delta ? currentIndex : selectedIndex),
                0
            );
            const selectedRatioItem = ratioList[minimalDeltaIndex];
            if (!selectedRatioItem) {
                return '';
            }
            const selectedRatio = (selectedRatioItem[1] / selectedRatioItem[0]);
            let {crop} = JSON.parse(video.cropping.replace(/&#34;/g, '"')); // trc serializer bug
            crop = Array.isArray(crop) ? crop : Object.values(crop); // item preview bug, value passed as {number: object} with not length
            let computedCroppingData = null;
            // eslint-disable-next-line guard-for-in, no-restricted-syntax
            for (const i in crop) { // find is not supported on PhantomJS
                const data = crop[i];
                if (data.ratio && (selectedRatio === (data.ratio.h / data.ratio.w))) {
                    computedCroppingData = data;
                    break;
                }
            }
            if (!computedCroppingData) {
                reporterCallback({
                    eventName: reportEventMap.parseCroppingPrefix.NoMatch
                });
                return '';
            }
            reporterCallback({
                eventName: reportEventMap.parseCroppingPrefix.Match
            });
            const {area} = computedCroppingData;
            const transposeRatio = +(1 / selectedRatio).toFixed(4);
            const areaParameters = ['w', 'x', 'y'].map(key => `${key}_${area[key]}`);
            const cropDetails = ['c_crop', 'f_jpg', 'q_auto', 'e_sharpen', `ar_${transposeRatio}`].concat(areaParameters);
            const newLink = `${constants.FETCH_PREFIX}${cropDetails.join(encodeURIComponent(','))}/`;
            return newLink;
        } catch (error) {
            reporterCallback({
                eventName: reportEventMap.parseCroppingPrefix.Error,
                error: error.toString()
            });
        }
        return '';
    };

    var imageUtils = {
        constants,
        computeImageOptimizationConfig,
        parseCroppingPrefix
    };

    const reportEventMap = {
        computeImageOptimizationConfigError: 'error-compute_image_optimization_dictionary',
        parseCroppingPrefix: {
            NoMatch: 'event-cropping_did_not_matched',
            Match: 'event-cropping_matched',
            Error: 'error-parse_cropping_data',
            noRatioList: 'error-no_ratio_list'
        }
    };

    const buildAReporterCallback = ({trcRBoxUI, video}) => {
        const flag = 'image-cropping-report';
        if (!TRC.util.isPercentEnabled(trcRBoxUI.trc.global, flag)) {
            return () => { };
        }
        video = video || {};
        const itemId = (video.id || video['item-id'] || '').slice(0, 40);
        const isCropping = !!video.cropping;
        const extraData = {itemId, isCropping};

        return setting => {
            setting = setting || {};
            const {eventName} = setting;
            setTimeout(() => {
                metricReporter.logUsage({
                    file: filename,
                    extraData: TRC.util.merge({}, setting, extraData, {eventName})
                });
                metricReporter.sendRboxMetricsEvent({eventName, value: '1', type: 'counter'});
            }, 0);
        };
    };

    const responsiveReporter = metricReporter$1.sub('responsive-utils');
    const placementIdPostRenderCellsMap = {};
    let fixResponsiveWidgetResizeHandler;
    const checkForCssPseudoSupport = pseudoString => {
        const div = document.createElement('div');
        let isSupported = false;
        try {
            div.querySelector(pseudoString);
            isSupported = true;
        } catch (error) {
            // do nothing
        }
        return isSupported;
    };
    const pseudoSupportMap = {nthChildOf: checkForCssPseudoSupport(':nth-child(1 of .videoCube)')};

    const reportingFlag = 'responsive-utils-report';
    const responsiveReportEventMap = {
        preFixingResponsiveWidget: 'event-pre_fixing_responsive_widget',
        fixingResponsiveWidget: `event-fixing_responsive_widget`,
        placementRenderedOk: `event-placement_rendered_ok`,
        placementLayoutShift: `event-placement_layout_shift`,
        checkingResponsiveWidget: 'event-checking_responsive_widget',
        checkingOverflowingCards: 'event-checking_overflowing_cards',
        overflowingCardsFound: 'event-overflowing_cards_found',
        responsiveFixError: 'error-responsive_fix_error',
        checkingResponsiveError: `error-checking_responsive_error`
    };

    const sendEvent = ({
        rbox, dataObj, eventName, id = ''
    } = {}) => {
        try {
            if (!TRC.util.isPercentEnabled(rbox.trc.global, reportingFlag)) {
                return;
            }

            const extraData = TRC.util.merge({}, dataObj, {
                mode: rbox.mode, publisher: rbox.publisher, eventName, id
            });

            responsiveReporter.logUsage({
                file: 'responsive-utils',
                extraData
            });
            responsiveReporter.sendRboxMetricsEvent({eventName, value: '1', type: 'counter'});
        } catch (error) {
            // do nothing
        }
    };

    const listenToResizeEventIfFirstTime = () => {
        if (!fixResponsiveWidgetResizeHandler) {
            fixResponsiveWidgetResizeHandler = true;
            const debounceTime = 500;
            window.TRC.dom.on(window, 'resize', TRC.util.debounce(() => {
                if (!TRCImpl.boxes) {
                    return;
                }

                Object.keys(TRCImpl.boxes).forEach(boxId => {
                    const trcRbox = TRCImpl.boxes[boxId];
                    if (!trcRbox) {
                        return;
                    }

                    fixResponsiveWidget({rbox: trcRbox, isTriggeredByResize: true});
                });

            }, debounceTime, false));
        }
    };

    const handleResponsiveWidget = ({rbox} = {}) => {
        if (!TRC || !TRC.util) {
            return;
        }

        fixResponsiveWidget({rbox});
        checkResponsiveWidget({rbox});
        checkOverflowingCards({rbox});
    };

    const checkOverflowingCards = ({rbox} = {}) => {
        try {
            if (!TRC.util.isPercentEnabled(rbox.trc.global, reportingFlag)) {
                return;
            }

            const sendTaskToFader = TRC.Fader();
            sendTaskToFader(() => {
                rbox.boxes.forEach(cell => {
                    if (!cell.offsetWidth) {
                        return;
                    }

                    sendEvent({rbox, eventName: responsiveReportEventMap.checkingOverflowingCards});
                    if (cell.scrollHeight > (cell.clientHeight + 1)) {
                        sendEvent({rbox, eventName: responsiveReportEventMap.overflowingCardsFound});
                    }
                });
            });
        } catch (error) {
            // do nothing
        }
    };

    const fixResponsiveWidget = ({rbox, isTriggeredByResize = false} = {}) => {
        if (!TRC.util.isPercentEnabled(rbox.trc.global, 'enable-responsive-float-fix')) {
            return false;
        }

        try {
            const rules = rbox.trc.getProperty(rbox.mode_name, 'responsive-rules', rbox.propertiesOverride);
            if (!rules) {
                return false;
            }

            if (!rbox.boxes.length) {
                return false;
            }

            sendEvent({rbox, dataObj: {isTriggeredByResize}, eventName: responsiveReportEventMap.preFixingResponsiveWidget});
            listenToResizeEventIfFirstTime();
            const effectiveResponsiveRule = rbox.getEffectiveResponsiveRule();
            if (effectiveResponsiveRule && ((effectiveResponsiveRule.cells === 1) || (effectiveResponsiveRule.rows === 1))) {
                return false;
            }

            const originalItemsPerRow = effectiveResponsiveRule ? effectiveResponsiveRule.cells : -1;
            const containerWidth = rbox.boxes[0].parentNode ? Math.floor(rbox.boxes[0].parentNode.offsetWidth) : null;
            if (!containerWidth) {
                return false;
            }

            const currentItemsPerRow = Math.floor(containerWidth / rbox.boxes[0].getBoundingClientRect().width);
            const cardWidth = rbox.boxes[0].offsetWidth;
            const isMultiWidget = (rbox.boxes.length > 1) && cardWidth
                      && rbox.boxes[1].offsetWidth && (cardWidth >= (rbox.boxes[1].offsetWidth * 2));
            const originalNumberOfItemsRendered = !placementIdPostRenderCellsMap[rbox.id] && (originalItemsPerRow === currentItemsPerRow);
            const fixedNumberOfItemsRendered = placementIdPostRenderCellsMap[rbox.id] === currentItemsPerRow;
            if (pseudoSupportMap.nthChildOf && !isMultiWidget && currentItemsPerRow && (originalNumberOfItemsRendered || fixedNumberOfItemsRendered)) {
                return false;
            }

            let itemsPerRowToRevert = originalItemsPerRow;
            // Cases of publisher mediaQuery sizing (via css hook) of videoCube and resize will be handled by this condition.
            const shouldFixResizedColumns = isTriggeredByResize && !isMultiWidget && !originalNumberOfItemsRendered
                  && !fixedNumberOfItemsRendered && placementIdPostRenderCellsMap[rbox.id];
            if (shouldFixResizedColumns) {
                itemsPerRowToRevert = placementIdPostRenderCellsMap[rbox.id];
            }

            placementIdPostRenderCellsMap[rbox.id] = currentItemsPerRow;

            let areAllCardsWithSameWidth = true;
            rbox.boxes.forEach(cell => {
                if (cell.offsetWidth && (cardWidth !== cell.offsetWidth)) {
                    areAllCardsWithSameWidth = false;
                }
            });

            // This will go over cards within placement, and change the clear attribute that was changed before via setBoxDimensions function css.es6.js
            rbox.boxes.filter(element => TRC.dom.containsClass(element, 'videoCube'))
                .forEach((videoCubeItem, index) => {
                    if (!index) {
                        return;
                    }

                    if (areAllCardsWithSameWidth && (index % currentItemsPerRow === 0)) {
                        videoCubeItem.style.clear = 'both';
                        return;
                    }

                    if (index % itemsPerRowToRevert === 0) {
                        videoCubeItem.style.clear = 'none';
                    }
                });

            sendEvent({
                rbox, dataObj: {areAllCardsWithSameWidth, isTriggeredByResize}, eventName: responsiveReportEventMap.fixingResponsiveWidget
            });
            return true;
        } catch (error) {
            sendEvent({rbox, dataObj: {isTriggeredByResize}, eventName: `${responsiveReportEventMap.responsiveFixError}_${error}`});
            return false;
        }
    };

    const getFloatLayoutShiftElementObj = ({floatDirection, previousRow, currentItem} = {}) => {
        // const affectedCard = currentItem;
        let rootCauseElement;
        let isCardBiggerThanOthers;
        if (previousRow.length) {
            for (let j = 0; j < previousRow.length; j++) {
                const floatDirectionConditionMatch = floatDirection === 'left' ? (previousRow[j].offsetLeft >= currentItem.offsetLeft) : (previousRow[j].offsetLeft <= currentItem.offsetLeft);
                if (floatDirectionConditionMatch) {
                    const heightObj = {};
                    previousRow.forEach(item => {
                        if (!item.offsetHeight) {
                            return;
                        }
                        heightObj[item.offsetHeight] = heightObj[item.offsetHeight] || [];
                        heightObj[item.offsetHeight].push(item);
                    });
                    const heightKeys = Object.keys(heightObj); // will give the sorted height by array of keys
                    if ((previousRow.length > 2) && (heightKeys.length === 2)
                        && (heightObj[heightKeys[0]].length === 1) && (heightObj[heightKeys[0]][0] === previousRow[j])) {
                        rootCauseElement = previousRow[j];
                    } else {
                        if (heightObj[heightKeys[heightKeys.length - 1]].length === 1) {
                            [rootCauseElement] = heightObj[heightKeys[heightKeys.length - 1]];
                        } else {
                            rootCauseElement = previousRow[j - 1] || previousRow[j];
                        }
                        isCardBiggerThanOthers = true;
                    }

                    if (!rootCauseElement.offsetHeight) {
                        return null;
                    }
                }
            }
        }

        return {
            rootCauseElement,
            isCardBiggerThanOthers
        };
    };

    const checkResponsiveWidget = ({rbox} = {}) => {
        if (!TRC.util.isPercentEnabled(rbox.trc.global, reportingFlag)) {
            return;
        }

        const sendTaskToFader = TRC.Fader();
        sendTaskToFader(() => {
            try {
                const placementItems = rbox.boxes;
                if (placementItems.length <= 1) {
                    return;
                }

                const floatDirection = window.getComputedStyle(placementItems[0]).float;
                if (floatDirection === 'none') {
                    return;
                }

                if (!placementItems[0].offsetWidth || !placementItems[0].parentElement.offsetWidth) {
                    return;
                }

                // assuming it is one card per row
                if (((placementItems[0].offsetWidth / window.innerWidth) > 0.8)
                    || ((placementItems[0].offsetWidth / placementItems[0].parentElement.offsetWidth) > 0.8)) {
                    return;
                }

                sendEvent({rbox, eventName: responsiveReportEventMap.checkingResponsiveWidget});

                let previousRow = [];
                let currentRow = [];
                let hasCta = false;
                currentRow.push(placementItems[0]);
                for (let i = 1; i < placementItems.length; i++) {
                    const previousItem = placementItems[i - 1];
                    const currentItem = placementItems[i];

                    if (!hasCta && currentItem.querySelector('.video-cta-button')) {
                        hasCta = true;
                    }

                    if (previousItem.offsetTop !== currentItem.offsetTop) {
                        const itemToCompare = currentRow[0];

                        // assuming multiWidget like
                        if (((itemToCompare.offsetHeight + itemToCompare.offsetTop) > currentItem.offsetTop)
                            && (itemToCompare.offsetWidth > (currentItem.offsetWidth * 2))) {
                            break;
                        }
                        previousRow = currentRow.slice();
                        currentRow = [];
                        let layoutShiftElementObj;
                        if (floatDirection === 'left' && (currentItem.offsetLeft >= (itemToCompare.offsetLeft + itemToCompare.offsetWidth))) {
                            layoutShiftElementObj = getFloatLayoutShiftElementObj({floatDirection, previousRow, currentItem});
                        } else if (floatDirection === 'right' && (currentItem.offsetLeft < itemToCompare.offsetLeft)) {
                            layoutShiftElementObj = getFloatLayoutShiftElementObj({floatDirection, previousRow, currentItem});
                        }

                        if (layoutShiftElementObj) {
                            const {rootCauseElement} = layoutShiftElementObj;
                            const id = (rootCauseElement && rootCauseElement.video_data['item-id']) ? rootCauseElement.video_data['item-id'].slice(0, 40) : '';
                            const isBrokenBecauseOfCta = rootCauseElement && rootCauseElement.querySelector('.video-cta-button');
                            sendEvent({
                                rbox,
                                dataObj: {
                                    rootCauseElement,
                                    isBiggerThanOthers: layoutShiftElementObj.isCardBiggerThanOthers,
                                    hasCta,
                                    isBrokenBecauseOfCta,
                                    id,
                                    isBroken: true
                                },
                                eventName: responsiveReportEventMap.placementLayoutShift
                            });
                            return;
                        }
                    }

                    if (currentRow.length && (currentItem.offsetLeft === currentRow[0].offsetLeft)) {
                        previousRow = currentRow.slice();
                        currentRow = [];
                    }

                    currentRow.push(currentItem);
                }

                sendEvent({rbox, dataObj: {hasCta, isBroken: false}, eventName: responsiveReportEventMap.placementRenderedOk});
            } catch (error) {
                sendEvent({rbox, eventName: `${responsiveReportEventMap.checkingResponsiveError}_${error}`});
            }
        });
    };

    var responsiveUtils_es6 = {
        handleResponsiveWidget
    };

    class BeaconUtils {
        static sendBeaconRequest(url, bodyParams) {
            if (typeof window.navigator.sendBeacon === 'function') {
                return window.navigator.sendBeacon(url, TRC.TRCLogger.formatBeaconParams(bodyParams));
            }
            return false;
        }
    }

    /*
     * R-Box UI implementation
     *
     * Loads:
     * 		recommendation list (asynchronous)
     *
     * Local storage:
     * 		"user-id" - Taboola anonymous viewer id, used for preventing session splits.
     * 		"session-data" - Taboola anonymous session key, used for preventing session splits.
     * 		"auto-play-intent" - support auto-play detection across page loads
     */

    (function(win,doc){
        var CONSTS = {
            REL_SPONSORED: "sponsored",
            EMPTY_HREF: "https://"
        };
        // set up the collection of available UI implementations
    	TRC.implClasses = TRC.implClasses || {};
        TRC.PVideoLoader = PVideoLoader; // unit backwards compatibility
        /**
         * Create text element with Non Breaking Space as content. This is a faster replacer instead of using
         * ```element.innerHTML = "&nbsp;"``` ... it MUCH faster!
         * @return {Text}
         */
        function createNonBreakingSpace() {
            return document.createTextNode('\u00A0');
        }

        /**
         * Create text with Ellipsis content. This is a faster replacer instead of using ```element.innerHTML =
         * '&hellip;'``` ... it MUCH faster!
         * @return {Text}
         */
        function createEllipsis() {
            return document.createTextNode('\u2026');
        }

    	/**
    	 * TRCRbox UI implementation
    	 */
    	var TRCRBox = TRC.implClasses.TRCRBox = function(origin, options,/** @type TRC.Manager */ parent) {
    	// !! notice al configurations taken from the mode level in the constructor will not apply on ab-test modes (replaced by trc)
            this._id = Math.floor(Math.random() * 100000);
            this.fixHeight = options.height;
    		this.domain = parent.domain;
    		this.origin = origin;
    		/** @type Element */
    		this.header = false;
    		this.id = 'trc_' + this._id;
    		this.response = this.request = null;
    		__trcCopyProps(options, this); // from this pont all the configurations from loader.js are available
    		this.loaded = (this.loaded)?this.loaded:false;
    		this.element = null;
    		this.listContainer = null;
    		this.retryCount = 0;
    		this.drawList = false;
    		this.forceItemType = false;
    		/** @Type TRC.Manager */
    		this.trc = parent;
            this.util = TRC.util;
    		this.timeoutId = null;
    		this.errorHandler = "";
    		this.boxes = [];
    		this.recommendationList = null;
    		this.use_cdn = (this.trc.getProperty(this.mode_name, 'use-cdn-recommendations', this.propertiesOverride) === true);
    		this.postRenderQueue = new TRC['PostRenderQueue']();
    		this.src = null;
            this.fullEventItemsHash = {}; // hash list of all items for events - hash-id = item-id
    		this.isCssImportant = this.trc.getProperty(this.mode_name, "use-css-important", this.propertiesOverride);
    		this.publisher = TRC.publisherId;
    		this.smallIOSDevice = this.trc['small-ios-device'] || 'iPhone|iPod';
            this.isSmallIOS = (this.smallIOSDevice.indexOf(TRC.Device.deviceType) >= 0) ? true : false;
            this.isFeedCard = options.isFeedCard;
            this.enableFeedView = options.feedViewConfig || this.trc.global['enable-feed-view'] || false;
            this.iosLinkTarget =  this.trc.getProperty(this.mode_name, 'ios-sc-link-target-mode', this.propertiesOverride) || this.trc.global['ios-sc-link-target']; // link target configuration for sponsored items in ios small devices
            this.defaultLinkTarget = this.trc.global['link-target-conf'] || {'NAV': '_self', 'NT': '_blank', 'SP': '_blank'};
            this.linkTargetConf =(this.isSmallIOS && this.iosLinkTarget)? this.iosLinkTarget : this.trc['link-target-conf'];// link target configuration for sponsored items
            this.ntHandlerEnabled = this.trc.global['publisher-onclick-nt-enabled'];
            this.organicRedirParam = this.trc.global['organic-redirect-param'];
            this.shiftRedirOnclick = this.trc.global['shift-redir-onclick'];
            this.useRedirect = TRC.util.isAmp(TRC) ? this.trc.global['enable-organic-redirect-on-amp'] : this.trc.global['enable-organic-redirect'];
            this.useRedirectOnLink = this.trc.global['use-redirect-on-link'];
            this.adcItemTypes = this.trc.global['adchoice-item-types'] || {'is-organic': false, 'is-in-network': false, 'is-syndicated': true, 'is-native': true};
            this.sendClickPiggyBack = this.trc.global['send-pb-in-click'];
    		this.imagesAltUrls = this.trc.global['images-alt-urls'] || [];
    		this.disableResponsiveCSSReuse = this.trc.global['disable-responsive-css-reuse'];
    		this.disableViolationMeasurementOnPaywall = this.trc.global['disable-violation-measurement-paywall'] || false;
    		this.disableViolationSelectorOnPaywall = this.trc.global['paywall-violation-disabled-selector'] || null;
            this.rvVisibleTimeout = this.trc.global['display-rv-visible-timeout'] || null;
    		this.options = options;

            this.apiData = [];
    		this.lazyLoadImageObserversIds = [];
    		this.isMultiWidget = options.trcResponse && options.trcResponse.multiWidget;
            this.multiWidgetModeLevelData = this.isMultiWidget && options.multiWidgetModeLevelData;

    		if (TRC.util.isPercentEnabled(this.trc.global, 'custom-image-size-round-percent')) {
                this.customImageSizeRound = this.trc.global['custom-image-size-round-value'];
            }

    		return this;
    	},
        FETCH_PREFIX = imageUtils.constants.FETCH_PREFIX,
        HEIGHT_AND_WIDTH = "h_{h},w_{w}",
        IMAGE_URL_PREFIX = FETCH_PREFIX + "f_jpg%2Cq_80%2Ch_{h}%2Cw_{w}%2Cc_fill%2Cg_faces%2Ce_sharpen/",
        GIF_URL_PREFIX = FETCH_PREFIX + "fl_lossy%2Cf_gif%2Ch_{h}%2Cw_{w}%2Cc_fill%2Cg_faces:auto%2Ce_sharpen/",
        RTB_IMAGE_URL_PREFIX = FETCH_PREFIX + "$pw_{w}%2C$ph_{h}/t_tbl-cnd/",
        protocol = TRC.PROTOCOL;

      TRCRBox.prototype.DEFAULT_THUMB_RATIO = 0.8;

    	TRCRBox.prototype.getImageUrlPrefix = function () {
    		return IMAGE_URL_PREFIX;
    	};

    	/**
    	 * Create our "list-id"
    	 * @returns {String} valid list ID for this component. Supports origins (deprecated)
    	 * @type String
    	 */
    	TRCRBox.prototype.getListId = function() {
    	  if (!this.visible) {
          return 'rbox-tracking';
        }
    		return 'rbox-' + this.origin;
    	};

        /**
    	 * @returns {String} the session id from the trc response
         */
    	TRCRBox.prototype.getSessionId = function() {
    		if(!this.response || !this.response.trc) {
    			return null;
    		}
    		return this.response.trc['session-id'];
    	};

    	/**
    	 * Return the correct item type of this TRCRBox origin - whether we are using the page item type or the
    	 * one overridden by updateRecommendations()
    	 * @returns String item type
    	 */
    	TRCRBox.prototype.getItemType = function() {
    		if (this.forceItemType)
    			return this.forceItemType;
    		return this.trc.getItemType();
    	};

    	/**
    	 * Create the R-Box header
    	 * @returns {Element} header element
    	 * @type Element
    	 */
    	TRCRBox.prototype.generateHeader = function(wrapper) {
    		var widgetToFeedHelper = this.getWidgetToFeedHelper(),
    			headerDiv = document.createElement('div'),
                headerSpan = document.createElement('span'),
                headerPropValue = this.trc.getProperty(this.mode_name, 'header', this.propertiesOverride),
                rightHeaderPropValue = this.trc.getProperty(this.mode_name, 'header-right', this.propertiesOverride),
                hasRightHeader = rightHeaderPropValue !== "No Header";

            headerDiv.id = this.id.replace("trc_", "trc_header_");
            headerDiv.className = "trc_rbox_header trc_rbox_border_elm";
            headerSpan.className = "trc_rbox_header_span";
            this.generateHeaderIcon(headerSpan);

            headerDiv['ext'] = document.createElement('div');
            headerDiv['ext'].className = 'trc_header_ext';
            headerDiv.appendChild(headerDiv['ext']);

            if(hasRightHeader) { //two headers, in case that the property "header-right" was defined
                this.generateHeaderPart(headerSpan, headerPropValue, 'trc_header_left_column trc_header_left_part');
                this.generateHeaderPart(headerSpan, rightHeaderPropValue, 'trc_header_right_column trc_header_right_part');
            }else {             //normal flow - only one header
                var headerString = (headerPropValue !== 'No Header') ? headerPropValue : '';
                headerSpan.insertAdjacentHTML('beforeend',headerString);
            }

            headerDiv['titleBox'] = headerSpan;
            headerDiv.appendChild(headerSpan);

            if(widgetToFeedHelper && !widgetToFeedHelper.getHeader()) {
            	widgetToFeedHelper.addHeaderToFeed(headerDiv);
            } else {
                wrapper.appendChild(headerDiv);
            }

    		return headerDiv;
    	};

        TRCRBox.prototype.generateHeaderIcon = function(headerSpan) {
            var iconDiv,
                iconImg,
                iconURL,
                iconSource = this.trc.getProperty(this.mode_name, 'header-icon', this.propertiesOverride) || 'NONE';

            if (iconSource === 'CUSTOM') {
                iconURL = this.trc.getProperty(this.mode_name, 'header-icon-url', this.propertiesOverride);
            } else if (iconSource === 'PUBLISHER_LOGO') {
                // Fallback to network logo (if exists) in case of network solutions.
                iconURL = this.trc.getPublisherVersionPropertyWithFallbackToNetwork("publisher-logo");
            }

        	if (iconURL) {

    			iconImg = document.createElement('img');
                iconImg.className = 'trc_rbox_header_icon_img trc_img';
                iconImg.src = TRC.URL.prototype.switchProtocol.call(iconURL, protocol);

                iconDiv = document.createElement('div');
                iconDiv.className = 'trc_rbox_header_icon_div';
                iconDiv.appendChild(iconImg);

                headerSpan.appendChild(iconDiv);
                headerSpan.className += ' trc_rbox_header_icon_span';
    		}
        };

        /**
         * Creates an inner part of a header (e.g., when header should
         * be divided into "two headers"
         * @param container - the main container of the header
         * @param content - the content that should be appended to the span that holds this part
         * @param className - an additional class name for this part
         */
        TRCRBox.prototype.generateHeaderPart = function(container, content, className) {
            var innerHeaderSpan = document.createElement('span');
            innerHeaderSpan.className = 'trc_inner_header ' + (className || '');
    		innerHeaderSpan.insertAdjacentHTML('beforeend', content);
            container.appendChild(innerHeaderSpan);
        };

    	/**
    	 * Render the R-Box into the specified container
    	 * @param container DOM element into which to put the R-Box
    	 */
    	TRCRBox.prototype.render = function(container) {
    		this.element                = document.createElement("div");
            this.element.id             = this.id.replace("trc_", "trc_wrapper_");
            this.element.className      = "trc_rbox " + this.mode_name;
    		this.element.style.overflow = 'hidden';
            this.element.modeName =  this.mode_name;
    		container.appendChild(this.element);

    		this.element.style.display = "none"; // hide the R-Box until generateVisibleParts shows it

            if(this.trc.getProperty(this.mode_name, "has-expand-animation", this.propertiesOverride) === true) {
                new TRC.ExpandAnimationManager(this);
            }
    	};

        /**
         * return a full list(jsonfy) of items returned for a mode
         * @param {Object}modeResponse
         */
        TRCRBox.prototype.setTargetItemsList = function(hashList, itemList, state){
            if (!itemList) return;
            var i=0, len = itemList.length;

            for (; i<len; i++){
                hashList[itemList[i]['item-id']] = { // item id may be illegal key names in javascript (e.g. starting with "~")
                    'tii' :  itemList[i]['item-id'],
                    'tipt' : this.getProviderType(itemList[i]),
                    'tit': itemList[i]['type'],
                    'tids' : state
                };
            }
        };
        /**
         *
         * @param {Array} hashList
         * @returns {{fil: *}}
         */
        TRCRBox.prototype.getJsonTargetItemsList = function(hashList){
            var list = [],
                i;
            for (i in hashList){
               hashList.hasOwnProperty(i) && list.push(hashList[i]);
            }
            return list;
        };

        /**
         * get provider type shortcut
         * @param {Object} item
         * @returns {string}
         */
        TRCRBox.prototype.getProviderType = function(item, fullType){
            if (item["is-syndicated"]){
               return (fullType) ? 'sponsored' : "SP";
            } else if(item["is-in-network"]){
                return (fullType) ? "exchange" : "NT";
            } else if (item["is-native"]){
                return (fullType) ? "native" : "NAV";
            }
            return (fullType) ? "organic" : "RC";
        };
        /**
         * set custom item data for the event API
         * @param {object} video
         */
        TRCRBox.prototype.setApiItemsData = function (video){
            this.apiData.push({
                'url' : video.url,
                'slot' : video.itemIndex,
                'id' : video.id,
                'type' : this.getProviderType(video, true),
                'title' : video.title
            });
        };
        TRCRBox.prototype.isReadMoreDevice = function(config){
            var devices = config.split('|'),
                check = {
                  'smart_phone': TRC.dom.isSmartPhone(),
                  'tablet': TRC.dom.isTablet(),
                  'desktop': TRC.dom.isDesktop()
              };
            for(var i=0; i < devices.length; i++){
                if(devices[i] === 'all'){
                   return true;
                } else if(check[devices[i]]) {
                  return true;
                }
            }
            return false;
        };

    	/**
    	 * merge read more client properties configuration into one object
    	 * @returns {property|*|{}}
    	 */
    	TRCRBox.prototype.getReadMoreConfig = function() {
    		var conf = this.trc.getProperty(this.mode_name, 'read-more-config', this.propertiesOverride) || {};
    		conf.boxSelector = this.trc.getProperty(this.mode_name, 'read-more-box-selector', this.propertiesOverride);
    		conf.threshold = this.trc.getProperty(this.mode_name, 'read-more-threshold', this.propertiesOverride);
    		conf.minimizedSize = this.trc.getProperty(this.mode_name, 'read-more-minimized-size', this.propertiesOverride);
    		conf.caption = this.trc.getProperty(this.mode_name, 'read-more-caption', this.propertiesOverride);
    		conf.cutoffType = this.trc.getProperty(this.mode_name, 'read-more-cutoff-from-type', this.propertiesOverride);
    		conf.anchorSelector = this.trc.getProperty(this.mode_name, 'read-more-anchor-selector', this.propertiesOverride);
    		conf.lengthFromAnchorElementType = this.trc.getProperty(this.mode_name, 'read-more-cutoff-length-type', this.propertiesOverride);
    		conf.lengthFromAnchorElement = this.trc.getProperty(this.mode_name, 'read-more-cutoff-length-from-anchor-element', this.propertiesOverride);
            conf.modeDevices = this.trc.getProperty(this.mode_name, 'read-more-mode-devices', this.propertiesOverride);

    		return conf;
    	};

    	TRCRBox.prototype.isNoRecommendationsMode = function() {
    		return this.getListId() == 'rbox-tracking' || this.mode_name === 'rbox-only-video';
    	};


        TRCRBox.prototype.calcModeName = function (response, pushed_mode_name) {
            var mode_name, testVariant;
            // Change this.mode_name to the name of base_mode or ab_test according to:
            //
            //	1. If there is a base_mode AND a test_variant in the response -
            //		The mode_name would be "ab_(base_mode_name)_(test_variant_name)"
            //
            //	2. If there is only a base_mode in the response -
            //		The mode_name would be "(base_mode_name)"
            //
            //	3. If there is only a test_variant in the response -
            //		The mode_name would be "ab_(mode_name_from_push)_(test_variant_name)"
            //
            //	4. If none of the above -
            //		The mode_name would be "(mode_name_from_push)"

            if(TRC.TRCParser.IsBaseModeAndABModeExist(response)) {
                return TRC.TRCParser.parseBaseModeAndABModeName(response);
            } else if (mode_name = TRC.TRCParser.parseBaseModeName(response)) {
                return mode_name;
            } else if(testVariant = TRC.TRCParser.parseTestVariant(response)) {
                TRC.pConsole(this.mode_name, "info", "test variant = " + testVariant);
                return TRC.TRCParser.parseABModeName(pushed_mode_name, response);
            }
        };

    	/**
    	 * Response handler that recieves the server's data
    	 * @param response {Object} server response
    	 */
    	TRCRBox.prototype.loadScriptCallback = function(cacheKey, response) {

            this.propertiesOverride = this.getPropertiesOverride(response);

            this.isProviderIframe = this.trcResponse && this.trcResponse.hasOwnProperty('ifr') && this.trcResponse.ifr;
            this.isDisplayToNative = this.isProviderIframe && this.trc.shouldRenderBannerAsNative(this);
            if(DisplayInSlotManager.isResponseHasDisplayInSlotItem(this.trcResponse)){
                this.displayInSlotManager = new DisplayInSlotManager(this.trcResponse);
                this.isExistDisplayInSlot = this.displayInSlotManager.isExistDisplayInSlot();
            }

    		var method_signature = 'TRCRBox.loadScriptCallback' + '(retry=' + this.retryCount + ')',
    			trc = response.trc, calc_mode_name,
    			isDNT = this.response && this.response.trc['DNT'] && this.response.trc['DNT'].toUpperCase() === 'TRUE',
                TRCParser = TRC.TRCParser,
    			// ***** NOTE: DO NOT use this.trc.getProperty(this.mode_name, ...) here to assign values for variables
                // ***** since this.mode_name may change later to ab_mode-name_test variant, and the value remain from the base mode.
                // ***** values should be assigned after the part in the code that switches the mode name (later in this function)
    			isAutoSize,
    			modeHasThumbs,
                postData,
    			utmParams,
            	thumbnailPosition = this.trc.getProperty(this.mode_name, 'thumbnail-position', this.propertiesOverride);

    		__trcDebug('Enter ' + method_signature);

    		this.abortRequest(); // clean up after the request

    		this.utm = this.requestTime && [this.requestTime,  ((new Date()).getTime() - TRC.utm.start)];

    		// detect load errors
            if(cacheKey){
                this.trc.trcCache.cacheResponse(cacheKey, response, TRC.pageManager.state.moreDispatchParams);
                this.trc.cachedResponses[cacheKey] = true;
            }

    		// check validity of response
    		if (!this.isValidResponse(trc)) {

    			__trcError('Exit ' + method_signature + ': request format error');
                var placement = this.response.feedPlacement || this.placement;
                TRC.dispatch('onRboxFlowError', {placement:placement});
                TRC.EventsAPI.dispatchNoContent(this.trc.NO_CONTENT.noItems, this.placement, this.isFeedCard);
    			return;
    		}

            TRC.UserIdMerger.notifyPossibleUserChange(this.trc, TRC.publisherId, trc['user-id'], trc['session-data']);
    		// collect request meta-data from response object
            if (!trc['consent-missing']) {
                TRC.pageManager.storePublisherValue(TRC.publisherId, 'session-data', trc['session-data']);
            }

    		if (response.trc['DNT'] && response.trc['DNT'].toUpperCase() === 'TRUE') {
    			TRC.doNotTrack = true;
    			TRC.pageManager.removeAllKeys();
                TRC.pageManager.removeUserId();
    		} else {
    			// store the user-id localy
                TRC.pageManager.storeUserId(trc['user-id'], trc['consent-missing']);
    		}

    		if (this.drawList) { // but list was already created
    			// complain and leave
    			__trcWarn('Exit ' + method_signature + ': got another response after already drawing');
    			return;
    		}

    		// successfully loaded recommendations
    		this.response = response; // keep my response
            if(this.isResponseFromCache()){
                this.cachedViewId = this.response.cachedViewId;
            }
            //set items in hash list to "a" status = "available"
            this.setTargetItemsList(this.fullEventItemsHash, trc['video-list'].video, "a");
            postData = new TRC.PlacementEventPostData();
            postData.setFullItemList(this.getJsonTargetItemsList(this.fullEventItemsHash));
    		utmParams = this.createUtmParam();
    		//merge yield order if existing
    		if(this.modeGroupOrder !== undefined){
    			this.util.merge(utmParams,{mgo: this.modeGroupOrder});
    		}

    		var availableEventCoordinator = TRC.availableEventCoordinator.get(this.trc);
            var cancelSendAvailableDueToLazyRendering = this.response && this.response.trc && availableEventCoordinator.availableReportedPlacements
                .indexOf(this.response.trc.placement) > -1;

            this.isResponsive = this.trc.getProperty(this.mode_name, 'mode-is-responsive', this.propertiesOverride);

    		this.recommendationList = this.isMultiWidget
                ? this.multiWidgetRecItems.splice(0, this.getCurrentListSize())
                : (trc['video-list'].video || []);

            var isInjectedCard = this.placement.indexOf('Injected') > -1;
            var hasRecommendation = this.recommendationList.length > 0;
            var isUIMode = !this.isNoRecommendationsMode();
            var noItemsInResponse = isUIMode && !hasRecommendation;

            if (noItemsInResponse) { // no videos in real mode
                if(!isInjectedCard){
                    __trcError('Exit ' + method_signature + ': no items in response - ' + this.mode_name);
                }
                this.handleNoItemInResponse(trc, method_signature, cancelSendAvailableDueToLazyRendering, utmParams, postData);
                return;
            }

            if (this.isProviderIframe || this.isExistDisplayInSlot) {
                TRC.listen('available::' + this.placement + this.trc.getItemSignature(this.trcResponse), function(event) {
                    var displayInSlotData = this.displayInSlotManager && this.displayInSlotManager.getDisplayInSlotItemData();
                    var config = displayInSlotData ? displayInSlotData.ifrObj.config : this.trcResponse.config;
                    if (config["send-events"] !== false) {
                        if(!cancelSendAvailableDueToLazyRendering) {
                            if(displayInSlotData){
                                this.displayInSlotManager.sendAvailableEvent(this, utmParams, postData);
                            }
                            else {
                                this.sendAvailableEvent(utmParams, postData, false, true);
                            }
                        }

                        if (trc['video-list'].video) {
                            var currVideo = displayInSlotData || trc['video-list'].video[0];
                            if (currVideo && currVideo.rv && currVideo.rvpm) {
                                var rvAvailableParams = {rvpm: currVideo.rvpm};
                                this.util.merge(rvAvailableParams, utmParams);
                                this.sendRequiredViewabilityAvailableEvent(rvAvailableParams, postData, currVideo['item-id']);
                            }
                        }
                        var setInViewportIntersection = function() {
                            TRC.intersections.isInViewPort({
                                targetElement: event.container,
                                enableDelayedVisibilityCheck: true,
                                onTrigger: (function () {
                                    if (this.recommendationList.length) {
                                        this.visibilityReporter.calculateVisibleItems(null, true, this.recommendationList);
                                    }
                                    this.visibilityReporter.reportVisibility();
                                }).trcBind(this)
                            });
                        };
                        this.visibilityReporter = new TRC.WidgetVisibilityReporter(this);
                        if (currVideo && currVideo.rv && currVideo.rvpm && this.rvVisibleTimeout) {
                            setTimeout(function () {
                                setInViewportIntersection.call(this);
                            }.trcBind(this), this.rvVisibleTimeout);
                        } else {
                            setInViewportIntersection.call(this);
                        }
                        this.registerProviderClicks(this.recommendationList);
                    }
                    var isItemLevel = Boolean(displayInSlotData);
                    var idList = displayInSlotData ? this.displayInSlotManager.getDisplayInSlotItemsIds() : null;
                    this.sendPlacementTrackingPixelsOnce('i', idList, isItemLevel);
                }.trcBind(this));
                if(this.isExistDisplayInSlot && !cancelSendAvailableDueToLazyRendering){
                    var nativeItemsPostData = postData.getSpecificItemsPostData(this.displayInSlotManager.getNativeItemsIds());
                    this.sendAvailableEvent(utmParams, nativeItemsPostData, false, true);
                }
            } else {
                if(!cancelSendAvailableDueToLazyRendering) {
                    this.sendAvailableEvent(utmParams, postData, false, false);
                }
            }

            var rtbWinExist = this['rtb-win'];
            if (rtbWinExist) {
                var eventEndPoint = rtbWinExist['ep'];
                if (eventEndPoint) {
                    this.sendEvent(eventEndPoint, rtbWinExist);
                } else {
                    this.sendEvent('rtb-win', rtbWinExist);
                }
            }

            this.itemsTypes = this.getItemsTypesList(this.recommendationList); // cahce a list of the items type for this mode
            this.privacyId = this.getPrivacyId(this.recommendationList);

            this.orig_name = this.mode_name;
            this.orig_placement = this.placement;

    		//we have recommendations - send external impression tracking
            if (!this.isProviderIframe) {
                if(this.isExistDisplayInSlot){
                    var nativeItemsIdArr = this.displayInSlotManager.getNativeItemsIds();
                    this.sendPlacementTrackingPixelsOnce('i', nativeItemsIdArr, true);
                } else if(this.trc.global["enable-rv-available"]){
                    this.handleAvailableTrackingPixels();
                } else {
                    this.sendPlacementTrackingPixelsOnce('i');
                }
            }

            calc_mode_name = this.calcModeName(response.trc, this.mode_name);
            this.changeModeName(calc_mode_name, true, 'mode - ' + calc_mode_name + ' has no config :- fallback - ' + this.mode_name);

    		// add test to see if selected mode is loaded
    		if(!this.isProviderIframe && !this.isNoRecommendationsMode() && typeof this.trc.modes[this.mode_name] == "undefined"){
    		    __trcError("TRCRBox.loadScriptCallback: Mode name '" + this.mode_name + "' doesn't exist in configuration file ");
    			return;
    		}

    		//Get mode properties used for drawing box pathway decisions
    		isAutoSize = this.trc.getProperty(this.mode_name, 'auto-size', this.propertiesOverride);
            modeHasThumbs = this.trc.getProperty(this.mode_name, 'thumbnail-position', this.propertiesOverride) != 'none';
            this.useNativeLineClamp = TRC.Browser.compatibility.lineClamp && !this.trc.getProperty(this.mode_name, 'details-inline-with-title', this.propertiesOverride)
    			&& this.trc.getProperty(this.mode_name, 'use-browser-line-clamp', this.propertiesOverride);
            this.widgetCreatorLayout = this.trc.getProperty(this.mode_name, 'widget-creator-layout',this.propertiesOverride);
            this.isWCTextLinks = this.widgetCreatorLayout === 'autowidget-template-text-links';
            this.isCarousel = this.trc.getProperty(this.mode_name, 'navigation-type', this.propertiesOverride) === "scrolling";
            // this is temp fix fo lazy load in vignette DEV-112784, Vignette - Improve loading performance of the Vignette interstitial
            if(this.trc.global["vignette-lazy-load"] && VignetteManager && VignetteManager.isDrawingVignette(this.placement)){
                this.shouldLazyLoadImages = false;
            } else {
                this.shouldLazyLoadImages = this.trc.getProperty(this.mode_name, 'has-thumbs-image-lazy-load', this.propertiesOverride) || this.trc.global["thumbnail-image-lazy-load"];
            }
            this.link_target = this.link_target || this.trc.getProperty(this.mode_name, 'link-target') || 'normal';

    		__trcDebug('Exit ' + method_signature + ': success');
            this.drawList = true;

            //set 'read-more' configurations
            this.hasReadMore = (this.trc.disableReadMore === true) ? false : this.trc.getProperty(this.mode_name, 'enable-read-more', this.propertiesOverride);// 'enable-read-more' on the publisher level is a for shutting off the feature for all modes
            this.readMorePageConfig = this['read_more'] || {}; // publisher can configure the read more through push API
            this.readMoreConfig = this.getReadMoreConfig();
            this.readMoreDevices = this.trc.getProperty(this.mode_name, 'read-more-mode-devices', this.propertiesOverride) || this.trc['read-more-devices'];

            if(this.getWidgetToFeedHelper()) {
            	this.getWidgetToFeedHelper().applyWidgetHeaderAndFooterStylesToFeed(this.mode_name);
    		}

            this.callPreRenderHooks();
            //reporting pending archive mode
            if (this.trc.getProperty(this.mode_name, 'pending-archive')){
                TRC.modDebug.logMessageToServer(0,'PENDING_ARCHIVE_MODE_ERROR[' + this.mode_name + ']',{ 'event-type': 'ARCHIVE_MODE_ERROR'});
    		}

            if(TRC.setReadMore && this.hasReadMore && this.isReadMoreDevice(this.readMoreDevices)){
                if(TRC.isOptim('defer-read-more')) {
                    setTimeout(function(){TRC.setReadMore(this);}.trcBind(this),0);
                } else {
                    TRC.setReadMore(this);
                }

            } else {
                TRC.EventsAPI.readmore('none', this.response && this.response.trc);
            }

            if(!this.trc.yieldingEnabled){
    			this.trc.totalModeCounter++;
    		}

    		var NO_TIME = null;
            try{
                this.reqId = this.response.trc.req;
            } catch (err) {
                this.reqId = -1;
            }
    		(TRC.performance && TRC.performance.mark("7.0.1." + this._id, NO_TIME, this.mode_name, this.reqId,'rendering',TRC.PerfEvenType.REQ_LEVEL_START));

    		if (this.container) { // SPY widget;
                this.container.setAttribute('data-placement-name', this.placement);
            }
            if ( !this.isProviderIframe || this.isDisplayToNative) {
              if(TRC.CategoryCard.enableCategoryCard(this)) {
                this.categoryCard = new TRC.CategoryCard(this);
              }

                // take the "responsive path"..
                if (this.isResponsive && !this.isWCTextLinks) {
                    this.generateResponsiveOuters(this.element);
    				this.drawResponsiveList(trc, postData, utmParams);
                    this.postHandleRecommendationsResponseData(trc, response, thumbnailPosition, modeHasThumbs, isDNT, NO_TIME);
                } else if(response.trc.mode === 'rbox-only-video') {
                    this.postHandleRecommendationsResponseData(trc, response, thumbnailPosition, modeHasThumbs, isDNT, NO_TIME);
                    this.postRender();
    			} else {
                    /*
                     * Check whether this mode is auto-size. If so, try to protect from cases
                     * where the main container does not have width, otherwise the mode will be rendered according to the
                     * width that the container is getting after generateVisibleParts() and the autosize code will
                     * miscalculate the number of cubes.
                     */
                    if (isAutoSize && this.container && this.container.clientWidth == 0) {
                        this.container.style.width = '100%';
                    }

                    TRC.ModuleLoader.load('non-responsive-widget', this.drawListBody, (function () {
                        this.generateVisibleParts();
                        this.drawListBody(trc);
                        this.postHandleRecommendationsResponseData(trc, response, thumbnailPosition, modeHasThumbs, isDNT, NO_TIME);
                    }).trcBind(this));
                }
            }
    	};

        TRCRBox.prototype.handleNoItemInResponse = function(trc, methodSignature, cancelSendAvailableDueToLazyRendering, utmParams, postData){
            TRC.EventsAPI.dispatchRender(trc);
            this.abortRendering();
            //send available event anyway
            if(!cancelSendAvailableDueToLazyRendering) {
                this.sendAvailableEvent(utmParams, postData, true, false);
            }
            var placement = this.response.feedPlacement || this.placement;
            TRC.dispatch('onRboxFlowError', {placement:placement});
            TRC.EventsAPI.dispatchNoContent(this.trc.NO_CONTENT.noItems, this.placement, this.isFeedCard);
        };

        TRCRBox.prototype.isValidResponse = function (trc) {
            return (trc && trc['video-list'] && trc['video-list'].video) || (this.isProviderIframe || this.isExistDisplayInSlot);
        };

    	TRCRBox.prototype.getPropertiesOverride = function(response){
            if(response.trc && response.trc['video-list']){
                if(this.isMultiWidget){
                    return this.multiWidgetModeLevelData && this.multiWidgetModeLevelData['properties-override'];
                } else {
                    return response.trc['video-list']['properties-override'];
                }
            }
        };

        TRCRBox.prototype.handleAvailableTrackingPixels = function() {
            try{
                var videosArray = this.response.trc['video-list'].video;
                var regularAvailableIds = [];
                this.rvAvailableIds = [];

                for(var i = 0; i < videosArray.length; i++){
                    var currVideo = videosArray[i];
                    if(currVideo.rv && currVideo.rvpm){
                        this.rvAvailableIds.push(currVideo['item-id']);
                    } else {
                        regularAvailableIds.push(currVideo['item-id']);
                    }
                }

                if(this.rvAvailableIds.length > 0){
                    if(regularAvailableIds.length > 0){
                        this.sendPlacementTrackingPixelsOnce('i', regularAvailableIds);
                    }
                } else {
                    this.sendPlacementTrackingPixelsOnce('i');
                }
            } catch(e){
                __trcWarn('Handle RvAvailable TrackingPixels error: ', e);
            }
        };

        TRCRBox.prototype.postHandleRecommendationsResponseData = function(trc, response, thumbnailPosition, modeHasThumbs, isDNT, NO_TIME) {
            if(this.shouldLazyLoadImages) {
                this.lazyLoadViewportMarginThreshold = this.trc.getProperty(this.mode_name, 'thumbs-image-lazy-load-margins', this.propertiesOverride) || this.trc.global["thumbs-image-lazy-load-margins"] || '600px 1500px 600px 1500px';

                if (this.isCarousel && thumbnailPosition !== 'none') {
                    this.createCarouselContainerImgLazyLoadObserver();
                }
            }

            if(TRC.RecommendationReel.shouldInitRecommendationReel(this)) {
              new TRC.RecommendationReel(this);
            }

            (TRC.performance && TRC.performance.mark("7.0.9." + this._id, NO_TIME, this.mode_name, this.reqId, 'rendering', TRC.PerfEvenType.REQ_LEVEL_STOP));

            TRC.dispatch('trcContentReady', {container: this.container, trcbox: this});

            //video tag ad unit loading
            if(trc && trc['video-list'] && trc['video-list'].vtag && this.trc['mode-before-video-load'](this)) {
                //TRC.performance && TRC.performance.mark("10.0.1." + this._id);
                (TRC.performance && TRC.performance.mark("10.0.1." + this._id, null, "videotag", "", 'videoTagLoad', TRC.PerfEvenType.START));
                var videoTagOptions = {
                    placement: this.placement,
                    container: this.container
                };
                this.videoTagLoader = new TRC.VideoTagLoader(this.trc, trc['video-list'].vtag, videoTagOptions, this,this.response.trc);
                this.videoTagLoader.loadVideo();
                (TRC.performance && TRC.performance.mark("10.0.9." + this._id, null, "videotag", "", 'videoTagLoad', TRC.PerfEvenType.STOP));
            }

            // this is a v2 way of calling, we didn't pass through handleLoadResponse
            // so we need to call spotlight
            try {
                TRC.SpotlightLoader.registerOnMainContainer(this.container, response);
                TRC.SpotlightLoader.load(this.response);
            } catch (e) {
                __trcError("Error while trying to load Spotlight");
            }

            //initialize "User Ad Choice" - only if all conditions are met
            if(this.shouldInitRTBUserAdChoice(modeHasThumbs, isDNT)) {
                TRC.ModuleLoader.load('user-adchoice', TRC.userAdChoice, this.initRTBUserAdChoice.trcBind(this));
            }

            //initialize Taboola Choice ("User X") - only if all conditions are met
            if(this.shouldInitTaboolaChoice(modeHasThumbs, isDNT)) {
                TRC.ModuleLoader.load('userx', TRC.userX, this.initTaboolaChoice.trcBind(this));
            }

            if(this.shouldInitSliderManager()) {
                TRC.RBoxUsage.logUsage('Init Escalator');

                TRC.ModuleLoader.load('slider', TRC.SliderManager, (function () {
                    new TRC.SliderManager(this);
                }).trcBind(this));
            }
        };

    	TRCRBox.prototype.shouldInitTaboolaChoice = function(modeHasThumbs, isDNT) {
    		var taboolaChoiceEnabled = this.trc.global['has-userx'] && this.trc.getProperty(this.mode_name, 'mode-has-userx', this.propertiesOverride);
    		var isNextUp = this.options && this.options.trcResponse && !!this.options.trcResponse.nup;

            TRC.pConsole(this.mode_name, "info", "has user X = " + taboolaChoiceEnabled, "");

            return taboolaChoiceEnabled					//only if feature is set to "on" in publisher level and in mode level
                && modeHasThumbs 						//only when the mode has thumbnails (e.g. mode is not text-links)
                && !isDNT 								//only if user has not sent a "do not track" request
                && !TRC.Device.isTouchDevice 			//feature should be off for touch devices
                && !TRC.SpotlightLoader.loadedScript    //feature should be off in case spotlight is loaded
                && !isNextUp                            //feature should be off in case NextUp enabled
        };

    	TRCRBox.prototype.initTaboolaChoice = function() {
            //init userX in the page level - if not initialized yet
            if(TRC.userX && !TRC.userX.isInitialized) {
                try { //prevent userX failure from failing the loading of the mode
                    TRC.userX.init(this.trc);
                } catch(e) {
                    __trcDebug('failed to init Taboola Choice', e);
                }
            }

            //init userX for the specific mode
            try { //prevent userX failure from failing the loading of the mode
                TRC.userX.initForMode(this);
            } catch(e) {
                __trcDebug('failed to init Taboola Choice for mode ' + this.mode_name);
            }
        };

    	TRCRBox.prototype.shouldInitRTBUserAdChoice = function(modeHasThumbs, isDNT) {
    		return this.trc.global['show-rtb-ad-choices-icon']                  //only with feature flag show-rtb-ad-choices-icon turned on
                && modeHasThumbs 												//only when the mode has thumbnails (e.g. mode is not text-links)
                && !isDNT 														//only if user has not sent a "do not track" request
                && !TRC.SpotlightLoader.loadedScript							//feature should be off in case spotlight is loaded
    			&& this.recommendationList && this.recommendationList.some(function (recommendation) {     //only if there is a relevant RTB recommendation (has RTB AdChoices link)
    				return recommendation.plink;
    			});
    	};

    	TRCRBox.prototype.initRTBUserAdChoice = function() {
            //init userAdChoice in the page level - if not initialized yet
            if(!TRC.userAdChoice.isInitialized) {
                try { //prevent userAdChoice failure from failing the loading of the mode
                    TRC.userAdChoice.init();
                } catch(e) {
                    __trcDebug('failed to init RTB Choice');
                }
            }

            //init userAdChoice for the specific mode
            try { //prevent userAdChoice failure from failing the loading of the mode
                TRC.userAdChoice.initForMode(this);
            } catch(e) {
                __trcDebug('failed to init RTB Choice for mode ' + this.mode_name);
            }
    	};

    	TRCRBox.prototype.shouldInitSliderManager = function() {
    		return (this.slider === true || this.trc.getProperty(this.mode_name, 'slider', this.propertiesOverride) === true)
    			&& this.trc.slider !== false;
    	};


        TRCRBox.prototype.callPreRenderHooks = function(){
            var mHook = this.trc.getProperty(this.mode_name,'mode-start'),
                pubHook = this.trc['mode-pub-start'];

            try{
                if(typeof  pubHook === 'function'){
                    pubHook(this, this.container);
                    TRC.CustomModulesManager.runHook('mode-pub-start',null, this, this, this.container);
                }
                if(typeof  mHook === 'function'){
                    mHook(this, this.container);
                }
            } catch (e){
                __trcError("Error in pre rendered hooks - " + e.message);
            }
        };

        TRCRBox.prototype.registerProviderClicks = function(recommendationList) {
            var video;
            for (var i=0; i <recommendationList.length; i++ ){
                video = recommendationList[i];
                TRC.listen('click::' + this.placement, (function(){
                    if(this.isExistDisplayInSlot){
                        video = this.displayInSlotManager.getDisplayInSlotItemData();
                    }
                    this.reportClick(video, {
                        it : video.type,
                        ii : video['item-id'],
                        p : (video["is-syndicated"]) ? video.publisher:'',
                        li : this.getListId()
                    }, null, false);
                    this.trc.sendExternalTracking(this.getAllExternalTrackingURLsList()['c']);
                }).trcBind(this));
                break; // currently supporting one click for all items
            }
        };

    	/**
    	 * Changing the name of the mode, according to the argument
    	 * If the new name not found in the trc.modes and the isWarning flag on warning 'msg' is returned
    	 * @param newModeName
    	 * @param isWarning
    	 * @param msg
         */
    	TRCRBox.prototype.changeModeName = function(newModeName, isWarning, msg) {
    	    if(!newModeName) return;
    		if(typeof this.trc.modes[newModeName] != 'undefined') {
    			this.mode_name = newModeName;
    			this.element.className = "trc_rbox" + " " + this.mode_name;
    		} else if(this.trc.global['send-variant-warning']) {
    			if(isWarning) {
    				__trcWarn(msg);
    			} else {
    				__trcDebug(msg);
    			}
    		}
    	};

    	/**
    	 * Abort a running request by removing the JSON script tag
    	 */
    	TRCRBox.prototype.abortRequest = function() {
    		if (this.timeoutId) {
    			TRC.Timeout.clear(this.timeoutId);
    			this.timeoutId = null;
    		}
    		if (!this.request)
    			return;
    		this.request.parentNode.removeChild(this.request);
    		this.request = null;
    	};

    	/**
    	 * Abort the rendering process of the R-Box by removing any remaining rendered elements
    	 * and calling the error handler
    	 */
    	TRCRBox.prototype.abortRendering = function() {
    		var method_signature = 'TRCRBox.abortRendering' + '(retry=' + this.retryCount + ')';
    		__trcDebug('Called ' + method_signature);

    		this.drawList = true;
    		switch(typeof this.errorHandler) {
                case "string":
                    if(this.listContainer != null ){
                        this.listContainer.appendChild(document.createTextNode("Error getting recommendations: "
                            + this.errorHandler));
                    }
                    return;
                case "function":
                    this['errorHandler']();
                    return;
            }
    	};


    	/**
    	 * Retrieves the DOM element provided to the render() method
    	 * @returns DOM element that contains the R-Box
    	 * @type Element
    	 */
    	TRCRBox.prototype.getContainer = function() {
    		return this.element.parentNode;
    	};

    	/**
    	 * Send an event for this R-Box with the specified type and additional parameters.
         *  The implementation internally provides all available state parameters such as request ID.
    	 * @param {String}      type Event type to send
    	 * @param {Object}      params property list with additional parameters to send
    	 * @param {Boolean}     once optionally use log1 to send the event
    	 * @param {Function}    callback optionally trigger this callback after the event is received by the server
         * @param timeout       (optional)
    	 */
    	TRCRBox.prototype.sendEvent = function(type, params, postParams, once, callback, timeout, shouldUseBeacon) {
            var wasCalled = false,
    			template = this.trc.formattedTRCRequest && this.trc.formattedTRCRequest.tmpl,
    			placementGroup = this.response.trc['placement-group'],
    			responseSessionData = (this.response && this.response.trc) ? this.response.trc['session-data'] : null,
    			eventParams = {
    				ri : this.response ? this.response.trc['req'] : null,
                    sd : this.trc.getSessionData(responseSessionData),
    				ui : TRC.pageManager.getUserId(),
    				pi : this.trc.getItemId(),
    				wi : this.response ? this.response.trc['watched-item'] : null,
    				pt : this.getItemType(),
    				vi : this.cachedViewId || TRC.pageManager.getPageData(),
    				li : this.getListId()
    			},
    			passedCallback = function() {
    				if (wasCalled){
    					return;
    				}
    				wasCalled = true;
    				if (callback) {
    					callback();
    				}
    			};
            if(this.isResponseFromCache()){
                eventParams.cache = '1';
            }
            if(this.trc.formattedTRCRequest && this.trc.formattedTRCRequest.ad) {
                eventParams.ad = __trcJSONify(this.trc.formattedTRCRequest.ad);
    		}
            if(this.trc.systemFlags && this.trc.systemFlags.loaderType !== 'normal') {
                eventParams.lt = this.trc.systemFlags.loaderType;
            }
            //currently we end trc piggyback parameters(ppb, cpb) on visible post events only
            if (this.response.trc && ((this.trc.global['tmp-use-pb-params'] && this.trc.configForPostEvent[type]) || (type === 'click' && this.sendClickPiggyBack))) {
                if (this.response.trc['ppb']) {
                    params.ppb = this.response.trc['ppb'];
                }
                if (this.response.trc['cpb']){
                    params.cpb = this.response.trc['cpb'];
                }
                if (this.response.trc['prty']){
                    params.prty = this.response.trc['prty'];
                }
                if (this.response.trc['caty']){
                    params.caty = this.response.trc['caty'];
                }
            }
            if(type == "click" && params.prt == "nt"){ //this is a network item click event that has is predefined params
                eventParams = {};
            }

            if(template) {
            	eventParams.tmpl = template;
            }
            if(placementGroup) {
            	eventParams.pg = placementGroup;
            }
    		__trcCopyProps(params, eventParams);

            if(once){
                TRC.pConsole(this.mode_name, "info", "sending event type : " + type, eventParams, "object");
                this.trc.log1(type, eventParams, postParams, passedCallback, this.placement, shouldUseBeacon);
            } else {
    			this.trc.logTrcEvent(type, eventParams, postParams, passedCallback, null, shouldUseBeacon);
    		}
    		var NO_TIME = null;
    		(TRC.performance && type == 'visible' && TRC.performance.mark("11.0." + this._id, NO_TIME, this.mode_name, this.reqId, 'visible',TRC.PerfEvenType.MARK));
    		if (typeof timeout == 'number') {
    			TRC.Timeout.set(passedCallback,timeout);
    		}
    	};

    	/**
    	 * Start to draw this R-Box by loading recommendations if we have all the request data
    	 * @param errorHandler callback method to invoke if the R-Box content failed to load
    	 */
    	TRCRBox.prototype.load = function(errorHandler) {
            this.errorHandler = errorHandler;

            if (this.loadRBoxRequestFailed) {
    			__trcError("loadRBox failed, aborting.");
    			this.abortRendering();
    			return;
            }

            var request = {};
            request[this.placement] = this;
            this.loadScriptCallback(null, this.response);
            this.detectBids();
            this.measureDistanceFromArticle();
            this.searchArticleAndFeedAreaForElements();
            this.takePageScreenshot();
    	};

        TRCRBox.prototype.detectBids = function() {
            if (TRC.util.isPercentEnabled(this.trc.global, 'enable-bid-detection')) {
    			TRC.ModuleLoader.load('bid-detection', TRC.BidDetection, (function () {
    				if (TRC.bidDetector) {
    					return;
    				}

    				TRC.bidDetector = new TRC.BidDetection(this.response.trc);
    				TRC.bidDetector.detect();
    			}).trcBind(this));
    		}
        };

    	/**
    	 *
    	 * @returns true/false boolean to measure events
    	 */
    	TRCRBox.prototype.isDistanceViolationEnabled = function() {
            /**
             *
             * @returns send paywallSelector event
             */
            var paywallSelectorEvent = function() {
                if (!TRC.isPaywallSelectorEventSent) {
                    var requestData = {
                        event_type: 'PAYWALL_BY_SELECTOR', event_state: 'REPORTED', event_value: true
                    };
                    TRCImpl.sendEvent('supply-feature', {d: JSON.stringify(requestData)}, null);
                    TRC.isPaywallSelectorEventSent = true;
                }
            };
            if (TRC.dom.isInIframe()) return false;
    		if (TRC.util.isRboxEncapsulated(TRC)) return false;
    		if (TRC.util.isTrue(this.trc.paywall) && this.disableViolationMeasurementOnPaywall) return false;
    		if (document.querySelector(this.disableViolationSelectorOnPaywall)) {
    			paywallSelectorEvent();
    			return false;
    		}
    		if (TRC.util.isPercentEnabled(this.trc.global, 'enable-distance-from-article')) return true;
    		return false;
    	};

        TRCRBox.prototype.measureDistanceFromArticle = function() {
    		if (this.isDistanceViolationEnabled()) {
    			TRC.ModuleLoader.load('distance-from-article', TRC.DistanceFromArticle, (function() {
    				TRC.DistanceFromArticle.measureAndReport(this.trc.global['distance-violation-minimal-article-text-percentage']);
    			}).bind(this));
    		}
            try {
                if(!TRC.util.isRboxEncapsulated(TRC) && !TRC.dom.isInIframe() && TRC.util.isPercentEnabled(this.trc.global,'monitor-article-distance-from-feed-percentage')) {
                    TRC.ModuleLoader.load('distance-from-article', TRC.DistanceFromArticle, (function() {
                        const supplyFeatureEvent = TRC.util.sendSupplyFeature.trcBind(TRC.util);
                        TRC.DistanceFromArticle.reportArticleDistanceFromFeed(supplyFeatureEvent);
                    }).bind(this));
                }
            } catch (e) {
                __trcError('Error in TRCRBox.measureDistanceFromArticle', e);
            }

        };

        TRCRBox.prototype.searchArticleAndFeedAreaForElements = function() {
            if (TRC.util.isPercentEnabled(this.trc.global, 'article-and-feed-area-scanner-report-percentage')) {
                TRC.ModuleLoader.load('article-and-feed-area-scanner', TRC.ArticleAndFeedAreaScanner, (function () {
                    TRC.ArticleAndFeedAreaScanner.initScanner();
                }).bind(this));
            }
        };

        TRCRBox.prototype.takePageScreenshot = function() {
    		if ((!TRC.util.isRboxEncapsulated(TRC)) && TRC.util.isPercentEnabled(this.trc.global, 'screenshot-capture-enabled')) {
                TRC.ModuleLoader.load('screenshot-capture', TRC.screenshotCaputre, (function () {
                    TRC.screenshotCaputre.init(document.body, {
                        keepImages: true
                    });
                }).trcBind(this));
            }
        };

        /**
         *
         * @param {object} innerRects - rectangle object of the widget (that may reside in an iframe for example)
         * @param {object} rects - rectangle object of the outter container (an iframe that contains the widget for example)
         * @returns {object} calculated rectangle object for the widget reffrencing the true device viewport
         */
        TRCRBox.prototype.getBoundingClientRect = function(innerRects, rects){
            if (rects){
                var newRect = {
                    left  :rects.boundingClientRect.left + innerRects.left,
                    right : rects.boundingClientRect.right + innerRects.left,
                    top : rects.boundingClientRect.top + innerRects.top,
                    bottom : rects.boundingClientRect.top + innerRects.bottom, // assuming the entire widget is in the ads viewport
                    width : rects.boundingClientRect.width,
                    height : rects.boundingClientRect.height
                };
                return newRect;
            }
            return innerRects;
        };

    	/**
    	 * Helper method to remove all child elements from a container
    	 * @param e element to clear
    	 */
    	TRCRBox.prototype.clearChilds = function(e) {
    		while (e.hasChildNodes()) e.removeChild(e.lastChild);
    	};

    	TRCRBox.prototype.hasDuration = function() {
    		var detail,
    			detail_order = this.trc.getProperty(this.mode_name, 'detail-order', this.propertiesOverride).split(",");

    		// do we need to render 'duration'?
    		for (var i = 0; detail = detail_order[i]; i++) {
    			if (detail == 'duration'){
    				return true;
    			}
    		}

            return false;
    	};

    	/**
    	 * cleanStyleDimensions
    	 * removes dimentions previously added by the rendering code.
    	 * @param box {Element} root element to start iteration
    	 * @returns {Element} the "video-duration" element or null if not found
    	 * @type Element
    	 */
    	TRCRBox.prototype.cleanStyleDimensions = function(box) {
    		var durationElement = null;
    		try {
    			// remove width and height values
    			// that were added by the drawVideoBox function
    			__trcDOMWalker(box, function (o) {
    				if (o.style.cssText){
    					o.style.width = "";
    					o.style.height = "";
    				}
    				if ((o.className + "").indexOf("video-duration") !== -1){
    					durationElement = o;
    				}
    			});
    		} catch (e) {
    			// ilb. might raise an exception in ie
    		}
    		return durationElement;
    	};

    	/**
    	 * createBillboard
    	 * creates a new billboard element
    	 *
    	 * @returns {Element}
    	 * @type Element
    	 */
    	TRCRBox.prototype.createBillboard = function() {
    		var insertPoint = __trcGetElementsByClass("trc_rbox_outer", "div", this.element)[0];

    		if (!insertPoint)
    			return null;

    		/** @type Element */
    		var elem = document.createElement("div");
    		this.billboard = elem;
    		elem.className = "trc_billboard";
    		elem.style.width = "auto";
    		insertPoint.parentNode.insertBefore(elem, insertPoint);
    		insertPoint.style.clear = "both";
    		return elem;
    	};

    	TRCRBox.prototype.checkForBlocking = function() {
    		var i,
    			item,
    			orphans,
    			sponsored,
    			inNetwork,
    			counter,
    			mozBinding,
    			visibility,
    			blocker = "",
    			blockedOrganic = [],
    			blockedInNetwork = [],
    			blockedSponsored = [];

            /**
             * TODO: completely remove this method and calls after end of Feb 2019 if the following publisher config is not
             * set to true in the DB
             */
    		if(!this.trc.global['enable-old-abp-check']) {
    		    return;
            }

    		for (i = 0; item = this.boxes[i]; i++) {
    			try {
    				inNetwork = item.video_data["is-in-network"] || item.video_data["is-native"];
    				if (!inNetwork) {
    					sponsored = item.video_data["is-syndicated"];
    				}
    			} catch (ex) {
    				// ilb
    			}

    			counter = inNetwork ?  blockedInNetwork : (sponsored ? blockedSponsored : blockedOrganic);

    			if (!item || item.nodeType !== 1 || !item.childNodes.length) {
    				counter.push(1);
    			} else {
    				mozBinding = document.trcGetCurrentStyle(item, '-moz-binding');
    				orphans = document.trcGetCurrentStyle(item, 'orphans');
    				visibility = document.trcGetCurrentStyle(item, 'visibility');

    				if (visibility != "hidden") {
    					if (document.trcGetCurrentStyle(item, 'display') == "none"){
    						if (document.trcGetCurrentStyle(item, 'orphans') == "4321"){
    							blocker = blocker || "adblockplus";
    						}
    						counter.push(1);
    					} else if (mozBinding && mozBinding != "none" ){
    						// blocked in FF
    						blocker = blocker || "adblockplus";
    						counter.push(1);
    					}
    				}

    			}
    		}
    		if (blockedOrganic.length || blockedSponsored.length || blockedInNetwork.length) {
    			__trcWarn("blocked:" + blockedOrganic.length + "-" + blockedInNetwork.length + "-" + blockedSponsored.length + "-" + (blocker || "unknown"));
    		}
    	};

        TRCRBox.prototype.setVideoPlayerLoad = function(playerContainer, videoUrl, poster, itemIndex, itemId, pVideoOverlayData) {
            try {
                PVideoLoader.loadVideo({
                    playerContainer : playerContainer,
                    url : videoUrl,
                    poster : poster,
                    itemIndex : itemIndex,
                    itemId : itemId,
                    // old version support
                    overlayData: pVideoOverlayData,
                    trcRBox:this
                });
                (TRC.tlf && console.time('in setVideoPlayerLoad'));
            }
            catch (e){
                __trcWarn("Error in setVideoPlayerLoad",e);
            }
        };

        TRCRBox.prototype.getThumbnailsDimensions = function(imgLazyLoadIntersectionEvent) {
            var targetBoundingClientRect = imgLazyLoadIntersectionEvent.boundingClientRect,
                targetImgDim = {"width": Math.ceil(targetBoundingClientRect.width), "height": Math.ceil(targetBoundingClientRect.height)};

            return targetImgDim;
        };

        TRCRBox.prototype.removeCarouselItemImgLazyLoadObserver = function(targetElementObserverArr) {
    		var targetElementObserverArr = targetElementObserverArr.split(' '),
                lazyLoadImageObserversIndex;

    		for(var i = 0; i < targetElementObserverArr.length; i++) {
                lazyLoadImageObserversIndex = this.lazyLoadImageObserversIds.indexOf(targetElementObserverArr[i]);

    			if(lazyLoadImageObserversIndex !== -1) {
                    TRC.intersections.unobserve(this.lazyLoadImageObserversIds[lazyLoadImageObserversIndex]);
                    this.lazyLoadImageObserversIds.splice(lazyLoadImageObserversIndex, 1);
    			}
    		}
        };

        TRCRBox.prototype.createCarouselContainerImgLazyLoadObserver = function() {
    		var thumbnailObserverParams = {
                targetElement: this.container,
                threshold: 0,
                rootMargin: this.lazyLoadViewportMarginThreshold,
                disableCheckOverlay: true,
                onEnter: this.createCarouselItemImgLazyLoadObserver.trcBind(this)
            };
            this.lazyLoadImageObserversIds.push(TRC.intersections.observe(thumbnailObserverParams));
        };

        TRCRBox.prototype.loadCarouselItemImage = function(img, box, url, retryCount, imageContainer, oldLazyLoad, imgLazyLoadIntersectionEvent, imgLazyLoadTarget, imgLazyLoadObserver, imgLazyLoadVisibilityState) {
            var targetImgDim = this.getThumbnailsDimensions(imgLazyLoadIntersectionEvent),
                targetElementObserverArr = imgLazyLoadTarget.getAttribute(TRC.intersections.TARGET_ATTRIB);

            this.setImageLoad(img, box, url, retryCount, imageContainer, oldLazyLoad, true, targetImgDim);

            if(targetElementObserverArr) {
            	this.removeCarouselItemImgLazyLoadObserver(targetElementObserverArr);
            }
        };

        TRCRBox.prototype.createCarouselItemImgLazyLoadObserver = function(imgLazyLoadIntersectionEvent, imgLazyLoadTarget, imgLazyLoadObserver, imgLazyLoadVisibilityState) {
            var thumbnailObserverParams,
                targetElementObserverArr = imgLazyLoadTarget.getAttribute(TRC.intersections.TARGET_ATTRIB);

            for(var i = 0; i < this.boxes.length; i++) {
                thumbnailObserverParams = {
                    rootSelector: ('#' + this.outerBox.id),
                    targetElement: this.boxes[i].thumbBlock,
                    threshold: 0,
                    rootMargin: this.lazyLoadViewportMarginThreshold,
                    onEnter: this.loadCarouselItemImage.trcBind(this, this.boxes[i].img, this.boxes[i], this.boxes[i].img_src, 100, this.boxes[i].thumbBlock, this.trc.global["thumb-lazy-load-switch"])
                };
                this.lazyLoadImageObserversIds.push(TRC.intersections.observe(thumbnailObserverParams));
    		}

            if(targetElementObserverArr) {
            	this.removeCarouselItemImgLazyLoadObserver(targetElementObserverArr);
            }
        };

        TRCRBox.prototype.lazyLoadImage = function(img, box, url, retryCount, imageContainer, oldLazyLoad, imgLazyLoadIntersectionEvent, imgLazyLoadTarget, imgLazyLoadObserver, imgLazyLoadVisibilityState) {
            var targetImgDim = this.getThumbnailsDimensions(imgLazyLoadIntersectionEvent),
                targetElementObserverArr = imgLazyLoadTarget.getAttribute(TRC.intersections.TARGET_ATTRIB);

    		this.setImageLoad(img, box, url, retryCount, imageContainer, oldLazyLoad, true, targetImgDim);

            if(targetElementObserverArr) {
            	this.removeCarouselItemImgLazyLoadObserver(targetElementObserverArr);
            }
        };

        TRCRBox.prototype.alternateImgBaseUrl = function (url) {
            TRC.imageCounter++;
            return url.replace('images.taboola.com', this.imagesAltUrls[TRC.imageCounter % this.imagesAltUrls.length]);
        };

    	TRCRBox.prototype.setImageLoad = function(img, box, url, retryCount, imageContainer, oldLazyLoad, loadImmediate, targetImgDim) {
            var videoUrl, itemIndex, itemId, imageOptimizePrefix,
                pVideoOverlayData,
                imgContDim,
                encodedUrl,
                thumbnailObserverParams,
                imgId;

            if (TRC.util.isPercentEnabled(this.trc.global, 'cloudinary-encode')) {
                encodedUrl = TRC.imageUtils.cloudinaryEncoding(url);
            } else if (this.trc.global['tmp-image-utf8-encode']) {
                encodedUrl = encodeURIComponent(url);
            } else {
                encodedUrl = escape(url);
            }

            if(!loadImmediate && this.shouldLazyLoadImages) {
            	if(this.isCarousel) {
            	  return;
                }

                thumbnailObserverParams = {
                  targetElement: imageContainer,
                  threshold: 0,
                  rootMargin: this.lazyLoadViewportMarginThreshold,
                          disableCheckOverlay: true,
                  onEnter: this.lazyLoadImage.trcBind(this, img, box, url, retryCount, imageContainer, oldLazyLoad)
                };

                this.lazyLoadImageObserversIds.push(TRC.intersections.observe(thumbnailObserverParams));
                  return;
            }

            imgContDim = loadImmediate ? targetImgDim : this.getContainerDim(imageContainer, box, this.isHiddenItem(box));
            imageContainer.imgContDim = imgContDim;

            if(!retryCount && !imgContDim) {
                var enableAspectRatio =  !this.trc.global.hasOwnProperty('enable-default-aspect-ratio') || this.trc.global['enable-default-aspect-ratio'];
                if ( box.rbox && box.rbox.isStories) {
                    imgContDim = {
                        width: screen.availWidth,
                        height: screen.availHeight
                    };
                } else if (enableAspectRatio) {
                    var aspectRatio = this.trc.global['default-image-aspect-ratio'] || (9 / 16);
                    var width = Math.min(screen.availWidth, 1000);
                    imgContDim = {
                        width: width,
                        height: Math.round(width * aspectRatio)
                    };
                }
            }
            if (imgContDim){
                /* pre calculation */
                var imageOptimizationConfig = imageUtils.computeImageOptimizationConfig({
                    trcRBoxUI: this,
                    video: box.video_data,
                    imgContDim: imgContDim
                });
                imageOptimizePrefix = this.getImageOptimizationUrlByItemRtbProp({
                    itemData: box.video_data,
                    imageOptimizationConfig: imageOptimizationConfig
                });
                url = this.getImageOptimizePrefix({
                    imageOptimizePrefix: imageOptimizePrefix,
                    imageOptimizationConfig: imageOptimizationConfig
                }) + encodedUrl;
            } else if(retryCount) {
                TRC.Timeout.set(this.setImageLoad.trcBind(this, img, box, url, (--retryCount), imageContainer, oldLazyLoad, loadImmediate, targetImgDim), 50);
                return;
            } else {
                __trcInfo('Failed to load image through cloudinary service because of missing dimensions:' + this.mode_name);
            }

            videoUrl = box.video_data['pvideo-url'];
            itemIndex = box.video_data.itemIndex;
            itemId = box.video_data['item-id'];

            if (this.imagesAltUrls.length > 0){
                url = this.alternateImgBaseUrl(url);
            }

            if (this.trc.getExpoImageTag()) {
                url += (url.indexOf('?') === -1 ? "?" : "&") + this.trc.getExpoImageTag();
            }

    	    box.img_src = url = TRC.URL.prototype.switchProtocol.call(url, protocol);

            img.src = url;

            //measure imageLoadTime and firstImageLoadTime
            TRC.imageUtils.markLoadPerformance(img);

            // initiate call to video player injection
            if (videoUrl) {
                pVideoOverlayData = {
                    isCreatePVideoOverlay: this.trc.getProperty(this.mode_name, 'p-video-overlay', this.propertiesOverride),
                    video_data: box.video_data,
    				container: box,
    				language: this.trc['language'],
    				isSendEvents: this.trc.global['p-video-overlay-send-events']
    			};
                imageContainer = !this.isResponsive ? imageContainer.firstChild : imageContainer;
                this.setVideoPlayerLoad(imageContainer, videoUrl, url, itemIndex, itemId, pVideoOverlayData);
            }
    	};

        TRCRBox.prototype.getImageOptimizationUrlByItemRtbProp = function (settings) {
            var itemData = settings.itemData;
            var imageOptimizationConfig = settings.imageOptimizationConfig;

            this.imageOptimizePrefixFlag = true;
            if (itemData['is-rtb']) {
                return this.rtbImageOptimizePrefix = this.rtbImageOptimizePrefix || this.getImageOptimizationUrl(itemData);
            }
            if(itemData['cropping']) {
                var prefix = imageUtils.parseCroppingPrefix({
                    trcRBoxUI: this,
                    imageOptimizationConfig: imageOptimizationConfig,
                    video: itemData,
                });
                if(prefix){
                    return prefix;
                }
            }

            if ((itemData['thumbnail-transformations'] || itemData['is-gift']) && this.trc.global['image-optimization-url-per-item-is-enabled']) {
                return this.getImageOptimizationUrl(itemData);
            }

            return this.imageOptimizePrefix = this.imageOptimizePrefix || this.getImageOptimizationUrl(itemData);
        };

        /**
    	 *
         * @param itemData
         * this method defines which prefix should be appended to an item's thumbnail then shifts the domain accordingly
         */
    	TRCRBox.prototype.setImagePrefixUrl = function (itemData) {
            var propertyName = "image-url-prefix",
                constFallBack = IMAGE_URL_PREFIX,
                thumbnailTransformations;

            if (itemData['is-rtb']) {
                propertyName = "rtb-image-url-prefix";
                constFallBack = RTB_IMAGE_URL_PREFIX;
            } else if (itemData['is-gift']) {
                propertyName = "gif-url-prefix";
                constFallBack = GIF_URL_PREFIX;
            } else if (itemData['thumbnail-transformations']) {
                thumbnailTransformations = FETCH_PREFIX + HEIGHT_AND_WIDTH + "," + itemData['thumbnail-transformations'] + "/";
            }

            return TRC.shiftDomain(thumbnailTransformations || this.trc.getProperty(this.mode_name, propertyName, this.propertiesOverride) || this.trc.global[propertyName] || constFallBack);
    	};

        TRCRBox.prototype.handleGifPrefixParams = function(prefix) {
        	var gifFadeEffectInMs = this.trc.global["gif-fade-effect-in-ms"],
    			FADE_PARAMS_PATTERN = ",e_fade:{fade},e_fade:-{fade}",
                fadeParams;

            // support display of fade loon effect for gifs
            if (gifFadeEffectInMs && gifFadeEffectInMs !== "0") {
    			fadeParams = encodeURIComponent(FADE_PARAMS_PATTERN.replace(new RegExp("{fade}", "g"), gifFadeEffectInMs));
                prefix = prefix.substr(0, prefix.length - 1) + fadeParams + (prefix.lastIndexOf("/") === (prefix.length - 1) ? "/" : "");
            }
            return prefix;
        };


        TRCRBox.prototype.forceGifPrefixUrl = function () {
            return TRC.shiftDomain(this.trc.getProperty(this.mode_name, "gif-url-prefix", this.propertiesOverride) || this.trc.global["gif-url-prefix"] || GIF_URL_PREFIX);
        };

        TRCRBox.prototype.getImageOptimizationUrl = function(itemData) {
            var prefix = this.setImagePrefixUrl(itemData),
                imagesHost = this.trc.global['images-host'],
                imagesRadius = this.trc.getProperty(this.mode_name, "images-radius", this.propertiesOverride),
                displayAsGif = itemData['is-gift'],
                urlObj;

            //Performance video fallback image gifs should always be treated as gifs
            if(itemData["pvideo-url"] && itemData.thumbnail && itemData.thumbnail.indexOf(".gif") > -1){
                prefix = this.forceGifPrefixUrl();
                displayAsGif = true;
            }
            if( imagesHost && imagesHost.length > 2){
                urlObj = new TRC.URL(prefix);
                urlObj.host = imagesHost;
                prefix = urlObj.toString();
            }

            if(imagesRadius && imagesRadius != "0") {
                if (displayAsGif) {
                    prefix = prefix.replace(new RegExp("f_gif"), "f_gif%2Cr_" + imagesRadius);
                } else {
                    //to allow rounded images / images with rounded corners we first need to make sure that we
                    //fetch png images so that the cropped part will be transparent - remove f_jpg token
                    prefix = prefix.replace(/f_jpg(%2C)?/, "");

                    //push the image radius token (r) + f_png token
                    prefix = prefix.replace(/fetch\//, "fetch/f_png%2C" + "r_" + imagesRadius + "%2C");
                }
            }

            if (displayAsGif) {
                prefix = this.handleGifPrefixParams(prefix);
            }

            return prefix;
        };


        TRCRBox.prototype.isHiddenItem = function(box){
    	    return (doc.trcGetCurrentStyle(box, "display", null) === "none");
    	};

        TRCRBox.prototype.getContainerDim = function (imageContainer, box, useCachedDim) {
            var rect,
                width,
                height = 100;

            if (useCachedDim) {
                if (this.cachedImageDim) {
                    return this.cachedImageDim;
                }
            } else {
                rect = TRC.dom.getElementRect(imageContainer);
                if(TRC.util.isEnabledByDefault(this.trc.global['enable-img-dim-fix']) && TRC.Browser.webView){
                    width = window.screen.width;
                    var maxWidth = this.trc.global['webview-img-max-width'] || 500;
                    width = width > maxWidth ? maxWidth : width;
                    var heightFroAspectRatio = Math.ceil((rect.bottom - rect.top) || this.getAspectHeight(box) || (width * this.getThumbAspectRatio(this.trc.modes[this.mode_name], "ratio")) || height);
                    var widthForAspectRatio = Math.ceil(rect.right - rect.left);
                    height = Math.ceil(heightFroAspectRatio/widthForAspectRatio * width);
                    return this.cachedImageDim = {"width": width, "height": height};
                }
                else {
                    width = Math.ceil(rect.right - rect.left);
                    if (width) {
                        height = Math.ceil(
                            (rect.bottom - rect.top) ||
                            this.getAspectHeight(box) ||
                            (width * this.getThumbAspectRatio(this.trc.modes[this.mode_name], "ratio")) ||
                            height);
                        return this.cachedImageDim = {"width": width, "height": height};
                    }
                }
            }
            return null;
        };

    	TRCRBox.prototype.getAspectHeight =  function(box){
    	   var rect;
    	   if(box.thumbnail_aspect){
    	       rect = TRC.dom.getElementRect(box.thumbnail_aspect);
    	       return rect.bottom - rect.top;
    	   }
    	   return 0;
    	};



    	/**
    	 * @method getImageOptimizePrefix
    	 * calculates the cloudinary service url prefix. it has some special behavior when the mode is responsive :
    	 * 1. for hidden items it uses cached width and height offsets of the last rendered  visible item  ("last"... for
    	 *     avoiding "big" first items)
    	 * 2. in responsive the visible image container have no offsetHeight. it needs to be calculated using the aspect
    	 *     ratio value against the item offsetWidth
    	 * @param {String} url - origin image url
    	 * @param {String} imageOptimizePrefix - prefix url containing {w}, {h} place holders
    	 * @param  {Object} imgContDim
    	 * @return {String}  - calculated url prefix
    	 */
    	TRCRBox.prototype.getImageOptimizePrefix = function(settings){
            var imageOptimizePrefix = settings.imageOptimizePrefix;
            var imageOptimizationConfig = settings.imageOptimizationConfig;
            (TRC.performance && TRC.performance.mark("7.1.1." + this._id));
            imageOptimizePrefix = imageOptimizePrefix
                .replace(new RegExp("{w}", "g"), imageOptimizationConfig.computedWidth.toString())
                .replace(new RegExp("{h}", "g"), imageOptimizationConfig.computedHeight.toString());
            (TRC.performance && TRC.performance.mark("7.1.9." + this._id));
            return imageOptimizePrefix;
    	};

        TRCRBox.prototype.getImageSizeFactor = function() {
            var imageSizeFactor =  this.trc.getProperty(this.mode_name, "image-size-factor", this.propertiesOverride) || 1.2;
            if (this.trc.global["use-dpr-images"] && this.trc.getProperty(this.mode_name, "use-dpr-images", this.propertiesOverride) && TRC.dom.isHighDensity()) {
                imageSizeFactor = this.trc.getProperty(this.mode_name, "image-dpr-factor", this.propertiesOverride) || imageSizeFactor;
            }
            return imageSizeFactor;
        };

        TRCRBox.prototype.getAllowedRatio = function(imgContDim) {
        	var allowedRatiosSorted = this.trc.getSortedCloudinaryRatios(),
    			allowedDiff = this.trc.getProperty(this.mode_name, "image-allowed-ratio-diff",this.propertiesOverride) || 0.01,
                imgRatio = ((imgContDim.height * 1.0) / imgContDim.width),
    			imgRatioWithDiff = Math.abs(imgRatio - allowedDiff);

        	for(var ratioIndex = 0; ratioIndex < allowedRatiosSorted.length ; ratioIndex++) {
                //finding the supremum of the original img ratio with a possible epsilon deviation
                var currRatio = allowedRatiosSorted[ratioIndex];
                if (!isNaN(currRatio) && currRatio >= imgRatioWithDiff) {
                    return currRatio;
                }
            }

            return imgRatio;
    	};

        TRCRBox.prototype.isInViewPort = function(container, minSpace){
            var inVP = TRC.visibility.getMinViewPortOffsets(this.container);
            return !(inVP < 0 && Math.abs(inVP) > minSpace);
        };

    	TRCRBox.prototype.createUtmParam = function() {
    		return {utm: TRC.utm.join(',') + (this.utm ? "," + this.utm.join(',') : '') };
    	};

    	/**
    	 * Activate all post-render actions
    	 */
    	TRCRBox.prototype.postRender = function(execute) {

    		if (execute) {
    			var front = this.postRenderQueue.popFront();
    			if (front == null) {
    				__trcDebug('TRCRBox.postRender: finished');
    			return;
    		    }
    			try {
    				front.func.call(this);
                    TRC.pConsole(this.mode_name, "debug", "executing postRender functions - see info", front.func.toString());
    			} catch (e) {
    				__trcError('Error in TRCRBox.postRender while executing '+front.name, e);
    			}
    		}

            // send end of placement rendering to server
            __trcInfo('Finish Rendering ' + (this.response.trc ? this.response.trc.placement: ""));


    		TRC.Timeout.set(this.postRender.trcBind(this,true),0);
    	};

    	TRCRBox.prototype.getPopupUrl = function() {
    		return this.trc.getProperty(this.mode_name, 'popup-custom-url', this.propertiesOverride) || ("popup.taboola.com/" + (this.trc['language'] || "en"));
    	};

    	/**
    	 * Make sure ad thumbnails are shown for ads that are visible in the client's view port
    	 */
    	TRCRBox.prototype.check_visibility = function() {
    		for (var i = 0; i < this.boxes.length; i++) {
    			var box = this.boxes[i];
    			if(this.itemMaxHeight)
    				box.style.height = this.itemMaxHeight + "px";

    		}
    	};

    	/**
    	 * Find an element according to the specified criteria
    	 * @param predicate Mandatory: a function to test each element against. The method
    	 * 	will return the first element for which this function returns a true value
    	 * @param parent Optional: The DOM node under which to start searching. If not
    	 * 	specified then the document node is used
    	 * @param tag Optional: limit the search to only elements with the specified tag name
    	 * @param dflt Optional: value to return in case nothing was found. defaults to the
    	 * 	undefined value
    	 * @returns {HTMLElement} The first element found or the value of the dflt argument.
    	 */
    	TRCRBox.prototype.findElement = function(predicate,parent,tag, dflt) {
    		if (typeof parent == "undefined")
    			parent = document;
    		if (typeof tag == "undefined")
    			tag = "*";
    		var elms = parent.getElementsByTagName(tag);
    		for (var i = 0; i < elms.length; i++)
    			if (predicate(elms[i]))
    				return elms[i];
    		return dflt;
    	};

    	/**
    	 * Get a list of elements, represented as comma-separated list and find them inside a given element.
    	 * @param elementsList - a list of elements class names, comma separated
    	 * @param parent - the element in which we lookup these elements
    	 * @param doClone (optional) - determines whether the function returns the original elements or clones
    	 *
    	 * @returns Array of clones of the found elements by the order in which we looked for them
    	 */
    	TRCRBox.prototype.findElements = function (elementsList, parent, doClone) {
    		var foundElements = [];

    		for(var i = 0; elementsList && i < elementsList.length; i++) {
    			var elementClassName = elementsList[i],
    				element = this.findElement(function(e){
    				return e.className.search(elementClassName) >= 0;
    			}, parent, 'span');

    			if(element) {
    				if(doClone) {
    					element = element.cloneNode(true);
    				}

    				foundElements.push(element);
    			}
    		}

    		return foundElements;
    	};

        /**
         *
         * @param itemType
         * @param targetConf
         * @returns {*}
         */
        TRCRBox.prototype.getLinkTarget = function(itemType, targetConf, defaultConf){
            var target;

            if(targetConf){
                target = targetConf[itemType] || defaultConf[itemType];
            } else {
                target = defaultConf[itemType];
            }
            if(!target){
                target = "_blank"; // default target
            }
            return target;
        };
        /**
         * add piggy back data to a url
         */
        TRCRBox.prototype.addPiggyBackParams = function(url){
            if (url){
                return url + "&ppb=" + this.response.trc['ppb'] + "&cpb=" + this.response.trc['cpb'];
            }
        };

        TRCRBox.prototype.detectItemFromSameHost = function(host, itemHost) {
        	if (host === itemHost || this.trc['detect-item-from-same-host'](host, itemHost)) {
        		return true;
            }
            var hostArr = host.split('.').reverse().join(''),
                itemHostArr = itemHost.split('.').reverse().join(''),
                maxHostParts = 6,
    		    equalUrlParts = true;

            for (var i = 0; i < maxHostParts; i++) {
            	if (hostArr[i] !== itemHostArr[i]) {
                    equalUrlParts = false;
                    break;
    			}
    		}
    		return equalUrlParts;
        };


        TRCRBox.prototype.createVideoLinkRel = function (video, itemFromSameHost, syndicatedLinkTarget) {
            var rel;
            if (this.trc.global['allow-nofollow-for-exchange'] ||
                !video['is-in-network'] ||
                (video['is-in-network'] && !itemFromSameHost)) {
                rel = "nofollow";

                if(!this.trc.global['disable-noopener-for-links'] && syndicatedLinkTarget === '_blank') {
                    rel += " noopener";
                }
            }

            // add sponsored to rel attr only for non exchange syndicated items
            if (!this.trc.global['disable-sponsored-for-links'] && !video['is-in-network'] && !video['is-dc']) {
                rel += " " + CONSTS.REL_SPONSORED;
            }
            return rel;
        };

        /**
         *
         * @param link recommendation item link
         * @param trc_logger_url trc.taboola logger to register the clicks
         * @param e event fired mousedown/click/touchstart
         * @param videoBoxContainer recommendation item container
         */
        TRCRBox.prototype.changeVideoHrefToReportClick = function(link, trc_logger_url, e, videoBoxContainer, video) {
            if(!video.directLink && link) {
                link.href = this.getVideoLoggerUrlToReportClickWithMetrics(trc_logger_url, e, videoBoxContainer, video);
            }
        };

        TRCRBox.prototype.getVideoLoggerUrlToReportClickWithMetrics = function(trc_logger_url, e, videoBoxContainer, video) {
            var updated_trc_logger_url = ItemMeasurements.addVisibleToClickTimeToParamURL(this.trc, trc_logger_url, e, videoBoxContainer, video);
            return this.attachHeatMapDataToLink(updated_trc_logger_url, e);
        };
        /**
         *
         * @param video recommendation item
         * @param params property list with additional parameters to send
         * @param postParams
         * @param once optionally use log1 to send the event
         * @param callback optionally trigger this callback after the event is received by the server
         * @param timeout (optional)
         */
        TRCRBox.prototype.reportClick = function(video, params, postParams, once, callback, timeout) {
            ItemMeasurements.setVisibleToClickTimeParamObj(this.trc, params, video);
            this.sendEvent('click', params, postParams, once, callback, timeout);
        };

        /**
         *
         * @param link recommendation item link
         * @param trc_logger_url trc.taboola logger to register the clicks
         * @param e event fired mousedown/click/touchstart
         * @param videoBoxContainer recommendation item container
         */
        TRCRBox.prototype.reportClickAsync = function(link, trc_logger_url, e, videoBoxContainer, video) {
            var clickUrl = this.getVideoLoggerUrlToReportClickWithMetrics(trc_logger_url, e, videoBoxContainer, video);
            clickUrl = TRC.URL.prototype.removeParamFromUrl(clickUrl, 'redir');
            if(!BeaconUtils.sendBeaconRequest(clickUrl, {})) {
                TRC.pConsole(this.mode_name, "error", "Failed sending click url using  sendBeacon = " + clickUrl);
            }
        };

    	/**
    	 * Create a recommendation list for the recommendation item UI
    	 * @param video recommendation item
    	 * @param title HTML "title" to set for the link
         * @param videoBoxContainer recommendation item container
    	 * @returns {HTMLElement} instance of an A tag
    	 */
    	TRCRBox.prototype.createVideoLink = function(video, title, videoBoxContainer) {
    		var link = document.createElement('a'),
                hasNtClickHandler = this.ntHandlerEnabled && video['is-in-network'],
    			syndicatedLinkTarget,
    			ignoreLoggerUrlPrefix,
                logger_trc_url = (this.sendClickPiggyBack) ? this.addPiggyBackParams(video.logger_url) : video.logger_url, //the trc redirect url
                stopPropagation = (this.trc.global["disable-stop-propagation"] === true) ? false : true,
                host = (TRC.pageManager.getTopMostWindow().location.hostname),
                itemHost = TRC.URL(video['url']).host,
                rel,
                isItemSameHost;

            link.setAttribute('attributionsrc', '');
            if(video['urlp']) {
                var urlpObject = video['urlp'];
                for (var attribute in urlpObject) {
                    if (urlpObject.hasOwnProperty(attribute)) {
                        var value = urlpObject[attribute];
                        link.setAttributeNS(null, attribute, value);
                    }
                }
            }

            var shouldHaveOrganicBehavior = false;
            isItemSameHost = this.detectItemFromSameHost(host, itemHost);
            if (video['is-in-network'] && TRC.hasFeedView && this.parentFeed && this.parentFeed.enableAEClicks) {
                if (isItemSameHost) {
                    video.scParams = video.scParams || {};
                    video.original_url = video.original_url || video.url;
                    shouldHaveOrganicBehavior = true;
                } else {
                    this.feedViewExchangeFallbackEventData = {
                        eventType: 'fallback',
                        original_url: host,
                        target_url: itemHost
                    };
                    this.shouldSendFeedViewExchangeFallbackEvent = true;
                }
            }

            if(hasNtClickHandler){
                video.hasNtClckHnadler = true;
            }
            if (TRC.isOptim('title-decode')) {
                link.title = title;
            } else {
                link.title = TRC.util.getHtmlDecodeText(title);
            }
    		video.link_target = this.link_target; // 'link_target' is a mode level api property (for organic items)
            if (video.isSyndicated && !hasNtClickHandler && !shouldHaveOrganicBehavior) { // sponsored item behavior
                // 1. first time we show the original landing page (when the user hovers over the link)
                // present only base url when hovering for specific advertisers
                var shouldTrimHref = 'thrf';
                var shouldRemoveHref = 'rhrf';

                if (video[shouldTrimHref]) {
                    link.href = TRC.URL.prototype.removeAllUrlParametersAndFragment(video.url);
                }
                else if (video[shouldRemoveHref]) {
                    link.href = CONSTS.EMPTY_HREF;
                }
                else {
                    link.href = video.url;
                }
                syndicatedLinkTarget = this.getLinkTarget(this.getProviderType(video), this.linkTargetConf, this.defaultLinkTarget );
                rel = this.createVideoLinkRel(video, isItemSameHost, syndicatedLinkTarget);
                if (rel) link.rel = rel;
                // logger url is a url that goes through trc("click" event) and redirects to the original landing page

    			link.logger_url = logger_trc_url.replace('&url=','&redir=')+((video['is-in-network'])?'&prt=nt':'')+((video['is-native'])?'&prt=nav':'');
    			link.target = syndicatedLinkTarget;
    			if (this.trc.global['enable-ie-split-click-event'] == true && TRC.Browser.ie) {
    				ignoreLoggerUrlPrefix = (link.logger_url.length > 2048);
    			}
                if(this.trc.global["touchstart-enabled"] === true){
                    TRC.dom.on(link, "touchstart",(function(e){
                        this.changeVideoHrefToReportClick(link, link.logger_url, e, videoBoxContainer, video);
                        link.isTouchPropagation = 1;
                        if(stopPropagation){
                            e.stopPropagation();
                        }
                    }).trcBind(this));
                }
    			//noinspection FunctionWithInconsistentReturnsJS
                link.onmousedown = (function(e) {
                    e = e || event;
                    // add target = 'blank' to the the clicked element
                    // to trick omniture not to capture this click
                    (e.target || e.srcElement).target = syndicatedLinkTarget;
                    if(link.isTouchPropagation){
                        return true;
                    }

    				if (!ignoreLoggerUrlPrefix) {
                        this.changeVideoHrefToReportClick(link, link.logger_url, e, videoBoxContainer, video);
    				}
    			}).trcBind(this);

                if (this.isDisplayToNative || DisplayInSlotManager.isItemDisplayInSlot(video)) {
                    link.onmouseout = (function (event) {
                        this.brandingTitleStyleToNative(event);
                    }).trcBind(this);

                    link.onmouseover = (function(event) {
                        if(!this.brandingEventStyle(event)) {
                            this.brandingTitleStyleToNative(event);
                        }
                    }).trcBind(this);
                }

    			// set Event Handler
    			link.onclick = (function(event) {
                    if ((this.isDisplayToNative || DisplayInSlotManager.isItemDisplayInSlot(video)) && !this.brandingEventStyle(event)) {
                        this.brandingTitleStyleToNative(event);
                        return false;
                    }
    				try {
    					if (TRC.clickFraudDetect.isInitialized && video["is-syndicated"]) {
    						var trcLinkParams = link.search.match(/[^&??=]+/g);
    						var indexItem = trcLinkParams.indexOf("ri");
    						var UTID = "";
    						if (indexItem > -1) {
    							UTID += trcLinkParams[indexItem + 1];
    						}
    						indexItem = trcLinkParams.indexOf("ii");
    						if (indexItem > -1) {
    							var ItemIdValue = trcLinkParams[indexItem + 1].match(/^~~V1~~(-?[\d]{10,})/);
    							UTID += ItemIdValue ? "_" + ItemIdValue[1] : "";
    						}
                            var isTRCUrl = link.href.indexOf('trc.taboola.com') >= 0;
                            TRC.clickFraudDetect.fraudScriptCallback(
                                this.placement,
                                TRC.pageManager.getUserId(),
                                UTID,
                                this.trc.referrer,
                                video.itemIndex,
                                isTRCUrl
                            );
    					}
    				}
    				catch (e) {
    					__trcError("Publisher 'onclick' Fraud handler had an error", e);
    				}

                    if (this.shouldSendFeedViewExchangeFallbackEvent) {
                        this.trc.sendAbTestEvent('feedView_ae', this.feedViewExchangeFallbackEventData);
                    }

    				this.trc.sendExternalTracking(this.getItemExternalTrackingURLsList(video)['c']);

                    if (video.directLink) {
                        this.reportClickAsync(link, link.logger_url, event, videoBoxContainer, video);
                        return true;
                    }
                     if(link.isTouchPropagation){
                        return true;
                    }
                    if (ignoreLoggerUrlPrefix) {
                        this.reportClick(video, { ii: video['item-id'], it: video.type}, null, false);
    				} else if (this.shiftRedirOnclick) {
                        this.changeVideoHrefToReportClick(link, link.logger_url, event, videoBoxContainer, video);
    				}
    				return true;
    			}).trcBind(this);
    		} else { // organic item behavior

    			link.href = video.url;
    			if (this.link_target != 'blank'){
    				if(TRC.util.isAmp(TRC) && this.trc.global['amp_target']) {
    					link.target = this.trc.global['amp_target'];
    				} else {
    					link.target = "_parent";
    				}
    			} else {
    				link.target = '_blank';
    				link.onmousedown = function(e) {
    					e = e || event;
    					(e.target || e.srcElement).target = '_blank';
    				};
    			}
                if(video['is-in-network']){
                    video.scParams.prt= 'nt';
                }

                if (this.organicRedirParam){
                    logger_trc_url = logger_trc_url.replace('&url=','&' + this.organicRedirParam + '=');
                }
                if(this.useRedirect && this.useRedirectOnLink){ // set the logger url directly on the link element not relying on any event to make the shift
                    link.href = logger_trc_url;
                }
    	        //the mouse down on organic items is a protection against right click(and then open in a new tab) scenarios
                //where we loose the the onclick handler(see next)
    			link.onmousedown = (function(e) {
                    this.changeVideoHrefToReportClick(link, logger_trc_url, e, videoBoxContainer, video);
    			}).trcBind(this);

    			link.onclick = this.videoLinkClickHandler.trcBind(this,videoBoxContainer, video, link, logger_trc_url);
    		}

            // Register an EventsAPI click handler
            if (this.trc.global['events-api-click-enabled']) {
                TRC.dom.on(link, 'click', function (e) {
                    var target = link.target;

                    video.linkTarget = target;

                    if (target === '_blank') {
                        setTimeout(function () {
                            TRC.EventsAPI.dispatchClick(video, this.response.trc);
                        }.trcBind(this), 0);
                    }
                    else {
                        TRC.EventsAPI.dispatchClick(video, this.response.trc);
                    }
                }.trcBind(this));
            }

    		return link;
    	};

        TRCRBox.prototype.brandingEventStyle = function(event){
            var brandingParentElement = TRC.dom.closest(event.target,'.attribution-disclosure-link-sponsored');
            if(brandingParentElement) {
                event.target.classList.add('tbl-branding-title-to-native');
                return true;
            } else {
                return false;
            }
        };

        TRCRBox.prototype.brandingTitleStyleToNative = function(event){
            event.target.classList.add('tbl-title-to-native');
            event.target.style.color= 'inherit';
        };

        TRCRBox.prototype.attachHeatMapDataToLink = function(originalUrl, event){
            if(!TRC.Heatmap.isEnabled(this.trc) || !this.listContainer.heatmap){
                return originalUrl;
            }
            try{
                var heatmap = this.listContainer.heatmap;
                var clickEventHeatmapData = TRC.Heatmap.collectClickHeatmapCardData(event);
                clickEventHeatmapData['item-d'] = heatmap.collectClickHeatmapItemData(event);
                var finalUrl  = originalUrl + '&' + "d=" + JSON.stringify(clickEventHeatmapData);
                return finalUrl;
            }
            catch(err){
                __trcError("Error in trcrbox-ui.attachHeatMapDataToLink - " + err, err);
                return  originalUrl;
            }

        };

    	/**
    	 * click handler for standard video elements
    	 */
    	TRCRBox.prototype.videoLinkClickHandler = (function(){
    		// private functions

    		// when a private method returns true, the browser may navigate to another page
    		// in the same window or in a new one

    		// when a method returns false, it prevents the browser from navigating
    		// and cancels the click

    		var	CLICK_TIMEOUT = 2000,

    			// open Blank (in a new tab)
    			// returns true to allow the browser navigation in the new tab.

    			openBlankBox = function(rbox, video, link, redirect) {
    				link.target = '_blank';

                    //we are going to redirect through trc.
                    // link.href has the redirect trc url that is set early in the mousedown event
    				if (redirect){
                        if(TRC.Browser['firefoxUpto'](8)){ // avoid the default behavior of FF in clickLink method
                            return true;
                        }
    					rbox.clickLink(link.href,link.target);
    					return false;
    				}

                    //we are not going to redirect through trc.
                    // video.url has the true landing page for the item
                    // this was the normal beahvior for organic clicks
                    link.href = video.url;
                    this.reportClick(video, { ii: video['item-id'], it: video.type}, null, false);
    				return true;
    			};

    		// public interface
    		return function(videoBoxContainer, video, link, logger_trc_url, e) {
    			e = e || event;

                ItemMeasurements.setVisibleToClickTime(this.trc, video, e, videoBoxContainer);
                if(video){
                    video.logger_url = ItemMeasurements.addVisibleToClickTimeToParamURL(this.trc, video.logger_url, e, videoBoxContainer, video);
                }

                var result = !!(TRC.feedViewModuleLoaded && TRC.FeedView.openIfFeedView(this, video, link));

    			var videoTarget =  video.link_target,
                    useRedirect = this.useRedirect;

    			if(videoTarget !== 'embed') { //openEmbedBox will already send external click tracking when calling playInsideHostingContainer
    				this.trc.sendExternalTracking(this.getItemExternalTrackingURLsList(video)['c']);
    			}

    			switch (videoTarget) {
                    case "feedView":
                        break;
    				case "blank":
    					// add target = 'blank' to the the clicked element
    					// to trick omniture not to capture this click
    					(e.target || e.srcElement).target = '_blank';
                        if(useRedirect){ //verifying that the link href is the logger url and not relying on the onmousedown event only(DEV-4279)
                            this.changeVideoHrefToReportClick(link, logger_trc_url, e, videoBoxContainer, video);
                        }
    					result = openBlankBox(this, video, link, useRedirect);
    					break;
    				default:
                        //we can redirect if there is a click handler some where or item(video) is suppose to open in current page
                        if (useRedirect && video.link_target != 'local' && typeof this.onclick != 'function' && typeof this.trc.onclick != 'function'){
                            if(this.shiftRedirOnclick) {
                                this.changeVideoHrefToReportClick(link, logger_trc_url, e, videoBoxContainer, video); //verifying that the link href is the logger url and not relying on the onmousedown event only(DEV-4279)
                            }
                            result = true;// in this case we relay on the default behavior of a href(set to trc redirect) element in a browser
                        } else {
                            var publisherClickHandler = this.publisherClickHandler.trcBind(this, video,
                                this.clickLink.trcBind(this, video.url));
                            this.reportClick(video,
                                (video.hasNtClckHnadler) ? video.scParams : { ii: video['item-id'], it: video.type},
                                null, false, publisherClickHandler, CLICK_TIMEOUT);
    					}
                }

    			if(video.url != video.original_url)
    				__trcDebug('url:'+video.original_url+', changed to:'+video.url+', on page:'+win.location.href);

    			if (!result) { // extra cancelling for Internet Explorer
    				e.cancelBubble = true;
    				if (e.stopPropagation)e.stopPropagation();
    			}
    			return result;
    		};
    	}());

    	/**
    	 * Simulate a user's click on a link.
    	 * This method will simulate, for each supported browser, a user that has clicked on a link with the specified URL,
    	 * in terms of the HTTP request generated by the click on the link (i.e. it will create correct referrer headers
    	 * and such).
    	 * @param url A valid URL that a user can click on.
         * @param target (optional)
    	 */
    	TRCRBox.prototype.clickLink = function (url, target) {
    		// Older firefoxes have no different logic for code that sets window.location directly, so we're home free
    		if (TRC.Browser['firefoxUpto'](8)) {
    			win.location.href = url;
    		}

    		// for other browsers, create a new link element that we can simulate a click on
    		var tempLink = document.createElement('a');
    		tempLink.href = url;
    		tempLink.target = !target ? '_parent' : target;
    		tempLink.style.visibility = 'hidden';
    		document.body.appendChild(tempLink);

    		// IE has a handy "click" command that does exactly what you think it should
    		if (tempLink.click) {
    			tempLink.click();
    			return;
    		}

    		// otherwise we are in a (hopefully) standard compliant browser where we can send "mouse click" event
    		var e = new MouseEvent("click", {
                bubbles: true,
                cancelable: true,
                view: window,
                button: 0
            });

    		tempLink.dispatchEvent(e);
    	};

    	/**
    	 * Execute the provided internal click handler (the callback) after allowing the publisher to handle the click
    	 * themselves using their onclick handler. This will possibly will not actually execute the callback if the
    	 * publisher's onclick logic returns 'false';
         * @param video - the recommendation object
    	 * @param callback internal function to be called (using our instance as a the this reference) if the publisher
    	 *     onclick handler allows.
    	 */
    	TRCRBox.prototype.publisherClickHandler = function(video,callback) {
    		// sanitize our video object for general consumption
    		var publicRecommendation = __trcCopyProps(video,{});
    		delete publicRecommendation['item-id'];
    		delete publicRecommendation.link;

    		try {
    			// see what the mode has to say about handling clicks
    		if (typeof this.onclick == 'function' && !this.onclick.call(this.pubOpts, publicRecommendation))
    				return false; // it said to abort
    			// see what the queue has to say about handling clicks
    		if (typeof this.trc.onclick == 'function' && !this.trc.onclick.call(this.pubOpts, publicRecommendation))
    				return false; // it said to abort
    		} catch (e) {
    			__trcError("Publisher 'onclick' handler had an error",e); // but continue nonetheless
    		}

    		return callback();
    	};

    	/**
    	 * Helper method to add SPAN elements
    	 * @param cssClass Class for the DOM element
    	 * @param content HTMl for the content
    	 * @param parentElement DOM element to attached the new element to
    	 * @returns {HTMLElement} instance of SPAM element that was created
    	 */
    	TRCRBox.prototype.add_span = function(cssClass, content, parentElement) {
    		/** @type Element */
    		var span = document.createElement('span');
    		if (cssClass != null) {
                span.className = cssClass;
            }

    		if (content != null) {
    			if (typeof content == "object") {
                    span.appendChild(content);
                }
    			else {
                    TRC.dom.setContentToElement(span, content);
                }
    		}
    		if (typeof parentElement != "undefined") {
                parentElement.appendChild(span);
            }

    		return span;
    	};

    	/**
    	 * Generate a BiDi compatible video label
    	 * @param labels_box Box of video labels
    	 * @param text Text to render
    	 * @param type Video label type
    	 * @returns {Element} a bidi label element
    	 * @type Element
    	 */
    	TRCRBox.prototype.genBidiLabel = function(labels_box, text, type) {
    		var span,
    			content;

                var textIsRtl = TRC.util.textIsRTL(text);
                content = text;

                var spanInnerHtml = content;
                var spanClass = "video-label " + type;
    		if (this.shouldUseSmartEllipsis()) {
                // Default tokenize strategy is "word", if we don't have this property for whatever reason, that's what we go for.
    			var strategyName = this.trc.getProperty(this.mode_name, "tokenize-strategy") || "word";
    			var tokenizeStrategy = TRC.Ellipsis._tokenizeStrategies[strategyName];

                // content may be either a string, or a BDE element with the string.
                spanInnerHtml = TRC.Ellipsis._tokenizeSingle(content.innerHTML || content, tokenizeStrategy);
    			spanClass += " trc-smart-ellipsis";

    			var isSiteLtr = this.trc.direction === 'ltr';

                if(isSiteLtr) {
                    if (textIsRtl) {
                        spanClass += ' tbl-rtl-label';
                    }
                    // Mixed labels of ltr and rtl will malfunction if we apply both to the same string (as happens commonly on the subtitle / attribution), so only do ltr override on titles.
                    else if(type !== "title") {
                        spanClass += ' tbl-ltr-label';
                    }
                }

    		}

                span = this.add_span(spanClass, spanInnerHtml, labels_box);
    		    labels_box[type] = span;

                //mark span as RTL
                span.isRTL = textIsRtl;
                span.tokenizeStrategy = strategyName;

                return span;
    	};

    	TRCRBox.prototype.handlePublishedDate = function (video, labels_box) {
    	    var dataFormatName = 'published-date';
            var isXTimeAgo = this.trc.getProperty(this.mode_name, 'format-x-days-ago', this.propertiesOverride);
            var dataFormatted = isXTimeAgo ? TRC.DateUtils.dateFormatTimeAgo(video[dataFormatName], this.trc.language, this)
                                           : this.formatData(dataFormatName, video[dataFormatName]);
            var publishedDatePosition = this.trc.getProperty(this.mode_name, 'published-date-position', this.propertiesOverride);
            if (publishedDatePosition === "with-branding") {
                var branding = labels_box.querySelector('.branding');
                if (branding) {
                    TRC.dom.addClass(branding, 'inline-branding');
                }
                var separator = this.trc.getProperty(this.mode_name, 'branding-separator', this.propertiesOverride) || "|";
                dataFormatted = " " + separator + " " + dataFormatted;
            }
            this.add_span('video-label video-published-date', dataFormatted, labels_box);
        };

    	/**
    	 * Build the recommendation item label box
    	 * @param labels_box pre-made container for the labels
    	 * @param video recommendation item
    	 * @param detail_order detail order to use for building labels
    	 */
    	TRCRBox.prototype.buildLabelBox = function(labels_box, video, detail_order) {
            var i, data, branding,
                hasTitle = detail_order.indexOf('title') !== -1,
                enableTitleIconOnSC = this.trc.getProperty(this.mode_name, 'enable-title-icon-on-sc', this.propertiesOverride),
                scTitleIconCondition = video.isSyndicated && hasTitle && enableTitleIconOnSC,
                ocTitleIconCondition = !video.isSyndicated && hasTitle;

    		if(ocTitleIconCondition || scTitleIconCondition) {
                this.createTitleAndIconContainer(labels_box);
    		}

    		for (i = 0; i < detail_order.length; i++) {
    			data = detail_order[i];

    			switch (data) {
    				case 'title':
                        var title = this.genBidiLabel(labels_box, video.title, 'video-title');
                        title && title.setAttribute && title.setAttribute('slot', 'title');
    					break;
    				case 'uploader':
    					if (typeof video.uploader != 'undefined')
    						this.add_span("video-label video-uploader", this.formatData('uploader', video.uploader),
    								labels_box);
    					break;
                    case 'category':
                        var categoryText = '';
                        if(this.isStories && !video.isSyndicated){
                            categoryText = this.parentStories.storiesPlacements[this.options.placement].topicData.title;
                        }else {
                            categoryText = video.category;
                        }
                        if(!this.trc.global['disable-decode-category-text']) {
                            categoryText = TRC.dom.decodeHtmlEntities(categoryText);
                        }

                        if(typeof video.category != 'undefined'){
                            categoryText = categoryText.split(';')[0].split('//')[0];
                        }

                        this.add_span("video-label video-category", this.formatData('category', decodeURIComponent(categoryText)), labels_box);
    					break;
    				case 'views':
    					this.add_span("video-label video-views", this.formatData('views', video['views']), labels_box);

    					break;
    				case 'rating':
    					this.add_span("video-label video-rating", this.formatData('rating', video['rating']), labels_box);
    					break;
    				case 'description':
                            var desc_span = this.genBidiLabel(labels_box, video.description, 'video-description');
                            desc_span && desc_span.setAttribute && desc_span.setAttribute('slot', 'description');
                            desc_span.title = '"Description: ' + this.removeHtmlTags(video.description) + '"';
    					break;
    				case 'duration':
    					if ((typeof video.duration != 'undefined') && (video.duration != ''))
    						this.add_span("video-label video-duration-detail", this.formatData('duration', video.duration), labels_box);
    					break;
    				case 'branding':
    					if(video.isSyndicated) {
                            if (this.shouldHandleScBrandingWithSponsoredLink() && video['is-app-install'] !== 'true'){
                                branding = this.createScBrandingWithSponsoredLink(video, labels_box);
    						} else {
                                branding = this.createScBranding(video, labels_box);
                            }
                        }else { //organic
                            branding = this.createOrganicBranding(video, labels_box);
    					}
                        labels_box['branding'] = branding;
                        branding && branding.setAttribute && branding.setAttribute('slot', 'branding');
    					break;
    				case 'url':
    					break;
                    case 'published-date':
                        this.handlePublishedDate(video, labels_box);
                        break;
    				default:
    					if (typeof video[data] != 'undefined' &&  video[data]){
    						this.add_span("video-label video-" + data, this.formatData(data, video[data]), labels_box);
    					}
    			}
    		}
    	};

        TRCRBox.prototype.shouldHandleScBrandingWithSponsoredLink = function () {
            return this.getDisclosurePosition() === 'after_branding';
        };

        TRCRBox.prototype.getDisclosurePosition = function () {
        	if(!this.disclosurePosition) {
                this.disclosurePosition =
                    this.trc.getProperty(this.mode_name, 'disclosure-position', this.propertiesOverride);
            }
            return this.disclosurePosition;
        };

        TRCRBox.prototype.getDisclosureAlignment = function () {
            if(!this.disclosureAlignment) {
                this.disclosureAlignment =
                    this.trc.getProperty(this.mode_name, 'disclosure-alignment', this.propertiesOverride);
            }
            return this.disclosureAlignment;
        };

        TRCRBox.prototype.createScBrandingWithSponsoredLink = function (video, labels_box) {
            var brandingSeparator, disclosureText, disclosureAlignment;

            brandingSeparator = this.trc.getProperty(this.mode_name, 'branding-separator', this.propertiesOverride);
            this.branding = this.add_span("branding composite-branding", null, labels_box);
            this.add_span("branding-inner", this.formatData('syndicator', video["branding-text"]), this.branding);

            disclosureText = this.trc.getProperty(this.mode_name, 'disclosure-link-text-sponsored', this.propertiesOverride);
            if (!disclosureText) {
                return;
            }

            disclosureAlignment = this.getDisclosureAlignment();
            if (disclosureAlignment !== 'right') {
                this.add_span("branding-separator", brandingSeparator, this.branding);
            }

            this.renderDisclosureLinkWithBranding(this.branding, disclosureText, disclosureAlignment);

            return this.branding;
        };

        TRCRBox.prototype.createScBranding = function (video, labels_box) {
            return createScBranding({
                trcRBoxUI: this,
                video: video,
                labelsBox: labels_box
            });
        };

        TRCRBox.prototype.createOrganicBranding = function (video, labels_box) {
            return this.add_span("branding", this.formatData('syndicator', this.getPublisherBrandingName()),labels_box);
        };

        TRCRBox.prototype.createTitleAndIconContainer = function(labelsBox) {
        	var iconContainer,
    			iconImg,
                iconURL,
    			iconSource = this.trc.getProperty(this.mode_name, 'title-icon', this.propertiesOverride) || 'NONE';

    		if (iconSource === 'CUSTOM') {
                iconURL = this.trc.getProperty(this.mode_name, 'title-icon-url', this.propertiesOverride);
    		} else if (iconSource === 'PUBLISHER_LOGO') {
    			// Fallback to network logo (if exists) in case of network solutions.
    			iconURL = this.trc.getPublisherVersionPropertyWithFallbackToNetwork("publisher-logo");
    		}

            if (iconURL) {
                iconContainer = document.createElement('span');
                iconImg = document.createElement('img');

                // Add icon to container
                iconContainer.className = 'video-icon-container';
                iconImg.className = 'video-icon-img trc_img';
                iconImg.src = TRC.URL.prototype.switchProtocol.call(iconURL, protocol);
    			labelsBox.className += ' label-box-with-title-icon';
                iconContainer.appendChild(iconImg);
                labelsBox.appendChild(iconContainer);
            }
    	};

    	TRCRBox.prototype.isUsingImageOptimizationService = function(imageUrl) {
    		var optimization_service = (this.trc.global['images-host']) ? this.trc.global['images-host'] : "images.taboola.com";

    		return imageUrl.indexOf(optimization_service) > -1;
    	};

        TRCRBox.prototype.isTaboolaCDNImage = function(imageUrl) {
    		return imageUrl.match(/cdn.taboola.com\/.*thumbnails\S/);
    	};

        TRCRBox.prototype.logImageError = function(imgUrl, itemId, fallbackImg, imageSource) {
            var imageSourceString = imageSource ? (imageSource + ' ') : '',
                serverLoggingPercentage = this.trc.global['rbox-image-error-reporting-pct'] || 0.1;

            __trcWarn('Failed to load ' + imageSourceString + 'thumbnail ' + imgUrl + ' for item=' + itemId + ', loading ' + fallbackImg + ' thumbnail instead', null, serverLoggingPercentage);
        };

        TRCRBox.prototype.getFallbackImageForTaboolaCDNImage = function(failedImageUrl, itemId, pageProtocol) {
            var isUsingOptimizationService = this.isUsingImageOptimizationService(failedImageUrl),
    			indexOfOrigImageInUrl = failedImageUrl.search(/\Shttp\S/),
    			origImageUrl = unescape(failedImageUrl.slice(indexOfOrigImageInUrl + 1)),
    			url = TRC.URL.prototype.switchProtocol.call( isUsingOptimizationService ? unescape(origImageUrl) : origImageUrl, pageProtocol);

            this.logImageError(failedImageUrl, itemId, url, 'taboola CDN');

            return url;
        };

    	TRCRBox.prototype.getFallbackImageForNonTaboolaCDNImage = function(imageElement, itemId, pageProtocol) {
            var failedImageUrl = imageElement.src,
                isUsingOptimizationService = this.isUsingImageOptimizationService(failedImageUrl),
                indexOfOrigImageInUrl = failedImageUrl.search(/\Shttp\S/),
    			origImgUrl = isUsingOptimizationService && unescape(imageElement.src.slice(indexOfOrigImageInUrl + 1)),
            	isAllowedToUseOrigImgUrl = pageProtocol !== 'https:' || (origImgUrl && origImgUrl.indexOf(pageProtocol) === 0) || this.trc.global['always-allow-orig-image-fallback'];

    		if (indexOfOrigImageInUrl > 5 && isUsingOptimizationService && isAllowedToUseOrigImgUrl){
            	return this.getOrigImageFromOptimizationUrl(imageElement.src, origImgUrl, itemId);
            } else {
            	return this.getDefaultThumbnail(imageElement, itemId, pageProtocol);
            }
    	};

        TRCRBox.prototype.getOrigImageFromOptimizationUrl = function(failedImageUrl, origImageUrl, itemId) {
            this.logImageError(failedImageUrl, itemId, origImageUrl);

            return origImageUrl;
    	};

        TRCRBox.prototype.getDefaultThumbnail = function(imageElement, itemId, pageProtocol) {
            var default_thumbnail = this.trc.getProperty(this.mode_name, 'default-thumbnail', this.propertiesOverride),
    			url = TRC.URL.prototype.switchProtocol.call( ( default_thumbnail != 'undefined') ? default_thumbnail : "", pageProtocol );

            imageElement.onerror = null;
            this.logImageError(imageElement.src, itemId, 'default');

            return url;
    	};

        TRCRBox.prototype.getRuleAspectRatio = function(rule, type) {
            if(rule['virtualThumbWidth'] && rule['virtualThumbHeight'] && !isNaN(rule['virtualThumbWidth']) && !isNaN(rule['virtualThumbHeight'])) {
                if(type == "ratio"){
                    return rule['virtualThumbHeight'] / rule['virtualThumbWidth'];
                } else {
                    return rule['virtualThumbHeight'] / rule['virtualThumbWidth'] * 100;
                }
            }

            return false;
        };

    	TRCRBox.prototype.getThumbAspectRatio = function(mode, type){
    		try {
    			var aspect = mode['thumbnail-height'] / mode['thumbnail-width'];
    		    if (type == "ratio"){
    		        return aspect;
    		    }
    		    return Math.round(aspect * 100);
    		} catch (e){
    			__trcWarn("getThumbAspectRatio", e.message);
    			return null;
    		}
    	};

    	/**
    	 * Consult the available thumbnail list in the video data, and figure out
    	 * the best thumbnail URL to use for the specified thumbnail dimension.
    	 * This method works under the permise that its better to scale down then up
    	 * and that aspect ratio doesn't matter.
    	 * @param videoData TRC recommendation object
    	 * @param thumbWidth needed thumbnail width
    	 * @param thumbHeight needed thumbnail height
    	 * @returns {String} a thumbnail URL from the video recommendation object
    	 */
    	TRCRBox.prototype.getThumbnailURL = function(videoData, thumbWidth, thumbHeight) {
    		if (typeof videoData['thumb-size'] == 'undefined')
    			return videoData['thumbnail'];
    		var thumbs = [ {
    			w:videoData['thumb-size'].split('x')[0],
    			h:videoData['thumb-size'].split('x')[1],
    			u:videoData['thumbnail']
    		} ];
    		for (var i = 1; ; i++) {
    			if (typeof videoData['thumb-size-' + i] == 'undefined')
    				break;
    			thumbs.push({
    				w:videoData['thumb-size-' + i].split('x')[0],
    				h:videoData['thumb-size-' + i].split('x')[1],
    				u:videoData['thumbnail-' + i]
    			});
    		}

    		thumbs = thumbs.sort(function(a,b) {
    			return (a.w*a.h) - (b.w*b.h);
    		});

    		for (var j = 0; j < thumbs.length; j++)
    			if (thumbWidth * thumbHeight <= thumbs[j].w * thumbs[j].h)
    				return thumbs[j].u;
    		return thumbs.pop().u;
    	};

        /**
         * Add the Taboola attribution label to the R-Box UI
         */
    	TRCRBox.prototype.addTaboolaLogo = function() {
          this.renderAdchoicesLink(this.getAdchoiceConfig(), this.itemsTypes, this.adcItemTypes);
          this.renderAttributionLink();
          this.renderDisclosureLink();
          this.addClearingDiv();
          this.addWidgetContentType();
          TRC.ccpa.renderOnWidgetFooter(this);
    	};

        /**
         * Renders the taboola attribution link in the header or in the footer of the widget
         */
    	TRCRBox.prototype.renderAttributionLink = function() {
    		var attributionElement = this.add_span(null, this.trc.getProperty(this.mode_name, 'attribution-text', this.propertiesOverride)),
                attributionPosition = this.trc.getProperty(this.mode_name, 'attribution-position', this.propertiesOverride),
                needsAttribution = this.trc['attribution'] && attributionPosition != 'none',
                hideAttributionWhenNoPlace = this.trc.getProperty(this.mode_name, 'hide-attribution-when-no-place', this.propertiesOverride),
    			direction = this.trc['attribution-disclosure-direction'];

            if (needsAttribution) {
                if ( ("top" === attributionPosition)) {
                    if (!this.isContainerNarrowForAttribution()) {
                        this.generateLinksBox(this.header.ext, attributionElement, direction, "attribution", null, "top");
                    } else {
                        if (!hideAttributionWhenNoPlace) {
                            this.generateLinksBox(this.getWidgetFooter(), attributionElement, direction, "attribution", null, "bottom");
                        }
                    }
                } else {
                    this.generateLinksBox(this.getWidgetFooter(), attributionElement, direction, "attribution", null, "bottom");
                }
            }
    	};

    	TRCRBox.prototype.isContainerNarrowForAttribution = function() {
    	    if (TRC.isOptim('attribution') && this.isFeedCard) {
    	        return false
    	    }
    		var minWidthForAttribution = this.trc.getProperty(this.mode_name, 'min-width-for-attribution', this.propertiesOverride),
    			containerWidth = this.container.clientWidth || this.container.offsetWidth;

    		return containerWidth && (minWidthForAttribution > containerWidth);

    	};

        /**
         * change the adc icon display state
         * @param elem
         * @param bigon
         */


        TRCRBox.prototype.adcHoverHandler = function(elem, bigon) {
            var badc = __trcGetElementsByClass("trc_adc_b_logo",null,elem)[0]; // elem.getElementsByClassName("trc_adc_b_logo")[0];
            if(bigon){
                badc.style.display = "inline-block";
            } else {
                badc.style.display = "none";
            }
        };
        /**
         * render adChoices icon and hooks hovering behavior
         * @param adcConfig
         * @param hasAdcItem
         * @returns {boolean}
         */
        TRCRBox.prototype.isAdchoicesEnabled = function(adcConfig, itemsTypes, adcItemTypes){
            if (!adcConfig) {
                return false;
            } else if (adcConfig.status =="off"){
                return false;
            } else if (!this.isAdchoiceItemTypes(itemsTypes, adcItemTypes)) {
                return false;
            }
            return true;
        };

        /**
         * locate item types suitable to ad choice by configuration
         * @param itemsTypes {Object}
         * @param config {Object}
         * @returns {boolean}
         */
        TRCRBox.prototype.isAdchoiceItemTypes = function(itemsTypes, config){
            for (var type in itemsTypes){
                if (config[type]){
                    return true;
                }
            }
            return false;
        };

        /**
         * collect and return adchoice configurations
         * @returns {{status: string, position: (property|*), url: (property|*), enableBig: (property|*)}}
         */
        TRCRBox.prototype.getAdchoiceConfig = function(){
    		var adcPosition = this.trc.getProperty(this.mode_name, 'adchoice-position', this.propertiesOverride);

            return {
                status : (this.trc.global['has-adchoice'] && adcPosition !== 'none') ? 'on' : 'off',
                position : adcPosition,
                url : this.trc.getProperty(this.mode_name, 'adchoice-target-url', this.propertiesOverride) || this.trc.global['adchoice-url'],
                enableBig : this.trc.getProperty(this.mode_name, 'adchoice-large', this.propertiesOverride)
            }
        };

        /**
         * return adchoice position
         * @param adcPosition
         * @param attributionPosition
         * @returns {string}
         */
        TRCRBox.prototype.getAdchoicesPosition = function(adcPosition, attributionPosition){
            var pos = 'top';
            if(adcPosition === 'auto'){
    			pos = (attributionPosition === 'none') ? pos : attributionPosition;

    			if(this.isContainerNarrowForAttribution()) {
    				pos = 'bottom';
    			}
    		} else {
                pos = adcPosition;
            }

            return pos;
        };
        /**
         * adds the ac-choice icons to a widget
         * @param adcConfig
         */
        TRCRBox.prototype.renderAdchoicesLink = function(adcConfig, itemsTypes, adcItemTypes) {
            this.hasAdChoicesLogo = this.isAdchoicesEnabled(adcConfig, itemsTypes, adcItemTypes);

            if ( !this.hasAdChoicesLogo ) {
                return;
            }
            var adcText = null, //append a &nbsp; so that the font size will affect the size for proper vertical alignment
                adcPosition = this.getAdchoicesPosition(adcConfig.position, this.trc.getProperty(this.mode_name, 'attribution-position', this.propertiesOverride)),
                adcContainer,
                url = adcConfig.url || null,
    			direction = this.trc['attribution-disclosure-direction'];

            adcText = this.add_span("trc_adc_wrapper", null);
            adcText.appendChild(this.add_span("trc_adc_s_logo", null));
            if (adcConfig.enableBig) {
                adcText.appendChild(this.add_span("trc_adc_b_logo", null));
            }
            adcText.appendChild(createNonBreakingSpace());

            if ("top" === adcPosition) { // falsy "adcConfig.position" value means that the adchoice logo positions itself with the attribution
    			adcContainer = this.generateLinksBox(this.header.ext, adcText, direction, "adc", null, "top", url);
            } else {
                adcContainer = this.generateLinksBox(this.getWidgetFooter(), adcText, direction, "adc", null, adcPosition, url);
            }
            if (adcConfig.enableBig) {
                adcContainer.onmouseover = function () {
                    TRCRBox.prototype.adcHoverHandler(this, true);
                };
                adcContainer.onmouseout = function () {
                    TRCRBox.prototype.adcHoverHandler(this, false);
                };
            }

        };

        /**
         * renders the link box and appends it to a hosting container
         * @param container  - where to render the link box
         * @param contentElement - the link's content element
         * @param direction  - "ltr" or "rtl"
         * @param type       - "attribution" or "disclosure"
         * @param mixType    - "", "sponsored" or "hybrid"
         * @param position   - "bottom" or "top", default "top"
         * @param _url       - "defaultUrl" or override url
         * @param alignment  - "left" or "right", default "left"
         */
        TRCRBox.prototype.generateLinksBox = function(container, contentElement, direction, type, mixType, position, _url, alignment) {
            var i,
                attributionContainer = document.createElement("div"),
                attributionClasses = ["trc_desktop_" + type + "_link", "trc_mobile_" + type + "_link"],
                attributionLink,
    			popupUrl = this.getPopupUrl(),
                defaultUrl = TRC.PROTOCOL + "//" + TRC.shiftDomain(popupUrl) + "/?" + this.getAttributionLinkParams(),
                url = _url || defaultUrl,
                sponsoredRelAttr = "sponsored",
                handleClick = function(event){
                    return TRC.aboutUs.open(event) || false;
                };

            if (container) {

                // first link is for desktop (opens in a modal dialog)
                // second link is for mobile devices (opens in a new tab)
                for (i = 0; i < attributionClasses.length; i++) {
                    attributionLink = document.createElement("a");
                    attributionLink.className = attributionClasses[i] + " trc_attribution_position_" + (position || "bottom");

    				attributionLink.rel = "nofollow";

    				if (!this.trc.global['disable-sponsored-for-links']) {
    					attributionLink.rel += " " + sponsoredRelAttr;
    				}

                    if (!this.trc.global['disable-noopener-for-links']) {
                        attributionLink.rel += " noopener";
                    }
                    attributionLink.appendChild(contentElement.cloneNode(true));
                    attributionLink.href = url;
                    attributionLink.target = '_blank';

                    /* this is a hack for adchoices logo - we append a span with nbsp; after the logo text in order to make sure that
                     all logos are vertically aligned. The logic here is that even when we have a font size without text in it
                     (for example, "adchoices" logo), the text in this span will make the browser vertically align
                     by this text.
                     */
                    if(this.hasAdChoicesLogo) {
                        var linkInner = this.add_span("trc_logos_v_align", null);
                        linkInner.appendChild(createNonBreakingSpace());
                        attributionLink.appendChild(linkInner);
                    }

                    if (!i) {
                        attributionLink.onclick = handleClick;
                    }
                    attributionContainer.appendChild(attributionLink);
                }
                if ("rtl" === direction) {
                    attributionContainer.style.cssFloat = attributionContainer.style.styleFloat = "left";
                }
                attributionContainer.className = "logoDiv link-" + type +  " " + (mixType ? " attribution-disclosure-link-" + mixType : "") + (alignment ? " align-" + type + "-" + alignment : "");
                container.appendChild(attributionContainer);

                return attributionContainer;
            }
        };

        TRCRBox.prototype.getAttributionLinkParams = function() {
            var paramsArr = [
                    'template=colorbox',
                    'utm_source=' + this.publisher,
                    'utm_medium=referral',
                    'utm_content=' + this.mode_name + ":" +  this.placement + ":" + (this.trc['test-variant'] || "")
                ];

            if(!this.trc.global['show-rtb-ad-choices-icon'] && this.privacyId) {
                paramsArr.push('plink=' + this.privacyId);
            }

            return paramsArr.join('&');
        };

        TRCRBox.prototype.addWidgetContentType = function() {
            var contentType = this.getWidgetContentType(this.itemsTypes);
            this.element.className += " trc-content-" + contentType + " ";
        };


        /**
         * iterates through the recommendation list to query the widget's type
         * @returns {string}  - "organic", "sponsored",  "hybrid"
         */
        TRCRBox.prototype.getWidgetContentType = function(typeList) {
            var isSponsored = typeList["is-syndicated"] || typeList["is-in-network"] || typeList["is-native"];
            return isSponsored && typeList["is-organic"] ? "hybrid" : (isSponsored ? "sponsored" : "organic");
        };
        /**
         * iterated over the modes recommendation list and extracts the items types to an object
         * @return {Object}
         */
        TRCRBox.prototype.getItemsTypesList = function(recommendationList){
            var itemTypes = {},
                i = 0,
                item;
            for(; item = recommendationList[i]; i++){
                if (item["is-syndicated"]){ // sponsored
                    itemTypes["is-syndicated"] = true;
                } else if(item["is-in-network"]){ // AE
                    itemTypes["is-in-network"] = true;
                } else if (item["is-native"]){ // publisher native
                    itemTypes["is-native"] = true;
                } else {
                    itemTypes["is-organic"] = true; // non standard type(trc has not "is-organic" item type)
                }
                if (item["is-adc"]){
                    itemTypes["is-adc"] = true;
                }

            }
            return itemTypes;
        };

        TRCRBox.prototype.getPrivacyId = function(recommendationList) {
            var i = 0,
                item;
            for(; item = recommendationList[i]; i++){
                if(item['plink']) {
                    return item['plink'];
                }
            }

            return null;
        };

        /**
         * Creates an ad-hoc footer and returns it when needed
         */
        TRCRBox.prototype.getWidgetFooter = function() {
        	var widgetToFeedHelper = this.getWidgetToFeedHelper();

            if (!this.footer) {
                this.footer = document.createElement("div");
                this.footer.className = "trc-widget-footer";

                if(widgetToFeedHelper && !widgetToFeedHelper.getFooter()) {
                	widgetToFeedHelper.addFooterToFeed(this.footer);
    			} else {
                    this.element.appendChild(this.footer);
                }
            }
            return this.footer;
        };

        /**
         * Renders taboola's disclosure link preferably on top (in the header of the widget)
         */
        TRCRBox.prototype.renderDisclosureLink = function() {
            var minWidthForDisclosure = this.trc.getProperty(this.mode_name, 'min-width-for-disclosure', this.propertiesOverride),
                hideDisclosureWhenNoPlace = this.trc.getProperty(this.mode_name, 'hide-disclosure-when-no-place', this.propertiesOverride),
                disclosureTextSponsored = this.add_span(null, this.trc.getProperty(this.mode_name, 'disclosure-link-text-sponsored', this.propertiesOverride)),
                disclosureTextHybrid = this.add_span(null, this.trc.getProperty(this.mode_name, 'disclosure-link-text-hybrid', this.propertiesOverride)),
                containerWidth,
    			direction = this.trc['attribution-disclosure-direction'];

            if (this.getDisclosurePosition() !== 'none' &&  this.getDisclosurePosition() !== 'after_branding') {
                if ((this.isFeedCard && TRC.isOptim('disclosure'))) {
                    containerWidth = 0;
                } else {
                    containerWidth = (this.container.clientWidth || this.container.offsetWidth);
                }
                if (this.getDisclosurePosition() !== 'bottom' && this.isHeaderExtContainerAvailable()
                    && (!containerWidth || containerWidth >= minWidthForDisclosure)) {
                    this.generateLinksBox(this.header.ext, disclosureTextSponsored, direction, "disclosure", "sponsored", "top");
                    this.generateLinksBox(this.header.ext, disclosureTextHybrid, direction, "disclosure", "hybrid", "top");
                } else {
                    if (!hideDisclosureWhenNoPlace) {
                        this.generateLinksBox(this.getWidgetFooter(),  disclosureTextSponsored, direction, "disclosure", "sponsored", "bottom");
                        this.generateLinksBox(this.getWidgetFooter(),  disclosureTextHybrid, direction, "disclosure", "hybrid", "bottom");
                    }
                }
            }
        };

        /**
         * Renders taboola's disclosure link when With branding option is selected
         */
        TRCRBox.prototype.renderDisclosureLinkWithBranding = function(parent, disclosureText) {
            var disclosureHTML = this.add_span(null, disclosureText),
    			direction = this.getDisclosureAlignment() === "right" ? this.trc.direction : null;

            this.generateLinksBox(parent, disclosureHTML, direction, "disclosure", "sponsored", this.getDisclosurePosition(), null, this.getDisclosureAlignment());
        };

        TRCRBox.prototype.isHeaderExtContainerAvailable = function() {
    		return this.header.ext
    			&& this.trc.getProperty(this.mode_name, 'header', this.propertiesOverride) != "No Header";
    	};

        /**
         * Adds a clearing div after the widgets footer to ensure any floating attribution or disclosure text
         * is properly cleared. Should be replaced with smarter css (auto clearing)
         */
        TRCRBox.prototype.addClearingDiv = function() {
            var clearDiv = document.createElement("div");
            clearDiv.className = "trc_clearer";
            this.element.appendChild(clearDiv);
        };

        /**
    	 * Generate the duration gradient box
    	 * @param dur duration in seconds
    	 * @return {HTMLElement} element
    	 */
    	TRCRBox.prototype.genDuration = function(dur) {
    		var durLabel = this.formatDuration(dur);
    		var op_dt = document.createElement('dt');
    		op_dt.style.position = "absolute";
    		op_dt.style.overflow = "hidden";
    		op_dt.style.height = "auto";
    		op_dt.style.width = "auto";
    		op_dt.style.zIndex = 48;
    		op_dt.style.right = 0;
    		var op_label = document.createElement('div');
    		op_label.style.zIndex = 50;
    		op_label.style.paddingLeft = "4px";
    		op_label.style.paddingRight = "4px";
    		op_label.innerText = durLabel;
    		op_dt.appendChild(op_label);
    		return op_dt;
    	};

    	/**
    	 * Fix overflowing text by truncating it with an elipsis or decreasing the font size until it fits
    	 * @param span DOM element with text to manipulate
    	 * @param originalText the original text that needs fitting into the box
    	 * @param byWords whether we should maintain complete words if possible
    	 * @param doTruncate Optional: set to "false" to try decreasing font-size first
         * @param inlineDetailsList (optional) - Array of details that should be appended to the title span (e.g. branding)
         * @param parent - the parent of the box
    	 */
    	TRCRBox.prototype.fixBoxOverflow = function(span, originalText, byWords, doTruncate, inlineDetailsList, parent) {
            if (TRC.util.isPercentEnabled(TRCImpl.global, 'enable-new-ellipsis-module')) {
                return TRC.LineClamp.fixBoxOverflow(
                    span,
                    originalText,
                    byWords,
                    doTruncate,
                    inlineDetailsList,
                    parent,
                    this.useNativeLineClamp,
                    this.shouldUseSmartEllipsis()
                );
            }
            else {
                return this.legacyFixBoxOverflow(span, originalText, byWords, doTruncate, inlineDetailsList, parent);
            }
        };

    	TRCRBox.prototype.legacyFixBoxOverflow = function(span, originalText, byWords, doTruncate, inlineDetailsList, parent) {
            var lineClampUsed = false;

            if (span == null)
    			return;

            /*
             If possible, use the browser's line-clamp feature instead of this heavy calculation function.
             Line clamp won't work when there are inline details in the title.
             */
            if(this.useNativeLineClamp) {
                lineClampUsed = this.setupBoxLineClamp(span);
                if(lineClampUsed) {
                    return;
                }
            }

    		if (this.shouldUseSmartEllipsis() && !lineClampUsed) {
    			return __trcDebug('Skipping fixBoxOverflow due to feature flag.');
    		}

    		if (TRC.ellipsisPerf) { console.timeStamp("Taboola old ellipsis"); }

    		if (span.clientHeight <= 0 || span.clientWidth <= 0)
                return;

    		var was_overflow = false;

            // measure the line height for this element - this is used by thumbnail-under widgets
            // for setting the label-box-anchor's height
    		span.parentNode.font = this.getFontSize(span);
    		var store = span.innerHTML;
    		span.innerText = '';
    		var measure = this.add_span(null,'H', span);
    		var lineHeight = Math.max(measure.offsetHeight,measure.clientHeight);
    		// do we need some extra padding to prevent cutting the bottom of the text?
    		var extra = Math.max(0, span.scrollHeight - span.clientHeight);
    		span.removeChild(measure);
            TRC.dom.setContentToElement(span, store);

            //If box should have additional inner elements, append them to the box.
            this.addInlineElementsForMeasure(span.inlineDetailsElements, span, true);
            //store the inline details HTML - should be re-appended after every measure and truncation
            span.inlineDetailsElementsHTML = span.innerHTML.replace(store, '');

    		// make sure the original text is not space padded
    		originalText = originalText.replace(/^\s+|\s+$/g, '');

    		while ((span.clientHeight + extra + (lineHeight / 2)) < span.scrollHeight && originalText.length) {
    			was_overflow = true;
    			originalText = this.truncateOverflowingText(span, originalText, byWords);

                if (span.inlineDetailsElementsHTML) {
                    span.innerHTML += span.inlineDetailsElementsHTML;
                }
    		}

            /*
             * Hide the original detail elements (these elements were already
             * cloned and appended to the title)
             */
    		this.hideClonedElementsAfterMeasure(inlineDetailsList, parent);

    		if (TRC.Browser.ie && !was_overflow) {
    			span.style.height = "auto";
    		}
        };

        /**
         * Fix overflowing text using the browser's line-clamp feature
         * @param span
         * @return {Boolean} - whether the line clamp succeeded
         */
        TRCRBox.prototype.setupBoxLineClamp = function(span) {
            TRC.dom.removeClass(span, 'trc_ellipsis');

            var lineHeight = parseInt(document.trcGetCurrentStyle(span, 'line-height'), 10),
                height = parseInt(document.trcGetCurrentStyle(span, 'height'), 10),
                numLines = lineHeight && height ? Math.round(height / lineHeight).toString() : null;

            //if we could not figure out how many lines are allowed, or the span text direction is RTL - do not perform line clamp
            //(line-clamp does not work with RTL, see https://bugs.webkit.org/show_bug.cgi?id=94282)
            if(!numLines || span.isRTL || document.trcGetCurrentStyle(span, 'direction') == 'rtl') {
                return false;
            }

            TRC.dom.addClass(span, 'trc_ellipsis');
            TRC.css.utils.setStyleProperty(span, '-webkit-line-clamp', numLines, false);

            // measure the line height for this element - this is used by thumbnail-under widgets
            // for setting the label-box-anchor's height
            span.parentNode.font = this.getFontSize(span);

            return true;
        };



    	/**
    	 * Truncates 1 character / word from overflowing text and adds hellipsis.
    	 * @param span - the span that contains the text
    	 * @param text - the text that should be truncated
    	 * @param byWords - whether to truncated one word / one character
    	 * @return {String} text - the text after truncation
    	 */
    	TRCRBox.prototype.truncateOverflowingText = function(span, text, byWords) {
    		text = byWords && text.search(/\s/)>=0 ?
    				text.replace(/\s+\S+$/,'') :
    				text.substr(0,text.length - 1);

    		var bde_el = span.getElementsByTagName('bde'); // check if we have an embedded BiDi element

            if(span.inlineDetailsElementsHTML && bde_el.length) {
                //remove the inline elements from to allow correct truncation of title.
                //needed only when bde is used, otherwise these elements will be removed from the span anyway
                //in the next lines because the innerHTML of the span is being reset
                var spanContent = span.innerHTML.replace(span.inlineDetailsElementsHTML, '');
                TRC.dom.setContentToElement(span, spanContent);
            }

            // remove old ellipsis if found
    		if (span.getElementsByTagName("span").length > 0) {
                span.removeChild(span.getElementsByTagName('span')[0]);
            }

    		var contentElement = (bde_el.length > 0) ? bde_el[0] : span;
            TRC.dom.setContentToElement(contentElement, text);
    		this.add_span(null,createEllipsis(),span);

    		return text;
    	};

    	/**
    	 * Appends inline elements to a given parent before parent is being measured for truncation
    	 * @param inlineElements
    	 * @param parent
         * @param doClone - whether the appended elements should be cloned before appending
    	 */
    	TRCRBox.prototype.addInlineElementsForMeasure = function(inlineElements, parent, doClone) {
    		var inlineElement,
                inlineElementFound,
                spacer;

            for(var i = 0; inlineElements && i < inlineElements.length; i++) {
    			inlineElement = inlineElements[i];
                inlineElementFound = this.findElement(function(e){
                    return e.className.search(inlineElement) >= 0 && e.parentNode === parent;
                }, parent);

    			if(!inlineElementFound && inlineElement) {
    				//Add space before element
    				spacer = document.createElement('span');
    				spacer.className = 'trc_inline_detail_spacer';
    				spacer.innerHTML = ' ';
    				parent.appendChild(spacer);

    				//append the inline element
    				parent.appendChild(doClone ? inlineElement.cloneNode(true) : inlineElement);
    			}
    		}
    	};

    	/**
    	 * Hide elements inside a given parent (after these elements were cloned)
    	 * @param originalElements - the original elements that were cloned and should be invisible now
    	 * @param parent
    	 */
    	TRCRBox.prototype.hideClonedElementsAfterMeasure = function(originalElements, parent) {
            var elementClassName,
                element;

    		for(var i = 0; originalElements && i < originalElements.length; i++) {
    			elementClassName = originalElements[i];
    			element = this.findElement(function(e){
    				return e.className.search(elementClassName) >= 0 && e.parentNode === parent;
    			}, parent, 'span');

    			if(element) {
    				element.style.display = 'none';
    			}

    		}
    	};

    	/**
    	 * Helper method to remove HTML tags from text strings
    	 * @param desc text to normialize
    	 * @returns {String} resulting text
    	 */
    	TRCRBox.prototype.removeHtmlTags = function(desc) {
    		return desc != null ? desc.replace(new RegExp('<[^>]+>', "g"), '') : null;
    	};

    	/**
    	 * Format a label using a custom formatter
    	 * @param formatname type of formatting to use - either a pattern, JS logic or the label "duration"
    	 * @param data data to format
    	 * @returns {String} formatted text
    	 * @type String
    	 */
    	TRCRBox.prototype.formatData = function(formatname, data) {
    		var format = this.trc.getProperty(this.mode_name, 'format-' + formatname, this.propertiesOverride);

    		format = format || '%s';
    		if (typeof format == "function")
    			return format.call(this, data);
    		if ((formatname.search("duration") >= 0) || (formatname.search("Duration") >= 0))
    			data = this.formatDuration(data);
    		if (typeof data == 'undefined')
    			data = "";
    		/** @type String */
    		return format.replace(new RegExp('%\\w'), '<dt style="display:inline">' + data + '</dt>');
    	};

    	/**
    	 * Helper method to format duration values into a textual time representation
    	 * @param dur duration in seconds
    	 * @returns {String} formatted time representation
    	 */
    	TRCRBox.prototype.formatDuration = function(dur) {
    		var hours = parseInt(dur / 3600);
    		if (hours >= 1)
    			dur = dur % 3600;
    		else
    			hours = 0;
    		var min = parseInt(dur / 60);
    		var sec = parseInt(dur % 60);

    		if (typeof hours != 'number' || typeof min != 'number' || typeof sec != 'number' || isNaN(hours) || isNaN(min)
    				|| isNaN(sec) || dur < 1)
    			return '';
    		return (hours >= 1 ? (hours + ':') : '') + (min < 10 ? '0' : '') + min + ':' + (sec < 10 ? '0' : '') + sec;
    	};

    	//noinspection JSUnusedGlobalSymbols
        /**
    	 * Helper method to format numbers using optional configurable logic
    	 * @param num integer to format
    	 * @returns {String} formatted text
    	 * @type String
    	 */
    	TRCRBox.prototype.formatNumber = function(num) {
    		if(typeof num == "undefined" ) {
          return "";
        }
        return this.trc.runHook(this, this.mode_name, 'format-number', this.propertiesOverride, false,  num);
    	};

        TRCRBox.prototype.dateFormatISO = TRC.DateUtils.dateFormatISO;

        TRCRBox.prototype.dateFormatAmerican = TRC.DateUtils.dateFormatAmerican;

        TRCRBox.prototype.dateFormatEuropean = TRC.DateUtils.dateFormatEuropean;

    	/**
    	 * Calculate font-size in pixels for a given DOM element
    	 * @param obj DOM element to inspect
    	 * @returns size of font in pixels
    	 */
    	TRCRBox.prototype.getFontSize = function(obj) {
    		var i = 0;
    		var hasStr = false;
    		var fontSize = document.trcGetCurrentStyle(obj, 'font-size');
    		var substr = [ 'px', 'pt', 'em', 'ch' ];
    		while ((!hasStr) && (i < substr.length)) {
    			if (fontSize.indexOf(substr[i])) {
    				fontSize = parseInt(fontSize);
    				switch (substr[i]) {
    					case 'px':
                            //do nothing - parseInt did the work
    						break;
    					case 'pt':
    						fontSize = (fontSize / 0.75);
    						break;
    					case 'em':
    					case 'ch':
    						fontSize = (fontSize * 10);
    						break;
    				}
    				hasStr = true;
    			}
    			i++;
    		}
    		return fontSize;
    	};

    	/********************************
    	 *  related responsive methods  *
    	 ********************************/
    	TRCRBox.prototype.sendExploreEvent = function(){
    		if (this.exploreTimeoutId) {
    			TRC.Timeout.clear(this.exploreTimeoutId);
    			this.exploreTimeoutId = null;
    		}
    		this.sendEvent('explore', {}, null, true);
    	};

    	TRCRBox.prototype.onMouseOverExploreTrackerHandler = function(explore_delay, e){
    		e = e || win.event;
    		var element = e.target || e.srcElement;
    		if((element != this.container && this.exploreTimeoutId != null) || (element == this.container && this.exploreTimeoutId != null)){
    			return;
    		}
    		this.exploreTimeoutId = TRC.Timeout.set(this.sendExploreEvent.trcBind(this), explore_delay);
    	};

        TRCRBox.prototype.setExploreTracker = function(){
        	var explore_delay = 0;
    		this.exploreTimeoutId = null;
    		if(typeof this.trc.global != "undefined"){
    			explore_delay = (this.trc.global['explore-delay'])?this.trc.global['explore-delay']:explore_delay;
    		}
    		this.container.onmouseover = this.onMouseOverExploreTrackerHandler.trcBind(this, explore_delay);
    		if(explore_delay != 0){
    			this.container.onmouseout = this.onMouseOutExploreTrackerHandler.trcBind(this);
    		}
        };

        TRCRBox.prototype.onMouseOutExploreTrackerHandler = function(e){
        	e = e || win.event;
    		var dimentions = this.container.getBoundingClientRect();
    		if((e.clientX >= dimentions.left && e.clientX < dimentions.right) && (e.clientY >= dimentions.top && e.clientY < dimentions.bottom)){
    			return;
    		}
    		if (this.exploreTimeoutId) {
    			TRC.Timeout.clear(this.exploreTimeoutId);
    			this.exploreTimeoutId = null;
    		}
        };

        TRCRBox.prototype.resetBoxes = function(){
    		this.boxes = [];
        };

        TRCRBox.prototype.setResponsiveRules = function(classPrefix, listSize) {
        	var rules = this.trc.getProperty(this.mode_name, 'responsive-rules', this.propertiesOverride);

    		if (rules){
    			this.setOnStandardResponsiveRules(classPrefix, listSize, rules);
    		} else {
    			this.setOnAutoSizeResponsiveRules(classPrefix, listSize, this.trc.getProperty(this.mode_name, 'auto-size-rules', this.propertiesOverride));
    		}
        };

        TRCRBox.prototype.setOnStandardResponsiveRules = function(classPrefix, listSize, standardRules){
    		var _rows = this.trc.getProperty(this.mode_name, 'rows', this.propertiesOverride),
        		DEFAULT_ROWS = 1,
                rulesArr,
    			carouselMinItems = this.trc.getProperty(this.mode_name, 'carousel-min-items', this.propertiesOverride) || 1.33;

        	try{
        		rulesArr = this.responsiveRules = [];
    			for(var i=0, len=standardRules.length; i<len; i++){
    				rulesArr[i] = {
    					rows    : standardRules[i].rows || _rows || DEFAULT_ROWS,
    					cells 	: standardRules[i].cells,
    					min     : standardRules[i].minWidth,
    					max 	: standardRules[i].maxWidth,
    					margin	: standardRules[i].margin.h, //percentage
    	   	     	 	ratio 	: this.getRuleAspectRatio(standardRules[i]) || this.getThumbAspectRatio(this.trc.modes[this.mode_name]) || (this.DEFAULT_THUMB_RATIO * 100)
    				};
    			}
                //inject rules only once per mode
                if(!TRC.css.responsive.injectedStyles[classPrefix] || this.disableResponsiveCSSReuse) {
                    TRC.css.utils.setStyleElements(TRC.css.responsive.rulesToCssText(classPrefix, this.responsiveRules, listSize, false, this.isWCTextLinks, this.trc.direction, this.isCarousel, carouselMinItems));
                    TRC.css.responsive.injectedStyles[classPrefix] = true;
                }
        	} catch (e){
        		__trcError("Error in setOnStandardResponsiveRules : ", e.message);
        	}
        };

        TRCRBox.prototype.setOnAutoSizeResponsiveRules = function(classPrefix, listSize, autoSizeRules){
        	var windowWidth = TRC.dom.getWindowWidth(),
        		containerWidth = (this.container.clientWidth > 0) ? this.container.clientWidth : this.container.offsetWidth,
        	    ratio = windowWidth / containerWidth,
        	    _rows = this.trc.getProperty(this.mode_name, 'rows', this.propertiesOverride),
        	    DEFAULT_ROWS = 1,
                rulesArr,
                carouselMinItems = this.trc.getProperty(this.mode_name, 'carousel-min-items', this.propertiesOverride);

        	try{
        		rulesArr = this.responsiveRules = [];
    			for(var i=0, len=autoSizeRules.length; i<len; i++){
    				rulesArr[i] = {
    					rows    : autoSizeRules[i].rows || _rows || DEFAULT_ROWS,
    					cells 	: autoSizeRules[i].n,
    					min     :  ratio * autoSizeRules[i]['minWc'],
    					margin	: ((Math.round((autoSizeRules[i]['maxWsRange'] + autoSizeRules[i]['minWsRange']) / 2)) / containerWidth) * 100,
    	   	     	 	ratio 	: this.getThumbAspectRatio(this.trc.modes[this.mode_name]) || autoSizeRules[i].ratio || (this.DEFAULT_THUMB_RATIO * 100)
    				};
    			}
                if(!TRC.css.responsive.injectedStyles[classPrefix] || this.disableResponsiveCSSReuse) {
                    TRC.css.utils.setStyleElements(TRC.css.responsive.rulesToCssText(classPrefix, this.responsiveRules, listSize, false, false, this.trc.direction), this.isCarousel, carouselMinItems);
                    TRC.css.responsive.injectedStyles[classPrefix] = true;
                }
    		}catch(e){
    			__trcError("Error in setOnAutoSizeResponsiveRules : ", e.message);
    		}
        };

        TRCRBox.prototype.setMetaAttribute = function(obj){
    		obj.meta = {};
    		__trcCopyProps(this.trc, obj.meta);
    		delete obj.meta['video-list'];
        };
        /**
    	 * initiate the responsive mode rendering phase
    	 * !! notice that in some cases the order the methods are call is important
    	 * as the the have dependencies on object populated/created by pre called methods
    	 * @param trc recommendation object retrieved from the server
    	 */
    	TRCRBox.prototype.drawResponsiveList = function(trc, postData, utmParams){
            (TRC.tlf && console.timeStamp('start mode - ' + this.mode_name));
            (TRC.tlf && console.group("mode - " + this.mode_name));
    		(TRC.tlf && console.time('mode rendering'));

    		var listContainer = this.listContainer,
    			internalc = document.createElement("div"),
    			listSize = this.recommendationList.length,
    			visible_delay = 0,
                visible_cycle = 1000,
    			trc_container = TRC.dom.closest(this.getContainer(), '.trc_related_container'),
    			ELASTIC_CSS_NAME = "trc_elastic";

        TRC.pConsole(this.mode_name, "debug", "start drawing responsive mode - see info", this.trc.getProperty(this.mode_name, 'responsive-rules', this.propertiesOverride), "object");

    		this.internalContainer = internalc;
    		this.orientation = this.trc.getProperty(this.mode_name, 'orientation', this.propertiesOverride);
        var ruleSuffix = this.disableResponsiveCSSReuse ? this.id : this.mode_name;
        TRC.dom.addClass(trc_container, ELASTIC_CSS_NAME + " " + ELASTIC_CSS_NAME + "_" + ruleSuffix);
    		this.resetBoxes();
    		internalc.id = 'internal_' + this.id;
    		TRC.dom.clearInnerElements(listContainer);
    		listContainer.appendChild(internalc);

    		this.setExploreTracker();
    		this.setMetaAttribute(internalc);
    		this.firstVideo = null;
    		this.setResponsiveRules(ELASTIC_CSS_NAME + "_" + ruleSuffix, listSize);
    		this.pasreRecommendationList(listSize, this.hasDuration(), internalc, postData, utmParams);
            this.renderCTA(internalc, this);
            handleResponsiveWidget({rbox: this});

    		if (!this.trc.global["smart-ellipsis"]) { // Smart ellipsis works on higher, "all boxes" level, not single box.
    			if (this.isClassFilter) {
    				TRC.listen("IE_ClassShift", this.fixResponsiveVideoBoxes.trcBind(this)); // this event is set in setResponsiveRules method and will ease the resize actions done on IE8-
    			} else {
    				TRC.dom.on(win, "resize", this.fixResponsiveVideoBoxes.trcBind(this).trcThrottle(500));
    				TRC.listen("videoCubeChange", this.fixResponsiveVideoBoxes.trcBind(this)); //support for widget creator event
    			}
    		}

    		if(!this.boxes.length || this.boxes.length <= 0) {
    		    var placement = this.response.feedPlacement || this.placement;
                TRC.dispatch('onRboxFlowError', {placement:placement});
            }

    		TRC.dom.addClass(this.boxes[0],'trc-first-recommendation trc-spotlight-first-recommendation');

    		// setup "end of R-Box" configuration handlers
    		this.postRenderQueue.pushBack("list-suffix,publisher-end",function(internalc) {
    		  this.trc.runHook(this, this.mode_name, "list-suffix", this.propertiesOverride, true, internalc, this);

          this.trc['publisher-end'](this.id);
          TRC.CustomModulesManager.runHook('publisher-end', null, this, this.id);
    		}.trcBind(this, internalc));

    		this.postRenderQueue.pushBack('checkForBlocking',this.checkForBlocking.trcBind(this));

    		// and run the post-rendering queue
    		this.postRender();

    		//send available event (doesn't depends on visibility) - !! we move the  "available to" the recommendations response handler
    		//this.sendEvent('available', {}, true);

    		this.visibleTimeoutId = null;
    		if(typeof this.trc.global != "undefined"){
    			visible_delay = (this.trc.global['visible-delay'])?this.trc.global['visible-delay']:visible_delay;
                visible_cycle = (this.trc.global['visible-cycle']) ? this.trc.global['visible-cycle'] : visible_cycle;
    		}
            TRC.MetricsManager.sendMetricsEvent(TRC, this.trc, {name: 'UiItemsRendered', value: TRC.MetricsManager.getMetricValue('UiItemsRendered'), type:'counter'}, null);
    		TRC.fallbackApi.finalize(this);
    		if(TRC.Heatmap.isEnabled(this.trc)){
    		    this.attachHeatMapToContainer(trc_container);
            }

    		// send visible event only when we are actually visible
            this.visibilityReporter = new TRC.WidgetVisibilityReporter(this);
            TRC.eventDelegator.dispatch("onrender", {name : this.mode_name, container : this.container, 'placement' : this.orig_placement});
            TRC.EventsAPI.dispatchRender(trc, this);
            (TRC.tlf && console.timeEnd('mode rendering'));
            (TRC.tlf && console.groupEnd());

    	};

      TRCRBox.prototype.attachHeatMapToContainer = function(trc_container){
          if(!this.isFeedCard){
              this.listContainer.heatmap = new TRC.Heatmap(this.trc);
              TRC.dom.on(this.listContainer, 'click', (function(event) {
                  this.listContainer.heatmap.captureAndSendClickData(event);
              }).bind(this));
          } else {
              this.listContainer.heatmap = this.getCurrentFeed(trc_container).heatmap;
          }
      };

    	TRCRBox.prototype.getCurrentFeed  = function(trcContainer){
          var feeds = this.trc.feedsManager.feeds,
              placementName = trcContainer.getAttribute('data-placement-name');
          for (var feedName in feeds) {
              if (feeds.hasOwnProperty(feedName) && placementName.indexOf(feedName) > -1) {
                  return feeds[feedName];
              }
          }
      };

    	TRCRBox.prototype.createVideoBoxDirectURL = function(videoBoxContainer){
    		var video = videoBoxContainer.video_data,
    			directURL = video.url;

    		// figure out direct and redirect URLs
    		try{
    			if (!video.isSyndicated) {
            video.original_url = directURL;
            var tracking = this.formatTrackingParam() || this.tracking;
    				directURL = this.trc.runHook(this, this.mode_name, "change-url", this.propertiesOverride, false, directURL, videoBoxContainer, tracking );

    				if(directURL === video.original_url && tracking){
    					directURL = TRC.URL.prototype.addParamsToUrl(directURL, tracking);
    				}
    			}

          video.url = directURL;

    			videoBoxContainer.directURL = directURL;
    		} catch (e){
    			__trcError("Error in createVideoBoxDirectURL", e);
    		}
    	};

      TRCRBox.prototype.formatTrackingParam = function() {
        var tracking = this.getModeClientProperty('organic-tracking-params');
        if(tracking){
          return Object.keys(tracking).reduce(function(prev, key, i){
            return prev + (i!==0 ? '&':'') + key + '=' + tracking[key];
          },'');
        }
      };

        /**
         * create and return params for log url
         * @param video recommendation object for this video box
         * @param directURL
         */
        TRCRBox.prototype.createVideoBoxClickUrlParams = function(video, directURL){
            var responseSessionData = (this.response && this.response.trc) ? this.response.trc['session-data'] : null,
                params = {
                pi: this.trc.getItemId(),
                ri: this.response.trc['req'],
                sd: this.trc.getSessionData(responseSessionData),
                ui: TRC.pageManager.getUserId(),
                it: video.type,
                ii: video['item-id'],
                pt: this.getItemType(),
                li: this.getListId(),
    			sig: video.sig,
                url: directURL,
                vi: this.cachedViewId || TRC.pageManager.getPageData(),
                p: (video.isSyndicated) ? video.publisher : '',
                r: Math.floor(Math.random() * 100)
            };

            var template = this.trc.formattedTRCRequest && this.trc.formattedTRCRequest.tmpl,
                placementGroup = this.response.trc['placement-group'];
            if (template) {
                params.tmpl = template;
            }
    		if (placementGroup) {
                params.pg = placementGroup;
            }
            return params;
        };

        /**
         * create and return log url with given parameters
         * @param params parameters of the url
         */
        TRCRBox.prototype.createVideoBoxClickUrlWithParams = function(params){
            var queryString = [],
                logUrl;

            for (var key in params) {
                if(params.hasOwnProperty(key) && params[key]){
                    this.trc['normalize-log-param'](key, params[key]);
                    queryString.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
                }
            }

            logUrl = protocol + '//' + this.domain + '/' + encodeURIComponent(this.trc['normalize-log-param']('publisher',TRC.publisherId)) + '/log/3/click?' + queryString.join('&');

            if(this.trc.enableExperimentsVariantIdEvent && this.trc.experimentsVariantIdParamsStr) {
                logUrl += "&" + this.trc.experimentsVariantIdParamsStr;
            }

            if (this.trc.getLoaderTypesValue()) {
                logUrl += "&" + this.trc.getLoaderTypesValue();
            }

            return logUrl;
        };
    	 /**
    	 * create and return log url for video box
    	 * @param video recommendation object for this video box
    	 * @param directURL
    	 */
    	TRCRBox.prototype.createVideoBoxClickUrl = function(video, directURL){
    	    var params = this.createVideoBoxClickUrlParams(video, directURL);
    	    return this.createVideoBoxClickUrlWithParams(params);
    	};

    	/**
    	 * Helper method to check the title and description entities in the specified label box
    	 * for overflow and fix it if needed
    	 * @param videoBoxContainer - the container element of the video box
    	 */
    	TRCRBox.prototype.fixResponsiveBoxTitleAndDesc = function(videoBoxContainer) {
    		var labels_box = videoBoxContainer.labelsBox,
    			videoData = videoBoxContainer.video_data,
    			link = videoBoxContainer.link,
    			titleSpans = this.getDetailSpansFromLabelsBoxes('title', videoBoxContainer),
    			descriptionSpans = this.getDetailSpansFromLabelsBoxes('description', videoBoxContainer),
                setLinkFontSize = function() {
                    if(videoData.thumbUnder && labels_box.font){
                        link.style.fontSize = labels_box.font + "px";
                    }
                };
    		try {
    			if (!this.trc.global['smart-ellipsis']) {
    				for(var i=0; i < titleSpans.length; i++){
                        TRC.dom.setContentToElement(titleSpans[i], videoBoxContainer.getAttribute("data-item-title"));
    				}
    			}
                //we use setTimeout here so that the browser will have enough time to inject resposive rules before calculation
                setTimeout(function() {
                    for(var i=0; i < titleSpans.length; i++){
                        this.fixBoxOverflow(titleSpans[i], videoBoxContainer.getAttribute("data-item-title"), false, videoData['truncate-title'] != "false");
                    }
                    setLinkFontSize();
                }.trcBind(this), 0);

    			if(descriptionSpans.length){
                    //we use setTimeout here so that the browser will have enough time to inject resposive rules before calculation
                    setTimeout(function() {
                        for(var i=0; i < descriptionSpans.length; i++){
                            this.fixBoxOverflow(descriptionSpans[i], videoData['description'], true, true);
                        }
                    }.trcBind(this), 0);
    			}
    		} catch (e) {
    			__trcError('Problem in fixResponsiveBoxTitleAndDesc',e);
    		}
    	};

        TRCRBox.prototype.getDetailSpansFromLabelsBoxes = function (detail, videoBoxContainer) {
            var detailSpansNodeList = videoBoxContainer.querySelectorAll('.video-label-box [class*="' + detail + '"]');
            return [].slice.call(detailSpansNodeList);
        };

    	/**
    	 * create and append a video label container to a label href element
    	 * @param link href element recommendation object for this video box
    	 *
    	 */
    	TRCRBox.prototype.createVideoBoxLabels =  function (link){ /** @type Element */
    		var labels_box = document.createElement('span'); /** @type Element */
    		this.setVideoBoxLabelsClass(labels_box);
    		link.appendChild(labels_box);
    		return labels_box;
    	};

    	TRCRBox.prototype.setVideoBoxLabelsClass =  function(labels_box){
    		labels_box.className = "video-label-box";
    	};

    	TRCRBox.prototype.createThumbBlockHolder = function(videoBoxContainer, thumbLink, has_duration_label, video){
    		var holder = doc.createElement("div");
    		holder.className = "thumbBlock_holder";
    		thumbLink.appendChild(holder);
    		this.createVideoBoxThumbBlock(videoBoxContainer, holder, has_duration_label);
            if(this.isDisplayToNative || DisplayInSlotManager.isItemDisplayInSlot(video)){
                var backgroundHolder = doc.createElement("div");
                var displayOptions = {
                    backgroundHolder: backgroundHolder,
                    holder: holder,
                    videoBoxContainer: videoBoxContainer,
                    video: video
                };
                this.showDisplayAdAsNative(displayOptions);
                if (!TRC.util.isPercentEnabled(this.trc.global, 'adjust-banner-height') && TRC.dom.isDesktop()){
                    DisplayInSlotManager.createVideoBoxAspectWithBackgroundImage(holder, videoBoxContainer, video.thumbnail);
                }
                else {
                    TRC.dom.addClass(backgroundHolder, "thumbBlock_holder_background_image");
                    thumbLink.insertBefore(backgroundHolder, thumbLink.firstChild);
                }
            }
            else {
                this.createVideoBoxAspect(holder, videoBoxContainer);
            }
    	};

    	TRCRBox.prototype.createVideoBoxAspect =  function(container, videoBoxContainer){
    		var aspect = document.createElement("div");
    		aspect.className = "videoCube_aspect";
    		container.appendChild(aspect);
    		videoBoxContainer.thumbnail_aspect = aspect;
    	};

        TRCRBox.prototype.showDisplayAdAsNative = function(displayOptions){
            var holder = displayOptions.holder;
            var backgroundHolder = displayOptions.backgroundHolder;
            var videoBoxContainer = displayOptions.videoBoxContainer;
            var video = displayOptions.video;
            if (this.trc.isCreateTaboolaConnectCard(this.options, video)) {
                var taboolaConnectCardConfig = this.trc.getTaboolaConnectCardConfig(this.options, video);
                if (!taboolaConnectCardConfig) {
                    TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: 'HTML-filter-no_connect_card_config', value: '1', type: 'counter'}, null);
                    return;
                }

                this.sendMetricsDisplayAdAsNative(taboolaConnectCardConfig.itemData, videoBoxContainer.thumbnail_position);

                if(taboolaConnectCardConfig.rvMargin){
                    videoBoxContainer.style.visibility = 'hidden';
                }
                taboolaConnectCardConfig.backgroundContainer = backgroundHolder;
                taboolaConnectCardConfig.container = holder;
                taboolaConnectCardConfig.videoBoxContainer = videoBoxContainer;
                TRC.taboolaConnect.createCard(taboolaConnectCardConfig);
            }
        };

        TRCRBox.prototype.sendMetricsDisplayAdAsNative =  function(cardConfigItemData, thumbnailPosition){
            if(!cardConfigItemData.thumbnail){
                this.sendDisplayAdAsNativeEvent('DisplayToNativeMissingBackgroundImage');
            }
            if(!cardConfigItemData.title){
                this.sendDisplayAdAsNativeEvent('DisplayToNativeMissingTitle');
            }
            if(!cardConfigItemData.description) {
                this.sendDisplayAdAsNativeEvent('DisplayToNativeMissingDescription');
            }
            if(thumbnailPosition === "start" || thumbnailPosition === undefined) {
                this.sendDisplayAdAsNativeEvent('DisplayToNativeShouldBlockCurrentMode');
            }
        };

        TRCRBox.prototype.sendDisplayAdAsNativeEvent =  function(metricName){
            TRC.MetricsManager.sendMetricsEvent(TRC, TRCImpl, {name: metricName, value: '1', type: 'counter'}, null);
        };

    	/**
    	 * assemble and append a thumbnail link
    	 * @param videoBoxContainer container element
    	 * @param has_duration_label
    	 * @param video unique video recommendation
    	 * @param title video title
    	 */
    	TRCRBox.prototype.drawVideoBoxThumbnailLink = function(videoBoxContainer, has_duration_label, video, title){
    		var thumbLink;

    		videoBoxContainer.img_src = this.getThumbnailURL(video, this.trc.getProperty(this.mode_name, 'thumbnail-width', this.propertiesOverride), this.trc.getProperty(this.mode_name, 'thumbnail-height', this.propertiesOverride) );
    		thumbLink = this.createVideoLink(video, title, videoBoxContainer);
            videoBoxContainer.thumbLink = thumbLink;
    		TRC.dom.addClass(thumbLink, "item-thumbnail-href");
    		this.createThumbBlockHolder(videoBoxContainer, thumbLink, has_duration_label, video);
            thumbLink && thumbLink.setAttribute && thumbLink.setAttribute('slot' ,'thumbnail');
    		return thumbLink;
    	};

    	TRCRBox.prototype.createVideoBoxThumbBlock = function(videoBoxContainer, holder, has_duration_label){
    		var thumbBlock = document.createElement('span'),
    			duration = '',
    			video = videoBoxContainer.video_data;
    		if (!has_duration_label && (video.type == 'video' && typeof video.duration != 'undefined' && video.duration != '' && video.duration != '0')) {
    			duration = this.genDuration(video.duration);
    		}
    		thumbBlock.className = "thumbBlock";

    		// Inserting image iframe if such exists
    		if (video.imageIframe) {
                // add background image to cancel late render effect.
                thumbBlock.style.backgroundImage = "none";
                this.drawImageIframe(thumbBlock, video.imageIframe, (videoBoxContainer.link || videoBoxContainer.preLink).logger_url);
                videoBoxContainer.hasFloatingButton = true;
    		}

    		videoBoxContainer.thumbBlock = thumbBlock;

    		holder.appendChild(thumbBlock);
    	};

    	/**
    	 * set handlers to the image element to control the loading status
    	 * @param {Object} thumbnail_img
    	 * @param {Object} videoBoxContainer
    	 * @param {Object} video
    	 */
    	TRCRBox.prototype.setVideoBoxImageHandlers = function(thumbnail_img, videoBoxContainer, video){
    		thumbnail_img.onerror = this.responsiveImageOnErrorHandler.trcBind(this, thumbnail_img, videoBoxContainer, video, protocol);
    		thumbnail_img.onload = this.responsiveImageOnLoadHandler.trcBind(this, thumbnail_img, videoBoxContainer, video);
    	};

    	TRCRBox.prototype.responsiveImageOnErrorHandler = function(thumbnail_img, videoBoxContainer, video, pageProtocol){
    		var url = thumbnail_img.src,
                index = url.search(/\Shttp\S/),
    			itemId = video["item-id"];

    		if (index > 5 && this.isTaboolaCDNImage(url) && !TRC.Browser.ie){ // confirm that we have a image that is cached in cdn.taboolasyndication
                url = this.getFallbackImageForTaboolaCDNImage(url, itemId, pageProtocol);

    			videoBoxContainer.img_src = thumbnail_img.src = url;
    			return;
    		} else {
                url = this.getFallbackImageForNonTaboolaCDNImage(thumbnail_img, itemId, pageProtocol);
            }

    		videoBoxContainer.thumbBlock.style.backgroundImage = "URL('" + url + "')";
    	};

    	TRCRBox.prototype.responsiveImageOnLoadHandler = function responsiveImageOnLoadHandler(thumbnail_img, videoBoxContainer, video){
            if(!thumbnail_img || !thumbnail_img.complete){
            	TRC.Timeout.set(responsiveImageOnLoadHandler.trcBind(this, videoBoxContainer.thumbBlock, thumbnail_img), 50);
    		} else {
    			this.appendVideoBoxImage(videoBoxContainer);
    		}
    	};

    	/**
    	 * fix the size of the image element (IE8-) to fit the size of its video box container (thumblock)
    	 * @param {Object} videoBoxContainer
    	 * @param {HTMLImageElement} img
    	 * @param {Boolean} refix
    	 */
    	TRCRBox.prototype.fixResponsiveVideoImage = function(videoBoxContainer, img, refix) {
    	    var culculated_image_width;

            if (this.imageOptimizePrefixFlag) {
    	        img.style.visibility = "visible";
    	        img.style.width = "100%";
    	        img.style.height = "100%";
    	        return;
    	    }
    		var rect = null,
    			thumbBlock = videoBoxContainer.thumbBlock,
    			frame_width = (rect) ? rect.right - rect.left: thumbBlock.clientWidth,
    			frame_height = (rect) ? rect.bottom - rect.top : thumbBlock.clientHeight,
    			frame_aspect_ratio,	image_aspect_ratio,	culculated_image_height, top, left,
    			important = this.isCssImportant,
    			cssUtil = TRC.css.utils;
    		if (frame_height == 0 || frame_width == 0 || img.height == 0){
    			if(!refix){
    				TRC.Timeout.set(this.fixResponsiveVideoImage.trcBind(this, videoBoxContainer, img, true), 500);
    			}
    			return;
    		}
    		try {
    			frame_aspect_ratio = frame_width / frame_height;
    			image_aspect_ratio = this.getImageAspectRatio(img);
    			if (frame_aspect_ratio > image_aspect_ratio) {
    				culculated_image_height = Math.floor(frame_width / image_aspect_ratio);
    				top = Math.floor((frame_height - culculated_image_height) / 2);
                    cssUtil.setStyleProperty(img, "width", frame_width + "px", important);
                    if(top != 0){
                        img.style.position = "relative";
                        cssUtil.setStyleProperty(img, "top", top + "px", important);
                    }
    			} else {
    				culculated_image_width = Math.floor(frame_height * image_aspect_ratio);
    				left = Math.floor((frame_width - culculated_image_width) / 2);
                    cssUtil.setStyleProperty(img, "height", frame_height + "px", important);
                    if (left != 0) {
                        img.style.position = "relative";
                        if (this.trc.direction == "ltr")
                            cssUtil.setStyleProperty(img, "left", left + "px", important);
                        else
                            cssUtil.setStyleProperty(img, "left", left * (-1) + "px", important);
                    }
    			}
    			img.style.visibility = "visible";
    		} catch (e){
    		    alert(e.message);
    			__trcError("Error in fixResponsiveVideoImage : ", e.message);
    		}
    	};

    	/**
    	 * return the image aspect ratio.
    	 * if the ratio is not cached as an image property it will be calculated and cached - this will minimize the reflows
    	 * @param {Object} img
    	 */
    	TRCRBox.prototype.getImageAspectRatio = function(img){
    		if (!img.trcRatio) {
    			img.trcRatio = img.width / img.height;
    		}
    		return img.trcRatio;
    	};

    	/**
    	 * create a new image element to control the image load phase (if loaded or not - error)
    	 * add overlay span
    	 * @param {Object} videoBoxContainer
    	 */
    	TRCRBox.prototype.createVideoBoxImageLoader = function( videoBoxContainer ){
    		var thumbnail_img = new Image(),
    		    video = videoBoxContainer.video_data, /** @type Object */
    		    thumbBlock = videoBoxContainer.thumbBlock;

    		if (this.trc.global["thumb-lazy-load-switch"]){
    	       this.updateThumbnailStack(thumbnail_img); // the lazy load mechanism will use this stack to load the images
    	    }
    		thumbnail_img.style.visibility = "hidden";

    		videoBoxContainer.img = thumbnail_img;

    		this.setVideoBoxImageHandlers(thumbnail_img, videoBoxContainer, video);
            if (this.trc.global["use-delay-image-load"]){ //let the browser set our css style - i.e "reflow"
                TRC.Timeout.set( this.setImageLoad.trcBind(this, thumbnail_img, videoBoxContainer, videoBoxContainer.img_src, 100, thumbBlock, this.trc.global["thumb-lazy-load-switch"] ), 10);
            } else {
               this.setImageLoad(thumbnail_img, videoBoxContainer, videoBoxContainer.img_src, 100, thumbBlock, this.trc.global["thumb-lazy-load-switch"]);
            }

            this.add_span("thumbnail-overlay", null, thumbBlock);

    		if (video.isSyndicated){
    		  this.addVideoBoxBranding(thumbBlock, video);
    		}

        new TRC.ThumbnailOverlayComponents(thumbBlock, video.isSyndicated, this);
    	};

    	TRCRBox.prototype.updateThumbnailStack = function(img){
    	    this.thumbnailImageStack = this.thumbnailImageStack || [];
    	    this.thumbnailImageStack.push(img);
    	};

    	/**
    	 * create and append a brand container to a thumbnail container
    	 * @param {HTMLElement} thumbBlock thumbnail container element
    	 * @param {Object} video unique video recommendation
    	 */
    	TRCRBox.prototype.addVideoBoxBranding = function(thumbBlock, video){
    		var branding = document.createElement('span');

    		branding.className = "branding";
    		if (video["branding-text"]){
    			branding.appendChild(document.createTextNode( this.formatData('syndicator',  video["branding-text"]) ));
    		} else if (video["branding-url"]){
    			this.createBrandingImage(branding, video["branding-url"]);
    		}
    		thumbBlock.appendChild(branding);
    	};

    	TRCRBox.prototype.createBrandingImage = function(branding, url){
    		var img = doc.createElement('img');
    		img.src = url;
    		branding.appendChild(img);
    	};

    	/**
         * create and append a thumbnail container
    	 * @param videoBoxContainer video box div container
    	 * @param has_duration_label
    	 */
    	TRCRBox.prototype.createVideoBoxThumbLink = function(videoBoxContainer, has_duration_label){
    		try{
    			var video = videoBoxContainer.video_data,
    				thumbnail_position = videoBoxContainer.thumbnail_position,
    				thumbLink = this.drawVideoBoxThumbnailLink(videoBoxContainer, has_duration_label, video, videoBoxContainer.getAttribute("data-item-title"));

                if(videoBoxContainer.gridComponent instanceof TblAppInstallGrid){
                    videoBoxContainer.gridComponent.appendChild(thumbLink);
                    return;
                }
    			if(thumbnail_position === "under"){

            thumbLink.title = videoBoxContainer.link.title = "";
            videoBoxContainer.insertBefore(thumbLink, videoBoxContainer.link);

            if (TRC.RecommendationReel.shouldInitRecommendationReel(this)) {
              TRC.RecommendationReel.setTextOverForRecommendationReel(this, videoBoxContainer);
            } else {
              var textOverOverlay = document.createElement('span');
              TRC.dom.addClass(videoBoxContainer.link, 'tbl-text-over-container');
              TRC.dom.addClass(textOverOverlay, 'tbl-text-over');
              videoBoxContainer.link.appendChild(textOverOverlay);
            }

            this.findElement(function(e){ return e.className.search("title") >= 0; }, videoBoxContainer.labelsBox, 'span', null);
            video.thumbUnder = true;

    			}else if(thumbnail_position === "bottom"){
    				videoBoxContainer.appendChild(thumbLink);
    			}// if the label is on top, then add the thumbnail under the link
    	 		else {
    				videoBoxContainer.insertBefore(thumbLink,videoBoxContainer.link);
    			}// otherwise it should be before the link
    		} catch (e){
    			__trcError("Error in createVideoBoxThumbLink",e);
    		}
    	};

    	/**
    	 * add some data- attributes for the sake of spotlight
    	 * @param div video box div container
    	 * @param video unique video recommendation object
    	 */
    	TRCRBox.prototype.setVideoBoxDataAttr = function( div, video ){
    		div.setAttribute('data-item-id', video['item-id']);
    		div.setAttribute('data-item-title', video.title);
    		div.setAttribute('data-item-thumb',  this.getThumbnailURL(video, 100, 80));
    		div.setAttribute('data-item-syndicated', !!video.isSyndicated);
    	};

    	/**
    	 *  return thumbnail position
    	 *
    	 */
    	TRCRBox.prototype.getThumbnailPosition = function(video, thumbnailPositionTemplate){
            return (thumbnailPositionTemplate || this.trc.getProperty(this.mode_name, 'thumbnail-position', this.propertiesOverride));
    	};

        TRCRBox.prototype.webComponentAppInstallVersionSupport = function(video){
            if (!TblAppInstallGrid.isAvailable || !video || (video['is-app-install'] !== 'true')) {
                return 0;
            }
            return (+video["app-install-version"]) || (+this.trc.global["web-component-app-install-version"]) || 0;
    	};

    	/** assemble and render a responsive video/ad/content recommendation container
    	 * @param {HTMLElement} container
         * @param video unique video recommendation object
         * @param has_duration_label
         * @param orientation mode layout orientation : vertical , horizontal
    	 * @param detailOrderTemplate
    	 * @param thumbnailPositionTemplate*
         * @param postData
    	 */
    	TRCRBox.prototype.drawResponsiveVideoBox = function( container, video, has_duration_label, orientation, detailOrderTemplate, thumbnailPositionTemplate, postData, utmParams){
            var videoBoxContainer = this.videoBoxContainer = document.createElement('div'); /** @type Element - this element will hold all the relevant meta data for a unique recommendation */
            try {
    			video = __trcCopyProps(video, {}, { // update video object with meta data
    			    isSyndicated : video["is-syndicated"] || video["is-in-network"] ||  video["is-native"],
    				isPhoto : video.type === 'photo',
    				isText : video.type === 'text',
                    imageIframe: video.hasOwnProperty('image-iframe') && video['image-iframe'],
    				tags : (typeof video.tags == 'string') ? TRC.text.parseCSV(video.tags) : [], // parse the tags field (if exists) into a list
                    placement: this.placement,
                    mode: this.mode,
                    urlp: video["urlp"],
                    directLink: video["udl"]
                });
                var webComponentAppInstallGridVersion = this.webComponentAppInstallVersionSupport(video);
                if (video['is-app-install'] === 'true' && webComponentAppInstallGridVersion) {
                    var element = document.createElement('tbl-app-install-grid');
                    element.setAttribute && element.setAttribute('version', webComponentAppInstallGridVersion);
                    if (element instanceof TblAppInstallGrid) {
                        if (TRC.util.isPercentEnabled(this.trc.global, 'app-install-multi-slot-border')) {
                            if (this.trcResponse && this.trcResponse.v && (this.trcResponse.v.length > 1)) {
                                TRC.dom.addClass(element, 'tbl-app-install-grid-multi-slot');
                                TRC.dom.addClass(element, 'trc_rbox_border_elm');
                            }
                        }
                        videoBoxContainer.gridComponent = element;
                        videoBoxContainer.appendChild(element);
                    }
                }
                new TRC.BlockClicksManager(this, videoBoxContainer, video);
                this.setApiItemsData(video);
                this.createResponsiveVideoBox(videoBoxContainer, video, detailOrderTemplate, thumbnailPositionTemplate);
                if (videoBoxContainer.thumbnail_position !== 'none'){
    				// we should have a thumbnail, so start by creating it
    				this.createVideoBoxThumbLink(videoBoxContainer,has_duration_label);
    			}
                if (this.isStories) {
                    TRC.Stories.createBlurImageBox(videoBoxContainer);
                }
                this.createResponsiveLabelsBoxes(videoBoxContainer);
                var viewLazyLoadTagsMargin =  video.rvpm;

                //Render "Script Tag" - only if TRC instruct it and a bot wasn't detected
                if (!TRC.botDetected && video[TRC.TrackingScriptLoader.TRC_SCRIPT_TAGS_ATTRIBUTE] && video[TRC.TrackingScriptLoader.TRC_SCRIPT_TAGS_ATTRIBUTE].length > 0) {
                  var viewabilityTagId = this.outermostContainer.id || this.placement.split(" ").join("-");
                  viewabilityTagId += "-" + video["itemIndex"];

                  TRC.TrackingScriptLoader.renderScriptTagIntoVideoBox(videoBoxContainer, video, viewabilityTagId, this.trc.global["view-tags-domains-url"], viewLazyLoadTagsMargin, video.rv);
                }

                this.setRequiredViewabilityAvailableObserver(video.rv, videoBoxContainer, postData, utmParams, video['item-id'], viewLazyLoadTagsMargin);
                this.trc.runHook(this, this.mode_name, 'item-renderer', this.propertiesOverride, true, videoBoxContainer, videoBoxContainer.video_data);
                if (TRC.util.isPercentEnabled(this.trc.global, 'new-cta-enabled')) {
                    NewCtaManager.initialize({rbox: this, itemContainer: videoBoxContainer});
                } else {
                    TRC.CTAManager.initialize(this, videoBoxContainer);
                }

                ISIManager.initialize({videoBoxContainer: videoBoxContainer});

                // create the locally bound method that can fix overflow in this video box
    			container.appendChild(videoBoxContainer);
    			this.fixResponsiveBoxTitleAndDesc(videoBoxContainer);
    			this.boxes.push(videoBoxContainer);

                // Since the parent-element is now a flexbox there is no need to manually calculate widths for ellipsis trimming
                if ( this.shouldHandleScBrandingWithSponsoredLink() && TRC.Browser.ieUpto(10) ) {
                   this.handleBrandingWithDisclosureContainerWidth();
                }

    			if (!video.imageIframe) {
                    this.createVideoBoxImageLoader(videoBoxContainer);
    			}

                TRC.MetricsManager.metricIncrement('UiItemsRendered');

                return videoBoxContainer;
    		} catch (e) {
    			__trcError("Error in drawResponsiveVideoBox",e);
    		}

            return null;
    	};

    	TRCRBox.prototype.createResponsiveLabelsBoxes = function(videoBoxContainer ){
    		this.buildLabelBox(videoBoxContainer.preLabelsBox, videoBoxContainer.video_data, videoBoxContainer.pre_detail_order);//fill pre-thumbnail container
    		this.buildLabelBox(videoBoxContainer.labelsBox, videoBoxContainer.video_data, videoBoxContainer.detail_order);//fill after-thumbnail container
    	};

        TRCRBox.prototype.renderCTA = function(internalc, myOrigin) {
            if (!TRC.ctaManager) {
                return;
            }

            TRC.ctaManager.renderCTAItems(internalc, myOrigin);
        };

    	TRCRBox.prototype.handleBrandingWithDisclosureContainerWidth = function(){
    		var brandingContainer = this.branding;

    		if (brandingContainer) {
                var brandingInner = brandingContainer.querySelector('.branding-inner'),
                    brandingSeparator = brandingContainer.querySelector('.branding-separator'),
                    disclosureText = brandingContainer.querySelector('.logoDiv'),
                    brandingSeparatorWidth = brandingSeparator && TRC.dom.getOuterWidth(brandingSeparator),
                    disclosureWidth = TRC.dom.getOuterWidth(disclosureText);

                brandingInner.style.maxWidth = 'calc(100% - ' + (brandingSeparatorWidth + disclosureWidth) + 'px)';
    		}
    	};

         /** create a video box container an add it meta data and related objects references
    	 * @param {Object} videoBoxContainer
         * @param {Object} video unique video recommendation object
    	 * @param detailOrderTemplate
    	 * @param thumbnailPositionTemplate
    	 */
    	TRCRBox.prototype.createResponsiveVideoBox = function(videoBoxContainer, video, detailOrderTemplate, thumbnailPositionTemplate){
    		videoBoxContainer.rbox = this;
    		videoBoxContainer.video_data = video;
    		videoBoxContainer.thumbnail_position = this.getThumbnailPosition(video, (thumbnailPositionTemplate ? thumbnailPositionTemplate : null));
    		this.setVideoBoxDataAttr( videoBoxContainer, video );
    		this.setVideoBoxClassName( videoBoxContainer );
    		this.createVideoBoxDirectURL( videoBoxContainer ); //set videoBoxContainer.directURL
    		video.logger_url = this.createVideoBoxClickUrl(videoBoxContainer.video_data, videoBoxContainer.directURL);
            videoBoxContainer.setAttribute("data-item-title", video.title);
    		this.setVideoBoxDetailsOrder( videoBoxContainer, (detailOrderTemplate ? detailOrderTemplate : null) );
    		this.createDetailsLabelsContainers(videoBoxContainer);
    	};

        TRCRBox.prototype.createDetailsLabelsContainers =  function( videoBoxContainer ){
            var numOfLabelBoxes = 0;
            if (videoBoxContainer.pre_detail_order.length > 0){
                this.createVideoBoxPreThumbnailLink( videoBoxContainer ); // create the pre-thumbnail label container
                numOfLabelBoxes++;
            }
            if (videoBoxContainer.detail_order.length > 0){
                this.createVideoBoxAfterThumbnailLink( videoBoxContainer ); // create the after-thumbnail label container
                numOfLabelBoxes++;
            }
            if (numOfLabelBoxes > 1){
                TRC.dom.addClass(videoBoxContainer, "trc-split-label");
            }
    	};

    	TRCRBox.prototype.setVideoBoxClassName =  function( videoBoxContainer ){
    		var index = 0,
                isResponsive = this.isResponsive,
                orientation = this.trc.getProperty(this.mode_name, 'orientation', this.propertiesOverride),
                syndicatedClassName = TRC.SYNDICATED_CLASS_NAME;

    		this.setVideoBoxClassName = function(videoBoxContainer){
    			var video  = videoBoxContainer.video_data;
    			videoBoxContainer.className = 'videoCube ' + 'trc_spotlight_item ' +
    			    'origin-' + video.origin + ' thumbnail_'+ videoBoxContainer.thumbnail_position +
    				(video.isSyndicated ? ' ' + syndicatedClassName : '') + (video['is-in-network'] ? ' inNetworkItem' : '') +
                    (video['is-native'] ? ' tabNativeItem' : '') + (video.isPhoto ? ' photoItem' : '') + (video.isText ? ' textItem' : '') + " " + (isResponsive ? ("videoCube_" + (index += 1) + "_child") : orientation);
    	    };
    		this.setVideoBoxClassName(videoBoxContainer);
    	};

    	/** set the detail_order property for the video box
    	 * @param {Object} videoBoxContainer
    	 * @param {String} detailOrderTemplate
    	 */
    	TRCRBox.prototype.setVideoBoxDetailsOrder = function(videoBoxContainer, detailOrderTemplate){
    		var afterThumbnailDetailsOrder = detailOrderTemplate || this.trc.getProperty(this.mode_name, 'detail-order' + (videoBoxContainer.video_data.isSyndicated ? "-syndicated" : ""), this.propertiesOverride),
    			preThumbnailDetailsOrder = this.trc.getProperty(this.mode_name, 'before-detail-order' + (videoBoxContainer.video_data.isSyndicated ? '-syndicated' : ''), this.propertiesOverride);

    	    videoBoxContainer.detail_order = afterThumbnailDetailsOrder ? afterThumbnailDetailsOrder.split(",") : [];
    	    videoBoxContainer.pre_detail_order = preThumbnailDetailsOrder ? preThumbnailDetailsOrder.split(",") : [];
    	};

    	/** create and append a video link to a div container
    	 * @param {Object} videoBoxContainer
    	 */
    	TRCRBox.prototype.createVideoBoxAfterThumbnailLink = function(videoBoxContainer){
    		var video = videoBoxContainer.video_data,
    			title = videoBoxContainer.getAttribute("data-item-title"),
    			link = this.createVideoLink(video, title, videoBoxContainer);
                if (videoBoxContainer.gridComponent instanceof TblAppInstallGrid) {
                    videoBoxContainer.labelsBox = videoBoxContainer.gridComponent;
                    videoBoxContainer.gridComponent.setWrapperLink(link);
                    videoBoxContainer.link = link;
                    return;
                }
                videoBoxContainer.labelsBox = this.createVideoBoxLabels(link);
                videoBoxContainer.appendChild(link);
                videoBoxContainer.link = link;
                TRC.dom.addClass(link, "item-label-href");
                TRC.dom.addClass(videoBoxContainer.labelsBox, "trc-main-label");
    	};

    	/** create and append a video link to a div container
    	 * @param {Object} videoBoxContainer
    	 */
    	TRCRBox.prototype.createVideoBoxPreThumbnailLink = function(videoBoxContainer){
            if (videoBoxContainer.gridComponent instanceof TblAppInstallGrid) {
                videoBoxContainer.preLabelsBox = videoBoxContainer.gridComponent;
                return;
            }
    		var video = videoBoxContainer.video_data,
    			title = videoBoxContainer.getAttribute("data-item-title"),
    			link = this.createVideoLink(video, title, videoBoxContainer);
    		videoBoxContainer.preLabelsBox = this.createVideoBoxLabels(link);
    		videoBoxContainer.appendChild(link);
    		videoBoxContainer.preLink = link;
    		TRC.dom.addClass(link, "item-label-href");
    		TRC.dom.addClass(videoBoxContainer.preLabelsBox, "trc-pre-label");
    		TRC.dom.addClass(videoBoxContainer, "item-has-pre-label");
    	};



    	/**
    	 * make the thumbnail image visible in the mode - either by setting the thumblock's background or appending the
    	 * image element to the thumblock
    	 * @param {Object} videoBoxContainer
    	 */
    	TRCRBox.prototype.appendVideoBoxImage = function(videoBoxContainer){
    		try{
    			if (videoBoxContainer.img_src != null || this.trc.global["thumb-lazy-load-switch"]  ) {
    				if(typeof videoBoxContainer.image_div == "undefined") { // ~ IE7
                        TRC.dispatch('item-image-loaded', { videoData: videoBoxContainer.video_data, container: videoBoxContainer });
    					videoBoxContainer.thumbBlock.style.backgroundImage = "URL('" + videoBoxContainer.img_src +"')";
    				} else {
    					videoBoxContainer.thumbBlock.appendChild(videoBoxContainer.image_div);
    					videoBoxContainer.image_div.appendChild(videoBoxContainer.img);
    					videoBoxContainer.img.style.visibility = "visible";
    				}
    			}
    		}catch(e){
    			__trcError("Pager thumbnail images fixing errors",e);
    		}
    	};

    	/**
    	* go over the recommendation list and initiate the draw of a video box for each recommendation in the list;
     	* @param {Number} listSize - the number of recommendations we should use from the list
     	* @param {Boolean} has_duration_label - should we render a duration element for each video recommendation
     	* @param {HTMLElement} internalc - the wrapper/parent element for all video boxes to be rendered
    	*/
    	TRCRBox.prototype.pasreRecommendationList = function(listSize, has_duration_label, internalc, postData, utmParams){
    		var cur,
    			lastItem;

            this.stopBoxRendering = false;

    		for ( var i = 0; i < listSize; i++) {
          (TRC.tlf && i === 0 && console.time('item rendering'));
    			cur = this.recommendationList[i];
    			cur.itemIndex = i;

    			if(this.firstVideo == null && cur.type == "video")
    				this.firstVideo = cur;

    			try {
    			  this.trc.runHook(this, this.mode_name, "item-data-filter", this.propertiesOverride, false, cur);

            if(this.fixHeight && !this.stopBoxRendering){
                lastItem = this.drawResponsiveVideoBox(internalc, cur, has_duration_label, this.orientation, null, null, postData, utmParams);
                this.stopBoxRendering = this.hasMaxHeightExploitation(parseInt(document.trcGetCurrentStyle(this.container, "height"), 10), this.fixHeight);
                if (this.stopBoxRendering) {
                    this.safeRemoveItem(lastItem);
                }
            } else if(!this.fixHeight){
              this.drawResponsiveVideoBox(internalc, cur, has_duration_label, this.orientation, null, null, postData, utmParams);
            }
    			} catch (e) {
    				__trcError("Error in pasreRecommendationList", e);
    			}
          (TRC.tlf && i == 0 && console.timeEnd('item rendering'));
    		}
    	};

        /**
         *  removes an item form the dom.
         *  !!!! it removes pending event handlers for inner elements but not for the item itself  !!!
         * @param item
         */
        TRCRBox.prototype.safeRemoveItem = function(item){
            var parentNode = item.parentNode;
            TRC.dom.clearInnerElements(item);
            parentNode.removeChild(item);
        };

        /**
         * returns true if the containerHeight is equeal or greater then the fixHeight determined for the mode
         * @param containerHeight
         * @param fixHeight
         * @returns {boolean}
         */
        TRCRBox.prototype.hasMaxHeightExploitation =  function(containerHeight, fixHeight){
            return fixHeight <= containerHeight;
        };

    	/**
    	* go over the all the video boxes an fix the title text
     	*/
    	TRCRBox.prototype.fixResponsiveVideoBoxes = function(){
    		var boxes = this.boxes;
    		for(var i=0, len=boxes.length; i< len; i++){
    			this.fixResponsiveBoxTitleAndDesc(boxes[i]);
    		}
    	};


    	/**
    	 * create the upper third level container wrapper for the recommendation boxes
    	 * and set the wrapper container to be visible (it is set at first to display="none")
    	 * @param {HTMLElement} wrapper - container for the modes header container and recommendation container
    	 */
    	TRCRBox.prototype.generateResponsiveOuters = function(wrapper){
    		if (this.listContainer != null){
    			return;
    		}
    		this.header = this.generateHeader(wrapper);
    		var outerdiv = doc.createElement("div");
    		outerdiv.id = this.id.replace("trc_", "outer_");
    		outerdiv.className = "trc_rbox_outer";

    		this.generateResponsiveRBoxDiv(outerdiv);
    		wrapper.appendChild(outerdiv);

    		this.outerBox = outerdiv;

    		this.addTaboolaLogo();

    		wrapper.style.display = "block"; // set from hidden mode to visible mode

            // send start placement rendering to server
            __trcInfo('Start Rendering ' + (this.response.trc ? this.response.trc.placement: ""));
    	};

        /**
         * create the the second level container wrapper for the recommendation boxes
     	 * @param {HTMLElement} outerdiv - outer div element
         */
        TRCRBox.prototype.generateResponsiveRBoxDiv = function(outerdiv) {
    		var div = doc.createElement("div");
    		div.id = this.getListId();
    		div.className = "trc_rbox_div trc_rbox_border_elm";
    		outerdiv.appendChild(div);
    		this.listContainer = div;
    	};

        TRCRBox.prototype.getSpecificExternalTrackingURLsList = function(type, itemIdList) {
            var items = this.response.trc['video-list'].video,
                externalTrackingList = [],
                itemTrackingUrlsByType;
            try {
                for (var i = 0; items && i < items.length; i++) {
                    if (itemIdList && itemIdList.indexOf(items[i]['item-id']) > -1) {
                        itemTrackingUrlsByType = this.getItemExternalTrackingURLsList(items[i]);
                        if (itemTrackingUrlsByType.hasOwnProperty(type)) {
                            externalTrackingList = externalTrackingList.concat(itemTrackingUrlsByType[type]);
                        }
                    }
                }
                return externalTrackingList;
            } catch (e) {
                __trcError('Error in TRCRBox.getSpecificExternalTrackingURLsList');
                return [];
            }
        };

    	/**
    	 * Create a merged data object of all tracking urls of the widget by type -
    	 * go over each recommendation and get its tracking urls (by calling getItemExternalTrackingURLsList),
    	 * and merge them.
    	 *
    	 * @returns {{}|*} - map of arrays, grouped by the tracking types of the pixels, e.g.:
    	 * {
    	 *      "vi": [
    	 *          'http://www.pixel1.com',
    	 *          'http://www.pixel2.com
    	 *      ],
    	 *      "c": [
    	 *          'http://www.pixel3.com',
    	 *      ]
    	 * }
    	 */
    	TRCRBox.prototype.getAllExternalTrackingURLsList = function() {
    		var items = this.response.trc['video-list'].video,
    			itemTrackingUrlsByType;
    		try {
    			if (!this.externalTrackingURLsList) {
    				this.externalTrackingURLsList = {};

    				for (var i = 0; items && i < items.length; i++) {
    					itemTrackingUrlsByType = this.getItemExternalTrackingURLsList(items[i]);

    					for (var trackingType in itemTrackingUrlsByType) {
    						if (itemTrackingUrlsByType.hasOwnProperty(trackingType)) {
    							if (!this.externalTrackingURLsList[trackingType]) {
    								this.externalTrackingURLsList[trackingType] = [];
    							}

    							this.externalTrackingURLsList[trackingType] = this.externalTrackingURLsList[trackingType].concat(itemTrackingUrlsByType[trackingType]);
    						}
    					}
    				}
    			}

    			return this.externalTrackingURLsList;
    		} catch (e) {
    			__trcError('Error in TRCRBox.getAllExternalTrackingURLsList');
    			return {};
    		}
    	};

    	/**
    	 * Create a data object of external tracking pixels of an item, classified by type. Note - the data object is cached
    	 * on a map which is a global property of the RBox - externalTrackingURLsListByItemId.
    	 *
    	 * @returns {{}|*} - map of arrays, grouped by the tracking types of the pixels, e.g.:
    	 * {
    	 *      "vi": [
    	 *          'http://www.pixel1.com',
    	 *          'http://www.pixel2.com
    	 *      ],
    	 *      "c": [
    	 *          'http://www.pixel3.com'
    	 *      ]
    	 * }
    	 */
    	TRCRBox.prototype.getItemExternalTrackingURLsList = function(itemData) {
    		var itemId = itemData['item-id'],
    			itemTrackingUrlsData = itemData['itp'],
    			itemTrackingUrlData,
    			trackingType,
    			trackingUrl,
    			itemTrackingUrlsByType = {};

    		if(!itemId) {
    			__trcDebug('Item does not have id. External tracking pixel will not be sent if defined');
    			return [];
    		}

    		try {
    			if (!this.externalTrackingURLsListByItemId) {
    				this.externalTrackingURLsListByItemId = {};
    			}

    			if (!this.externalTrackingURLsListByItemId[itemId]) {
    				for (var j = 0; itemTrackingUrlsData && j < itemTrackingUrlsData.length; j++) {
    					itemTrackingUrlData = itemTrackingUrlsData[j];
    					trackingType = itemTrackingUrlData['t'];
    					trackingUrl = itemTrackingUrlData['u'];
    					if (trackingType && trackingUrl) {
    						if (!itemTrackingUrlsByType[trackingType]) {
    							itemTrackingUrlsByType[trackingType] = [];
    						}
    						itemTrackingUrlsByType[trackingType].push(trackingUrl);
    					}
    				}

    				this.externalTrackingURLsListByItemId[itemId] = itemTrackingUrlsByType;
    			}

    			return this.externalTrackingURLsListByItemId[itemId];
    		} catch (e) {
    			__trcError('Error in TRCRBox.getItemExternalTrackingURLsList');
    			return [];
    		}
    	};

        TRCRBox.prototype.sendPlacementTrackingPixelsOnce = function(eventType, idList, isItemLevel) {
            if (isItemLevel) {
                this.sendSpecificTrackingPixelsOfType(eventType, idList);
            } else {
                this.trc.log1(eventType, {ri: this.response.trc.req}, null, null, this.placement,
                    idList ? this.sendSpecificTrackingPixelsOfType.trcBind(this, eventType, idList) : this.sendAllTrackingPixelsOfType.trcBind(this, eventType));
            }
        };

        TRCRBox.prototype.sendAllTrackingPixelsOfType = function(type) {
            this.trc.sendExternalTracking(this.getAllExternalTrackingURLsList()[type]);
    	};

        TRCRBox.prototype.sendTrackingPixelsForSpecificItem = function(eventType, itemId) {
            if(eventType && itemId){
                this.trc.log1(eventType, {ri: this.response.trc.req, ii:itemId, li:this.getListId()}, null, null, null, this.sendSpecificTrackingPixelsOfType.trcBind(this, eventType, [itemId]));
            }
        };

        TRCRBox.prototype.sendSpecificTrackingPixelsOfType = function(type, idList) {
            this.trc.sendExternalTracking(this.getSpecificExternalTrackingURLsList(type, idList));
        };

        TRCRBox.prototype.shouldUseSmartEllipsis = function() {
    		return this.trc.global['smart-ellipsis'] && (this.trc.global['smart-ellipsis'] === 'enableAndOverrideModeFlag' || this.trc.getProperty(this.mode_name, "smart-ellipsis"));
    	};

    	//TODO: Add unit tests
    	TRCRBox.prototype.getEffectiveResponsiveRule = function(responsiveRules, minWidthPropName, maxWidthPropName) {
    		responsiveRules = responsiveRules || this.responsiveRules;
            minWidthPropName = minWidthPropName || 'min';
            maxWidthPropName = maxWidthPropName || 'max';

    		if(typeof win['matchMedia'] !== 'function' || !this.isResponsive || !responsiveRules) {
    			return null;
    		}

    		for(var i = 0; i < responsiveRules.length; i++) {
    			if(win['matchMedia']('screen and (min-width: ' + responsiveRules[i][minWidthPropName] + 'px)'
    					+ (!isNaN(responsiveRules[i][maxWidthPropName]) ? ' and (max-width: ' + responsiveRules[i][maxWidthPropName] + 'px)' : '')).matches) {
    				return responsiveRules[i];
    			}
    		}

    		return null;
    	};

        TRCRBox.prototype.getCurrentListSize = function() {
            var responsiveRulesProp = this.trc.getProperty(this.mode_name, 'responsive-rules', this.propertiesOverride),
    			effectiveResponsiveRule = this.getEffectiveResponsiveRule(responsiveRulesProp, 'minWidth', 'maxWidth');

            if(this.isResponsive && effectiveResponsiveRule) {
                return effectiveResponsiveRule.rows * effectiveResponsiveRule.cells;
            } else {
                return this.trc.getListSize(this);
            }
        };

        TRCRBox.prototype.drawImageIframe = function(container, iframe, redirUrl) {
        	iframe = iframe || '';
            redirUrl = redirUrl && redirUrl.replace(/&redir=[^&]*/,'') + '&redir=';
            container.innerHTML = iframe.replace('${CLICK_URL_ESC}', encodeURIComponent(redirUrl));
    	};

    	TRCRBox.prototype.getWidgetToFeedHelper = function() {
    		return this.parentFeed && this.parentFeed.widgetToFeedHelper;
    	};

        TRCRBox.prototype.getPublisherBrandingName = function() {
            if(!this.publisherBrandingText) {
                var customPublisherName = this.trc.getPublisherVersionPropertyWithFallbackToNetwork('publisher-branding') || '';
                this.publisherBrandingText = TRC.text.encodeHTML(customPublisherName) || this.trc.getSiteNameOgValue() || "";
            }
            return this.publisherBrandingText;
        };

      TRCRBox.prototype.sendAvailableEvent = function(utmParams, postData, isEmptyResponse, shouldAvoidDeferred) {
          var isCachedResponse = this.isResponseFromCache() && !this.trc.global['send-available-for-cached-response'];
          var widgetRemoved = this.trc.isRemovedWidget(this.response.trc["video-list"]);

          if(isCachedResponse || widgetRemoved) {
              return;
          }

          if(!shouldAvoidDeferred && this.trc.isDeferredAvailable){
              (TRC.performance && TRC.performance.mark("8.0.1." + this._id));
              var deferredSendEventCallback = this.sendEvent.trcBind(this, 'available', this.util.merge(utmParams, {'df' : 1}), postData.getAll(), true);

              if(isEmptyResponse) {
                  TRC.Timeout.set(deferredSendEventCallback, 0);
              } else {
                  this.postRenderQueue.pushBack('available', deferredSendEventCallback);
              }

          } else {
              this.sendEvent('available', utmParams, postData.getAll(), true);
          }
      };

      TRCRBox.prototype.sendRequiredViewabilityAvailableEvent = function(utmParams, postData, itemId) {
          var itemPostData = postData.getSpecificItemsPostData([itemId]);
          this.sendEvent('required-viewability-available', utmParams, itemPostData.getAll());
          if (this.trc.global["enable-rv-available"] && this.rvAvailableIds && this.rvAvailableIds.length > 0){
              this.sendTrackingPixelsForSpecificItem('i', itemId);
          }
      };

      TRCRBox.prototype.isResponseFromCache = function() {
          return this.response && this.response.cached;
      };

      TRCRBox.prototype.getModeClientProperty = function(propertyName) {
        return this.trc.getProperty(this.mode_name, propertyName, this.propertiesOverride);
      };

      TRCRBox.prototype.setRequiredViewabilityAvailableObserver = function (isRvEnabled, item, postData, utmParams, itemId, viewLazyLoadTagsMargin) {
          if(this.trc.global["enable-rv-available"] && isRvEnabled && !this.isProviderIframe && !this.isExistDisplayInSlot){
              if(this.trc.global["rv-available-for-reco-reel"] && TRC.RecommendationReel.shouldInitRecommendationReel(this)){
                  TRC.RecommendationReel.setRVAvailableListener(this, item, postData, utmParams, itemId);
              }
              else if (viewLazyLoadTagsMargin){
                  this.setRVAvailableObserverByMargin(item, postData, utmParams, itemId, viewLazyLoadTagsMargin);
              }
          }
      };

        TRCRBox.prototype.setRVAvailableObserverByMargin = function (item, postData, utmParams, itemId, viewLazyLoadTagsMargin) {
            var rvAvailableParams = { rvpm : viewLazyLoadTagsMargin };
            this.util.merge(rvAvailableParams, utmParams);
            var itemObserver = {
                targetElement: item,
                rootMargin:  viewLazyLoadTagsMargin + "px",
                onEnter: (function () {
                    if (TRC.dom.closest(item, '.tbl-invisible')){
                        return;
                    }
                    this.sendRequiredViewabilityAvailableEvent(rvAvailableParams, postData, itemId);
                    TRC.intersections.unobserve(item.getAttribute("rvAvailableObserverTargetId"));
                }).bind(this)
            };
            item.setAttribute("rvAvailableObserverTargetId", TRC.intersections.observe(itemObserver));
        };
    })(window, document);

    (function (win, doc) {

      /**
       * URL parsing class to mimic window.location
       * @param text
       * @type URL
       * @returns URL new URL instance
       */
      var URL = TRC.URL = function (text) {
          var lsplit = TRC.text.lsplit;
          if (!text) {
            throw new Error('Invalid URL!');
          }
          this.href = text; // store complete value
          // figure out hash ref:
          var t = lsplit(text, '#', 2);
          this.hash = (t.length > 1) ? '#' + t.pop() : '';
          text = t[0]; // store URI parts preceding the hash ref for more processing
          // figure out search query:
          t = lsplit(text, '?', 2);
          this.search = (t.length > 1) ? '?' + t.pop() : '';
          text = t[0]; // store URI parts preceding the search query for more processing
          // figure out protocol:
          t = lsplit(text, '://', 2);
          this.protocol = (t.length > 1) ? t.shift() + ':' : '';
          text = t[0]; // store URI parts succeeding the protocol for more processing
          // figure out pathname:
          t = lsplit(text, '/', 2);
          this.pathname = (t.length > 1) ? '/' + t.pop() : '/';
          text = t[0]; // store URI parts preceding the pathname for more processing
          // figure out auth:
          t = lsplit(text, '@', 2);
          this.auth = (t.length > 1) ? t.shift() : '';
          text = t[0]; // store URI parts succeeding the auth for more processing
          // I can split auth into username:password, but its not in the RFC so I don't care
          // figure out port:
          t = lsplit(text, ':', 2);
          this.port = (t.length > 1) ? parseInt(t.pop()) : 0;
          // figure out hostname:
          this.host = t[0];
          // all done

          return this;
        },
        PROTOCOLS = {"http:": 1, "https:": 1}; //rbox supported protocols

      URL.prototype.toString = function (isRemoveHash) {
        return (this.host ?
               this.protocol + '//' + (this.auth ? this.auth + '@' : '') + this.host
               + (this.port ? ':' + this.port : '')
                          : '') // if we don't have a host specification, skip everything up to the pathname
               + this.pathname + this.search + (isRemoveHash ? '' : (this.hash || ''));
      };

      URL.prototype.switchProtocol = function (protocol, isExternalUrl) {
        var url = (this instanceof TRC.URL) ? this : new TRC.URL(this),
          urlStr;
        if (PROTOCOLS[protocol]) {
          if (isExternalUrl && url.protocol == "https:") {
            // We don't want to change the protocol in this case
          } else {
            url.protocol = protocol;
          }
        }
        urlStr = url.toString(false);
        return (urlStr.length > 1) ? urlStr : ""; // fix bug that reruns '/' for zero length url's
      };

      /**
       * Parse query string parameters
       * @param name Query string parameter name
       * @param decoder for using instead of the default unescape decoder
       * @return First value for a parameter whose name was specified, or null if none found
       */
      URL.prototype.getParameter = function (name, decoder) {
        var params = TRC.URL.prototype.getQueryStringObj.call(this);
        for (var key in params) {
          if (unescape(key) == name) {
            return decoder ? decoder(params[key]) : unescape(params[key]);
          }
        }

        return null;
      };

      URL.prototype.getQueryStringObj = function () {
        var url = (this instanceof TRC.URL) ? this : new TRC.URL(this);
        var params = url.search.substr(1).split(/&/);
        var querystringObj = {};

        for (var i = 0; i < params.length; i++) {
          if (!params[i]) {
            continue;
          }

          var kv = params[i].split(new RegExp("="), 2);
          querystringObj[kv[0]] = kv[1];
        }

        return querystringObj;
      };

      URL.prototype.addParamsToUrl = function(url, tracking){
    		var parts = url.split('#');
    		return parts[0] + ((parts[0].search('\\?')>=0)?'&':'?')+ tracking + ((parts[1])?('#'+parts[1]):'');
      };

      URL.prototype.removeParamFromUrl = function(url, parameterName) {
            var urlParts = url.split('?');
            if (urlParts.length >= 2) {
                var baseUrl = urlParts[0];
                var queryString = urlParts[1];
                var updatedParams = [];
                var params = queryString.split('&');
                for (var i = 0; i < params.length; i++) {
                    var paramKeyValue = params[i].split('=');
                    if (paramKeyValue[0] !== parameterName) {
                        updatedParams.push(params[i]);
                    }
                }
                return updatedParams.length > 0 ? baseUrl + '?' + updatedParams.join('&') : baseUrl;
            }
            return url;
        };

        URL.prototype.removeAllUrlParametersAndFragment = function(url) {
            // Remove query parameters (if they exist)
            var queryIndex = url.indexOf('?');
            var baseUrl = queryIndex !== -1 ? url.substr(0, queryIndex) : url;
            // Remove fragment identifier (if it exists)
            var fragmentIndex = baseUrl.indexOf('#');
            return fragmentIndex !== -1 ? baseUrl.substr(0, fragmentIndex) : baseUrl;
        };

    })(window, document);

    /**
     * A module that handles user-id race condition.
     * It happens when there are multiple concurrent requests in a page (mostly iframes...)
     * where each request was assigned with a different user-id in the server.
     */
    (function (win, doc) {
        win.TRC = win.TRC || {};

        TRC.UserIdMerger = {

            notifyPossibleUserChange: function (trcManager, publisherId, userIdFromResponse, sessionDataFromResponse){
                var storedUserId,
                    storedSessionData,
                    isUserFixEventEnabled = trcManager.global['rbox-enable-fix-user-id-event'];

                if (!isUserFixEventEnabled){
                    return;
                }

                storedUserId = TRC.pageManager.getValue('user-id');
                storedSessionData = TRC.pageManager.getPublisherValue(publisherId, 'session-data');

                if (this.multipleUsersExist(userIdFromResponse, storedUserId)){
                    this.sendUserIdFixEvent(trcManager, storedUserId, userIdFromResponse, storedSessionData, sessionDataFromResponse);
                }
            },

            multipleUsersExist: function(userIdFromResponse, storedUserId){
                return storedUserId && userIdFromResponse && (storedUserId !== userIdFromResponse);
            },

            sendUserIdFixEvent: function(trcManager, storedUserId, currentUserId, storedSessionData, currentSessionData){
                var eventData = {
                    time: new Date().getTime(),
                    fromUser: storedUserId,
                    toUser: currentUserId,
                    fromSD: storedSessionData,
                    toSD: currentSessionData
                };

                trcManager.sendEvent('fix-user-id', eventData);
            }

        };

    }(window, document));

    /**
     * p-video-overlay.js
     * This module is responsible for displaying an overlay
     * on a performance video when clicked.
     * The overlay has 2 actions:
     * 1. go-to syndicator page
     * 2. back to video (hide overlay)
     */
    ((win, doc, trc) => {
        trc = trc || {
            dom: {
                stopEvent(e) {
                    e.stopPropagation && e.stopPropagation();
                    e.preventDefault && e.preventDefault();
                },
                on(el, event, callback) {
                    el.addEventListener(event, callback);
                },
                addClass(el, cls) {
                    el.className += ` ${cls} `;
                },
                removeClass(elem, name) {
                    const re = new RegExp(`s*${name}`, 'g');
                    elem.className = elem.className.replace(re, '');
                }
            },
            global: {'p-video-overlay-send-events': false}
        };

        const MESSAGES = {
                cancel: 'CANCEL',
                goto: 'GO TO'
            },
            domUtils = trc.dom;

        TRC._translationQueue = TRC._translationQueue || [];
        TRC._translationQueue.push({
            'p-video-overlay': MESSAGES
        });

        let localeMessages = {},
            isSendDebugEvents;

        /**
         * sends log message to server
         */
        const sendDebugEvent = function (message, videoData) {
                if (!isSendDebugEvents) {
                    return;
                }

                const data = {
                    itemId: videoData['item-id'],
                    publisher: videoData.publisher,
                    syndicatorId: videoData['syndicator-id']
                };

                TRCImpl.sendAbTestEvent && TRCImpl.sendAbTestEvent(message, __trcJSONify(data));
                trc.modDebug.logMessageToServer(1, message, data);
            },

            /**
             * strips url address.
             */
            stripUrl = function (url) {
                if (!url || !url.length) {
                    return '';
                }

                const trimmed = url.replace(/(^\w+:|^)\/\//, '');
                return trimmed.replace(/\/.*/, '');
            },

            /**
             * toggles the overlay display
             */
            videoOverlayToggleDisplay = function (overlayElement) {
                const overlayElementDisplay = overlayElement.className.match(/p-video-overlay-show/);

                domUtils[overlayElementDisplay ? 'removeClass' : 'addClass'](overlayElement, 'p-video-overlay-show');
            },

            /**
             * p-video overlay click handler
             */
            videoOverlayClickHandler = function (videoData, event) {
                videoOverlayToggleDisplay(event.currentTarget.firstElementChild);

                event.gotoSyndicator === undefined && sendDebugEvent('p-video-overlay__display-overlay', videoData);
                if (!event.gotoSyndicator) {
                    domUtils.stopEvent(event);
                }
            },

            /**
             * action click handler
             */
            actionClickHandler = function (videoData, actionData, event) {
                sendDebugEvent(actionData.msg, videoData);
                event.gotoSyndicator = actionData.flag;
            },

            /**
             * creates action element: container with click handler and children
             */
            createActionElement = function (elementClassName, clickCallback, childrenArray) {
                const element = domUtils.createHTMLElement('div', {className: elementClassName || ''});

                (typeof clickCallback === 'function') && domUtils.on(element, 'click', clickCallback);

                childrenArray && childrenArray.length && childrenArray.forEach && childrenArray.forEach(child => {
                    element.appendChild(child);
                });

                return element;
            },

            /**
             * creates the back element
             */
            createBackActionElement = function (videoData) {
                const labelSpan = domUtils.createHTMLElement('span', {className: 'p-video-back-action-label', innerText: localeMessages.cancel || MESSAGES.cancel});
                const action = createActionElement(
                    'p-video-overlay-action p-video-back-action',
                    actionClickHandler.bind(this, videoData, {msg: 'p-video-overlay__hide-overlay', flag: false}),
                    [labelSpan]
                );

                return action;
            },

            /**
             * creates go-to action element
             */
            createGotoActionElement = function (videoData) {
                const labelSpan = domUtils.createHTMLElement('span', {className: 'p-video-goto-action-label', innerText: localeMessages.goto || MESSAGES.goto});
                const urlSpan = domUtils.createHTMLElement('span', {className: 'p-video-goto-action-url', innerHTML: videoData['branding-text']});

                const action = createActionElement(
                    'p-video-overlay-action p-video-goto-action',
                    actionClickHandler.bind(this, videoData, {msg: 'p-video-overlay__go-to-syndicator-page', flag: true}),
                    [labelSpan, urlSpan]
                );

                return action;
            },

            /**
             * creates the p-video overlay
             */
            createVideoPlayerOverlayElement = function (videoData) {
                const backToVideoAction = createBackActionElement(videoData);
                const gotoSyndicationAction = createGotoActionElement(videoData);

                const overlay = createActionElement('p-video-overlay', null, [gotoSyndicationAction, backToVideoAction]);

                return overlay;
            },

            /**
             * creates the p-video overlay container
             */
            createVideoOverlay = function (videoData, language, isSendEvents) {
                const overlay = createVideoPlayerOverlayElement(videoData);

                isSendDebugEvents = isSendEvents;
                localeMessages = TRC.translationManager.getLabel({feature: 'p-video-overlay'}) || MESSAGES;
                const overlayContainer = createActionElement('p-video-overlay-container', videoOverlayClickHandler.bind(this, videoData), [overlay]);
                sendDebugEvent('p-video-overlay__overlay-created-on-item', videoData);

                return overlayContainer;
            };

        trc.pVideoOverlay = {
            create: createVideoOverlay,
            createVideoPlayerOverlayElement,
            createActionElement,
            createGotoActionElement,
            createBackActionElement,
            actionClickHandler,
            videoOverlayClickHandler,
            videoOverlayToggleDisplay,
            stripUrl,
            sendDebugEvent
        };

    })(window, document, TRC);

    /**
     * Created by amir.g
     */
    (() => {
        class BaseVideoUnitLoader {
            constructor(videoConfig) {
                this.videoConfig = videoConfig;
            }

            loadUnit(videoCallbackData) {
                (TRC.performance && TRC.performance.mark('videoEvalBaseLoadUnitStart', null, '', '', 'videoEvalBaseLoadUnitTime', TRC.PerfEvenType.START));
                // eslint-disable-next-line no-eval
                const unit = eval(videoCallbackData.tags[0].url);
                (TRC.performance && TRC.performance.mark('videoEvalBaseLoadUnitStop', null, '', '', 'videoEvalBaseLoadUnitTime', TRC.PerfEvenType.STOP));
                const {rawJsonValue} = this.videoConfig;

                this.setUnitParams(unit, rawJsonValue);
                return unit;
            }

            // eslint-disable-next-line class-methods-use-this
            getVideoContainerSelector() {
                return null;
            }

            setUnitParams(unit) {
                const {advancedVideoConfiguration} = this.videoConfig;

                // set all params from videoConfig to unit
                const ignoreList = {
                    detachToSlider: true, unitType: true, parentFeedOptions: true, rawJsonValue: true
                };
                Object.keys(this.videoConfig).forEach(key => {
                    if (this.videoConfig[key]) {
                        if (!ignoreList[key]) {
                            unit.set(key, this.videoConfig[key]);
                        }
                    }
                });

                // set all params from rawJsonValue to unit - dynamically created on server
                BaseVideoUnitLoader.setAdvancedVideoConfiguration(unit, advancedVideoConfiguration);

                const aggLevel = this.videoConfig.aggLevel || 1,
                    preset = {level: aggLevel};

                if (aggLevel > 1) {
                    unit.set('preset', preset);
                }
            }

            static setAdvancedVideoConfiguration(unit, advancedVideoConfiguration) {
                if (advancedVideoConfiguration) {
                    Object.keys(advancedVideoConfiguration)
                        .forEach(key => {
                            const camelCaseKey = TRC.text.splitAndJoin(key, TRC.text.toLowerCamelCase);
                            BaseVideoUnitLoader.setToUnit(unit, advancedVideoConfiguration, key, camelCaseKey);
                        });
                }
            }

            static setToUnit(unit, rawJsonValue, key, camelCaseKey) {
                const ignoreList = {unitType: true, parentFeedOptions: true, rawJsonValue: true};

                if (rawJsonValue.unitType !== 'IN_WIDGET') {
                    ignoreList.detachToSlider = true;
                }
                const specialMapping = {'additionalCss.zIndex': 'additionalCss.z-index'};
                if (!ignoreList[camelCaseKey]) {
                    if (!specialMapping[camelCaseKey]) {
                        unit.set(camelCaseKey, rawJsonValue[key]);
                    } else {
                        unit.set(specialMapping[camelCaseKey], rawJsonValue[key]);
                    }
                }
            }

        }

        TRC.BaseVideoUnitLoader = BaseVideoUnitLoader;
    })();

    /**
     * Created by adi.s
     */
    (() => {
        class SingleVideoManagerUnitLoader extends TRC.BaseVideoUnitLoader {
            constructor(videoConfig, trcManager) {
                super(videoConfig);
                this.trcManager = trcManager;
                this.parentFeedOptions = videoConfig.parentFeedOptions;
            }

            loadUnit(videoCallbackData) {
                (TRC.performance && TRC.performance.mark('videoEvalSingleManagerLoadUnitStart', null, '', '', 'videoEvalSingleManagerLoadUnitTime', TRC.PerfEvenType.START));
                // eslint-disable-next-line no-eval
                const unit = eval(videoCallbackData.tags[0].url);
                (TRC.performance && TRC.performance.mark('videoEvalSingleManagerLoadUnitStop', null, '', '', 'videoEvalSingleManagerLoadUnitTime', TRC.PerfEvenType.STOP));
                this.setUnitParams(unit);
                return unit;
            }

            // eslint-disable-next-line class-methods-use-this
            getVideoContainerSelector() {
                return null;
            }

            setUnitParams(unit) {
                super.setUnitParams(unit);

                const distanceRepeat = this.videoConfig.distanceRepeat || 0,
                    startFromSlider = TRC.util.isTrue(this.videoConfig.startFromSlider),
                    detachToSlider = TRC.util.isTrue(this.videoConfig.detachToSlider),
                    detachToSliderAnimation = TRC.util.isTrue(this.videoConfig.detachToSliderAnimation),
                    abTest = this.videoConfig.videoAbTest || null,
                    startCard = this.videoConfig.startCard || null,
                    maxVideoCards = this.videoConfig.maxVideoCards || null,
                    permanentCard = this.videoConfig.permanentCard || null,
                    {feedDynamicParameters} = this.parentFeedOptions,
                    videoDisclosurePosition = (feedDynamicParameters && feedDynamicParameters.videoDisclosurePosition) || this.parentFeedOptions.videoDisclosurePosition || this.trcManager.global['video-disclosure-position'],
                    uiDesignVersion = this.parentFeedOptions && this.parentFeedOptions.uiDesignVersion;

                unit.set('distanceRepeat', distanceRepeat);
                unit.set('detachToSlider.isStartFromSlider', startFromSlider);
                unit.set('detachToSlider.isDetachToSlider', detachToSlider);
                unit.set('detachToSlider.animation', detachToSliderAnimation);
                unit.set('abTest', abTest);

                if (startCard) {
                    unit.set('startCard', startCard);
                }
                if (maxVideoCards) {
                    unit.set('maxVideoCards', maxVideoCards);
                }
                if (permanentCard) {
                    unit.set('permanentCard', permanentCard);
                }
                if (videoDisclosurePosition) {
                    unit.set('components.adChoice.position', videoDisclosurePosition);
                }
                if (uiDesignVersion >= 3) {
                    unit.set('components.adChoice.title.style.color', '#999999');
                    unit.set('components.adChoice.title.logoStyle.display', 'none');
                }
            }
        }

        TRC.SingleVideoManagerUnitLoader = SingleVideoManagerUnitLoader;
    })();

    /**
     * Created by adi.d
     */
    (() => {
        class SliderVideoUnitLoader extends TRC.BaseVideoUnitLoader {

            loadUnit(videoCallbackData) {
                (TRC.performance && TRC.performance.mark('videoEvalSliderLoadUnitStart', null, '', '', 'videoEvalSliderLoadUnitTime', TRC.PerfEvenType.START));
                // eslint-disable-next-line no-eval
                let unit;
                try {
                    // eslint-disable-next-line no-eval
                    unit = eval(videoCallbackData.tags[0].url);
                } catch (e) {
                    __trcWarn(`video debug: SliderVideoUnitLoader loadUnit ${(TRCImpl.experimentsData && TRCImpl.experimentsData['2'] || '')}`, e);
                }
                (TRC.performance && TRC.performance.mark('videoEvalSliderLoadUnitStop', null, '', '', 'videoEvalSliderLoadUnitTime', TRC.PerfEvenType.STOP));
                this.setUnitParams(unit);

                return unit;
            }

            // eslint-disable-next-line class-methods-use-this
            getVideoContainerSelector() {
                return null;
            }

            // eslint-disable-next-line class-methods-use-this
            setUnitParams(unit) {
                super.setUnitParams(unit);
            }

        }

        TRC.SliderVideoUnitLoader = SliderVideoUnitLoader;
    })();

    /**
     * Created by adi.d
     */
    (() => {

        class StandaloneVideoUnitLoader extends TRC.BaseVideoUnitLoader {
            constructor(videoConfig, options) {
                super(videoConfig);
                this.options = options;
            }

            loadUnit(videoCallbackData, videoContainer) {
                this.setCmTag(videoContainer);
                (TRC.performance && TRC.performance.mark('videoEvalStandaloneLoadUnitStart', null, '', '', 'videoEvalStandaloneLoadUnitTime', TRC.PerfEvenType.START));
                // eslint-disable-next-line no-eval
                const unit = eval(videoCallbackData.tags[0].url);
                (TRC.performance && TRC.performance.mark('videoEvalStandaloneLoadUnitStop', null, '', '', 'videoEvalStandaloneLoadUnitTime', TRC.PerfEvenType.STOP));
                this.setupVideo(videoContainer, unit);

                return unit;
            }

            // eslint-disable-next-line class-methods-use-this
            getVideoContainerSelector(publisherWidgetContainer) {
                if (!publisherWidgetContainer || !publisherWidgetContainer.id) {
                    __trcWarn('Cannot get a selector for standalone video container - Taboola publisher container must be defined and have an ID');
                    return null;
                }

                return `#${publisherWidgetContainer.id}`;
            }

            setCmTag(videoContainer) {
                window.cmTag.set('isCustomEvents', true);
                window.cmTag.set('width', videoContainer.getBoundingClientRect().width);
                window.cmTag.set('customization', this.options.videoCssCustomization);
            }

            setupVideo(container, unit) {
                let videoPlayed = false;
                const startFromSlider = TRC.util.isTrue(this.videoConfig.startFromSlider),
                    detachToSlider = TRC.util.isTrue(this.videoConfig.detachToSlider),
                    detachToSliderAnimation = TRC.util.isTrue(this.videoConfig.detachToSliderAnimation),
                    displayIfInViewPort = function () {
                        if (!videoPlayed && TRC.visibility.isInViewPortWithOffset(container, -50)) {
                            if (unit.play && typeof unit.play === 'function') {
                                unit.play(container);
                            }
                            videoPlayed = true;
                            TRC.dispatch('trcContentReady', {container});
                            TRC.dom.off(window, 'scroll', displayIfInViewPort);
                        }
                    };

                unit.set('detachToSlider.isStartFromSlider', startFromSlider);
                unit.set('detachToSlider.isDetachToSlider', detachToSlider);
                unit.set('detachToSlider.animation', detachToSliderAnimation);

                unit.on('ready', () => {
                    displayIfInViewPort();
                    if (!videoPlayed) {
                        TRC.dom.on(window, 'scroll', displayIfInViewPort);
                    }
                });
            }
        }

        TRC.StandaloneVideoUnitLoader = StandaloneVideoUnitLoader;

    })();

    /**
     * Created by adi.d
     */
    (() => {

        class VideoAsItemUnitLoader extends TRC.BaseVideoUnitLoader {
            constructor(videoConfig, options, rbox) {
                super(videoConfig);
                this.options = options;
                this.rbox = rbox;
                this.allowExpandInViewport = TRC.util.isTrue(videoConfig.allowExpandInViewport);
                this.replaceWidgetItems = TRC.util.isTrue(videoConfig.replaceWidgetItems);
                this.disableFitToSizeForSingleColumn = TRC.util.isTrue(videoConfig.disableFitToSizeForSingleColumn);
                this.isContainerRatioValidForTakeOver = false;
                this.getContainerDimensions(options.container);

            }

            loadUnit(videoCallbackData, videoContainer) {
                const itemsToHide = this.getSponsoredItemsToHide();

                let unit;
                if (!this.replaceWidgetItems || (itemsToHide && itemsToHide.length)) {
                    const slotItem = this.getSlotWidgetItem();
                    if (slotItem) {
                        const slotItemComputedStyle = getComputedStyle(slotItem);
                        this.setCmTag(slotItem, slotItemComputedStyle);
                        (TRC.performance && TRC.performance.mark('videoEvalItemLoadUnitStart', null, '', '', 'videoEvalItemLoadUnitTime', TRC.PerfEvenType.START));
                        // eslint-disable-next-line no-eval
                        unit = eval(videoCallbackData.tags[0].url);
                        (TRC.performance && TRC.performance.mark('videoEvalItemLoadUnitStop', null, '', '', 'videoEvalItemLoadUnitTime', TRC.PerfEvenType.STOP));
                        this.setUnitParams(unit);

                        this.setupVideo(unit, itemsToHide, videoContainer, slotItemComputedStyle);
                    }
                }

                return unit;
            }

            getVideoContainerSelector(publisherWidgetContainer) {
                const videoContainer = this.createVideoContainer(publisherWidgetContainer);

                return videoContainer ? `#${videoContainer.id}` : null;
            }

            createVideoContainer(publisherWidgetContainer) {
                const videoContainer = document.createElement('figure'),
                    slotWidgetItem = this.getSlotWidgetItem(),
                    widgetContainer = slotWidgetItem && slotWidgetItem.parentNode;

                if (!slotWidgetItem || !widgetContainer || !publisherWidgetContainer) {
                    __trcWarn('Could not create video container selector for integrated widget - nowhere to append the video container');
                    return null;
                }

                if (!publisherWidgetContainer.id) {
                    videoContainer.id = Math.floor(Math.random() * 2147483648).toString(36);
                } else {
                    videoContainer.id = publisherWidgetContainer.id;
                }

                videoContainer.id += '-video';

                widgetContainer.insertBefore(videoContainer, slotWidgetItem);

                return videoContainer;
            }

            setCmTag(slotItem, slotItemComputedStyle) {
                const unitContainerStyle = this.getUnitContainerStyle(slotItem, slotItemComputedStyle);

                window.cmTag.set('isCustomEvents', true);
                window.cmTag.set('width', parseInt(unitContainerStyle.width, 10));
                window.cmTag.set('customization', this.getUnitCustomization(slotItem, unitContainerStyle));
                window.cmTag.set('isFitToSize', this.isFitToSizeVideo());
                window.cmTag.set('openingEffect', this.videoConfig.expandEffect);
                window.cmTag.set('isContainerRatioNotValidForTakeOver', !this.isContainerRatioValidForTakeOver);
                window.cmTag.set('rboxContainerRatio', this.containerRatio);
            }

            getUnitCustomization(slotItem, unitContainerStyle) {
                const customization = {};

                customization.unitContainer = unitContainerStyle;

                if (!this.isFitToSizeVideo()) {
                    const itemThumb = slotItem.querySelector('.thumbBlock_holder'),
                        itemTitle = slotItem.querySelector('.video-label-box .video-title'),
                        itemBranding = slotItem.querySelector('.video-label-box .branding');

                    customization.placeHolder = getComputedStyle(itemThumb);
                    customization.titleContainer = {
                        title: getComputedStyle(itemTitle),
                        branding: getComputedStyle(itemBranding)
                    };
                }

                return customization;
            }

            isFitToSizeVideo() {
                if (!this.disableFitToSizeForSingleColumn) {
                    return true;
                }

                const effectiveResponsiveRule = this.rbox.getEffectiveResponsiveRule();

                return !effectiveResponsiveRule || effectiveResponsiveRule.cells !== 1;
            }

            getUnitContainerStyle(slotItem, itemComputedStyle) {
                const itemMarginLeft = parseFloat(itemComputedStyle.marginLeft),
                    itemMarginRight = parseFloat(itemComputedStyle.marginRight),
                    itemWidth = parseFloat(itemComputedStyle.width),
                    numOfSlotsToOccupy = this.getNumOfSlotsToOccupy(),
                    widthToOccupy = Math.ceil((itemWidth * numOfSlotsToOccupy) + ((itemMarginLeft + itemMarginRight) * (numOfSlotsToOccupy - 1)));

                return {
                    width: `${widthToOccupy}px`,
                    height: itemComputedStyle.height
                };
            }

            setTakeOverUnitContainerStyle(slotItem, slotItemComputedStyle) {
                const unitContainerStyle = this.getUnitContainerStyle(slotItem, slotItemComputedStyle);
                const effectiveResponsiveRule = this.rbox.getEffectiveResponsiveRule(),
                    itemMarginTop = parseFloat(slotItemComputedStyle.marginTop),
                    itemMarginBottom = parseFloat(slotItemComputedStyle.marginBottom),
                    itemHeight = parseFloat(slotItemComputedStyle.height),
                    numOfRows = effectiveResponsiveRule.rows;
                
                unitContainerStyle.height = Math.ceil((itemHeight * numOfRows) + ((itemMarginTop + itemMarginBottom) * (numOfRows - 1)));
                
                TRC.dispatch('widgetTakeoverSizeChange', {
                    width: parseInt(unitContainerStyle.width, 10),
                    customization: this.getUnitCustomization(slotItem, unitContainerStyle)
                });
            }

            setupVideo(unit, itemsToHide, videoContainer, itemComputedStyle) {
                const {allowExpandInViewport} = this,
                    widgetContainerElem = this.rbox.container;
                let slotWidgetItem = this.getSlotWidgetItem();

                this.setVideoContainerInitialStyle(videoContainer, itemComputedStyle);
                unit.on('ready', adTypeConfig => {
                    if (adTypeConfig && adTypeConfig.isTakeoverWidget && adTypeConfig.isContainerRatioValidForTakeOver) {
                        this.setPlacementSingleAdConf();
                        slotWidgetItem = this.getMaxHeightSlot();
                        const slotItemComputedStyle = getComputedStyle(slotWidgetItem);
                        this.setTakeOverUnitContainerStyle(slotWidgetItem, slotItemComputedStyle);
                        this.setVideoContainerInitialStyle(videoContainer, slotItemComputedStyle);
                        videoContainer.style.zIndex = 999;
                    }
                    if (allowExpandInViewport || !TRC.visibility.isInViewPortWithOffset(slotWidgetItem, 0)) {

                        if (widgetContainerElem) {
                            TRC.dom.addClass(widgetContainerElem, 'iw_video_frame');
                        }

                        if (this.replaceWidgetItems) {
                            if (itemsToHide && itemsToHide.length) {
                                if (!parseInt(this.videoConfig.expandEffect, 10)) { // no expand effect or expand effect type is 0
                                    VideoAsItemUnitLoader.displayVideoInsteadOfItems(videoContainer, itemsToHide);
                                } else {
                                    unit.on('renderAnimation:completed', VideoAsItemUnitLoader.displayVideoInsteadOfItems.trcBind(this, videoContainer, itemsToHide));
                                }

                                if (unit.play && typeof unit.play === 'function') {
                                    unit.play(videoContainer);
                                }
                            } else {
                                __trcDebug('Not enough sponsored items to hide - aborting integrated widget video load');
                            }
                        } else if (unit.play && typeof unit.play === 'function') {
                            unit.play(videoContainer);
                        }
                    }
                });
            }

            setVideoContainerInitialStyle(container, itemComputedStyle) {
                const slotWidgetItem = this.getSlotWidgetItem(),
                    itemMarginLeft = parseFloat(itemComputedStyle.marginLeft),
                    outerRBoxComputedStyle = this.getOuterRBoxComputedStyle(),
                    outerRBoxMarginLeft = parseFloat(outerRBoxComputedStyle.marginLeft),
                    // container already gets the margin from the item
                    left = (slotWidgetItem.offsetLeft - itemMarginLeft) - (outerRBoxMarginLeft + itemMarginLeft);

                container.style.position = 'absolute';
                container.style.float = itemComputedStyle.float;
                container.style.top = `${slotWidgetItem.offsetTop}px`;
                container.style.left = `${left}px`;
                container.style.width = 'auto';

                // do margins separately because IE does not return margin computed style correctly
                container.style.marginLeft = itemComputedStyle.marginLeft;
                container.style.marginRight = itemComputedStyle.marginRight;
                container.style.marginTop = itemComputedStyle.marginTop;
                container.style.marginBottom = itemComputedStyle.marginBottom;

                if (!this.replaceWidgetItems) {
                    container.style.zIndex = 90;
                }
            }

            getOuterRBoxComputedStyle() {
                const outerRBox = this.rbox.outerBox;

                return getComputedStyle(outerRBox);
            }

            static displayVideoInsteadOfItems(container, itemsToHide) {
                VideoAsItemUnitLoader.hideWidgetItems(itemsToHide);

                container.style.position = 'static';
            }

            static hideWidgetItems(items) {
                items.forEach(item => {
                    item.style.display = 'none';
                    item.style.visibility = 'hidden';
                });

            }

            /**
             * get the widget item of the insertion point slot
             * @returns {HTMLElement}
             */
            getSlotWidgetItem() {
                if (this.slotWidgetItem) {
                    return this.slotWidgetItem;
                }

                const widgetItems = this.getWidgetItems();
                const slotIndex = this.getInsertionPointSlotNumber() - 1;

                if (!isNaN(slotIndex)) {
                    return this.slotWidgetItem = widgetItems[slotIndex];
                }
            }

            /**
             * Gets the first video-cube container under the RBox container that is not yet in view port (starting from the
             * specified slot index).
             * @returns {Number} - the index of the video insertion point
             */
            getInsertionPointSlotNumber() {
                const widgetItems = this.getWidgetItems(),
                    slotNumFromConfig = parseInt(this.videoConfig.slot, 10);

                if (typeof this.insertionPointSlotNumber !== 'undefined') {
                    return this.insertionPointSlotNumber;
                }

                if (!isNaN(slotNumFromConfig) && slotNumFromConfig > 0) {
                    if (this.allowExpandInViewport) {
                        return this.insertionPointSlotNumber = slotNumFromConfig;
                    }

                    let slotIndex;
                    for (let slotNum = slotNumFromConfig; slotNum <= widgetItems.length; slotNum++) {
                        slotIndex = slotNum - 1;
                        if (!TRC.visibility.isInViewPortWithOffset(widgetItems[slotIndex], 0)) {
                            return this.insertionPointSlotNumber = slotNum;
                        }
                    }
                }

                __trcWarn(`video tag loader - unknown slot (${slotNumFromConfig}) for integrated widget implementation`);
                return null;
            }

            /**
             * Returning the last sponsored items in the widget if enough are found, otherwise return null.
             * @returns {Array} - array of elements of the last sponsored video-cubes
             */
            getSponsoredItemsToHide() {
                const widgetItems = this.getWidgetItems(),
                    insertionPointSlotNumber = this.getInsertionPointSlotNumber(),
                    numOfSlotsToOccupy = this.getNumOfSlotsToOccupy(),
                    lastVisibleSponsoredItems = [];
                let slotNumber = widgetItems.length,
                    currentWidgetItem,
                    slotIndex;

                for (; slotNumber >= insertionPointSlotNumber; slotNumber--) {
                    slotIndex = slotNumber - 1;
                    currentWidgetItem = widgetItems[slotIndex];
                    if (currentWidgetItem.video_data['is-syndicated']
                        && currentWidgetItem.offsetParent !== null) { // offsetParent will check invisibility assuming position is not "fixed"
                        lastVisibleSponsoredItems.push(currentWidgetItem);
                        if (lastVisibleSponsoredItems.length === numOfSlotsToOccupy) {
                            return lastVisibleSponsoredItems;
                        }
                    }
                }

                __trcWarn('video tag loader - didn\'t find enough sponsored items for integrated widget replacement');
                return null;
            }

            /**
             * @returns {Array|*} the list of the widget's video cubes elements
             */
            getWidgetItems() {
                return this.rbox.boxes;
            }

            getNumOfSlotsToOccupy() {
                const slotsMaxSize = this.videoConfig.slotMaxSize || 2,
                    insertionPointSlotNumber = this.getInsertionPointSlotNumber();

                if (typeof this.numOfSlotsToOccupy === 'undefined') {
                    const effectiveResponsiveRule = this.rbox.getEffectiveResponsiveRule();

                    if (!effectiveResponsiveRule) {
                        this.numOfSlotsToOccupy = slotsMaxSize;
                    } else {
                        // e.g. for slot 5 in a 2 x 3 widget we get 2. if we get 0 this means that this is the last slot, so take "cells" value
                        const slotPositionInRow = (insertionPointSlotNumber % effectiveResponsiveRule.cells) || effectiveResponsiveRule.cells;
                        const remainingSlotsInRow = effectiveResponsiveRule.cells - slotPositionInRow + 1;
                        this.numOfSlotsToOccupy = Math.min(remainingSlotsInRow, slotsMaxSize);
                    }
                }

                return this.numOfSlotsToOccupy;
            }

            setPlacementSingleAdConf() {
                this.videoConfig.slot = 1;
                this.videoConfig.slotMaxSize = 99;
                this.slotWidgetItem = null;
                this.insertionPointSlotNumber = undefined;
                this.numOfSlotsToOccupy = undefined;
                this.isTakeoverWidget = true;
            }

            getContainerDimensions(container) {
                if (container) {
                    const containerBoundingRect = container.getBoundingClientRect();
                    this.containerWidth = containerBoundingRect.width;
                    this.containerHeight = containerBoundingRect.height;
                    this.containerRatio = this.containerWidth / this.containerHeight;
                    if (this.containerRatio < 2.36 && this.containerRatio > 1) {
                        this.isContainerRatioValidForTakeOver = true;
                    }
                }
            }

            getMaxHeightSlot() {
                const widgetItems = this.getWidgetItems();
                let maxSlotHeight = -1;
                let maxSlot = widgetItems[0];
                for (let i = 0; i < widgetItems.length; i++) {
                    const currSlotheight = parseInt(getComputedStyle(widgetItems[i]).height, 10);
                    if (currSlotheight > maxSlotHeight) {
                        maxSlotHeight = currSlotheight;
                        maxSlot = widgetItems[i];
                    }
                }
                return maxSlot;
            }
        }

        TRC.VideoAsItemUnitLoader = VideoAsItemUnitLoader;
    })();

    /**
     * Created by adi.d
     */
    (() => {
        class WidgetAdjacentVideoUnitLoader extends TRC.BaseVideoUnitLoader {

            loadUnit(videoCallbackData) {
                (TRC.performance && TRC.performance.mark('videoEvalWidgetLoadUnitStart', null, '', '', 'videoEvalWidgetLoadUnitTime', TRC.PerfEvenType.START));
                // eslint-disable-next-line no-eval
                const unit = eval(videoCallbackData.tags[0].url);
                (TRC.performance && TRC.performance.mark('videoEvalWidgetLoadUnitStop', null, '', '', 'videoEvalWidgetLoadUnitTime', TRC.PerfEvenType.STOP));
                this.setUnitParams(unit);
                return unit;
            }

            getVideoContainerSelector(publisherWidgetContainer) {
                if (this.videoConfig.position) {
                    const videoContainer = this.createVideoContainer(publisherWidgetContainer);
                    return `#${videoContainer.id}`;
                }

                return null;
            }

            createVideoContainer(publisherWidgetContainer) {
                const videoContainer = document.createElement('div'),
                    widgetContainer = publisherWidgetContainer._trc_container;

                if (!publisherWidgetContainer.id) {
                    videoContainer.id = Math.floor(Math.random() * 2147483648).toString(36);
                } else {
                    videoContainer.id = publisherWidgetContainer.id;
                }

                videoContainer.id += '-video';

                if (!widgetContainer) {
                    __trcWarn('Cannot generate a selector for widget adjacent video container - widget container is not found');
                    return null;
                }

                let insertionPoint;
                switch (this.videoConfig.position) {
                    case 'above':
                        insertionPoint = widgetContainer;
                        break;
                    case 'below':
                        insertionPoint = widgetContainer.nextSibling;
                        break;
                    default:
                        __trcWarn(`Unknown position in video config: ${this.videoConfig.position}`);
                }

                publisherWidgetContainer.insertBefore(videoContainer, insertionPoint);

                return videoContainer;
            }

        }

        TRC.WidgetAdjacentVideoUnitLoader = WidgetAdjacentVideoUnitLoader;
    })();

    (function(){
        TRC.InvokeVideoLoader = function () {

            var VIDEO_LAYER = 50;

            TRC.VideoLoader = function VideoLoader(trcManager, videoConfig, placement, container, trcResponse){
                this.trcManager = trcManager;
                this.videoConfig = videoConfig;
                this.placement = placement;
                this.unifiedPlacement = videoConfig.unifiedPlacement;
                this.taboolaContainer = container;
                this.trcResponse =  trcResponse;
                this.consentData = trcManager.consentState || TRC.consentData || {};
                this.genieVideoLayers = this.trcManager.global["genie-video-layers"] || [50,61,62];
            };

            TRC.VideoLoader.prototype.CALLBACK_NAME_PREFIX = 'videoCallback';

            /**
             * Checks if value is null or undefined. If not, returns the value, otherwise returns en empty string
             * @param value - the value to check
             * @returns {*} - the value or empty string
             */
            TRC.VideoLoader.prototype.valueOrEmptyString = function(value) {
                if(value !== null && typeof value !== 'undefined') {
                    return value;
                }

                return '';
            };

            /**
             * Loads the main video script with the configuration URL parameters
             *
             * @param videoCallbackParams - an Object that holds the parameters of each video.
             *                              The object is being used inside genVideoCallback which is a function being
             *     overridden. For more details look at genVideoCallback implementation.
             */
            TRC.VideoLoader.prototype.loadVideo = function(videoCallbackParams) {
                if (isFillerBlock(this.videoConfig)) {
                    __trcDebug("video loader - not loading. Filler detected");
                    return;
                }

                if (TRC.botDetected) {
                    __trcDebug("video loader - not loading. Bot detected.");
                    return;
                }
                if (this.blockVideo) {
                    __trcDebug("video loader - not loading. Video was blocked due to configuration.");
                    return;
                }
                if(TRC.Browser['ieUpto'](10)) {//Supporting IE11 and above - limitation from the video side
                    __trcDebug("video loader - not loading. Unsupported browser.");
                    return;
                }

                var videoCallbackName = this.genVideoCallback(videoCallbackParams);

                if (this.trcManager.global['use-unit-fetcher-response-instead-of-tb'] && this.videoConfig.unitFetcherResponse) {
                    runVideoCallbackOnUnitFetcherResponse(this.videoConfig.unitFetcherResponse, videoCallbackName);
                    return true;
                }
                var scriptUrlTemplate = this.videoConfig.scriptUrlTemplate;

                var enableVideoAjax = TRC.util.isTrue(TRCImpl.global['enable-video-ajax']);

                TRC.pConsole("video loader", "info", "loading video for placement: " + this.placement);

                var videoIntegrationVariant = TRC.URL.prototype.getParameter.call(location.href,"video-integration-variant");
                if(videoIntegrationVariant === null){
                    videoIntegrationVariant = this.trcManager.global["video-integration-variant"];
                }
                if(scriptUrlTemplate) {

                    var videoScript = document.createElement('script');
                    videoScript.id = this.taboolaContainer.id + '-v-loader';
                    videoScript.src = replaceVideoParams.trcBind(this, videoCallbackParams, videoIntegrationVariant, TRC.shiftDomain(scriptUrlTemplate), videoCallbackName)();
                    (TRC.performance && TRC.performance.mark('videoJsonpRequestStart', null, '', '', 'videoJsonpRequestTime', TRC.PerfEvenType.START));
                    if (enableVideoAjax) {
                        this.loadVideoByAjax(videoScript.src, videoCallbackName);
                    } else {
                        this.taboolaContainer.appendChild(videoScript);
                    }
                } else {
                    TRC.pConsole("video loader", "error", "error while loading video for placement: " + this.placement + '. missing script url template in response');
                }
                return true;
            };

            var isFillerBlock = function (videoConfig) {
                var enableFillerBlock = TRCImpl.global['enable-filler-block'];
                if (enableFillerBlock) {
                    if (videoConfig && videoConfig.unitFetcherResponse && videoConfig.unitFetcherResponse.indexOf("fillerResponse=true") > 0) {
                        return true;
                    }
                }
                return false;
            };

            var runVideoCallbackOnUnitFetcherResponse = function (unitFetcherResponse, videoCallbackName) {
                var response = {
                    target: {
                        status: 200,
                        readyState: XMLHttpRequest.DONE,
                        responseText: videoCallbackName.toString() + '(' + unitFetcherResponse.toString() + ')'
                    }
                };

                var videoCallback = convertFuncNameToFunction(videoCallbackName);
                videoCallback(response);
            };

            var replaceVideoParams = function (videoCallbackParams, videoIntegrationVariant, scriptTemplate, videoCallbackName) {
                // Parse genie video variants list first
                for (var i=0; i<this.genieVideoLayers.length; i++){
                    var layerId = this.genieVideoLayers[i];
                    var scriptTemplateParam = '{GENIE_VIDEO_'+layerId+'_VARIANT}';
                    scriptTemplate = scriptTemplate.replace(scriptTemplateParam, this.valueOrEmptyString(this.getGenieVariantIdByLayer(layerId)));
                }

                return scriptTemplate
                    .replace('{PUBLISHER_NAME}', TRC.publisherId)
                    .replace('{UNIT_TYPE}', encodeURIComponent(this.videoConfig.unitType))
                    .replace('{UNIT_LOCATION}', encodeURIComponent(this.valueOrEmptyString(this.videoConfig.unitLocation)))
                    .replace('{SOURCE_PAGE_TYPE}', this.trcManager.getItemType())
                    .replace('{PLACEMENT_NAME}', encodeURIComponent(this.getPlacementName()))
                    .replace('{UNIFIED_PLACEMENT_NAME}', encodeURIComponent(this.valueOrEmptyString(this.getUnifiedPlacementName())))
                    .replace('{USER_ID}', TRC.pageManager.getUserId())
                    .replace('{CALLBACK_NAME}', videoCallbackName)
                    .replace('{REFERRER}', encodeURIComponent(this.trcManager.getReferrer()))
                    .replace('{PAGE_URL}', encodeURIComponent(this.valueOrEmptyString(this.getItemUrlForVideo())))
                    .replace('{CACHE_BUSTER}', this.getScriptCacheBuster())
                    .replace('{PLATFORM}', this.valueOrEmptyString(this.videoConfig.platform))
                    .replace('{NORM_PLATFORM}', this.valueOrEmptyString(this.videoConfig.fullyNormalizedPlatform))
                    .replace('{COUNTRY}', this.valueOrEmptyString(this.videoConfig.country))
                    .replace('{TAG_ID}', this.valueOrEmptyString(this.videoConfig.tagId)) //Tag ID override
                    .replace('{VARIANT}', this.valueOrEmptyString(this.videoConfig.variant))
                    .replace('{INTEGRATION_VARIANT}', this.valueOrEmptyString(videoIntegrationVariant))
                    .replace('{SESSION_ID}', this.valueOrEmptyString(this.trcManager.getSessionId()))
                    .replace('{SOURCE_ITEM_ID}', this.valueOrEmptyString(this.trcManager.getItemId()))
                    .replace('{VIEW_ID}', this.valueOrEmptyString(TRC.pageManager.getPageData()))
                    .replace('{GEO_LAT}', this.valueOrEmptyString((getParamFromAdditionalData('loc') || {}).lat))
                    .replace('{GEO_ING}', this.valueOrEmptyString((getParamFromAdditionalData('loc') || {}).ing))
                    .replace('{DEVICE_IFA}', this.valueOrEmptyString(this.trcManager.deviceId))
                    .replace('{APP_ID}', this.valueOrEmptyString(getParamFromAdditionalData('appid')))
                    .replace('{SESSION_DATA}', this.valueOrEmptyString(this.getSessionData()))
                    .replace('{REQUEST_ID}', this.valueOrEmptyString(this.getRequestId()))
                    .replace('{APP_NAME}', this.valueOrEmptyString(getParamFromAdditionalData('app')))
                    .replace('{CONSENT_DAISY_BIT}', this.valueOrEmptyString(this.getConsentString()))
                    .replace('{GDPR_APPLIES}', this.valueOrEmptyString(this.getGdprApplies()))
                    .replace('{OPEN_EXCHANGE_ENABLED}', this.valueOrEmptyString(this.getOpenExchangeEnabled()))
                    .replace('{EXTERNAL_VIEW_ID}', this.valueOrEmptyString(this.getExternalViewId()))
                    .replace('{SOURCE_ITEM_ID}', this.valueOrEmptyString(this.getSourceItemId()))
                    .replace('{SOURCE_ITEM_ID_INT}', this.valueOrEmptyString(this.getSourceItemId()))
                    .replace('{PUBLISHER_ID}', this.valueOrEmptyString(this.getPublisherId()))
                    .replace('{SDK_NAME}', encodeURIComponent(this.valueOrEmptyString(getParamFromAdditionalData('sdkt'))))
                    .replace('{SDK_VERSION}', this.valueOrEmptyString(getParamFromAdditionalData('sdkv')))
                    .replace('{OS}', encodeURIComponent(this.valueOrEmptyString(getParamFromAdditionalData('os'))))
                    .replace('{USER_ID_SOURCE}', this.valueOrEmptyString(this.getUserIdSource()))
                    .replace('{FAGG}', this.valueOrEmptyString(this.videoConfig.aggLevel || 1))
                    .replace('{CCPA_DNS}',  this.valueOrEmptyString(this.getCcpaDoNotSell()))
                    .replace('{CCPA_PRIVACY}',  this.valueOrEmptyString(this.getCcpaPrivacyString()))
                    .replace('{REGION}',  this.valueOrEmptyString(this.getRegion()))
                    .replace('{HAS_GDPR_CONSENT}',  this.valueOrEmptyString(this.getHasGDPRConsent()))
                    .replace('{TCF_VERSION}', this.valueOrEmptyString(this.getTCFVersion()))
                    .replace('{CMP_STATUS}', this.valueOrEmptyString(this.consentData.cmpStatus))
                    .replace('{TABOOLA_NETWORK_ID}', this.valueOrEmptyString(this.getTaboolaNetworkId()))
                    .replace('{AB_TEST_PERCENT}', this.valueOrEmptyString(getParamFromQueryString('vidABTestPercent')))
                    .replace('{AB_TEST_LAYER}', this.valueOrEmptyString(getParamFromQueryString('vidABTestLayer')))
                    .replace('{GENIE_VIDEO_VARIANT}', this.valueOrEmptyString(this.getGenieVariantIdByLayer(VIDEO_LAYER)));
            };

            var getParamFromQueryString = function (paramName) {
                try {
                    var getParameter = TRC.URL.prototype.getParameter;

                    return getParameter.call(getQueryString(), 'tb_' + paramName, false);
                } catch (ex) {
                    return '';
                }
            };

            var getQueryString = function () {
                if (window.TRCImpl.getItemUrlQueryString && typeof window.TRCImpl.getItemUrlQueryString === 'function') {
                    return window.TRCImpl.getItemUrlQueryString() || '';
                }

                return document.location.search;
            };

            var getParamFromAdditionalData = function (param) {
                if (verifyAdditionalDataMobileParamsExists()) {
                    if (typeof TRCImpl.additional_data.sdkd[param] !== 'undefined') {
                        return TRCImpl.additional_data.sdkd[param];
                    }
                }
            };

            var verifyAdditionalDataMobileParamsExists = function () {
                return (typeof TRCImpl.additional_data !== 'undefined') && (typeof TRCImpl.additional_data.sdkd !== 'undefined');
            };

            TRC.VideoLoader.prototype.loadVideoByAjax = function (url, videoCallbackName) {
                var http = new XMLHttpRequest();
                http.open("GET", this.addProtocolToUrl(url), true);
                http.setRequestHeader("Content-Type", "text/plain");
                http.withCredentials = true;
                http.addEventListener("readystatechange", convertFuncNameToFunction(videoCallbackName));
                (TRC.performance && TRC.performance.mark('videoAjaxStart', null, '', '', 'videoAjaxRoundtrip', TRC.PerfEvenType.START));
                http.send(null);
            };

            TRC.VideoLoader.prototype.addProtocolToUrl = function (url) {
                if (url.indexOf('//') === 0) {
                    url = TRC.PROTOCOL + url;
                }

                return url;
            };

            var convertFuncNameToFunction = function (videoCallbackName) {
                var path = videoCallbackName.split('.') || [];
                var func = window;

                for (var i = 0; i < path.length; i++) {
                    var namespace = path[i];
                    if (func[namespace]) {
                        func = func[namespace];
                    } else {
                        func = function () {};
                        break;
                    }
                }

                return func;
            };

            /**
             * Generates a name for a callback function for the main video script.
             * The callback name is sequential - every time that such a callback is created,
             * its numeric suffix is incremented.
             * @param callbacksObjectKey - a string that represents the key of the callbacks object on the TRC
             * @returns {string} - the name of the generated callback (e.g. videoCallback1)
             */
            TRC.VideoLoader.prototype.generateCallbackName = function () {
                var callbackSeqNum,
                    callbacksObjectKey = this.getCallbacksObjectKey();

                TRC[callbacksObjectKey] = TRC[callbacksObjectKey] || {};
                callbackSeqNum = TRC[callbacksObjectKey].auto_gen_callback_seq = TRC[callbacksObjectKey].auto_gen_callback_seq + 1 || 1;
                return this.CALLBACK_NAME_PREFIX + callbackSeqNum;
            };

            /**
             * This function is an 'abstract' function and has to be overridden in every module that uses VideoLoader.
             * The implementation needs to generate a callback function for the main video script and to save it on the
             * video callback namespace (TRC.videoCallbacks).
             * It also needs to use TRC.VideoLoader.prototype.generateCallbackName in order to generate the new callback
             * (e.g. videoCallback1).
             *
             * @param videoCallbackParams - (Optional for usage) an Object that holds the parameters of each video such as
             *     url, playerContainer etc.\
             * @returns {string} - the path to the generated callback (e.g. TRC.videoCallbacks.videoCallback1)
             */
            TRC.VideoLoader.prototype.genVideoCallback = function(/*videoCallbackParams*/) {
                throw new Error("This is an abstract method that should be inherited.");
            };

            /**
             * This function is an 'abstract' function and has to be overridden in every module that uses VideoLoader.
             * The implementation needs to generate a key name for the object that will hold all callbacks of the inherited
             * video loader. The function will be used at the generateCallbackName function. For example if a complete
             * callback path is TRC.videoCallbacks.videoCallback1 - the 'videoCallbacks' part will be generated by this
             * function.
             * @returns {string} - the key of the callbacks object to be stored over TRC object (e.g. videoCallbacks)
             */
            TRC.VideoLoader.prototype.getCallbacksObjectKey = function () {
                throw new Error("This is an abstract method that should be inherited.");
            };


            /**
             * Gets the the current page URL + the following URL parameters (if exists) :   vstaging, keyword, customTB
              * @returns {string} - the url + filtered parameters
             */
            TRC.VideoLoader.prototype.getItemUrlForVideo = function() {
                var keyValPairs = [],
                    paramsList="",
                    url,
                    videoParams ,
                    queryString,
                    key,
                    prefix;

                url =  this.trcManager.getItemUrl();
                if(!url){
                    return null;
                }

                videoParams = this.getVideoParametersToKeep();
                queryString = this.getWindowLocationSearch();
                queryString = queryString.substr(1);

                if (queryString.length) {
                    keyValPairs = queryString.split('&');
                    for (var pairNum=0;pairNum<keyValPairs.length;pairNum++) {
                        key = keyValPairs[pairNum].split('=')[0];
                        if (!key.length) continue;
                        if(videoParams.indexOf(key) !== -1 && url.indexOf(key.concat("=")) === -1){
                            paramsList = paramsList.concat(key,"=",keyValPairs[pairNum].split('=')[1],"&");
                        }
                    }
                    if(paramsList.length >=1){
                        paramsList = paramsList.substring(0, paramsList.length - 1);
                        prefix = url.indexOf("?") === -1 ? "?" : "&";
                        paramsList  = prefix.concat(paramsList);
                    }
                    url = url.concat(paramsList);
                }
                 return url;
            };

            TRC.VideoLoader.prototype.getSessionData = function() {
                return this.trcResponse['session-data'];
            };

            TRC.VideoLoader.prototype.getRequestId = function() {
                return this.trcResponse['req'];
            };

            /**
             * Gets the placement name that should be passed to the video script - if not configured in the TRc
             * response, then the placement name of the RBox widget is returned (adjacent video)
             * @returns {string} - the placement name of the video
             */
            TRC.VideoLoader.prototype.getPlacementName = function() {
                return this.videoConfig.placement || this.placement;
            };

            TRC.VideoLoader.prototype.getUnifiedPlacementName = function() {
                return this.unifiedPlacement;
            };

            TRC.VideoLoader.prototype.getExternalViewId = function() {
                return this.videoConfig.rid;
            };

            TRC.VideoLoader.prototype.getOpenExchangeEnabled = function() {
                return this.videoConfig.oee;
            };

            TRC.VideoLoader.prototype.getSourceItemId = function() {
                return this.videoConfig.sii;
            };

            TRC.VideoLoader.prototype.getScriptCacheBuster = function() {
                return new Date().getTime().toString();
            };

            TRC.VideoLoader.prototype.getWindowLocationSearch = function() {
                return window.location.search || '';
            };

            TRC.VideoLoader.prototype.getVideoParametersToKeep = function() {
                return this.trcManager.global['video-tag-keep-url-params'] || ["vstaging", "keyword", "customTB"];
            };

            TRC.VideoLoader.prototype.getPublisherId = function() {
                return this.videoConfig.tpubid;
            };

            TRC.VideoLoader.prototype.getUserIdSource = function() {
                return this.videoConfig.uis;
            };

            TRC.VideoLoader.prototype.getCcpaDoNotSell = function() {
                return this.videoConfig.ccpaDns;
            };

            TRC.VideoLoader.prototype.getCcpaPrivacyString = function() {
                return this.videoConfig.ccpaPrivacy;
            };

            TRC.VideoLoader.prototype.getRegion = function() {
                return this.videoConfig.region;
            };

            TRC.VideoLoader.prototype.getHasGDPRConsent = function() {
                return this.videoConfig.hasGDPRConsent;
            };

            TRC.VideoLoader.prototype.getConsentDaisyBit = function(){
                return this.consentData.consentData || this.consentData.consentDaisyBit;
            };

            TRC.VideoLoader.prototype.getTCFVersionByConsentStr = function() {
                if (this.consentData.tcString)
                    return 2
                if (this.getConsentDaisyBit())
                    return 1
            };

            TRC.VideoLoader.prototype.getTCFVersionByMethodImpl = function() {
                if (typeof window.__tcfapi == 'function')
                    return 2
                if (typeof window.__cmp == 'function')
                    return 1
            };

            TRC.VideoLoader.prototype.getTCFVersion = function() {
                return this.videoConfig.tcfVersion || this.getTCFVersionByConsentStr() || this.getTCFVersionByMethodImpl();
            };

            TRC.VideoLoader.prototype.getConsentString = function() {
                return this.getTCFVersion() == 2 ? this.consentData.tcString : this.getConsentDaisyBit();
            };

            TRC.VideoLoader.prototype.getTaboolaNetworkId = function() {
                return this.videoConfig.tnetid;
            };

            TRC.VideoLoader.prototype.getGenieVariantIdByLayer = function(layerId) {
                if(this.trcManager.experimentsData && this.trcManager.experimentsData[layerId]) {
                    return this.trcManager.experimentsData[layerId].split('|')[1];
                }
                return null;
            };

            TRC.VideoLoader.prototype.getGdprApplies = function() {
                return this.trcManager.global['video-gdpr-applies-use-requires-consent'] ?
                    this.videoConfig.gdprApplies : this.consentData.gdprApplies;
            };

        };
    })();

    /* eslint-disable prefer-destructuring,prefer-var,prefer-arrow-callback,no-var,vars-on-top,prefer-template */
    /**
     * Created by adi.d
     */
    (function () {
        TRC.InvokeVideoTagLoader = function () {

            TRC.VideoTagLoader = function VideoTagLoader(trcManager, videoConfig, options, rbox, trcResponse) {
                if (rbox && rbox.mode === "rbox-only-video") {
                    this.invisibleContainer = '#' + options.container.id;
                }
                this.blockVideo = this.shouldBlockVideoLoader( trcManager.blockVideoLoader, trcManager.global['block-video-prob']) || !trcManager['before-video-load']();
                // Inheritance mechanism
                if (!this.blockVideo) {
                    TRC.VideoLoader.call(this, trcManager, videoConfig, options.placement, options.container, trcResponse);
                    this.options = options;
                    this.videoConfig = videoConfig;
                    this.videoConfig.isHip = this.isHip(rbox);
                    this.videoConfig.rboxContainerId  = rbox && rbox.id;
                    this.unitLoader = this.initUnitLoader(videoConfig, options, rbox, trcManager);
                } else {
                    trcManager.sendAbTestEvent('blockedVideo', 1);
                }
            };

            // Inheritance mechanism
            TRC.VideoTagLoader.prototype = __trcObjectCreate(TRC.VideoLoader.prototype);

            TRC.VideoTagLoader.prototype.LOCATION_TYPES = {
                ABOVE: 'above',
                BELOW: 'below',
                ITEM: 'item',
                STANDALONE: 'standalone',
                SINGLE_MANAGER: 'singleManager'
            };

            TRC.VideoTagLoader.prototype.initUnitLoader = function (videoConfig, options, rbox, trcManager) {
                switch (videoConfig.position) {
                    case this.LOCATION_TYPES.STANDALONE:
                        return new TRC.StandaloneVideoUnitLoader(videoConfig, options);
                    case this.LOCATION_TYPES.ITEM:
                        return new TRC.VideoAsItemUnitLoader(videoConfig, options, rbox);
                    case this.LOCATION_TYPES.SINGLE_MANAGER:
                        return new TRC.SingleVideoManagerUnitLoader(videoConfig, trcManager);
                    case this.LOCATION_TYPES.ABOVE:
                    case this.LOCATION_TYPES.BELOW:
                        return new TRC.WidgetAdjacentVideoUnitLoader(videoConfig);
                    default:
                        return new TRC.SliderVideoUnitLoader(videoConfig);
                }
            };

            TRC.VideoTagLoader.prototype.setGlobalUnitParams = function (unit) {
                // Sent video parameters when in mobile SDK
                if (this.trcManager && this.trcManager.framework && this.trcManager.framework === 'mobile-sdk') {
                    unit.set('isSDK', true);
                    unit.set('widgetPlacement', this.getPlacementName());
                }

                if (this.options && this.options.isFeed && this.options.container){
                    unit.set('feedContainer', this.options.container);
                }

                var feedPlacementName = this.getPlacementName();
                if (this.options && this.options.sca && this.isFeedHasSC(this.options.sca,feedPlacementName)) {
                    unit.set("placementWithScAdjacency", feedPlacementName);
                }

                // Might have been initialized by vv - video
                TRC.filledImpressions = TRC.filledImpressions || [];
                unit.on('filledImpression', function (obj) {
                    TRC.filledImpressions.push(obj);
                });
            };

            /**
             * The function returns a key name for the object that will hold all callbacks of the video-tag-loader.
             * The function will be used at the generateCallbackName function.
             * @returns {string} - the key of the callbacks object to be stored over TRC object (e.g. videoTagCallbacks)
             */
            TRC.VideoTagLoader.prototype.getCallbacksObjectKey = function () {
                return 'videoTagCallbacks';
            };

            /**
            * The function returns true if R-Box shoud not continue video flow after caluclating configured probability
             */
            TRC.VideoTagLoader.prototype.shouldBlockVideoLoader = function (blockVideoLoaderTRC, blockVideoLoaderProbability) {
                var blockVideoLoader = blockVideoLoaderTRC || false;
                if (blockVideoLoader) return blockVideoLoader;

                if (!isNaN(blockVideoLoaderProbability)) {
                    blockVideoLoader = Math.random() < (blockVideoLoaderProbability / 100);
                }
                TRC.pConsole("page", "info", "Blocked video: " + blockVideoLoader + ", block-video-prob: " + blockVideoLoaderProbability, "string");

                return blockVideoLoader;
            };

            /**
             * Generates a callback function for the main video tag script and saves it on the
             * video tags callback namespace (TRC.videoTagCallbacks).
             * The callback name is sequential - every time that such a callback is created,
             * its numeric suffix is incremented.
             *
             * @returns {string} - the path to the generated callback (e.g. TRC.videoTagCallbacks.videoCallback1)
             */
            TRC.VideoTagLoader.prototype.genVideoCallback = function () {
                var videoCallbackName = this.generateCallbackName(),
                    that = this;

                TRC.videoTagCallbacks[videoCallbackName] = function (videoCallbackData) {
                    if (TRCImpl.global['enable-video-ajax']) {
                        if (!that.isXHRDone(videoCallbackData.target)) {
                            return;
                        }
                        (TRC.performance && TRC.performance.mark('videoAjaxStop', null, '', '', 'videoAjaxRoundtrip', TRC.PerfEvenType.STOP));
                        videoCallbackData = that.parseTBResponse(videoCallbackData.target.responseText);
                    }

                    (TRC.performance && TRC.performance.mark('videoJsonpRequestStop', null, '', '', 'videoJsonpRequestTime', TRC.PerfEvenType.STOP));
                    var unitBootSrc,
                        script;

                    videoCallbackData = videoCallbackData || {};
                    if (videoCallbackData.tags && videoCallbackData.tags[0]) {
                        unitBootSrc = that.getLiteUnitVersion(videoCallbackData.tags[0].liteUnitBootSrc || that.videoConfig.liteUnitBootSrc);

                        if (!unitBootSrc) {
                            unitBootSrc = videoCallbackData.tags[0].unitBootSrc || that.videoConfig.unitBootSrc;
                        }

                        if (window.TRC.liteUnit) {
                            unitBootSrc = that.getLiteUnitFromTRCConfig(unitBootSrc);
                        }

                        var videoMacrosLiteUnitVersion = that.getVideoMacrosLiteUnitVersion(videoCallbackData.tags[0].url);
                        if (videoMacrosLiteUnitVersion && window.location.href.indexOf('static-test-files.taboolasyndication') === -1) {
                            unitBootSrc = that.replaceVersion(unitBootSrc, videoMacrosLiteUnitVersion);
                        }

                        var qs = TRC.isAMP ? window.context.location.search :
                            (window.TRCImpl.getItemUrlQueryString() || '');
                        if (qs.indexOf('tb_liteUnitUrl') > -1 || qs.indexOf('tb_liteUnitVersion') > -1) {
                            unitBootSrc = that.getVersionFromUrl(unitBootSrc, qs);
                        }

                        script = document.createElement('script');
                        script.src = unitBootSrc;
                        script.crossOrigin = 'anonymous';

                        script.onload = function () {

                            /* Test Code - should be deleted */
                            window.TRC = window.TRC || {};
                            window.TRC.liteUnit = window.TRC.liteUnit || {};
                            if (TRCImpl.global['enable-mw-no-items-exit']) {
                                window.TRC.liteUnit.abTest = 'scadjtst1_vA';
                            } else if (TRCImpl.global['enable-mw-content-ready-margins']) {
                                window.TRC.liteUnit.abTest = 'scadjtst1_vB';
                            } else if (TRCImpl.global['enable-mw-control']) {
                                window.TRC.liteUnit.abTest = 'scadjtst1_vC';
                            }
                            /* Test Code - should be deleted */

                            if (window.TRC.liteUnit && window.TRC.liteUnit.abTest) {
                                window.cmTag.set('pixels.startWithABT.isFire', true);
                                window.cmTag.push('abTest', window.TRC.liteUnit.abTest);
                            }

                            // eslint-disable-next-line max-len
                            var containerSelector = that.videoConfig.containerSelector || that.unitLoader.getVideoContainerSelector(that.taboolaContainer) || that.invisibleContainer;

                            var videoContainer;

                            if (containerSelector) {
                                window.cmTag.set('parentSelector', containerSelector);
                                videoContainer = document.querySelector(containerSelector);
                            }


                            if (!that.isFillerBlock(videoCallbackData)) {
                                var unit = that.unitLoader.loadUnit(videoCallbackData, videoContainer);

                                if (unit) {
                                    that.setGlobalUnitParams(unit);
                                }
                            } else {
                                __trcDebug("video loader - not loading. Filler detected");
                            }

                        };

                        document.getElementsByTagName('head')[0].appendChild(script);
                    }
                };

                return 'TRC.' + this.getCallbacksObjectKey() + '.' + videoCallbackName;
            };

            TRC.VideoTagLoader.prototype.isFillerBlock = function(videoCallbackData) {
                var enableFillerBlock = TRCImpl.global['enable-filler-block'];
                if (enableFillerBlock) {
                    if (videoCallbackData.tags[0].url.indexOf("fillerResponse=true") > 0) {
                        return true;
                    }
                }

                return false;
            };

            TRC.VideoTagLoader.prototype.isXHRDone = function (xhr) {
                return xhr.status === 200 && xhr.readyState === XMLHttpRequest.DONE;
            };

            TRC.VideoTagLoader.prototype.parseTBResponse = function (responseText) {
                var videoCallbackData;
                try {
                    (TRC.performance && TRC.performance.mark('videoAjaxParsingStart', null, '', '', 'videoAjaxParsing', TRC.PerfEvenType.START));
                    videoCallbackData = JSON.parse(this.extractJSONFromResponse(responseText));
                } catch (ex) {
                    videoCallbackData = undefined;
                    __trcError("video debug: VideoTagLoader exception "  + (TRCImpl.experimentsData && TRCImpl.experimentsData['2'] || ''), ex);
                } finally {
                    (TRC.performance && TRC.performance.mark('videoAjaxParsingStop', null, '', '', 'videoAjaxParsing', TRC.PerfEvenType.STOP));
                }

                return videoCallbackData;
            };

            TRC.VideoTagLoader.prototype.extractJSONFromResponse = function (responseText) {
                return responseText.slice(responseText.indexOf('(') + 1, responseText.lastIndexOf(')'));
            };

            TRC.VideoTagLoader.prototype.getLiteUnitVersion = function (liteUnitBootSrc) {
                if (this.isLiteUnitUrlValid(liteUnitBootSrc)) {
                    liteUnitBootSrc = decodeURIComponent(liteUnitBootSrc);
                    if (liteUnitBootSrc !== 'lite-unit-boot-src') {
                        var unitType = this.getUnitType();

                        if (unitType) {
                            return liteUnitBootSrc.replace('{{UNIT_TYPE}}', unitType)
                                                .replace('{{PLATFORM}}', TRC.dom.isDesktop() ? 'Desktop' : 'Mobile');
                        }
                    }
                }

                return '';
            };

            TRC.VideoTagLoader.prototype.isLiteUnitUrlValid = function (liteUnitUrl) {
                if(typeof liteUnitUrl !== 'string') {
                    return false;
                }

                if (!liteUnitUrl) {
                  return false;
                }

                var liteUnitUrlDomain = new TRC.URL(/^http/.test(liteUnitUrl) ? liteUnitUrl : 'https:' + liteUnitUrl).host;

                const isValidLiteUnitUrl = this.ALLOWED_LITE_UNIT_URLS_DOMAINS.indexOf(liteUnitUrlDomain) > -1;

                if(!isValidLiteUnitUrl) {
                    __trcWarn('Invalid lite unit url was supplied.\nProvided url: ' + liteUnitUrl);
                }

                return isValidLiteUnitUrl;
            };

            TRC.VideoTagLoader.prototype.ALLOWED_LITE_UNIT_URLS_DOMAINS = [
                'localhost',
                'vidstat.taboola.com'
            ];

            TRC.VideoTagLoader.prototype.getUnitType = function () {
                for (var unitType in this.UNIT_TYPES) {
                    if (this.UNIT_TYPES[unitType].indexOf(this.videoConfig.unitType) > -1) {
                        return unitType;
                    }
                }

                return '';
            };

            TRC.VideoTagLoader.prototype.UNIT_TYPES = {
                Slider: ['46','59'],
                Inline: ['193','198','199','194','216', '48', '32', '215'],
                WidgetItem: ['226','227','248', '4', '5'],
                FeedManager: ['244','245','247'],
                VideoForPerformance: ['232','233'],
                RecoReelWidget: ['254','255'],
                StoriesWidget: ['143','144'],
                Instream: ['107','108'],
                ExcoPlayer: ['242', '243'],
                MidArticleSlider: ['147', '148']
            };

            TRC.VideoTagLoader.prototype.getLiteUnitFromTRCConfig = function (unitBootSrc) {
                if (window.TRC.liteUnit.liteUnitVersion) {
                    unitBootSrc = this.getLiteUnitVersion(window.TRC.liteUnit.liteUnitVersion);
                }

                if (window.TRC.liteUnit.version) {
                    unitBootSrc = this.replaceVersion(unitBootSrc, window.TRC.liteUnit.version);
                }

                return unitBootSrc;
            };

            TRC.VideoTagLoader.prototype.replaceVersion = function (unitBootSrc, version) {
                return unitBootSrc.replace(/\d+[_|.]\d+[_|.]\d+/, version);
            };

            TRC.VideoTagLoader.prototype.getVideoMacrosLiteUnitVersion = function (tbRes) {
                var regex = new RegExp("liteUnitVersion", "gi"), versionIndex = undefined;
                while (regex.exec(tbRes)) {
                    versionIndex = regex.lastIndex;
                }

                if (versionIndex !== undefined) {
                    tbRes = tbRes.substring(versionIndex);
                    tbRes = tbRes.substring(2, tbRes.indexOf(');'));
                    var version = tbRes.replace(/\'|\"|\s+/g, '');
                    if (version) {
                        return version;
                    }
                }
            };

            TRC.VideoTagLoader.prototype.getVersionFromUrl = function (unitBootSrc, qs) {
                var url = undefined, version = undefined;
                qs.split('&').forEach(function (item) {
                    if (item.indexOf('tb_liteUnitUrl') > -1) {
                        url = item.split('=')[1];
                    } else if (item.indexOf('tb_liteUnitVersion') > -1) {
                        version = item.split('=')[1];
                    }
                });

                if (url) {
                    unitBootSrc = this.getLiteUnitVersion(url);
                }

                if (version) {
                    unitBootSrc = this.replaceVersion(unitBootSrc, version);
                }

                return unitBootSrc;
            };

            TRC.VideoTagLoader.prototype.isFeedHasSC = function (sca, placementName) {
                for (var i = 0; i < sca.length; i++) {
                    if(sca[i] === placementName) {
                        return true;
                    }
                }
                return false;
            };

            TRC.VideoTagLoader.prototype.isHip = function (rbox) {
                var midArticleUnitTypes = ['4', '254'];

                if (!rbox || !rbox.trcResponse || !rbox.trcResponse.vtag) {
                    return false;
                }

                var vtag = rbox.trcResponse.vtag;

                if (vtag.advancedVideoConfiguration && vtag.advancedVideoConfiguration['mid-article-hip-opt-out'] === 'true') {
                    return false;
                }

                return vtag.unitType && midArticleUnitTypes.indexOf(vtag.unitType.toString()) > -1;
            };
        };
    }());

    (() => {
        class VirtualPlacementsManager {
            constructor() {
                this.virtualPlacementsMap = {};
                this.response = {};
            }

            static handleVirtualPlacement(trcManager, unifiedPlacementName) {
                const {virtualPlacementsManager} = trcManager;
                const virtualPlacementConfig = virtualPlacementsManager.response[unifiedPlacementName];

                if (virtualPlacementConfig) {
                    const containerSelectorConfiguration = __trcCopyProps(virtualPlacementConfig, {});
                    containerSelectorConfiguration.id = unifiedPlacementName;
                    virtualPlacementsManager.createVirtualPlacement(containerSelectorConfiguration, unifiedPlacementName, trcManager);
                }
            }

            createVirtualPlacement(virtualPlacementConfig, unifiedPlacement, trcManager) {
                if (!virtualPlacementConfig || this.virtualPlacementsMap[unifiedPlacement]) {
                    return;
                }

                this.virtualPlacementsMap[unifiedPlacement] = virtualPlacementConfig;
                const container = trcManager.getOrCreateContainer(virtualPlacementConfig);
                trcManager.setPlacementDataInPreloadRequest(unifiedPlacement, container);
            }
        }

        TRC.VirtualPlacementsManager = VirtualPlacementsManager;
    })();

    TRC.visibility = TRC.visibility || {};
    TRC.visibility = function(win, doc){
    	/**
    	 * returns the vertical shift(pixels) of an nodeElement from the current viewport
    	 * if the element is inside the viewport the value is positive otherwise the value is negative
    	 * @param {Object} elem - nodeElement
    	 * @return {Number}
    	 */
    	function getVerticalVPShift(elem){
    		var verticalR = TRC.dom.getViewportVerticalRange(),
    		    rect  = TRC.dom.getElementRect(elem);
    			if (rect.top <0){
                    return Math.max(rect.top, rect.bottom)
                } else {
                    return  verticalR.max - rect.top - verticalR.min;
                }
    	}
    	/**
    	 * returns the horizontal shift(pixels) of an nodeElement from the current viewport
    	 * if the element is inside the viewport the value is positive otherwise the value is negative
    	 * @param {Object} elem - nodeElement
    	 * @return {Number}
    	 */	
    	function getHorizontalVPShift(elem){
    		var horizontalR = TRC.dom.getViewportHorizontalRange(),
    		    rect  = TRC.dom.getElementRect(elem);
    		    if (rect.left <0){
    		        return Math.max(rect.left, rect.right)
    		    } else {
    		        return  horizontalR.max - rect.left - horizontalR.min;
    		    }
    	}
    	
    	var modObject = {
    		/**
    		 * returns the amount of pixels an element is in the current viewport (max of vertical or horizontal).
    		 * if the entire element is outside the viewport the method will return negtaive values :
    		 * the minimum distance of the element from the viewport's borders.
    		 * @param {Object} elem - elementNode
    		 * @return {Number}    
    		 */
    		getViewPortOffsets : function(elem){
    		   var verticalShift = getVerticalVPShift(elem),
    		   	   horizontalShift = getHorizontalVPShift(elem);
     	      return {verticalOffset : verticalShift, horizontalOffset : horizontalShift};
     	    },

    		getMinViewPortOffsets: function(elem){
    			var vpOffs = this.getViewPortOffsets(elem);
    			if (vpOffs.verticalOffset < 0  && vpOffs.horizontalOffset < 0){
    				return Math.max(vpOffs.verticalOffset, vpOffs.horizontalOffset);
    			}
    			return Math.min(vpOffs.verticalOffset, vpOffs.horizontalOffset);
    		},

    		isInViewPortWithOffset: function(container, offset){
    			var inVP = this.getMinViewPortOffsets(container);
    			offset = offset || 0;
    			return !(inVP < offset);
    		}
    	};	 
    	// public methods for UT 
    	if (win._trcIsUTactive){
    		modObject.getVerticalVPShift = getVerticalVPShift;
    		modObject.getHorizontalVPShift = getHorizontalVPShift;
    	}

    	return modObject;
    	
    }(window, document);

    (() => {
        const widgetBadEncodingReporter = {
            init() {
                this.initiated = true;
                this.selector = '.video-title';
                TRC.listen('trcResponseHandled', this.checkEncoding.bind(this));
            },
            getText(selector) {
                const el = document.querySelector(selector);
                return el ? el.textContent : '';
            },
            searchBadEncoding(str) {
                const badEncPattern = /×.×.×.×/;
                return badEncPattern.exec(str);
            },
            checkEncoding() {
                if (TRCImpl.global['disable-bad-encoding-report']) {
                    return;
                }
                const str = this.getText(this.selector);
                const substringWithBadEncoding = this.searchBadEncoding(str);
                if (substringWithBadEncoding) {
                    __trcWarn(`Found bad encoding: ${substringWithBadEncoding}`);
                }
            }
        };
        widgetBadEncodingReporter.init();

        if (window._trcIsUTactive) {
            TRC.widgetBadEncodingReporter = widgetBadEncodingReporter;
        }
    })();

    (() => {
        const spatialDefaults = {
            defaultMaxSlotsGeometryPerPage: 50,
            maxDefaultThrottleNumber: 1000,
            defaultThresholdThrottleNumber: 10
        };

        class WidgetVisibilityReporter {
            constructor(rBoxWidget) {
                this.rBoxWidget = rBoxWidget;
                this.trcManager = this.rBoxWidget.trc;
                this.widgetContainer = this.rBoxWidget.container;
                this.widgetItems = this.rBoxWidget.boxes;
                this.uiModeName = this.rBoxWidget.mode_name;
                this.MIN_VISIBLE_ITMES = this.trcManager.global['min-visible-items'] || 1;
                this.enableVisibleOnItemLevel = WidgetVisibilityReporter.isVisibleOnItemLevelEnabled(this.trcManager);
                this.sendNewVisibleItemsOnly = this.trcManager.global['send-newvp-items-only'];
                this.init();
            }

            init() {
                this.resetVisibilityData();

                if (this.rBoxWidget.isProviderIframe) {
                    return;
                }

                if (this.isManualVisibilityMode()) {
                    TRC.listen(`visible::${this.rBoxWidget.orig_placement}`, this.reportManualVisibilityIfVisibleByRects.trcBind(this));
                } else {
                    this.initVisibilityObserver();
                }
            }

            resetVisibilityData() {
                this.organicVisibleItems = {};
                this.sponsoredVisibleItems = {};
                this.exchangeVisibleItems = {};
                this.nativeVisibleItems = {};
                this.visibleItemsIdxList = [];
            }

            isManualVisibilityMode() {
                return !!(((!this.rBoxWidget.isFeedCard && !window.AMP_MODE) || this.trcManager.framework === 'mobile-sdk')
                    && (this.rBoxWidget.manualVisibilityTrigger || this.trcManager.manualVisibilityTrigger) && this.trcManager.global['enable-manual-visible']);

            }

            reportVisibility() {
                const postData = new TRC.PlacementEventPostData();
                const thumbnailPosition = this.trcManager.getProperty(this.uiModeName, 'thumbnail-position', this.rBoxWidget.propertiesOverride),
                    ilarr = [],
                    silarr = [],
                    iltarr = [],
                    siltarr = [],
                    ntilarr = [],
                    ntiltarr = [],
                    siltparr = [],
                    niltparr = [],
                    navilarr = [],
                    naviltarr = [],
                    naviltparr = [];

                if (!this.enableVisibleOnItemLevel && this.visibilityReported) {
                    return;
                }

                Object.keys(this.organicVisibleItems).forEach(key => {
                    ilarr.push(this.organicVisibleItems[key].id);
                    iltarr.push(this.organicVisibleItems[key].type);
                });

                Object.keys(this.sponsoredVisibleItems).forEach(key => {
                    silarr.push(this.sponsoredVisibleItems[key].id);
                    siltarr.push(this.sponsoredVisibleItems[key].type);
                    siltparr.push(this.sponsoredVisibleItems[key].publisher);
                });

                Object.keys(this.exchangeVisibleItems).forEach(key => {
                    ntilarr.push(this.exchangeVisibleItems[key].id);
                    ntiltarr.push(this.exchangeVisibleItems[key].type);
                    niltparr.push(this.exchangeVisibleItems[key].publisher);
                });

                Object.keys(this.nativeVisibleItems).forEach(key => {
                    navilarr.push(this.nativeVisibleItems[key].id);
                    naviltarr.push(this.nativeVisibleItems[key].type);
                    naviltparr.push(this.nativeVisibleItems[key].publisher);
                });

                if (ilarr.length > 0 || silarr.length > 0 || ntilarr.length > 0 || navilarr.length > 0 || this.rBoxWidget.isProviderIframe) {
                    TRC.pConsole(this.uiModeName, 'info', 'sending new visible event', '');

                    let itemsList = this.rBoxWidget.getJsonTargetItemsList(this.rBoxWidget.fullEventItemsHash);

                    postData.setVisibleLevel(this.enableVisibleOnItemLevel);

                    if (this.enableVisibleOnItemLevel) {
                        if (this.sendNewVisibleItemsOnly) {
                            postData.setNewVisibleSent();
                            itemsList = WidgetVisibilityReporter.getNewVisibleEvents(itemsList);
                        }
                        postData.setFirstVisibleEvent(!this.visibilityReported);
                    }

                    postData.setFullItemList(itemsList);

                    if (this.enableVisibleOnItemLevel) {
                        postData.setFirstVisibleEvent(!this.visibilityReported);
                    }

                    if (this.trcManager.enablePageGeometry) {
                        this.trcManager.addGeometryPageData(postData, this.trcManager.global['page-geometry-selectors']);
                    }

                    if (this.trcManager.enablePageGeometryExtended) {
                        this.trcManager.addGeometryExtendedPageData(postData);
                    }

                    if (this.trcManager.enablePlacementGeometry) {
                        this.trcManager.addGeometryPlacementData(postData, this.widgetContainer);
                    }

                    TRC.EventsAPI.dispatchVisible(this.rBoxWidget.response.trc, this);

                    const eventParams = {
                        il: ilarr.join(','),
                        sil: silarr.join(','),
                        ilt: iltarr.join(','),
                        navil: navilarr.join(','),
                        silt: siltarr.join(','),
                        ntil: ntilarr.join(','),
                        ntilt: ntiltarr.join(','),
                        navilt: naviltarr.join(','),
                        niltp: niltparr.join(','),
                        siltp: siltparr.join(','),
                        naviltp: naviltparr.join(','),
                        tp: thumbnailPosition
                    };

                    this.processSpatialSlotsData(eventParams);

                    this.rBoxWidget.sendEvent(
                        'visible',
                        eventParams,
                        postData.getAll(),
                        !this.enableVisibleOnItemLevel
                    );
                    // send external impression tracking pixels ('vi')
                    if (this.enableVisibleOnItemLevel) {
                        this.rBoxWidget.sendPlacementTrackingPixelsOnce('vi', this.visibleItemsId, true);
                    } else if (this.trcManager.global['disable-external-visibility-once'] || !this.externalVisibleSent) {
                        this.rBoxWidget.sendPlacementTrackingPixelsOnce('vi');
                        this.externalVisibleSent = true;
                    }

                    if (this.trcManager.global['disable-runHook']) {
                        this.trcManager.getFunction(this.uiModeName, 'after-visible', this.rBoxWidget.propertiesOverride, this.rBoxWidget.internalContainer, this);
                        TRC.CustomModulesManager.runHook('after-visible', this.uiModeName, this, this.rBoxWidget.propertiesOverride, this.rBoxWidget.internalContainer, this);
                    } else {
                        this.trcManager.runHook(this, this.uiModeName, 'after-visible', this.rBoxWidget.propertiesOverride, true, this.rBoxWidget.internalContainer, this);
                    }

                    this.visibilityReported = true;
                }
            }

            static getNewVisibleEvents(data) {
                return data.filter(item => item.tids === 'newvp');
            }

            static isSpatialEnabled(trcManager) {
                return TRC.util.isPercentEnabled(trcManager.global, 'enable-spatial-data-per-page') || trcManager.spatialSlotsThrottleTHPerPage;
            }

            static isVisibleOnItemLevelEnabled(trcManager) {
                return trcManager.visibleOnItemLevel || TRC.util.isPercentEnabled(trcManager.global, 'visible-on-item-level');
            }

            processSpatialSlotsData(eventParams) {
                // Avoid spatial data for 3rd party cards
                if (this.rBoxWidget.isProviderIframe) {
                    return;
                }

                // Page level throttle:
                if (!WidgetVisibilityReporter.isSpatialEnabled(this.trcManager)) {
                    return;
                }

                // Slots level throttle:
                if (!this.isThrottleValidated()) {
                    return;
                }

                // We don't expect to send more than this.trcManager.global['max-slots-geometry-per-page']
                //  slots metrics(Geometry and/or Saliency) per page , fallback set to 50:
                const maxSlotsGeometryPerPage = this.trcManager.global['max-slots-geometry-per-page'] || spatialDefaults.defaultMaxSlotsGeometryPerPage;

                const geometryData = [];
                const thumbDimensionData = [];
                const saliencyData = [];
                let docComputedStyle = null;
                if (this.trcManager.enableSlotsSaliency) {
                    docComputedStyle = window.getComputedStyle(window.document.body);
                }

                this.visibleItemsIdxList.slice(-maxSlotsGeometryPerPage).forEach(idx => {
                    const item = this.rBoxWidget.boxes[idx];

                    if (this.trcManager.enableSlotsGeometry) {
                        WidgetVisibilityReporter.processVisibleItemGeometry(item, geometryData, thumbDimensionData);
                    }

                    if (this.trcManager.enableSlotsSaliency) {
                        WidgetVisibilityReporter.processVisibleItemSaliency(item, docComputedStyle, saliencyData);
                    }
                });

                const spatialList = [];
                if (geometryData.length === 0 && saliencyData.length > 0) {
                    const itemIds = saliencyData.map(item => item.id);
                    itemIds.forEach((itemId, index) => {
                        const saliencyObj = saliencyData[index];
                        delete saliencyObj.id;
                        spatialList.push({id: itemId, ssd: saliencyObj});
                    });
                    eventParams.spatialData = __trcJSONify(spatialList);
                } else if (geometryData.length > 0 && saliencyData.length === 0) {
                    const itemIds = geometryData.map(item => item.id);
                    itemIds.forEach((itemId, index) => {
                        const geometryObj = geometryData[index];
                        delete geometryObj.id;
                        const thumbDimensionObj = thumbDimensionData[index];
                        if (thumbDimensionObj) {
                            delete thumbDimensionObj.id;
                        }
                        spatialList.push({id: itemId, sgd: geometryObj, tgd: thumbDimensionObj});
                    });
                    eventParams.spatialData = __trcJSONify(spatialList);
                } else if (geometryData.length > 0 && saliencyData.length > 0) {
                    const itemIds = geometryData.map(item => item.id);

                    itemIds.forEach((itemId, index) => {
                        const geometryObj = geometryData[index];
                        delete geometryObj.id;
                        const saliencyObj = saliencyData[index];
                        delete saliencyObj.id;
                        const thumbDimensionObj = thumbDimensionData[index];
                        delete thumbDimensionObj.id;
                        spatialList.push({
                            id: itemId,
                            sgd: geometryObj,
                            ssd: saliencyObj,
                            tgd: thumbDimensionObj
                        });
                    });
                    eventParams.spatialData = __trcJSONify(spatialList);
                }
            }

            /**
             * Validate that the current throttle threshold is not being crossed
             * @returns {Boolean} whether the throttle is validated or not
             */
            isThrottleValidated() {
                // Validate that we send only sample of the data, according to throttled random generated number:
                const maxThrottleNumber = this.trcManager.spatialSlotsThrottleMax || spatialDefaults.maxDefaultThrottleNumber;
                let throttleNumber = this.trcManager.spatialSlotsThrottleTH;
                if (!(typeof (throttleNumber) === 'number')) {
                    throttleNumber = spatialDefaults.defaultThresholdThrottleNumber;
                }

                if (throttleNumber !== maxThrottleNumber) {
                    if (throttleNumber > 0) {
                        const randomThrottle = Math.floor(Math.random() * maxThrottleNumber);
                        if (randomThrottle > throttleNumber) {
                            return false;
                        }
                    } else {
                        return false;
                    }

                }
                return true;
            }

            static processVisibleItemGeometry(item, geometryData, thumbDimensionData) {
                let itemGeometryData = {
                    id: item.video_data['item-id'] || -1,
                    x: -1,
                    y: -1,
                    h: -1,
                    w: -1
                };

                if (item.lastVisibleBoundingClientRect) {
                    // If we couldn't sample the page[X/Y]Offset send [geometryOffsetError]:
                    const xDOMWise = (item.lastVisibleBoundingClientRect.left + item.lastVisibleBoundingClientRect.pageXOffset).toFixed(2);
                    const yDOMWise = (item.lastVisibleBoundingClientRect.top + item.lastVisibleBoundingClientRect.pageYOffset).toFixed(2);
                    itemGeometryData = {
                        id: item.video_data['item-id'],
                        x: xDOMWise,
                        y: yDOMWise,
                        h: item.lastVisibleBoundingClientRect.height.toFixed(2),
                        w: item.lastVisibleBoundingClientRect.width.toFixed(2)
                    };

                }

                WidgetVisibilityReporter.processVisibleItemThumbnailDimension(item, thumbDimensionData);
                geometryData.push(itemGeometryData);
            }

            static processVisibleItemSaliency(item, docComputedStyle, saliencyData) {
                const itemComputedStyle = window.getComputedStyle(item);
                const itemSaliencyData = {
                    id: item.video_data['item-id'],
                    fsi: itemComputedStyle.getPropertyValue('font-size'),
                    fst: itemComputedStyle.getPropertyValue('font-style'),
                    fn: itemComputedStyle.getPropertyValue('font-family'),
                    cbg: itemComputedStyle.getPropertyValue('background-color'),
                    dbg: docComputedStyle.getPropertyValue('background-color')
                };
                saliencyData.push(itemSaliencyData);
            }

            static processVisibleItemThumbnailDimension(item, thumbDimensionData) {
                const itemThumbDimensionData = {
                    id: (item.video_data['item-id']) || -1,
                    h: (item.thumbBlock && item.thumbBlock.imgContDim && item.thumbBlock.imgContDim.height.toString()) || -1,
                    w: (item.thumbBlock && item.thumbBlock.imgContDim && item.thumbBlock.imgContDim.width.toString()) || -1
                };

                thumbDimensionData.push(itemThumbDimensionData);
            }

            calculateVisibleItems(rects, forceAllItems, items) {
                const itemsArr = items || this.rBoxWidget.boxes;
                let visibleItemsCount = 0;
                this.visibleItemsIdxList = [];
                this.visibleItemsId = [];

                itemsArr.forEach((item, i) => {
                    const itemData = item.video_data || item,
                        itemsHashObj = this.rBoxWidget.fullEventItemsHash[itemData['item-id']];

                    if (forceAllItems || item.isVisible || (rects && this.isElementVisibleByRects(item, rects))) {
                        if (itemData['is-syndicated']) {
                            WidgetVisibilityReporter.addVisibleItemToList(this.sponsoredVisibleItems, itemData, 'is-syndicated');
                        } else if (itemData['is-in-network']) {
                            WidgetVisibilityReporter.addVisibleItemToList(this.exchangeVisibleItems, itemData, 'is-in-network');
                        } else if (itemData['is-native']) {
                            WidgetVisibilityReporter.addVisibleItemToList(this.nativeVisibleItems, itemData, 'is-native');
                        } else { // organic
                            WidgetVisibilityReporter.addVisibleItemToList(this.organicVisibleItems, itemData, 'is-organic');
                        }
                        this.setVisibleValues(itemsHashObj);
                        if (!this.enableVisibleOnItemLevel || (this.enableVisibleOnItemLevel && (itemsHashObj && itemsHashObj.tids === 'newvp'))) {
                            visibleItemsCount++;
                            if (this.enableVisibleOnItemLevel) {
                                this.visibleItemsId.push(itemData['item-id']);
                            }
                        }
                        this.visibleItemsIdxList.push(i);
                    } else if (itemsHashObj.tids === 'newvp') {
                        itemsHashObj.tids = 'vp';
                    } else if (itemsHashObj.tids !== 'vp' && itemsHashObj.tids !== 'newvp') {
                        itemsHashObj.tids = 'nvp';
                        if (this.enableVisibleOnItemLevel && itemData.srvopl) {
                            this.visibleItemsId.push(itemData['item-id']);
                        }
                    }

                });
                return visibleItemsCount;
            }

            setVisibleValues(itemsHashObj) {
                if (this.enableVisibleOnItemLevel) {
                    if (itemsHashObj.tids === 'newvp') {
                        itemsHashObj.tids = 'vp';
                    } else if (itemsHashObj.tids !== 'vp') {
                        itemsHashObj.tids = 'newvp';
                    }
                } else {
                    itemsHashObj.tids = 'vp';
                }
            }

            static addVisibleItemToList(visibleTypeObject, itemData) {
                visibleTypeObject[itemData['item-id']] = {
                    id: itemData['item-id'],
                    type: itemData.type,
                    publisher: itemData.publisher // for organic this might be undefined
                };
            }

            isVisibleWidget() {
                return (this.calculateVisibleItems() >= this.MIN_VISIBLE_ITMES) || !this.enableVisibleOnItemLevel && this.widgetContainer.isVisible;
            }

            initVisibilityObserver() {
                const visibilityCallback = this.reportVisibility.trcBind(this),
                    visibleWidgetPredicate = this.isVisibleWidget.trcBind(this);

                (TRC.tlf && console.time(`visibility - ${this.uiModeName}`));
                this.resetVisibilityData();

                if (!this.isVisibilityObserverInitialized) {
                    const observerContainerParams = {
                        targetElement: this.widgetContainer,
                        enableDelayedVisibilityCheck: true,
                        visibleWidgetPredicate,
                        onTrigger: visibilityCallback,
                        onEnter: () => {
                            if (TRC.util.isPercentEnabled(this.trcManager.global, 'guarantee-card-clash-detection')) {
                                TRC.ModuleLoader.load('card-interference-detector', TRC.CardInterferenceDetector, () => {
                                    TRC.CardInterferenceDetector.detectCardInterrupted(this.widgetContainer);
                                });
                            }
                        }
                    };

                    // set visibility on the widget container
                    TRC.intersections.isInViewPort(observerContainerParams);

                    const heatmap = this.rBoxWidget.listContainer && this.rBoxWidget.listContainer.heatmap;
                    // set visibility for each item in the widget
                    this.widgetItems.forEach(item => {
                        const observerItemParams = {
                            targetElement: item,
                            enableDelayedVisibilityCheck: true,
                            visibleWidgetPredicate,
                            onTrigger: visibilityCallback,
                            onEnter: () => {
                                heatmap && heatmap.captureItemTime(item.video_data.id);
                            }
                        };

                        TRC.intersections.isInViewPort(observerItemParams);
                    });

                    this.isVisibilityObserverInitialized = true;
                }

                (TRC.tlf && console.timeEnd(`visibility - ${this.uiModeName}`));
            }

            /**
             *
             * @param {object} rects - outer rectangle objects (e.g. AMP visible event)
             */
            reportManualVisibilityIfVisibleByRects(rects) {
                if (this.calculateVisibleItems(rects) >= this.MIN_VISIBLE_ITMES
                    || (this.isElementVisibleByRects(this.widgetContainer, rects) && !this.enableVisibleOnItemLevel)) {
                    this.reportVisibility();
                }
            }

            /**
             * Check if the current element is visible in the client's view port according to
             * provided bounding rects details. Used for manual visibility mode
             * @returns {Boolean} whether the element is visible
             */
            isElementVisibleByRects(container, rects) {
                container = (container) || this.widgetContainer;

                const bcr = container.getBoundingClientRect();

                if (!WidgetVisibilityReporter.hasVolume(bcr)) {
                    return false;
                }

                const rect = this.rBoxWidget.getBoundingClientRect(bcr, rects);

                const targetX = rect.left + Math.round((rect.right - rect.left) / 2),
                    targetY = rect.top + Math.round((rect.bottom - rect.top) / 2);

                const content = (TRC.Browser.operaUpto(10.1) || TRC.Browser.safariUpto(4))
                    ? document.elementFromPoint(targetX + document.body.scrollLeft, targetY + document.body.scrollTop)
                    : document.elementFromPoint(targetX, targetY);
                const rootBounds = WidgetVisibilityReporter.getRootBounds(rects);
                const inVP = targetX > 0 && targetX < rootBounds.maxX && targetY > 0 && targetY < rootBounds.maxY;
                if (rects) {
                    return inVP;
                }
                return inVP && content && WidgetVisibilityReporter.isAncestor(content, container);
            }

            /**
             * validates if the rects object has a vertical volume
             *
             * @param {object} rects - rectangle object of a container
             * @returns {boolean}
             */
            static hasVolume(rects) {
                return rects.top !== rects.bottom;
            }

            /**
             *
             * @param {object} rects - AMP/ mobile SDK rectangles object - intersectionRect, boundingClientRect and
             *     rootBounds
             * @returns {object} - computed rootBounds - i.e. the viewport dimensions
             */
            static getRootBounds(rects) {
                const rootBounds = {};
                if (rects) {
                    rootBounds.maxX = rects.rootBounds.width;
                    rootBounds.maxY = rects.rootBounds.height;
                    return rootBounds;
                }
                rootBounds.maxX = document.compatMode === 'CSS1Compat' && document.documentElement.clientWidth || document.body.clientWidth;
                rootBounds.maxY = document.compatMode === 'CSS1Compat' && document.documentElement.clientHeight || document.body.clientHeight;
                return rootBounds;
            }

            static isAncestor(elm, ancestor) {
                if (!elm.parentNode || elm.parentNode === document.documentElement && elm !== ancestor) {
                    return false;
                }

                return elm === ancestor || WidgetVisibilityReporter.isAncestor(elm.parentNode, ancestor);
            }
        }

        TRC.WidgetVisibilityReporter = WidgetVisibilityReporter;
    })();

    (() => {
        const INITIAL_REQ_ID = -1;
        class WebWorker {
            constructor(options) {
                this.initialUrl = options.initialUrl;
                this.initialUrlTimeout = options.initialUrlTimeout;
                if (this.initialUrl) {
                    this.initialUrlPending = true;
                }
                const worker = new Worker(WebWorker._buildBlob(this.initialUrl, this.initialUrlTimeout));
                TRC.URL = TRC.URL || TRC.webkitURL;
                worker.onmessage = this.onWorkerMessage.bind(this);
                this.worker = worker;
                this.contextCallbacks = {};
                this.context = 0;
            }

            handshake(resolve) {
                const data = {
                    type: 'handshake',
                    _context: this._generateContextId()
                };
                this.contextCallbacks[data._context] = {
                    resolve
                };
                this.worker.postMessage(data);
            }

            xhr(url, timeout, resolve, reject) {
                const data = {
                    url,
                    timeout: timeout || 8000,
                    type: 'xhr',
                    _context: this._generateContextId()
                };
                if (url === this.initialUrl && this.initialUrlPending) {
                    data._context = INITIAL_REQ_ID;
                }
                this.initialUrlPending = false;
                this.contextCallbacks[data._context] = {
                    resolve,
                    reject
                };
                // if initialUrlPending this is only assigment
                if (data._context !== INITIAL_REQ_ID) {
                    this.worker.postMessage(data);
                }
            }

            onWorkerMessage(e) {
                const obj = e.data,
                    {_context: context, type, error} = obj,
                    objClbk = this.contextCallbacks[context] || {},
                    {resolve, reject} = objClbk,
                    result = type === 'xhrBlob' ? obj.buffer : obj.result;
                

                if ((resolve && typeof resolve === 'function') && !error) {
                    resolve(result || {});
                } else {
                    typeof reject === 'function' && reject();
                }
                delete this.contextCallbacks[context];
            }

            _generateContextId() {
                return ++this.context;
            }

            static _buildBlob(url, timeout) {
                url = url || '';
                let code = `self.addEventListener('message', e => {
    const msg = e.data,
        {
            url,
            timeout,
            _context: cntxt,
            type
        } = msg;

    if (type === 'handshake') {
        return onHandshake(cntxt);
    }

    fetch(url, timeout, xhr => {
        const result = xhr.responseText,
            msg = {
                result,
                type,
                _context: cntxt
            };
        self.postMessage(msg);
    }, () => {
        const msg = {
            error: true,
            type,
            _context: cntxt
        };
        self.postMessage(msg);
    });

}, false);


function onHandshake(cntxt) {
    const msg = {
        _context: cntxt,
        type: 'handshake'
    };
    self.postMessage(msg);
}

function fetch(url, timeout, resolve, reject) {
    url = url.replace('/trc/3/json?', '/trc/3/json?wrkr=1&');
    const xhr = new XMLHttpRequest();
    xhr.withCredentials = true;

    xhr.onreadystatechange = function () {
        if (xhr.readyState < 4 || xhr.status !== 200) {
            return;
        }
        if (xhr.readyState === 4) {
            resolve(xhr);
        }
    };

    xhr.onerror = function (e) {
        (new Image()).src = 'http://trc.taboola.com/xhrworker-errors/log/2/debug?tim=10:24:11.81&type=xhrerror';
        reject(e);
    };
    
    xhr.ontimeout = function (e) {
        (new Image()).src = 'http://trc.taboola.com/xhrworker-errors/log/2/debug?tim=10:24:11.81&type=xhrtimeout';
        reject(e);
    };

    xhr.open('GET', url, true);

    if (timeout) {
        xhr.timeout = timeout;
    }
    xhr.send('');
}


const initialUrl = '%%initialUrl%%';
const initialTimeout = '%%timeout%%' || 8000;

if (initialUrl) {

    fetch(initialUrl, initialTimeout, xhr => {
        const result = xhr.responseText,
            msg = {
                result,
                _context: -1,
                type: 'xhr'
            };
        postMessage(msg);
    }, () => {
        const msg = {
            _context: -1,
            error: true,
            type: 'xhr'
        };
        postMessage(msg);
    });
}
`;
                code = code.replace('%%initialUrl%%', url);
                code = code.replace('%%timeout%%', timeout || '');
                const blob = new Blob([code], {type: 'text/javascript'});
                return window.URL.createObjectURL(blob);
            }
        }


        TRC.initWorkerIfAvailable = function (url, timeout) {

            TRC.workerInited = true;
            if (TRC.worker) {
                return;
            }

            if (window.Worker && window.URL && window.URL.createObjectURL && TRCImpl.global['xhr-worker']) {
                const worker = new WebWorker({initialUrl: url, timeout});
                TRC.worker = worker;
                const timer = setTimeout(() => {
                    __trcError('worker timeout');
                    clbk = () => {};
                    TRC.worker = false;
                }, 200);
                let clbk = () => clearTimeout(timer);

                worker.handshake(() => clbk());
            }
        };
        TRC.WebWorker = WebWorker;
    })();

    (() => {

        let instance = null;

        class AvailableEventCoordinator {
            constructor(trcManager) {
                this.trcManager = trcManager;
                this.availableReportedPlacements = [];
                this.fullEventItemsHash = {};
                this.utm = '';
                this.modeGroupOrder = null;
            }

            getEventItemHash() {
                return this.fullEventItemsHash;
            }

            updateUtm(utm) {
                this.utm = utm;
            }

            updateModeOrderGroup(mog) {
                this.modeGroupOrder = mog;
            }

            ExcludeDueToAMP() {
                if (this.trcManager.global['do-not-send-eager-availables-on-AMP'] && TRC.isAMP) {
                    return true;
                }
                return false;
            }

            sendAvailableEventsForPlacement(placementData) {
                if (this.ExcludeDueToAMP()) {
                    return;
                }
                const requestByPlacement = this.trcManager.preloadRequest[placementData.placement];
                const response = requestByPlacement && requestByPlacement.response;
                if (!response || !response.trc) {
                    return;
                }
                const {trc} = response;
                if (!trc || !trc.placement || this.availableReportedPlacements.indexOf(trc.placement) > -1) {
                    return;
                }
                this.availableReportedPlacements.push(response.trc.placement);
                AvailableEventCoordinator.setTargetItemsList(this.fullEventItemsHash, trc['video-list'].video, 'a');
                const postData = new TRC.PlacementEventPostData();
                postData.setFullItemList(AvailableEventCoordinator.getJsonTargetItemsList(this.fullEventItemsHash));
                const utmParams = {utm: TRC.utm.join(',') + (this.utm ? `,${this.utm.join(',')}` : '')};
                if (this.modeGroupOrder) {
                    TRC.util.merge(utmParams, {mgo: this.modeGroupOrder});
                }
                this.sendAvailableEvents(response, placementData, utmParams, postData);
            }

            sendAvailableEvents(response, placementData, utmParams, postData) {
                const isResponseFromCache = response && response.cached;
                if (isResponseFromCache && !this.trcManager.global['send-available-for-cached-response']) {
                    return;
                }

                const widgetRemoved = this.trcManager.isRemovedWidget(response.trc['video-list']);
                if (widgetRemoved) {
                    return;
                }

                this.addRboxParams(utmParams, response, placementData);
                this.trcManager.sendEvent('available', utmParams, postData.getAll(), true);
            }

            static setTargetItemsList(hashList, itemList, state) {
                if (!itemList) return;
                let i = 0;
                const len = itemList.length;

                for (; i < len; i++) {
                    hashList[itemList[i]['item-id']] = { // item id may be illegal key names in javascript (e.g. starting with "~")
                        tii: itemList[i]['item-id'],
                        tipt: AvailableEventCoordinator.getProviderType(itemList[i]),
                        tit: itemList[i].type,
                        tids: state
                    };
                }
            }

            static getJsonTargetItemsList(hashList) {
                const list = [];

                Object.keys(hashList)
                    .forEach(i => list.push(hashList[i]));
                return list;
            }

            static getProviderType(item, fullType) {
                if (item['is-syndicated']) {
                    return (fullType) ? 'sponsored' : 'SP';
                } if (item['is-in-network']) {
                    return (fullType) ? 'exchange' : 'NT';
                } if (item['is-native']) {
                    return (fullType) ? 'native' : 'NAV';
                }
                return (fullType) ? 'organic' : 'RC';
            }

            static get(trcManager) {
                if (instance) {
                    return instance;
                }
                return (instance = new AvailableEventCoordinator(trcManager));
            }

            static getListId(placementData) {
                if (!placementData.visible) {
                    return 'rbox-tracking';
                }
                return `rbox-${placementData.origin}`;
            }

            addRboxParams(params, response, placementData) {
                const additionalParams = {};
                additionalParams.li = AvailableEventCoordinator.getListId(placementData);
                if (response && response.cached) {
                    additionalParams.cache = '1';
                }
                if (this.trcManager.formattedTRCRequest && this.trcManager.formattedTRCRequest.ad) {
                    additionalParams.ad = __trcJSONify(this.trcManager.formattedTRCRequest.ad);
                }
                if (this.trcManager.systemFlags && this.trcManager.systemFlags.loaderType !== 'normal') {
                    additionalParams.lt = this.trcManager.systemFlags.loaderType;
                }

                if (response.trc && ((this.trcManager.global['tmp-use-pb-params'] && this.trcManager.configForPostEvent.available))) {
                    if (response.trc.ppb) {
                        params.ppb = response.trc.ppb;
                    }
                    if (response.trc.cpb) {
                        params.cpb = response.trc.cpb;
                    }
                    if (response.trc.prty) {
                        params.prty = response.trc.prty;
                    }
                    if (response.trc.caty) {
                        params.caty = response.trc.caty;
                    }
                }

                const template = this.trcManager.formattedTRCRequest && this.trcManager.formattedTRCRequest.tmpl;
                const placementGroup = response.trc && response.trc['placement-group'];

                if (template) {
                    additionalParams.tmpl = template;
                }
                if (placementGroup) {
                    additionalParams.pg = placementGroup;
                }
                __trcCopyProps(additionalParams, params);
                return params;
            }

            getReportedPlacements() {
                return this.availableReportedPlacements;
            }
        }

        TRC.availableEventCoordinator = AvailableEventCoordinator;

        if (window._trcIsUTactive) {
            AvailableEventCoordinator.prototype.setEventItemHash = function (itemsHash) {
                this.fullEventItemsHash = itemsHash;
            };
        }

    })();

    (trc => {
        class UnmaskedIpParser {
            constructor() {
                this.unmaskedIp = null;
            }

            parse(response) {
                this.unmaskedIp = (response && response.trc && response.trc.umip) || null;
            }

            get() {
                return this.unmaskedIp;
            }
        }

        trc.unmaskedIpParser = trc.unmaskedIpParser || new UnmaskedIpParser();
    })(TRC);

    var CONSTANTS = {
        STYLESHEET: ``,
        BLOCK_CLICKS: 'taboola-unit-unintentional-clicks'
    };

    function getAllDynamicConfig(config, dynamicConfigKey) {
        if (!config[dynamicConfigKey]) return config;

        return TRC.util.merge({}, config, config[dynamicConfigKey]);
    }

    function getFromDynamicConfig(options, dyanmicParameterName, optionName, dynamicParametersProperty) {
        if (!options) {
            return null;
        }
        const config = getDynamicParameter(options[dynamicParametersProperty], dyanmicParameterName);
        return config || options[optionName];
    }

    function getDynamicParameter(dynamicParameters, dynamicParameterName) {
        if (!dynamicParameters) {
            return null;
        }
        const dynamicParam = dynamicParameters[dynamicParameterName];
        return dynamicParam ? JSON.parse(dynamicParam) : null;
    }

    function setElementblockMarginalclicks(element, marginalValue) {
        TRC.dom.on(element, 'click', e => {
            if (isMarginalClick(e, element, marginalValue)) {
                preventClickBubbling(e);
            }
        });
    }

    function isMarginalClick(e, element, marginalValue) {
        const width = element.offsetWidth;
        const height = element.offsetHeight;
        const transformedConfig = transformBlockMarginalClicksConfig(width, height, marginalValue);

        const rect = element.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        return (
            // top margin
            y < transformedConfig.vertical
            // right margin
            || x > width - transformedConfig.horizontal
            // left margin
            || x < transformedConfig.horizontal
            // bottom margin
            || y > height - transformedConfig.vertical
        );
    }

    function preventClickBubbling(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    function calculatePercentage(parsedValue, compare) {
        return (parsedValue / 100) * compare;
    }

    function handleValueType(value, compare) {
        const parsedValue = parseFloat(value);
        if (!isNaN(parsedValue)) {
            if (typeof value === 'string' && value.indexOf('px') !== -1) {
                return parsedValue;
            }
            return calculatePercentage(parsedValue, compare);
        }
        return 0;
    }

    function transformBlockMarginalClicksConfig(width, height, marginalValue) {
        return {
            vertical: handleValueType(marginalValue, height),
            horizontal: handleValueType(marginalValue, width)
        };
    }

    (() => {

        class TaboolaUnit {

            constructor(placementName) {
                if (!TaboolaUnit.styleRendered) {
                    TaboolaUnit.InjectUnitStyle();
                }
                if (!placementName) {
                    __trcWarn(`taboola unit got no valid placement name, got ${placementName}`);
                    return;
                }
                this.productContainer = TaboolaUnit.getProductContainer(placementName);
                if (!this.productContainer) {
                    __trcWarn(`taboola unit could not find a viable container, got ${this.productContainer}`);
                    return;
                }
                this.baseContainer = this.createBaseContainer();
            }

            static InjectUnitStyle() {
                TRC.dom.injectStyle(CONSTANTS.STYLESHEET);
                TaboolaUnit.styleRendered = true;
            }

            createBaseContainer() {
                const wrapper = TRC.dom.createHTMLElement('section', {className: 'taboola-unit'});
                this.productContainer.parentNode.insertBefore(wrapper, this.productContainer);
                wrapper.appendChild(this.productContainer);
                return wrapper;
            }

            static getProductContainer(placementName) {
                try {
                    return document.querySelector(`[data-placement-name="${placementName}"]`);
                } catch (ex) {
                    __trcError(`Error in getProductContainer in Taboola unit for placement: ${placementName}`);
                }
            }

            blockUnintentionalClicks(msTime) {
                TRC.dom.on(this.baseContainer, 'click', e => {
                    if (this.isBlockingClicks) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }, true);

                if (msTime <= 0) {
                    return;
                }

                TRC.dom.addClass(this.baseContainer, CONSTANTS.BLOCK_CLICKS);
                this.isBlockingClicks = true;
                TRC.Timeout.set(() => {
                    TRC.dom.removeClass(this.baseContainer, CONSTANTS.BLOCK_CLICKS);
                    this.isBlockingClicks = false;
                }, msTime);
            }

            static blockElementMarginalClicks(element, marginalValue) {
                setElementblockMarginalclicks(element, marginalValue);
            }

            static getFromDynamicConfig(options, parameterName, optionName, dynamicParametersProperty) {
                return getFromDynamicConfig(options, parameterName, optionName, dynamicParametersProperty);
            }

            static getDynamicParameter(dynamicParameters, parameterName) {
                return getDynamicParameter(dynamicParameters, parameterName);
            }

            static getAllDynamicConfig(config, dynamicConfigKey) {
                return getAllDynamicConfig(config, dynamicConfigKey);
            }
        }

        TRC.TaboolaUnit = TaboolaUnit;
    })();

    /*********************************************************************
     * Please do not add imports to this file!
     * Additions to this file will not be approved in PR.
     *
     * For information on adding new modules to R-Box please see:
     * https://brain.taboola.com/pages/viewpage.action?pageId=270971094
     *********************************************************************/

})();



/*********  Taken from local file trc-logger.js, last modified 2023-10-23 13:57:13.132060485 +0300 IDT ******** */ 


(function(win, TRC) {

    win.TRC = win.TRC || {};

    // Send Ajax event - special case for IE8
    var doNothing = function() {
            return true;
        },

        buildLogUrl = function(host, event, id, params) {
            var res = host + '/' + encodeURIComponent(id || win.TRC.publisherId) + '/log/3' + '/' + event;
            if (params) {
                res += '?' + TRC.TRCLogger.formatParams(params)
            }
            return res;
        },

        prepareGenericRequest = function(type, url, headers) {
            var Request = win.XDomainRequest || win.XMLHttpRequest,
                httpRequest = new Request();

            httpRequest.open(type, url);

            // Supporting IE-9 bug - all events must be defined
            httpRequest.onload = doNothing;
            httpRequest.onerror = doNothing;
            httpRequest.ontimeout = doNothing;
            httpRequest.onprogress = doNothing;
            httpRequest.withCredentials = true;

            if (headers) {
                setHeaders(httpRequest, headers);
            }
            return httpRequest;
        },

        setHeaders = function(httpRequest, headers) {
             for (var key in headers) {
                 if (headers.hasOwnProperty(key)) {
                     httpRequest.setRequestHeader(key, headers[key]);
                 }
             }
         };

    win.TRC.TRCLogger = TRC.TRCLogger = {
        post: function(host, type, params, explicitPublisherId, queryParams, sendBeacon) {
            // Preparing URL and parameters
            var url = buildLogUrl(host, type, explicitPublisherId, queryParams),
                request = prepareGenericRequest('POST', url);

            if (sendBeacon && typeof win.navigator.sendBeacon === 'function') {
                win.navigator.sendBeacon(url, TRC.TRCLogger.formatBeaconParams(params));
            } else {
                if (request.setRequestHeader){ //not supported on XDomainRequest
                    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                }
                request.send(TRC.TRCLogger.formatParams(params));
            }
        },
        get: function(host, type, params, explicitPublisherId) {
            if(params.headers) {
                //Delete headers so not to send them in the url with the params
               var headers = params.headers;
               delete params.headers
            }
            var url = buildLogUrl(host, type, explicitPublisherId, params),
                request = prepareGenericRequest('GET', url, headers);

            request.send();
        },
        formatParams: function(params) {
            //TODO: handle complex params object (arrays, inner objects, etc.)
            var formattedParams = [];

            for(var key in params) {
                if (params.hasOwnProperty(key)) {
                    formattedParams.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
                }
            }
            return formattedParams.join('&');
        },
        /*
         formatBeaconParams - creates a native form object
        */
        formatBeaconParams: function(params) {
            var formString = '';

            for(var key in params) {
                if (params.hasOwnProperty(key)) {
                    formString += key + '=' + encodeURIComponent(params[key]) + '&';
                }
            }
            var blob = new Blob([formString.slice(0, -1)], {
                type: 'application/x-www-form-urlencoded',
            });
            return blob;
        },
        reportES: function(logger) {
			if (!TRC || !TRC.util || !TRC.util.isPercentEnabled(TRCImpl.global, 'enable-rbox-es-events')) {
				return;
			}
            var baseUrl = (TRCImpl && TRCImpl.global && TRCImpl.global['rbox-es-events-url']) || 'https://vidanalytics.taboola.com/putes';
			baseUrl = baseUrl + '/' + logger.index;

            var data = {
                timestamp: new Date().toISOString(),
                name: logger.name
            };
            for (var key in logger.data) {
                data[key] = logger.data[key];
            }

            if (typeof navigator.sendBeacon === 'function') {
                navigator.sendBeacon(baseUrl, JSON.stringify(data) );
            } else {
                var http = new XMLHttpRequest();
                http.open('POST', baseUrl, true);
                http.send(JSON.stringify(data));
            }
		},
     };


})(window, window[!("${jsScope}".indexOf("{jsScope}") >= 0) ? "${jsScope}" : 'TRC']);


/*********  Taken from local file libtrc.js, last modified 2023-10-23 13:57:13.142307462 +0300 IDT ******** */ 


/*
 * TRC initialization code.
 *
 * This file implements any one-time initialization that needs to be done as soon as the implementation code is loaded.
 *
 * Also, this file contains the place holders for default configuration data (such as rbox.css) that is baked-in during
 * compilation.
 */
(function(win,doc) {
    (TRC.performance && TRC.performance.mark("4.0"));
    var protocol = TRC.PROTOCOL,
        getParameter = TRC.URL.prototype.getParameter,
        taboolaConsole = getParameter.call(location.href,'trc_console');
	// consult the user for the requires reporting level
	win.trc_debug_level = getParameter.call(location.href,'taboola-debug');
    TRC.tlf = !!getParameter.call(location.href,'taboola-perf');
    TRC.taboola_yield_report = !!getParameter.call(location.href,'taboola-yield-report');
    if(taboolaConsole && taboolaConsole.toLowerCase() === "yes"){
        TRC.taboolaConsole = true;
        TRC.Manager.prototype.loadExternal("http://c2.taboola.com/console/console_loader.js", "js");
    }

	if (isNaN(parseInt(win.trc_debug_level))) {
        trc_debug_level = 2;
    }

	// This function invokes the modules that are dependent on each other since they use inheritance mechanism.
	// This function is only necessary because trc-rbox doesn't use requirejs or module export/import to handle dependencies
	function invokeInheritedModules() {
		TRC.InvokeVideoLoader();
		TRC.InvokePOldVideoLoader();
		TRC.InvokeVideoTagLoader();
	}

	/**
	 * Callback list for server responses
	 */
	TRC.callbacks = {
			mute: function(){
			         var modes = TRCImpl.boxes,
			             mode;
                     TRCImpl.clearPreloadRequestLoaderAndCallNext();
			         TRC.Timeout.reset();
			         if (modes){
			             for (mode in modes){
			                 modes[mode].request = null;
			             }
			         }
                     TRC.EventsAPI.dispatchNoContent(TRCImpl.NO_CONTENT.mute);
                TRC.pConsole("warning - mute!", "warn", "server returned mute", "");
			}
	};

	/* Name space state variables */
	TRC.trc_drawRBox = false; // whether drawRBox has already completed
	TRC.listOrigin = new TRC.ListOriginBuilder();
	TRC.baseDomain = TRC.baseDomain || protocol + '//cdn.taboola.com/libtrc/' + TRC.publisherId + '/';
	TRC.prototype = TRC.prototype || {}; // TODO: remove emulation of TRC.prototype for compatibility with old hooks
	/**
     * TRC.Interval is a singlton responsible for
     * keeping track of setInterval calls with the ability
     * to cancel all pending intervals
     */
    TRC.Interval = function() {
        var intervals = {};

        return {
            set: function(callback, interval) {
            	var aArgs = Array.prototype.slice.call(arguments, 2),
                    intervalId = win.setInterval(function() {
                    if (typeof callback === 'function') {
                    	callback.apply(null, aArgs);
                    } else {
                    	eval(callback);
                    }
                }, interval);

                // save reference in 'timers' map
                intervals[intervalId.toString()] = 1;

                return intervalId;
            },

            clear: function(intervalId) {
            	if (intervalId) {
                    win.clearInterval(intervalId);
                    delete intervals[intervalId.toString()];
            	}
            },

            reset: function() {
                for (intervalId in intervals) {
                    win.clearInterval(intervalId);
                    delete intervals[intervalId.toString()];
                }
            }
        };
    }();
	  /**
     * TRC.timeout is a singlton responsible for
     * keeping track of setTimeout calls with the ability
     * to cancel all pending timers
     */
    TRC.Timeout = function() {
        var timers = {};

        return {
            set: function(callback, interval) {
                var timerId = win.setTimeout(function() {
                    // delete current timer from 'timers' map
                    delete timers[timerId.toString()];
                    callback();
                }, interval);

                // save reference in 'timers' map
                timers[timerId.toString()] = 1;

                return timerId;
            },

            clear: function(timerId) {
            	if (timerId) {
            		win.clearTimeout(timerId);
            		delete timers[timerId.toString()];
            	}
            },

            reset: function() {
                var timerId;

                for (timerId in timers) {
                    win.clearTimeout(timerId);
                    delete timers[timerId.toString()];
                }
            }
        };
    }();

    /* Final system initialization steps */
	TRC.trcReady = function (){
		var div;

		return function() {
			try {
                TRC.pConsole("page", "debug", "libtrc : calling TRC.ready", "");
				invokeInheritedModules();
				TRC.implLoaded = true;
				// call loader to initialize the implementation with the configuration
				/**
				 * @type {TRC.Manager}
                 */
				var instanceResult = TRC.ready( {style:".trc_rbox_container {\
    direction: ltr;\
    text-align: left;\
}\
\
/*override bootstrap default css  */\
.trc_rbox_container [class*=span] {\
    float: none;\
    margin-left: 0;\
}\
\
/*------------- Multi-widget -------------*/\
\
.trc_multi_widget_container {\
    display: -ms-flexbox;\
    display: flex;\
\
    -ms-flex-pack: justify;\
    justify-content: space-between;\
}\
\
.trc_multi_widget_container .trc_rbox_div {\
    margin: 0;\
}\
\
/*----------------------------------------*/\
\
.trc_rbox_header {\
    border: 0 solid;\
    overflow: hidden;\
    vertical-align: middle;\
}\
\
.trc_rbox_container .trc_img {\
    display: inline-block !important;\
}\
\
.trc_rbox_header_icon_div {\
    display: table-cell;\
    vertical-align: baseline;\
}\
\
.trc_rbox_header .trc_rbox_header_icon_div .trc_rbox_header_icon_img {\
    vertical-align: middle;\
    width: auto;\
}\
\
.trc_rbox_header_icon_span {\
    display: inline-table;\
}\
\
.in_trc_header {\
    position: relative !important;\
    float: right;\
    margin: 0;\
}\
\
#trc_rbox_css_loaded {\
    overflow: hidden;\
    width: 0;\
    height: 0;\
}\
\
.trc_rbox {\
    margin-top: 0;\
}\
\
.trc_rbox_div {\
    margin: 0 0 3px;\
    direction: ltr;\
    padding: 0;\
    box-sizing: border-box;\
    -moz-box-sizing: border-box;\
    -ms-box-sizing: border-box;\
    -webkit-box-sizing: border-box;\
    overflow: auto;\
    position: relative;\
    width: auto;\
    border: solid #CCC 1px;\
}\
\
.loading-animation span {\
    display: block;\
}\
\
.videoCube {\
    zoom: 1;\
    cursor: pointer;\
    float: none;\
    overflow: hidden;\
    box-sizing: border-box;\
    -moz-box-sizing: border-box;\
    -ms-box-sizing: border-box;\
    -webkit-box-sizing: border-box;\
}\
\
div.videoCube:hover,\
.videoCube_hover {\
    cursor: pointer;\
}\
\
.videoCube span.video-title:hover,\
.videoCube_hover span.video-title {\
    text-decoration: underline;\
}\
\
.videoCube a {\
    text-decoration: none;\
    border: 0;\
    color: black;\
    cursor: pointer;\
}\
\
.videoCube a:hover, .videoCube_hover a,\
.videoCube a:link,\
.videoCube a {\
    text-decoration: none !important;\
    outline: none;\
}\
\
.videoCube a .thumbBlock {\
    float: left;\
    display: block;\
    overflow: hidden !important;\
}\
\
.videoCube a img, .videoCube img {\
    border: 0;\
    display: block;\
    margin: 0;\
    height: auto;\
    width: auto;\
}\
\
.videoCube a img.app-install-logo,\
.videoCube img.app-install-logo {\
    display: inline-block;\
    max-height: 36px;\
    min-height: 36px;\
    height: 36px;\
    max-width: 36px;\
    min-width: 36px;\
    width: 36px;\
    object-fit: contain;\
}\
\
.videoCube .video-label {\
    display: block;\
    overflow: hidden;\
}\
\
.videoCube .video-label {\
    width: auto !important;\
    white-space: pre-wrap; /* css-3 */\
    white-space: -moz-pre-wrap; /* Mozilla, since 1999 */\
    white-space: -o-pre-wrap; /* Opera 7 */\
    word-wrap: break-word; /* Internet Explorer 5.5+ */\
}\
\
.videoCube .video-label-box.label-box-with-title-icon {\
    display: table;\
}\
\
.video-icon-container {\
    float: left;\
    display: table-cell;\
    vertical-align: baseline;\
}\
\
.video-icon-img {\
    vertical-align: middle;\
}\
\
.videoCube .video-duration {\
    height: 0;\
    float: left;\
    position: relative;\
    color: white;\
    font-size: 11px;\
}\
\
.videoCube .video-duration dt {\
    border-radius: 4px;\
    -moz-border-radius: 4px;\
    -webkit-border-radius: 4px;\
    background-color: black;\
    opacity: 0.6;\
    filter: alpha(opacity=60);\
}\
\
/* browser native line-clamp */\
.videoCube span.video-label.trc_ellipsis {\
    position: relative;\
    overflow: hidden;\
    display: -webkit-box;\
    -webkit-box-orient: vertical;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis {\
    position: relative;\
    overflow: hidden;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis ins {\
    display: inline-block;\
    text-decoration: inherit;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis.tbl-ltr-label {\
    direction: ltr;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis.tbl-ltr-label ins {\
    float: left;\
    margin-right: 5px;\
    direction: ltr;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis.tbl-rtl-label {\
    float: right;\
    direction: rtl;\
    width: 100% !important;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis.tbl-rtl-label ins {\
    float: right;\
    margin-left: 5px;\
    direction: rtl;\
}\
\
.videoCube span.video-label.trc-smart-ellipsis ins.lastLineEllipsis {\
    display: block;\
    overflow: hidden;\
    text-overflow: ellipsis;\
    white-space: nowrap;\
    word-wrap: normal;\
    width: 100%;\
}\
\
.video-duration.video-duration-detail div {\
    color: white;\
}\
\
.trc_rbox .sponsored {\
    position: relative;\
    display: block;\
    overflow: visible;\
    height: auto;\
    width: auto;\
    padding-right: 0;\
    text-align: right;\
    font-size: 9px;\
}\
\
/* Configuration defaults */\
.trc_rbox_div {\
    height: 410px;\
}\
\
.videoCube {\
    direction: ltr;\
    font-size: 11px;\
    margin: 0;\
    color: black;\
    border-width: 0;\
}\
\
.videoCube.vertical:first-child {\
    border-top: 0;\
    margin-top: 0;\
}\
\
.videoCube.horizontal:first-child {\
    border-left: 0;\
    margin-left: 0;\
}\
\
div.videoCube:hover,\
.videoCube_hover {\
    background-color: #EBF0FF;\
    color: black;\
}\
\
.videoCube .thumbBlock {\
    margin: 0;\
    border-style: solid;\
}\
\
.videoCube a img,\
.videoCube img {\
    border-color: #ececec;\
}\
\
.videoCube .video-label-box {\
    margin-left: 81px;\
}\
\
.videoCube .video-label dt {\
    font-weight: bold;\
}\
\
.videoCube .video-title {\
    height: auto;\
    margin-bottom: 3px;\
    white-space: normal;\
}\
\
.videoCube .trc_inline_detail_spacer {\
    display: inline-block;\
    white-space: pre;\
}\
\
.loading-animation {\
    font-family: sans;\
    font-size: 1.5em;\
    text-align: center;\
    color: gray;\
    height: 100%;\
}\
\
.trc_rbox_header {\
    font-family: Arial, Helvetica, sans-serif;\
    font-size: 12px;\
    font-weight: bold;\
    text-decoration: none;\
    color: black;\
}\
\
.trc_header_right_part {\
    position: absolute;\
    left: 50%;\
    top: 0;\
}\
\
.branding_div {\
    overflow: visible;\
    float: right;\
}\
\
.branding_div img {\
    height: 20px;\
}\
\
.videoCube .branding .logoDiv {\
    font-size: inherit;\
    line-height: inherit;\
    background: none;\
    margin: 0;\
    padding: 0;\
}\
\
.videoCube .branding .logoDiv a {\
    vertical-align: inherit;\
    color: inherit;\
    line-height: inherit;\
}\
\
.videoCube .branding .logoDiv a span {\
    vertical-align: inherit;\
}\
\
.trc_related_container .videoCube .branding .attribution-disclosure-link-sponsored {\
    display: inline-block;\
    float: none;\
}\
\
.trc_related_container .videoCube .branding .attribution-disclosure-link-sponsored.align-disclosure-right {\
    float: right;\
    margin-left: auto;\
    padding-left: 2px;\
}\
\
.videoCube .video-label-box .branding.composite-branding {\
    display: -webkit-box;\
    display: -ms-flexbox;\
    display: flex;\
}\
\
.branding.composite-branding > * {\
    display: inline-block;\
    vertical-align: bottom;\
}\
\
.branding .branding-separator {\
    margin: 0 2px;\
    font-weight: normal;\
}\
\
.branding .branding-inner {\
    text-overflow: ellipsis;\
    overflow: hidden;\
    white-space: nowrap;\
}\
\
.video-label-box span.branding.inline-branding {\
    display: inline-block;\
}\
\
/* Support for Horizontal mode */\
.trc_related_container div.horizontal {\
    float: left;\
    box-sizing: border-box;\
    -moz-box-sizing: border-box;\
    -ms-box-sizing: border-box;\
    -webkit-box-sizing: border-box;\
}\
\
/* Support for thumbnail position */\
.trc_related_container DIV.videoCube.thumbnail_top .thumbBlock,\
.trc_related_container DIV.videoCube.thumbnail_bottom .thumbBlock {\
    float: none;\
}\
\
/* SEO blocks should be hidden once R-Box loads */\
.vidiscovery-note {\
    display: none;\
}\
\
.videoCube .thumbBlock .trc_sponsored_overlay_base {\
    display: block;\
    width: auto;\
    margin-left: 0;\
    position: absolute;\
    color: white !important;\
}\
\
.videoCube .thumbBlock .trc_sponsored_overlay {\
    filter: alpha(opacity=60);\
    opacity: 0.6;\
    display: block;\
    position: absolute;\
}\
\
.videoCube .thumbBlock .trc_sponsored_overlay_base .sponsored {\
    position: relative;\
    display: block;\
    overflow: visible;\
    width: auto;\
    text-align: center;\
    padding: 0 5px;\
    margin-top: 0;\
}\
\
.videoCube .thumbBlock .trc_sponsored_overlay_base.round .trc_sponsored_overlay {\
    border-radius: 4px;\
    -moz-border-radius: 4px;\
    -webkit-border-radius: 4px;\
}\
\
.videoCube .thumbBlock .trc_sponsored_overlay_base.round {\
    margin-left: 4px;\
}\
\
.thumbnail-emblem,\
.videoCube .thumbnail-overlay,\
.videoCube:hover .thumbnail-overlay,\
.videoCube_hover .thumbnail-overlay {\
    position: absolute;\
    background: transparent no-repeat;\
    background-size: contain;\
    z-index: 50;\
}\
\
.thumbnail_bottom {\
    padding-bottom: 8px;\
}\
\
.trc_related_container .logoDiv {\
    font-family: Arial, Helvetica, sans-serif;\
    white-space: nowrap;\
    font-size: 9px;\
}\
\
.trc_related_container .logoDiv a {\
    font-size: 9px;\
    text-decoration: none !important;\
    color: black;\
    margin-right: 1px; /* don't allow focus line to cause overflow */\
    vertical-align: text-bottom;\
}\
\
.logoDiv a span:hover {\
    text-decoration: underline;\
}\
\
.trc_rbox_header .logoDiv {\
    font-size: 1em;\
}\
\
/* text-link widgets*/\
.trc_tl .trc_rbox_header .logoDiv {\
    position: relative;\
    z-index: 1;\
}\
\
.trc_tl .trc_rbox_header_span .trc_header_right_column {\
    position: absolute;\
    width: 48%;\
    left: 52%;\
    top: 0;\
}\
\
.trc_tl .trc_rbox_div .videoCube.horizontal {\
    clear: left;\
}\
\
.trc_tl .trc_rbox_div .videoCube.trc_tl_right_col {\
    float: none;\
    clear: right;\
    margin-left: auto;\
}\
\
.trc_tl .videoCube .video-title .branding {\
    line-height: 1.3em;\
}\
\
.trc_tl .videoCube:hover span.branding,\
.trc_tl .videoCube_hover span.branding {\
    text-decoration: none;\
}\
\
.trc_tl .trc_rbox_div .videoCube.thumbnail_none a{\
    vertical-align: top;\
    overflow: visible;\
}\
\
.trc_tl .videoCube .video-label-box {\
    display: inline-block;\
    vertical-align: top;\
    width: 100%;\
}\
\
/* text-link widgets - end*/\
\
.trc_rbox_container.trc_expandable {\
    overflow: hidden;\
    max-height: 0;\
    transition-property: max-height;\
    -webkit-transition-property: max-height;\
    -moz-transition-property: max-height;\
    -o-transition-property: max-height;\
    -webkit-transform: translateZ(0);\
    -moz-transform: translateZ(0);\
    -ms-transform: translateZ(0);\
    -o-transform: translateZ(0);\
    transform: translateZ(0);\
}\
\
.trc_related_container .videoCube .thumbBlock .branding {\
    position: absolute;\
    bottom: 0;\
    z-index: 1;\
    width: 100%;\
    margin: 0;\
    padding: 5px 0;\
    text-align: center;\
}\
\
.syndicatedItem .branding {\
    margin: 0;\
}\
\
.trc-inplayer-rbox {\
    background: #333;\
    background: rgba(30, 30, 30, 0.9);\
    bottom: 0;\
    position: absolute;\
    height: 300px;\
    text-align: center;\
}\
\
.trc-inplayer-rbox .trc_rbox_container {\
    margin: 50px auto 0;\
    width: 640px\
}\
\
.trc_rbox.trc-auto-size {\
    width: 100%;\
    height: 100%;\
}\
\
.videoCube.thumbnail_under .video-title {\
    min-height: 2.58em;\
}\
\
.videoCube.thumbnail_under .tbl-text-over-container {\
    width: 100%;\
    position: absolute;\
    z-index: 1;\
    left: 0;\
    bottom: 0;\
    min-height: 66%;\
    max-height: 66%;\
    padding-top: 2px;\
    padding-bottom: 2px;\
    line-height: 1.25em;\
}\
\
.videoCube.thumbnail_under .tbl-text-over-container .tbl-text-over {\
    height: 100%;\
    width: 100%;\
    position: absolute;\
    background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.8) 100%);\
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000, endColorstr=#CC000000, GradientType=0);\
}\
\
.videoCube.thumbnail_under .tbl-text-over-container span.video-title,\
.videoCube.thumbnail_under .tbl-text-over-container span.video-description,\
.videoCube.thumbnail_under .tbl-text-over-container span.branding {\
    position: relative;\
    z-index: 1;\
    padding: 0 8px;\
    margin: 0;\
}\
\
.videoCube.thumbnail_under .tbl-text-over-container span.video-title {\
    margin-bottom: 6px;\
    min-height: auto;\
}\
\
.videoCube.thumbnail_under .tbl-text-over-container .video-label-box {\
    position: absolute;\
    bottom: 0;\
    left: 0;\
    width: 100%;\
    padding: 0 8px 6px 8px;\
    min-height: auto;\
}\
\
.trc-auto-size .trc_rbox_outer .trc_rbox_div {\
    height: auto;\
    width: auto;\
}\
\
.trc-auto-size .trc_rbox_div .videoCube {\
    height: auto;\
}\
\
.trc-auto-size .trc_rbox_div .videoCube.trc-first-recommendation {\
    margin-top: 0;\
}\
\
.trc_rbox .trc_rbox_outer .trc_rbox_div .videoCube.trc-first-in-row {\
    margin-left: 0;\
}\
\
.trc_elastic .trc_rbox {\
    width: auto;\
}\
\
.trc_elastic .videoCube {\
    overflow: hidden;\
}\
\
.trc_elastic .videoCube .thumbBlock {\
    background: transparent no-repeat center center;\
    background-size: cover;\
    position: absolute;\
    display: inline-block;\
    top: 0;\
    right: 0;\
    bottom: 0;\
    left: 0;\
    margin-left: 0;\
    margin-right: 0;\
}\
\
.trc_elastic .thumbBlock_holder {\
    position: relative;\
    width: 100%;\
}\
\
.trc_elastic .thumbnail_start .thumbBlock_holder {\
    float: left;\
    margin-right: 10px;\
}\
\
.trc_elastic .thumbnail_start.item-has-pre-label .thumbBlock_holder {\
    margin-right: 0;\
}\
\
.trc_elastic .videoCube_aspect {\
    width: 1px;\
}\
\
.trc_elastic .trc_rbox .trc_rbox_div {\
    height: auto;\
}\
\
.trc_elastic .thumbnail_start .trc-pre-label {\
    float: left;\
    padding-right: 10px;\
}\
\
.trc_elastic .thumbnail_start.trc-split-label .trc-main-label {\
    float: left;\
    padding-left: 10px;\
}\
\
.trc_elastic .video-label-box {\
    display: block;\
}\
\
.trc_elastic .thumbnail_start .video-label-box {\
    box-sizing: border-box;\
}\
\
/** USER Ad-Choice **/\
.trc_user_adChoice_btn {\
    background: url(\"//cdn.taboola.com/static/c5/c5ef96bc-30ab-456a-b3d5-a84f367c6a46.svg\") no-repeat scroll 0 0 rgba(255, 255, 255, 1);\
    border-radius: 0 0 0 5px;\
    width: 16px;\
    height: 16px;\
    position: absolute;\
    right: 0;\
    top: 0;\
    z-index: 9000;\
    cursor: pointer;\
    border-width: 2px 0 2px 4px;\
    border-style: solid;\
    border-color: #fff;\
    opacity: 0.7;\
    background-size: contain;\
    visibility: hidden;\
}\
\
.videoCube:hover .trc_user_adChoice_btn,\
.videoCube_hover .trc_user_adChoice_btn {\
    visibility: visible;\
}\
\
.videoCube .trc_user_adChoice_btn_static {\
    visibility: visible;\
}\
\
.p-video-overlay-container {\
    position: absolute;\
    width: 100%;\
    height: 100%;\
    top: 0;\
    left: 0;\
    background-color: transparent;\
}\
\
.p-video-overlay.p-video-overlay-show {\
    display: flex;\
}\
\
.p-video-overlay {\
    display: none;\
    background-color: #000;\
    opacity: 0.7;\
    width: 100%;\
    height: 100%;\
    flex-direction: column;\
}\
\
.p-video-overlay-action {\
    color: #fff;\
    width: 100%;\
    direction: ltr;\
    text-align: center;\
    display: flex;\
    justify-content: center;\
    flex-direction: column;\
}\
\
.p-video-overlay-action.p-video-back-action {\
    height: 34%;\
}\
\
.p-video-back-action-label {\
    font-family: Helvetica Neue, serif;\
    font-size: 14px;\
    font-weight: 200;\
    letter-spacing: 1px\
}\
\
.p-video-overlay-action.p-video-goto-action {\
    height: 66%;\
}\
\
.p-video-goto-action-url {\
    font-family: Helvetica Neue, serif;\
    font-size: 24px;\
    font-weight: 400;\
    text-decoration: underline;\
    margin-top: 5px;\
}\
\
.p-video-goto-action-label {\
    font-family: Helvetica Neue, serif;\
    font-size: 14px;\
    font-weight: 100;\
    letter-spacing: 1px;\
}\
\
.trc_related_container .trc_clearer {\
    clear: both;\
    height: 0;\
    overflow: hidden;\
    font-size: 0;\
    line-height: 0;\
    visibility: hidden;\
}\
\
/* Ad Choices */\
.link-adc {\
    float: right !important;\
}\
\
.trc-widget-footer .logoDiv {\
    line-height: normal;\
    padding-bottom: 5px;\
}\
\
.trc-widget-footer .link-adc a .trc_adc_wrapper,\
.trc_header_ext .link-adc a .trc_adc_wrapper {\
    height: 12px;\
    width: 18px;\
    display: inline-block;\
    padding-left: 1px;\
    margin-bottom: 2px;\
}\
\
.trc-widget-footer .link-adc a .trc_adc_s_logo,\
.trc_header_ext .link-adc a .trc_adc_s_logo,\
.trc-widget-footer .link-adc a .trc_adc_b_logo,\
.trc_header_ext .link-adc a .trc_adc_b_logo {\
    vertical-align: middle;\
    height: 15px;\
    display: inline-block;\
    margin-top: -1px; /**fix v align of adc logo - compensate for link underline */\
}\
\
.trc-widget-footer .link-adc a .trc_adc_s_logo,\
.trc_header_ext .link-adc a .trc_adc_s_logo {\
    width: 12px;\
    height: 14px;\
    background: url(\"//cdn.taboola.com/static/c5/c5ef96bc-30ab-456a-b3d5-a84f367c6a46.svg\") no-repeat;\
    background-size: contain;\
    vertical-align: middle;\
}\
\
.trc-widget-footer .link-adc a .trc_adc_b_logo,\
.trc_header_ext .link-adc a .trc_adc_b_logo {\
    width: 77px;\
    background: #ffffff url(\"//cdn.taboola.com/libtrc/static/thumbnails/0781f9c5a8637d1e162874f157460048.png\") no-repeat !important;\
    right: -1px;\
    display: none;\
    position: absolute;\
}\
\
/* Attribution och Disclosure */\
\
.logoDiv .trc_mobile_disclosure_link,\
.logoDiv .trc_mobile_attribution_link,\
.logoDiv .trc_mobile_adc_link {\
    display: none;\
}\
\
.logoDiv .trc_desktop_disclosure_link,\
.logoDiv .trc_desktop_attribution_link,\
.logoDiv .trc_desktop_adc_link {\
    display: inline;\
}\
\
@media screen and (max-width: 767px) {\
    .logoDiv .trc_mobile_disclosure_link {\
        display: inline;\
    }\
\
    .logoDiv .trc_mobile_attribution_link {\
        display: inline;\
    }\
\
    .logoDiv .trc_mobile_adc_link {\
        display: inline;\
    }\
\
    .logoDiv .trc_desktop_disclosure_link {\
        display: none;\
    }\
\
    .logoDiv .trc_desktop_attribution_link {\
        display: none;\
    }\
\
    .logoDiv .trc_desktop_adc_link {\
        display: none;\
    }\
}\
\
.trc_in_iframe .logoDiv .trc_mobile_attribution_link,\
.trc_in_iframe .logoDiv .trc_mobile_disclosure_link {\
    display: inline;\
}\
\
.trc_in_iframe .logoDiv .trc_desktop_attribution_link,\
.trc_in_iframe .logoDiv .trc_desktop_disclosure_link {\
    display: none;\
}\
\
.trc_related_container .logoDiv,\
.trc_related_container .trc_header_ext .logoDiv {\
    float: right;\
}\
\
.trc_related_container .logoDiv + .logoDiv {\
    margin-right: 2px;\
}\
\
.trc_related_container .attribution-disclosure-link-sponsored,\
.trc_related_container .attribution-disclosure-link-hybrid {\
    display: none;\
}\
\
.trc_related_container .trc-content-sponsored .attribution-disclosure-link-sponsored,\
.trc-w2f.trc-content-sponsored .attribution-disclosure-link-sponsored {\
    display: block;\
}\
\
\
.trc_related_container .trc-content-hybrid .attribution-disclosure-link-hybrid,\
.trc-w2f.trc-content-hybrid .attribution-disclosure-link-hybrid {\
    display: block;\
}\
\
.trc_related_container .trc-widget-footer:hover a span,\
.trc_related_container .trc_header_ext:hover a span {\
    text-decoration: underline !important;\
}\
\
/* this span makes sure that all logos (attribution + adc + disclosure)\
 are vertically aligned - especially when the attribution font-size\
 is smaller than the adc logo height (15px) */\
.logoDiv a span.trc_logos_v_align {\
    display: inline-block !important;\
    font-size: 15px !important;\
    line-height: 1em !important;\
    width: 0 !important;\
}\
\
.trc_related_container .trc_header_ext:hover a span.trc_logos_v_align,\
.trc_related_container .trc_header_ext:hover a span.trc_adc_wrapper,\
.trc_related_container .trc-widget-footer:hover a span.trc_logos_v_align,\
.trc_related_container .trc-widget-footer:hover a span.trc_adc_wrapper {\
    text-decoration: none !important;\
}\
\
.trc_related_container .trc_rbox_header_span .trc_header_right_column {\
    display: none;\
}\
\
.trc_related_container img {\
    max-width: none;\
}\
\
.trc_related_container {\
    clear: both;\
}\
\
.tbl-loading-spinner {\
    width: 100%;\
    height: 40px;\
    background: url(//cdn.taboola.com/static/91/91a25024-792d-4b52-84e6-ad1478c3f552.gif) center center no-repeat;\
    background-size: 40px;\
}\
\
.tbl-hidden {\
    display: none !important;\
}\
\
.tbl-invisible {\
    opacity: 0;\
    pointer-events: none;\
}\
\
.tbl-batch-anchor {\
    width: 100%;\
    height: 1px;\
}\
\
/* Support for integrated widget frame */\
.iw_video_frame .trc_rbox_div {\
    overflow: hidden;\
}\
\
.trc-w2f .trc_rbox .trc_rbox_header,\
.trc-w2f .trc_rbox .trc-widget-footer {\
    display: none !important;\
}\
\
.tbl-banner-to-native {\
    width: 100%;\
    cursor: auto;\
    box-shadow: none !important;\
    background-position: center;\
    background-repeat:no-repeat;\
    background-size:cover;\
    margin-bottom: 0 !important;\
    backdrop-filter: blur(4px);\
    -webkit-backdrop-filter: blur(4px);\
}\
\
@media screen and (min-width:768px)  {\
    .tbl-banner-to-native {\
        backdrop-filter: blur(10px);\
        -webkit-backdrop-filter: blur(10px);\
    }\
}\
\
.tbl-banner-to-native-hidden {\
    background-size: 0 0;\
}\
\
.tbl-banner-to-native-iframe {\
    backdrop-filter: blur(4px);\
    -webkit-backdrop-filter: blur(4px);\
}\
\
.tbl-banner-to-native-iframe-desktop {\
    position: absolute;\
    top: 50%;\
    left: 50%;\
    transform: translate(-50%, -50%);\
}\
\
.tbl-banner-to-native-image-desktop {\
    background-size: cover;\
    filter: blur(4px);\
    -webkit-filter: blur(4px);\
}\
\
span.video-label.video-title.tbl-title-to-native {\
    text-decoration: none;\
    cursor: default;\
}\
\
.tbl-branding-title-to-native {\
    text-decoration: underline;\
    cursor: pointer;\
}\
\
span.video-label-box.trc-main-label.tbl-title-to-native,div.display-to-native-item-box.display-to-native-item-box {\
    cursor: auto;\
}\
\
.thumbBlock_holder_background_image {\
    position: absolute;\
    width: 100%;\
    background-position: center;\
    background-repeat:no-repeat;\
    background-size:cover;\
}"} );

				function runManagerInstance(instance) {
					try { // Ellipsis event listener. Only needs to be bound once, hence the ellipsisListening flag.
						if (instance.global['smart-ellipsis'] && !TRC.ellipsisListening && instance._repaintEllipsis) {
							TRC.listen('ellipsis', instance._repaintEllipsis.trcBind(instance));
							TRC.listen('allrender', instance._repaintEllipsis.trcBind(instance));
							TRC.listen('batchrender', instance._repaintEllipsis.trcBind(instance));
							TRC.ellipsisListening = true;
						}

						/** If instance._repaintEllipsis is undefined or null, it needs to be reported as it indicates an issue. */
						if (!instance._repaintEllipsis) {
							__trcWarn('instance._repaintEllipsis is undefined or null');
						}

						// initializing CLS Event reporter for analytics
						TRC.CLSReporter && TRC.CLSReporter.init();
						TRC.TBTReporter && TRC.TBTReporter.init();
						if (!instance.invisible) {
							return;
						}

						// "tracking code" R-Box has a bit more initialization
						TRC.dom.onReady(function () {
							// lazy creation after body is presents
							if (!div) {
								div = doc.createElement('div');
								doc.body.appendChild(div).style.display = 'none';
							} else {
								div.innerHTML = "";
								div.style.display = 'none';
							}

							_taboola.push({mode: 'rbox-tracking', container: div});
						});
					} catch (e) {
						__trcError('Error in libtrc initialization runManagerInstance',e);
					}
				}

				// The instance can be Promise instance, when we split the task of initialization from TRECS or in the RBox loader.js, or normal TRC Manager.
				// In both cases we get the Manager but using Promise we reduce the browser Long Task. When it normal Manager instance we just continue to run.
				if (typeof instanceResult.then === 'function') {
					instanceResult.then(runManagerInstance);
				}
				else {
					runManagerInstance(instanceResult);
				}
			} catch (e) {
				__trcError("Error in libtrc initialization",e);
			}
		};
	}();
    TRC.pConsole("", "time", "impl file loaded", "");
	// monitor user timings
	TRC.utm.push((new Date).getTime() - TRC.utm.start);
    (TRC.tlf && console.timeStamp('call trcReady'));
	TRC.trcReady();

})(window, document);
